Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,AD7Process,The method has 107 lines of code.
Long Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdBreak,The method has 119 lines of code.
Long Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The method has 370 lines of code.
Long Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,AD7StackFrame,The method has 102 lines of code.
Long Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,SetFrameInfo,The method has 107 lines of code.
Complex Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7Module,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Module.cs,GetInfo,Cyclomatic complexity of the method is 9
Complex Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,SendAssembly,Cyclomatic complexity of the method is 10
Complex Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,Cyclomatic complexity of the method is 9
Complex Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,AD7StackFrame,Cyclomatic complexity of the method is 12
Complex Method,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,SetFrameInfo,Cyclomatic complexity of the method is 17
Complex Method,Cosmos.VS.DebugEngine.Commands,DebugLaunchCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLaunchCommand.cs,Execute,Cyclomatic complexity of the method is 13
Complex Method,Cosmos.VS.DebugEngine.Commands,DebugLogCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLogCommand.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,Cosmos.VS.DebugEngine.Utilities,Extensions,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Utilities\Extensions.cs,GetFullName,Cyclomatic complexity of the method is 9
Complex Method,Cosmos.VS.DebugEngine.Utilities,Extensions,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Utilities\Extensions.cs,GetFullName,Cyclomatic complexity of the method is 8
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,LaunchSuspended,The method has 13 parameters. Parameters: aPszServer' aPort' aDebugInfo' aArgs' aDir' aEnv' aOptions' aLaunchFlags' aStdInputHandle' aStdOutputHandle' hStdError' aAD7Callback' oProcess
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,Attach,The method has 5 parameters. Parameters: rgpPrograms' rgpProgramNodes' aCeltPrograms' ad7Callback' dwReason
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,EnumCodePaths,The method has 6 parameters. Parameters: hint' start' frame' fSource' pathEnum' safetyContext
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,WatchForExpressionEvaluationOnThread,The method has 5 parameters. Parameters: pOriginatingProgram' dwTid' dwEvalFlags' pExprCallback' fWatch
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7ProgramProvider,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7ProgramProvider.cs,GetProviderProcessData,The method has 5 parameters. Parameters: Flags' port' ProcessId' EngineFilter' processArray
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7ProgramProvider,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7ProgramProvider.cs,GetProviderProgramNode,The method has 6 parameters. Parameters: Flags' port' ProcessId' guidEngine' programId' programNode
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7ProgramProvider,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7ProgramProvider.cs,WatchForProviderEvents,The method has 6 parameters. Parameters: Flags' port' ProcessId' EngineFilter' guidLaunchingEngine' ad7EventCallback
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,EnumChildren,The method has 7 parameters. Parameters: dwFields' dwRadix' guidFilter' dwAttribFilter' pszNameFilter' dwTimeout' ppEnum
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,GetPropertyInfo,The method has 6 parameters. Parameters: dwFields' dwRadix' dwTimeout' rgpArgs' dwArgCount' pPropertyInfo
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,EnumProperties,The method has 6 parameters. Parameters: dwFields' nRadix' guidFilter' dwTimeout' elementsReturned' enumObject
Long Parameter List,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,ParseText,The method has 6 parameters. Parameters: pszCode' dwFlags' nRadix' ppExpr' pbstrError' pichError
Long Parameter List,Cosmos.VS.DebugEngine,CosmosDebugEnginePackage,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\CosmosDebugEnginePackage.cs,Exec,The method has 5 parameters. Parameters: cmdGroup' nCmdID' nCmdExecOpt' pvaIn' pvaOut
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_TERMINATE_PROCESSES_STILL_DETACHING is 37.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_TERMINATE_PROCESSES_STILL_TERMINATING is 39.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_CANNOT_REMAP_NOT_AT_SEQUENCE_POINT is 36.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_GETDERIVEDMOST_NO_DERIVED_MOST is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_GETMEMORYBYTES_NO_MEMORY_BYTES is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_GETMEMORYCONTEXT_NO_MEMORY_CONTEXT is 36.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter S_GETEXTENDEDINFO_NO_EXTENDEDINFO is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_ATTACH_DEBUGGER_ALREADY_ATTACHED is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_ATTACH_DEBUGGEE_PROCESS_SECURITY_VIOLATION is 44.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_ATTACH_CANNOT_ATTACH_TO_DESKTOP is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_LAUNCH_DEBUGGING_NOT_POSSIBLE is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_LAUNCH_KERNEL_DEBUGGER_ENABLED is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_LAUNCH_KERNEL_DEBUGGER_PRESENT is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_MSHTML_SCRIPT_DEBUGGING_DISABLED is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_DE_CLR_DBG_SERVICES_NOT_INSTALLED is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_MIX_MINDUMP_DEBUGGING is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_SERVER_DOES_NOT_EXIST is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_SERVER_MACHINE_DOES_NOT_EXIST is 38.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_DEBUGGER_NOT_REGISTERED_PROPERLY is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_SERVER_MACHINE_NO_DEFAULT is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SERVICE_ACCESS_DENIED_ON_CALLBACK is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_COMPONENTS_NOT_REGISTERED is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SHARE_LEVEL_ACCESS_CONTROL_ENABLED is 36.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_WORKGROUP_REMOTE_LOGON_FAILURE is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_WINAUTH_CONNECT_NOT_SUPPORTED is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_EVALUATE_BUSY_WITH_EVALUATION is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_INTEROP_NOT_SUPPORTED_FOR_THIS_CLR is 36.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CLR_CANNOT_DEBUG_FIBER_PROCESS is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_PROCESS_OBJECT_ACCESS_DENIED is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_PROCESS_TOKEN_ACCESS_DENIED_NO_TS is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_OPERATION_REQUIRES_ELEVATION is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_PROCESS_DEBUGGER_IS_DEBUGGEE is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_JIT_VSJITDEBUGGER_NOT_REGISTERED is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SESSION_TERMINATE_DETACH_FAILED is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_ON_NONLEAF_FRAME is 44.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SETIP_TO_DIFFERENT_FUNCTION is 36.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_ON_EXCEPTION is 40.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_INTO_FINALLY is 40.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_OUT_OF_FINALLY is 42.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_INTO_CATCH is 38.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_GENERAL is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_SET_NEXT_STATEMENT_INTO_OR_OUT_OF_FILTER is 49.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_ASYNCBREAK_DEBUGGEE_NOT_INITIALIZED is 37.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_CONTINUE_DURING_PENDING_EXPR_EVAL is 42.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_REDIRECTION_UNSUPPORTED is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_LAUNCH_FAILED_WITH_ELEVATION is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_FIND_INTERNET_EXPLORER is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_EXCEPTION_CANNOT_BE_INTERCEPTED is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_EXCEPTION_CANNOT_UNWIND_ABOVE_CALLBACK is 40.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_INTERCEPT_CURRENT_EXCEPTION_NOT_SUPPORTED is 43.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_INTERCEPT_CANNOT_UNWIND_LASTCHANCE_INTEROP is 44.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_LOAD_DLL_TL_INCORRECT_VERSION is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_LOAD_DLL_DM_INCORRECT_VERSION is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_DEVICE_ACCESS_DENIED_SELECT_YES is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SETVALUE_VALUE_CANNOT_BE_SET is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SETVALUEASREFERENCE_NOTSUPPORTED is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CANNOT_GET_UNMANAGED_MEMORY_CONTEXT is 37.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SERVER_UNAVAILABLE_ON_CALLBACK is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_UNKNOWN_AUTHN_SERVICE_ON_CALLBACK is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_USER_LEVEL_ACCESS_CONTROL_REQUIRED is 36.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_64BIT_COMPONENTS_NOT_INSTALLED is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_CREDENTIALS_PROHIBITED is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_FIREWALL_CANNOT_OPEN_APPLICATION is 34.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_FIREWALL_CANNOT_OPEN_FILE_SHARING is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_REMOTE_DEBUGGING_UNSUPPORTED is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_AUTOATTACH_WEBSERVER_NOT_FOUND is 32.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_DBGEXTENSION_FUNCTION_NOT_FOUND is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CAUSALITY_NO_SERVER_RESPONSE is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CAUSALITY_REMOTE_NOT_REGISTERED is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CAUSALITY_BREAKPOINT_NOT_HIT is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_CAUSALITY_BREAKPOINT_BIND_ERROR is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SQL_SP_ENABLE_PERMISSION_DENIED is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SQL_DEBUGGING_NOT_ENABLED_ON_SERVER is 37.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SQL_CANT_FIND_SSDEBUGPS_ON_CLIENT is 35.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SQL_EXECUTED_BUT_NOT_DEBUGGED is 31.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_SQL_VDT_INIT_RETURNED_SQL_ERROR is 33.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_ATTACH_FAILED_ABORT_SILENTLY is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Definitions,AD7_HRESULT,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Definitions\AD7Hresult.cs,,The length of the parameter E_MANAGED_FEATURE_NOTSUPPORTED is 30.
Long Identifier,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,,The length of the parameter mASMSteppingOut_NumEndMethodLabelsPassed is 40.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7BoundBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7BoundBreakpoint.cs,Enable,The length of the statement  "                // A production debug engine would remove or add the underlying int3 here. The sample engine does not support true disabling " is 124.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,LaunchSuspended,The length of the statement  "            // Normally' Visual Studio launches a program using the IDebugPortEx2::LaunchSuspended method and then attaches the debugger " is 124.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,LaunchSuspended,The length of the statement  "            // (for example' if the debug engine is part of an interpreter and the program being debugged is an interpreted language)' " is 122.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,LaunchSuspended,The length of the statement  "            // The IDebugEngineLaunch2::ResumeProcess method is called to start the process after the process has been successfully launched in a suspended state. " is 150.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,LaunchSuspended,The length of the statement  "                //var processLaunchInfo = new ProcessLaunchInfo(exe' xCmdLine' dir' env' options' launchFlags' hStdInput' hStdOutput' hStdError); " is 129.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,CreatePendingBreakpoint,The length of the statement  "            // Creates a pending breakpoint in the engine. A pending breakpoint is contains all the information needed to bind a breakpoint to " is 130.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,CauseBreak,The length of the statement  "            // Requests that all programs being debugged by this DE stop execution the next time one of their threads attempts to run. " is 122.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Engine,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Engine.cs,GetProgramId,The length of the statement  "            // Gets a GUID for this program. A debug engine (DE) must return the program identifier originally passed to the IDebugProgramNodeAttach2::OnAttach " is 147.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Module,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Module.cs,GetSymbolInfo,The length of the statement  "            // This engine only supports loading symbols at the location specified in the binary's symbol path location in the PE file and " is 126.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,GetDocumentContext,The length of the statement  "            IDebugDocumentPosition2 docPosition = (IDebugDocumentPosition2)(Marshal.GetObjectForIUnknown(mBpRequestInfo.bpLocation.unionmember2)); " is 134.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The length of the statement  "                    xDocName = xDocName.ToLower(); //Bug: Some filenames were returned with the drive letter as lower case but in DocumentGUIDs it was captialised so file-not-found! " is 161.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The length of the statement  "                            //uint[] addresses = mEngine.DebuggedProcess.GetAddressesForSourceLocation(null' documentName' startPosition[0].dwLine + 1' startPosition[0].dwColumn); " is 151.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The length of the statement  "                                //    AD7BreakpointResolution breakpointResolution = new AD7BreakpointResolution(mEngine' addr' GetDocumentContext(addr)); " is 122.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The length of the statement  "                    // The breakpoint could not be bound. This may occur for many reasons such as an invalid location' an invalid expression' etc... " is 128.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The length of the statement  "                    // The sample engine does not support this' but a real world engine will want to send an instance of IDebugBreakpointErrorEvent2 to the " is 135.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The length of the statement  "                    // UI and return a valid instance of IDebugErrorBreakpoint2 from IDebugPendingBreakpoint2::EnumErrorBreakpoints. The debugger will then " is 135.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,CanBind,The length of the statement  "                // The sample engine does not support this' but a real world engine will want to return a valid enumeration of IDebugErrorBreakpoint2. " is 134.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,EnumErrorBreakpoints,The length of the statement  "            // Called when a pending breakpoint could not be bound. This may occur for many reasons such as an invalid location' an invalid expression' etc... " is 146.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,EnumErrorBreakpoints,The length of the statement  "            // The sample engine does not support this' but a real world engine will want to send an instance of IDebugBreakpointErrorEvent2 to the " is 135.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,EnumErrorBreakpoints,The length of the statement  "            // UI and return a valid enumeration of IDebugErrorBreakpoint2 from IDebugPendingBreakpoint2::EnumErrorBreakpoints. The debugger will then " is 138.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,mDebugUpPipe_DataPacketReceived,The length of the statement  "                            throw new Exception(String.Format("Command value '{0}' not supported in method AD7Process.mDebugUpPipe_DataPacketReceived."' aCmd)); " is 132.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdNullReferenceOccurred,The length of the statement  "                        var xSequencePoints = mDebugInfoDb.GetSequencePoints(mDebugInfoDb.GetAssemblyFileById(xMethod.AssemblyFileID).Pathname' xMethod.MethodToken); " is 141.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdNullReferenceOccurred,The length of the statement  "                        AD7Util.MessageBox($"NullReferenceException occurred in '{xMethod.LabelCall}'{Environment.NewLine}Document: {mDebugInfoDb.GetDocumentById(xMethod.DocumentID).Pathname}{Environment.NewLine}Line: {xLine}{Environment.NewLine}Address: 0x{lastEIPAddress.ToString("X8")}"); " is 267.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,GetPhysicalProcessId,The length of the statement  "            // http://blogs.msdn.com/b/jacdavis/archive/2008/05/01/what-to-do-if-your-debug-engine-doesn-t-create-real-processes.aspx " is 121.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,Terminate,The length of the statement  "                    "Failed to stop debugger! You probably need to install the VMWare VIX API!\r\n\r\nCheck Output window for more details."' " is 121.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,ChangeINT3sOnCurrentMethod,The length of the statement  "                var tpAdresses = clear ? new List<KeyValuePair<uint' string>>(INT3sSet.Count) : mDebugInfoDb.GetAllINT3AddressesForMethod(currMethod' true); " is 140.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadData,The length of the statement  "                xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' (uint)System.Runtime.InteropServices.Marshal.SizeOf(typeof(T))); " is 140.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The length of the statement  "                                    inf.Pointer = (uint)(xPointer + mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i)); " is 123.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The length of the statement  "                        ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); })); " is 136.
Long Statement,Cosmos.VS.DebugEngine.AD7.Impl,AD7StackFrame,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7StackFrame.cs,SetFrameInfo,The length of the statement  "        // If there is source information' construct a string that contains the module name' function name' and optionally argument names and values. " is 141.
Long Statement,Cosmos.VS.DebugEngine,AD7Util,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7Util.cs,Log,The length of the statement  "            //  File.AppendAllText(@"c:\data\sources\ad7.log"' DateTime.Now.ToString("HH:mm:ss.ffffff: ") + String.Format(message' args) + Environment.NewLine); " is 148.
Long Statement,Cosmos.VS.DebugEngine.Commands,DebugExecCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugExecCommand.cs,DebugExec,The length of the statement  "                    commandWindow.ExecuteCommand(String.Format(CultureInfo.InvariantCulture' "Debug.EvaluateStatement -exec {0}"' command)); " is 120.
Long Statement,Cosmos.VS.DebugEngine.Commands,DebugLaunchCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLaunchCommand.cs,Execute,The length of the statement  "            if (parseCommandLine.GetSwitchValue((int)DebugLaunchCommandSwitchEnum.Executable' out executable) != VSConstants.S_OK || " is 120.
Long Statement,Cosmos.VS.DebugEngine.Commands,DebugLaunchCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLaunchCommand.cs,Execute,The length of the statement  "                    throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "Options file '{0}' does not exist"' optionsFilePath)); " is 125.
Long Statement,Cosmos.VS.DebugEngine.Commands,DebugLogCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLogCommand.cs,Execute,The length of the statement  "                    throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "/On and /Off cannot both appear on command line")); " is 122.
Long Statement,Cosmos.VS.DebugEngine.Commands,DebugLogCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLogCommand.cs,Execute,The length of the statement  "                    throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "Must specify a log file (/On:<path>) or /OutputWindow")); " is 128.
Long Statement,Cosmos.VS.DebugEngine.Commands,DebugLogCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugLogCommand.cs,Execute,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' "One of /On or /Off must be present on command line")); " is 125.
Long Statement,Cosmos.VS.DebugEngine.Engine.Impl,EngineCallback,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Engine.Impl\EngineCallback.cs,OnSymbolSearch,The length of the statement  "      string statusString = (dwStatusFlags == enum_MODULE_INFO_FLAGS.MIF_SYMBOLS_LOADED ? "Symbols Loaded - " : "No symbols loaded") + status; " is 136.
Long Statement,Cosmos.VS.DebugEngine.Engine.Impl,EngineCallback,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Engine.Impl\EngineCallback.cs,OnBreakpointBound,The length of the statement  "      AD7BreakpointBoundEvent eventObject = new AD7BreakpointBoundEvent((AD7PendingBreakpoint)pendingBreakpoint' boundBreakpoint); " is 124.
Empty Catch Block,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdNullReferenceOccurred,The method has an empty catch block.
Empty Catch Block,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,AD7Process,The method has an empty catch block.
Empty Catch Block,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,HostShutdown,The method has an empty catch block.
Empty Catch Block,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The method has an empty catch block.
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7PendingBreakpoint,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7PendingBreakpoint.cs,Bind,The following statement contains a magic number: try              {                  if (CanBind())                  {                      var xDocPos = (IDebugDocumentPosition2)(Marshal.GetObjectForIUnknown(mBpRequestInfo.bpLocation.unionmember2));                        // Get the name of the document that the breakpoint was put in                      string xDocName;                      EngineUtils.CheckOk(xDocPos.GetFileName(out xDocName));                      xDocName = xDocName.ToLower(); //Bug: Some filenames were returned with the drive letter as lower case but in DocumentGUIDs it was captialised so file-not-found!                        // Get the location in the document that the breakpoint is in.                      var xStartPos = new TEXT_POSITION[1];                      var xEndPos = new TEXT_POSITION[1];                      EngineUtils.CheckOk(xDocPos.GetRange(xStartPos' xEndPos));                        UInt32 xAddress = 0;                      var xDebugInfo = mEngine.mProcess.mDebugInfoDb;                        // We must check for DocID. This is important because in a solution that contains many projects'                      // VS will send us BPs from other Cosmos projects (and possibly non Cosmos ones' didnt look that deep)                      // but we wont have them in our doc list because it contains only ones from the currently project                      // to run.                      long xDocID;                      if (xDebugInfo.DocumentGUIDs.TryGetValue(xDocName' out xDocID))                      {                          // Find which Method the Doc' Line' Col are in.                          // Must add +1 for both Line and Col. They are 0 based' while SP ones are 1 based.                          // () around << are VERY important.. + has precedence over <<                          Int64 xPos = (((Int64)xStartPos[0].dwLine + 1) << 32) + xStartPos[0].dwColumn + 1;                            try                          {                              var xMethod = xDebugInfo.GetMethodByDocumentIDAndLinePosition(xDocID' xPos' xPos);                              var asm = xDebugInfo.GetAssemblyFileById(xMethod.AssemblyFileID);                                // We have the method. Now find out what Sequence Point it belongs to.                              var xSPs = xDebugInfo.GetSequencePoints(asm.Pathname' xMethod.MethodToken);                              var xSP = xSPs.Single(q => q.LineColStart <= xPos && q.LineColEnd >= xPos);                                // We have the Sequence Point' find the MethodILOp                              var xOp = xDebugInfo.GetFirstMethodIlOpByMethodIdAndILOffset(xMethod.ID' xSP.Offset);                                // Get the address of the Label                              xAddress = xDebugInfo.GetAddressOfLabel(xOp.LabelName);                                  if (xAddress > 0)                              {                                  var xBPR = new AD7BreakpointResolution(mEngine' xAddress' GetDocumentContext(xAddress));                                  var xBBP = new AD7BoundBreakpoint(mEngine' xAddress' this' xBPR);                                  mBoundBPs.Add(xBBP);                              }                                // Ask the symbol engine to find all addresses in all modules with symbols that match this source and line number.                              //uint[] addresses = mEngine.DebuggedProcess.GetAddressesForSourceLocation(null' documentName' startPosition[0].dwLine + 1' startPosition[0].dwColumn);                              lock (mBoundBPs)                              {                                  //foreach (uint addr in addresses) {                                  //    AD7BreakpointResolution breakpointResolution = new AD7BreakpointResolution(mEngine' addr' GetDocumentContext(addr));                                  //    AD7BoundBreakpoint boundBreakpoint = new AD7BoundBreakpoint(mEngine' addr' this' breakpointResolution);                                  //    m_boundBreakpoints.Add(boundBreakpoint);                                  //    mEngine.DebuggedProcess.SetBreakpoint(addr' boundBreakpoint);                                  //}                              }                          }                          catch (InvalidOperationException)                          {                              //No elements in potXMethods sequence!                              return VSConstants.S_FALSE;                          }                      }                      return VSConstants.S_OK;                  }                  else                  {                      // The breakpoint could not be bound. This may occur for many reasons such as an invalid location' an invalid expression' etc...                      // The sample engine does not support this' but a real world engine will want to send an instance of IDebugBreakpointErrorEvent2 to the                      // UI and return a valid instance of IDebugErrorBreakpoint2 from IDebugPendingBreakpoint2::EnumErrorBreakpoints. The debugger will then                      // display information about why the breakpoint did not bind to the user.                      return VSConstants.S_FALSE;                  }              }              //catch (ComponentException e)              //{              //    return e.HResult;              //}              catch (Exception e)              {                  return EngineUtils.UnexpectedException(e);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdRegisters,The following statement contains a magic number: if (aData.Length < 40)              {                  mCurrentAddress = null;              }              else              {                  uint x32 = (uint)                      (aData[39] << 24 |                       aData[38] << 16 |                       aData[37] << 8 |                       aData[36]);                  mCurrentAddress = x32;                  //SendAssembly(true);              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,mDebugUpPipe_DataPacketReceived,The following statement contains a magic number: try              {                  if (aCmd <= 127)                  {                      switch (aCmd)                      {                          case Windows2Debugger.Noop:                              // do nothing                              break;                            case Windows2Debugger.PingVSIP:                              mDebugDownPipe.SendCommand(Debugger2Windows.PongVSIP);                              break;                            case Windows2Debugger.PingDebugStub:                              mDbgConnector.Ping();                              break;                            case Windows2Debugger.SetAsmBreak:                              {                                  string xLabel = Encoding.UTF8.GetString(aData);                                  uint xAddress = mDebugInfoDb.GetAddressOfLabel(xLabel);                                  mDbgConnector.SetAsmBreakpoint(xAddress);                                  mDbgConnector.Continue();                              }                              break;                            case Windows2Debugger.ToggleAsmBreak2:                              {                                  string xLabel = Encoding.UTF8.GetString(aData);                                  uint xAddress = mDebugInfoDb.GetAddressOfLabel(xLabel);                                  if (GetASMBreakpointInfoFromASMAddress(xAddress) == null)                                  {                                      SetASMBreakpoint(xAddress);                                  }                                  else                                  {                                      ClearASMBreakpoint(xAddress);                                  }                                  break;                              }                          case Windows2Debugger.ToggleStepMode:                              ASMSteppingMode = !ASMSteppingMode;                              break;                            case Windows2Debugger.SetStepModeAssembler:                              ASMSteppingMode = true;                              break;                            case Windows2Debugger.SetStepModeSource:                              ASMSteppingMode = false;                              break;                            case Windows2Debugger.CurrentASMLine:                              {                                  mCurrentASMLine = Encoding.UTF8.GetString(aData);                                  ASMWindow_CurrentLineUpdated.Set();                                  break;                              }                          case Windows2Debugger.NextASMLine1:                              {                                  if (aData.Length == 0)                                  {                                      mNextASMLine1 = null;                                      mNextAddress1 = null;                                  }                                  else                                  {                                      mNextASMLine1 = Encoding.UTF8.GetString(aData);                                      ASMWindow_NextLine1Updated.Set();                                  }                                  break;                              }                          case Windows2Debugger.NextLabel1:                              {                                  string nextLabel = Encoding.UTF8.GetString(aData);                                  mNextAddress1 = mDebugInfoDb.GetAddressOfLabel(nextLabel);                                  ASMWindow_NextAddress1Updated.Set();                                  break;                              }                          //cmd used from assembler window                          case Windows2Debugger.Continue:                              Step(enum_STEPKIND.STEP_OVER);                              break;                          //cmd used from assembler window                          case Windows2Debugger.AsmStepInto:                              Step(enum_STEPKIND.STEP_INTO);                              break;                          default:                              throw new Exception(String.Format("Command value '{0}' not supported in method AD7Process.mDebugUpPipe_DataPacketReceived."' aCmd));                      }                  }                  else                  {                      throw new NotImplementedException("Sending other channels not yet supported!");                  }              }              catch (Exception ex)              {                  //We cannot afford to silently break the pipe!                  OutputText("AD7Process UpPipe receive error! " + ex.Message);                  System.Diagnostics.Debug.WriteLine("AD7Process UpPipe receive error! " + ex.ToString());              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,CreateDebugConnector,The following statement contains a magic number: if ((null == xParts) || (2 > xParts.Length))              {                  throw new Exception(string.Format("Unable to parse VS debug port: '{0}'"' xPort));                  //throw new Exception(string.Format(                  //    "The '{0}' Cosmos project file property is either ill-formed or missing."'                  //    BuildProperties.VisualStudioDebugPortString));              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,DbgCmdBreak,The following statement contains a magic number: if (mASMSteppingOut)              {                  string[] currentASMLabels = mDebugInfoDb.GetLabels(aAddress);                  foreach (string aLabel in currentASMLabels)                  {                      if (aLabel.Contains("END__OF__METHOD_EXCEPTION__2"))                      {                          mASMSteppingOut_NumEndMethodLabelsPassed++;                          break;                      }                  }                  if (mASMSteppingOut_NumEndMethodLabelsPassed >= 2)                  {                      mASMSteppingOut = false;                  }                  new System.Threading.Tasks.Task(() =>                  {                      mDbgConnector.SendCmd(Vs2Ds.AsmStepInto);                  }).Start();              }              else              {                  bool fullUpdate = true;                      var xActionPoints = new List<object>();                  var xBoundBreakpoints = new List<IDebugBoundBreakpoint2>();                    if (!mBreaking)                  {                      // Search the BPs and find ones that match our address.                      foreach (var xBP in mEngine.BPMgr.mPendingBPs)                      {                          foreach (var xBBP in xBP.mBoundBPs)                          {                              if (xBBP.mAddress == aAddress)                              {                                  xBoundBreakpoints.Add(xBBP);                              }                          }                      }                  }                    mStackFrame = null;                  mCurrentAddress = aAddress;                  mCurrentASMLine = null;                  if (xBoundBreakpoints.Count == 0)                  {                      // If no matching breakpoints are found then its one of the following:                      //   - VS Break                      //   - Stepping operation                      //   - Asm break                          //We _must_ respond to the VS commands via callback if VS is waiting on one so check this first...                      if (mBreaking)                      {                          mCallback.OnBreak(mThread);                          mBreaking = false;                      }                      else if (mStepping)                      {                          mCallback.OnStepComplete();                          mStepping = false;                      }                      else                      {                          //Check if current address is the ASM BP we might be looking for                          if (ASMBPToStepTo != null && ASMBPToStepTo.Item2 == aAddress)                          {                              //There is an ASM BP at this address so break                              mCallback.OnBreak(mThread);                              //Clear what we are stepping towards                              ASMBPToStepTo = null;                          }                          else                          {                              fullUpdate = false;                                //Check we aren't already stepping towards an ASM BP                              if (ASMBPToStepTo == null)                              {                                  //Check for future ASM breakpoints...                                    //Since we got this far' we know this must be an INT3 for a future ASM BP that has to be in current C# line.                                  //So get the ASM BP based off current address                                  var bp = GetASMBreakpointInfoFromCSAddress(aAddress).First();                                  //Set it as address we are looking for                                  ASMBPToStepTo = bp;                              }                                //Step towards the ASM BP(step-over since we don't want to go through calls or anything)                                //We must check we haven't just stepped and address jumped wildely out of range (e.g. conditional jumps)                              if (aAddress < ASMBPToStepTo.Item1 || aAddress > ASMBPToStepTo.Item2)                              {                                  //If we have' just continue execution as this BP won't be hit.                                  mDbgConnector.Continue();                                  ASMBPToStepTo = null;                              }                              else                              {                                  //We must do an update of ASM window so Step-Over can function properly                                  SendAssembly(true);                                  //Delay / wait for asm window to update                                  WaitForAssemblyUpdate();                                  //Do the step-over                                  ASMStepOver();                              }                          }                      }                  }                  else                  {                      // Found a bound breakpoint                      mCallback.OnBreakpoint(mThread' xBoundBreakpoints.AsReadOnly());                  }                  if (fullUpdate)                  {                      RequestFullDebugStubUpdate();                  }              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,SendAssembly,The following statement contains a magic number: if (xSourceInfos.Count > 0)              {                  //We should be able to display the asesembler source for any address regardless of whether a C#                  //line is associated with it.                  //However' we do not store all labels in the debug database because that would make the compile                  //time insane.                  //So:                  // - We take the current address amd find the method it is part of                  // - We use the method header label as a start point and find all asm labels till the method footer label                  // - We then find all the asm for these labels and display it.                    Label[] xLabels = mDebugInfoDb.GetMethodLabels(xAddress);                  AD7Util.Log("SendAssembly - MethodLabels retrieved");                  // get the label of our current position' or the closest one before                  var curPosLabel = xLabels.Where(i => i.Address <= xAddress).OrderByDescending(i => i.Address).FirstOrDefault();                  // if curPosLabel is null' grab the first one.                  if (curPosLabel == null)                  {                      curPosLabel = xLabels[0];                  }                    var curPosIndex = Array.IndexOf(xLabels' curPosLabel);                  // we want 50 items before and after the current item' so 100 in total.                  var itemsBefore = 10;                  var itemsAfter = 10;                    if (curPosIndex < itemsBefore)                  {                      // there are no 50 items before the current one' so adjust                      itemsBefore = curPosIndex;                  }                  if ((curPosIndex + itemsAfter) >= xLabels.Length)                  {                      // there are no 50 items after the current one' so adjust                      itemsAfter = xLabels.Length - curPosIndex;                  }                    var newArr = new Label[itemsBefore + itemsAfter];                  for (int i = 0; i < newArr.Length; i++)                  {                      newArr[i] = xLabels[(curPosIndex - itemsBefore) + i];                  }                  xLabels = newArr;                    //The ":" has to be added in because labels in asm code have it on the end - it's easier to add it here than                  //strip them out of the read asm                  var xLabelNames = xLabels.Select(x => x.Name + ":").ToList();                    // Get assembly source                  var xCode = AsmSource.GetSourceForLabels(Path.ChangeExtension(mISO' ".asm")' xLabelNames);                  AD7Util.Log("SendAssembly - SourceForLabels retrieved");                    // Get label for current address.                  // A single address can have multiple labels (IL' Asm). Because of this we search                  // for the one with the Asm tag. We dont have the tags in this debug info though'                  // so instead if there is more than one label we use the longest one which is the Asm tag.                  string xCurrentLabel = "";                  var xCurrentLabels = mDebugInfoDb.GetLabels(xAddress);                  if (xCurrentLabels.Length > 0)                  {                      xCurrentLabel = xCurrentLabels.OrderBy(q => q.Length).Last();                  }                  if (string.IsNullOrEmpty(xCurrentLabel))                  {                      xCurrentLabel = "NO_METHOD_LABEL_FOUND";                  }                    // Insert filter labels list as THIRD(!) line of our data stream                  string filterLabelsList = "";                  foreach (var addressInfo in INT3sSet)                  {                      //"We have to add the ".00:" because of how the ASM window works...                      filterLabelsList += "|" + addressInfo.Value + ".00";                  }                  if (filterLabelsList.Length > 0)                  {                      filterLabelsList = filterLabelsList.Substring(1);                  }                  xCode.Insert(0' filterLabelsList + "\r\n");                  // Insert parameters as SECOND(!) line of our data stream                  xCode.Insert(0' (noDisplay ? "NoDisplay" : "") + "|" + (ASMSteppingMode ? "AsmStepMode" : "") + "\r\n");                  // Insert current line's label as FIRST(!) line of our data stream                  xCode.Insert(0' xCurrentLabel + "\r\n");                  //THINK ABOUT THE ORDER that he above lines occur in and where they insert data into the stream - don't switch it!                  AD7Util.Log("SendAssembly - Sending through pipe now");                  mDebugDownPipe.SendCommand(Debugger2Windows.AssemblySource' Encoding.UTF8.GetBytes(xCode.ToString()));                  AD7Util.Log("SendAssembly - Done");              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,SendAssembly,The following statement contains a magic number: if (xSourceInfos.Count > 0)              {                  //We should be able to display the asesembler source for any address regardless of whether a C#                  //line is associated with it.                  //However' we do not store all labels in the debug database because that would make the compile                  //time insane.                  //So:                  // - We take the current address amd find the method it is part of                  // - We use the method header label as a start point and find all asm labels till the method footer label                  // - We then find all the asm for these labels and display it.                    Label[] xLabels = mDebugInfoDb.GetMethodLabels(xAddress);                  AD7Util.Log("SendAssembly - MethodLabels retrieved");                  // get the label of our current position' or the closest one before                  var curPosLabel = xLabels.Where(i => i.Address <= xAddress).OrderByDescending(i => i.Address).FirstOrDefault();                  // if curPosLabel is null' grab the first one.                  if (curPosLabel == null)                  {                      curPosLabel = xLabels[0];                  }                    var curPosIndex = Array.IndexOf(xLabels' curPosLabel);                  // we want 50 items before and after the current item' so 100 in total.                  var itemsBefore = 10;                  var itemsAfter = 10;                    if (curPosIndex < itemsBefore)                  {                      // there are no 50 items before the current one' so adjust                      itemsBefore = curPosIndex;                  }                  if ((curPosIndex + itemsAfter) >= xLabels.Length)                  {                      // there are no 50 items after the current one' so adjust                      itemsAfter = xLabels.Length - curPosIndex;                  }                    var newArr = new Label[itemsBefore + itemsAfter];                  for (int i = 0; i < newArr.Length; i++)                  {                      newArr[i] = xLabels[(curPosIndex - itemsBefore) + i];                  }                  xLabels = newArr;                    //The ":" has to be added in because labels in asm code have it on the end - it's easier to add it here than                  //strip them out of the read asm                  var xLabelNames = xLabels.Select(x => x.Name + ":").ToList();                    // Get assembly source                  var xCode = AsmSource.GetSourceForLabels(Path.ChangeExtension(mISO' ".asm")' xLabelNames);                  AD7Util.Log("SendAssembly - SourceForLabels retrieved");                    // Get label for current address.                  // A single address can have multiple labels (IL' Asm). Because of this we search                  // for the one with the Asm tag. We dont have the tags in this debug info though'                  // so instead if there is more than one label we use the longest one which is the Asm tag.                  string xCurrentLabel = "";                  var xCurrentLabels = mDebugInfoDb.GetLabels(xAddress);                  if (xCurrentLabels.Length > 0)                  {                      xCurrentLabel = xCurrentLabels.OrderBy(q => q.Length).Last();                  }                  if (string.IsNullOrEmpty(xCurrentLabel))                  {                      xCurrentLabel = "NO_METHOD_LABEL_FOUND";                  }                    // Insert filter labels list as THIRD(!) line of our data stream                  string filterLabelsList = "";                  foreach (var addressInfo in INT3sSet)                  {                      //"We have to add the ".00:" because of how the ASM window works...                      filterLabelsList += "|" + addressInfo.Value + ".00";                  }                  if (filterLabelsList.Length > 0)                  {                      filterLabelsList = filterLabelsList.Substring(1);                  }                  xCode.Insert(0' filterLabelsList + "\r\n");                  // Insert parameters as SECOND(!) line of our data stream                  xCode.Insert(0' (noDisplay ? "NoDisplay" : "") + "|" + (ASMSteppingMode ? "AsmStepMode" : "") + "\r\n");                  // Insert current line's label as FIRST(!) line of our data stream                  xCode.Insert(0' xCurrentLabel + "\r\n");                  //THINK ABOUT THE ORDER that he above lines occur in and where they insert data into the stream - don't switch it!                  AD7Util.Log("SendAssembly - Sending through pipe now");                  mDebugDownPipe.SendCommand(Debugger2Windows.AssemblySource' Encoding.UTF8.GetBytes(xCode.ToString()));                  AD7Util.Log("SendAssembly - Done");              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,WaitForAssemblyUpdate,The following statement contains a magic number: ASMWindow_CurrentLineUpdated.WaitOne(5000);
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,WaitForAssemblyUpdate,The following statement contains a magic number: ASMWindow_NextAddress1Updated.WaitOne(5000);
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Process,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Process.cs,WaitForAssemblyUpdate,The following statement contains a magic number: ASMWindow_NextLine1Updated.WaitOne(5000);
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The following statement contains a magic number: xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The following statement contains a magic number: xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The following statement contains a magic number: if (xData == null)              {                  propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");              }              else              {                  uint xPointer = BitConverter.ToUInt32(xData' 0);                  if (xPointer == 0)                  {                      propertyInfo.bstrValue = NULL;                  }                  else                  {                      xData = mProcess.mDbgConnector.GetMemoryData(xPointer + mArrayLengthOffset' 4' 4);                      if (xData == null)                      {                          propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                      }                      else                      {                          uint xDataLength = BitConverter.ToUInt32(xData' 0);                          bool xIsTooLong = xDataLength > 512;                          if (xIsTooLong)                          {                              xDataLength = 512;                          }                          if (xDataLength > 0)                          {                              if (this.m_variableInformation.Children.Count == 0)                              {                                  for (int i = 0; i < xDataLength; i++)                                  {                                      DebugLocalInfo inf = new DebugLocalInfo();                                      inf.IsReference = true;                                      inf.Type = typeof(T).AssemblyQualifiedName;                                      inf.Offset = (int)(mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Pointer = (uint)(xPointer + mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Name = "[" + i.ToString() + "]";                                      this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                  }                              }                          }                          propertyInfo.bstrValue = String.Format(typeAsString + "[{0}] at 0x{1} "' xDataLength' xPointer.ToString("X"));                      }                  }              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The following statement contains a magic number: if (xData == null)              {                  propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");              }              else              {                  uint xPointer = BitConverter.ToUInt32(xData' 0);                  if (xPointer == 0)                  {                      propertyInfo.bstrValue = NULL;                  }                  else                  {                      xData = mProcess.mDbgConnector.GetMemoryData(xPointer + mArrayLengthOffset' 4' 4);                      if (xData == null)                      {                          propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                      }                      else                      {                          uint xDataLength = BitConverter.ToUInt32(xData' 0);                          bool xIsTooLong = xDataLength > 512;                          if (xIsTooLong)                          {                              xDataLength = 512;                          }                          if (xDataLength > 0)                          {                              if (this.m_variableInformation.Children.Count == 0)                              {                                  for (int i = 0; i < xDataLength; i++)                                  {                                      DebugLocalInfo inf = new DebugLocalInfo();                                      inf.IsReference = true;                                      inf.Type = typeof(T).AssemblyQualifiedName;                                      inf.Offset = (int)(mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Pointer = (uint)(xPointer + mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Name = "[" + i.ToString() + "]";                                      this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                  }                              }                          }                          propertyInfo.bstrValue = String.Format(typeAsString + "[{0}] at 0x{1} "' xDataLength' xPointer.ToString("X"));                      }                  }              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The following statement contains a magic number: if (xData == null)              {                  propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");              }              else              {                  uint xPointer = BitConverter.ToUInt32(xData' 0);                  if (xPointer == 0)                  {                      propertyInfo.bstrValue = NULL;                  }                  else                  {                      xData = mProcess.mDbgConnector.GetMemoryData(xPointer + mArrayLengthOffset' 4' 4);                      if (xData == null)                      {                          propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                      }                      else                      {                          uint xDataLength = BitConverter.ToUInt32(xData' 0);                          bool xIsTooLong = xDataLength > 512;                          if (xIsTooLong)                          {                              xDataLength = 512;                          }                          if (xDataLength > 0)                          {                              if (this.m_variableInformation.Children.Count == 0)                              {                                  for (int i = 0; i < xDataLength; i++)                                  {                                      DebugLocalInfo inf = new DebugLocalInfo();                                      inf.IsReference = true;                                      inf.Type = typeof(T).AssemblyQualifiedName;                                      inf.Offset = (int)(mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Pointer = (uint)(xPointer + mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Name = "[" + i.ToString() + "]";                                      this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                  }                              }                          }                          propertyInfo.bstrValue = String.Format(typeAsString + "[{0}] at 0x{1} "' xDataLength' xPointer.ToString("X"));                      }                  }              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ReadDataArray,The following statement contains a magic number: if (xData == null)              {                  propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");              }              else              {                  uint xPointer = BitConverter.ToUInt32(xData' 0);                  if (xPointer == 0)                  {                      propertyInfo.bstrValue = NULL;                  }                  else                  {                      xData = mProcess.mDbgConnector.GetMemoryData(xPointer + mArrayLengthOffset' 4' 4);                      if (xData == null)                      {                          propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                      }                      else                      {                          uint xDataLength = BitConverter.ToUInt32(xData' 0);                          bool xIsTooLong = xDataLength > 512;                          if (xIsTooLong)                          {                              xDataLength = 512;                          }                          if (xDataLength > 0)                          {                              if (this.m_variableInformation.Children.Count == 0)                              {                                  for (int i = 0; i < xDataLength; i++)                                  {                                      DebugLocalInfo inf = new DebugLocalInfo();                                      inf.IsReference = true;                                      inf.Type = typeof(T).AssemblyQualifiedName;                                      inf.Offset = (int)(mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Pointer = (uint)(xPointer + mArrayFirstElementOffset + (System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)) * i));                                      inf.Name = "[" + i.ToString() + "]";                                      this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                  }                              }                          }                          propertyInfo.bstrValue = String.Format(typeAsString + "[{0}] at 0x{1} "' xDataLength' xPointer.ToString("X"));                      }                  }              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine.AD7.Impl,AD7Property,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AD7.Impl\AD7Property.cs,ConstructDebugPropertyInfo,The following statement contains a magic number: try              {                  if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME))                  {                      propertyInfo.bstrFullName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_FULLNAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME))                  {                      propertyInfo.bstrName = m_variableInformation.Name;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_NAME;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE))                  {                      propertyInfo.bstrType = mDebugInfo.TYPENAME;                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_TYPE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE))                  {                      byte[] xData;                        #region string                      if (mDebugInfo.TYPENAME == typeof(string).AssemblyQualifiedName)                      {                          const uint xStringLengthOffset = 12;                          const uint xStringFirstCharOffset = 16;                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xStrPointer = BitConverter.ToUInt32(xData' 0);                              if (xStrPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xStringLength = BitConverter.ToUInt32(xData' 0);                                      propertyInfo.bstrValue = "String of length: " + xStringLength;                                      if (xStringLength > 100)                                      {                                          propertyInfo.bstrValue = "For now' strings larger than 100 chars are not supported..";                                      }                                      else if (xStringLength == 0)                                      {                                          propertyInfo.bstrValue = "\"\"";                                      }                                      else                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xStrPointer + xStringFirstCharOffset' xStringLength * 2' 2);                                          if (xData == null)                                          {                                              propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                          }                                          else                                          {                                              propertyInfo.bstrValue = "\"" + Encoding.Unicode.GetString(xData) + "\"";                                          }                                      }                                  }                              }                          }                      }                      #endregion    #warning TODO: String[]                        #region byte                      // Byte                      else if (mDebugInfo.TYPENAME == typeof(byte).AssemblyQualifiedName)                      {                          ReadData<byte>(ref propertyInfo' new Func<byte[]' int' byte>(delegate(byte[] barr' int ind) { return barr[ind]; }));                      }                      else if (mDebugInfo.TYPENAME == typeof(byte[]).AssemblyQualifiedName)                      {                          ReadDataArray<byte>(ref propertyInfo' "byte");                      }                      #endregion                        #region sbyte                      // SByte                      else if (mDebugInfo.TYPENAME == typeof(sbyte).AssemblyQualifiedName)                      {                          ReadData<sbyte>(ref propertyInfo' new Func<byte[]' int' sbyte>(delegate(byte[] barr' int ind) { return unchecked((sbyte)barr[ind]); }));                      }                      else if (mDebugInfo.TYPENAME == typeof(sbyte[]).AssemblyQualifiedName)                      {                          ReadDataArray<sbyte>(ref propertyInfo' "sbyte");                      }                      #endregion                        #region char                      else if (mDebugInfo.TYPENAME == typeof(char).AssemblyQualifiedName)                      {                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 2);                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xTypedCharValue = BitConverter.ToChar(xData' 0);                              propertyInfo.bstrValue = String.Format("{0} '{1}'"' (ushort)xTypedCharValue' xTypedCharValue);                          }                      }                      else if (mDebugInfo.TYPENAME == typeof(char[]).AssemblyQualifiedName)                      {                          // Get handle                          xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          // Get actual pointer                          xData = mProcess.mDbgConnector.GetMemoryData(BitConverter.ToUInt32(xData' 0)' 4);                            if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              uint xArrayPointer = BitConverter.ToUInt32(xData' 0);                              if (xArrayPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayLengthOffset' 4' 4);                                  if (xData == null)                                  {                                      propertyInfo.bstrValue = String.Format("Error! Memory data received was null!");                                  }                                  else                                  {                                      uint xDataLength = BitConverter.ToUInt32(xData' 0);                                      bool xIsTooLong = xDataLength > 512;                                      var xSB = new StringBuilder();                                      xSB.AppendFormat("Char[{0}] at 0x{1} {{ "' xDataLength' xArrayPointer.ToString("X"));                                      if (xIsTooLong)                                      {                                          xDataLength = 512;                                      }                                      if (xDataLength > 0)                                      {                                          xData = mProcess.mDbgConnector.GetMemoryData(xArrayPointer + mArrayFirstElementOffset' xDataLength * 2);                                          if (xData == null)                                          {                                              xSB.Append(String.Format("Error! Memory data received was null!"));                                          }                                          else                                          {                                              bool first = true;                                              for (int i = 0; (i / 2) < xDataLength; i += 2)                                              {                                                  if (!first)                                                      xSB.Append("' ");                                                  char c = BitConverter.ToChar(xData' i);                                                  xSB.Append('\'');                                                  if (c == '\0')                                                  {                                                      xSB.Append("\\0");                                                  }                                                  else                                                  {                                                      xSB.Append(c);                                                  }                                                  xSB.Append('\'');                                                    first = false;                                              }                                          }                                      }                                      if (xIsTooLong)                                      {                                          xSB.Append("' ..");                                      }                                        xSB.Append(" }");                                      propertyInfo.bstrValue = xSB.ToString();                                  }                              }                          }                      }                      #endregion                        #region short                      // Short                      else if (mDebugInfo.TYPENAME == typeof(short).AssemblyQualifiedName)                      {                          ReadData<short>(ref propertyInfo' new Func<byte[]' int' short>(BitConverter.ToInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(short[]).AssemblyQualifiedName)                      {                          ReadDataArray<short>(ref propertyInfo' "short");                      }                      #endregion                        #region ushort                      // UShort                      else if (mDebugInfo.TYPENAME == typeof(ushort).AssemblyQualifiedName)                      {                          ReadData<ushort>(ref propertyInfo' new Func<byte[]' int' ushort>(BitConverter.ToUInt16));                      }                      else if (mDebugInfo.TYPENAME == typeof(ushort[]).AssemblyQualifiedName)                      {                          ReadDataArray<ushort>(ref propertyInfo' "ushort");                      }                      #endregion                        #region int                      // Int32                      else if (mDebugInfo.TYPENAME == typeof(int).AssemblyQualifiedName)                      {                          ReadData<int>(ref propertyInfo' new Func<byte[]' int' int>(BitConverter.ToInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(int[]).AssemblyQualifiedName)                      {                          ReadDataArray<int>(ref propertyInfo' "int");                      }                      #endregion                        #region uint                      // UInt32                      else if (mDebugInfo.TYPENAME == typeof(uint).AssemblyQualifiedName)                      {                          ReadData<uint>(ref propertyInfo' new Func<byte[]' int' uint>(BitConverter.ToUInt32));                      }                      else if (mDebugInfo.TYPENAME == typeof(uint[]).AssemblyQualifiedName)                      {                          ReadDataArray<uint>(ref propertyInfo' "uint");                      }                      #endregion                        #region long                      // Long                      else if (mDebugInfo.TYPENAME == typeof(long).AssemblyQualifiedName)                      {                          ReadData<long>(ref propertyInfo' new Func<byte[]' int' long>(BitConverter.ToInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(long[]).AssemblyQualifiedName)                      {                          ReadDataArray<long>(ref propertyInfo' "long");                      }                      #endregion                        #region ulong                      // ULong                      else if (mDebugInfo.TYPENAME == typeof(ulong).AssemblyQualifiedName)                      {                          ReadData<ulong>(ref propertyInfo' new Func<byte[]' int' ulong>(BitConverter.ToUInt64));                      }                      else if (mDebugInfo.TYPENAME == typeof(ulong[]).AssemblyQualifiedName)                      {                          ReadDataArray<ulong>(ref propertyInfo' "ulong");                      }                      #endregion                        #region float                      // Float                      else if (mDebugInfo.TYPENAME == typeof(float).AssemblyQualifiedName)                      {                          ReadData<float>(ref propertyInfo' new Func<byte[]' int' float>(BitConverter.ToSingle));                      }                      else if (mDebugInfo.TYPENAME == typeof(float[]).AssemblyQualifiedName)                      {                          ReadDataArray<float>(ref propertyInfo' "float");                      }                      #endregion                        #region double                      // Double                      else if (mDebugInfo.TYPENAME == typeof(double).AssemblyQualifiedName)                      {                          ReadData<double>(ref propertyInfo' new Func<byte[]' int' double>(BitConverter.ToDouble));                      }                      else if (mDebugInfo.TYPENAME == typeof(double[]).AssemblyQualifiedName)                      {                          ReadDataArray<double>(ref propertyInfo' "double");                      }                      #endregion                        #region bool                      // Bool                      else if (mDebugInfo.TYPENAME == typeof(bool).AssemblyQualifiedName)                      {                          ReadData<bool>(ref propertyInfo' new Func<byte[]' int' bool>(BitConverter.ToBoolean));                      }                      else if (mDebugInfo.TYPENAME == typeof(bool[]).AssemblyQualifiedName)                      {                          ReadDataArray<bool>(ref propertyInfo' "bool");                      }                      #endregion                        else                      {                          if (m_variableInformation.IsReference)                          {                              xData = mProcess.mDbgConnector.GetMemoryData(m_variableInformation.Pointer' 4' 4);                          }                          else                          {                              xData = mProcess.mDbgConnector.GetStackData(OFFSET' 4);                          }                          if (xData == null)                          {                              propertyInfo.bstrValue = String.Format("Error! Stack data received was null!");                          }                          else                          {                              var xPointer = BitConverter.ToUInt32(xData' 0);                              if (xPointer == 0)                              {                                  propertyInfo.bstrValue = NULL;                              }                              else                              {                                  try                                  {                                      var mp = mProcess.mDebugInfoDb.GetFieldMap(mDebugInfo.TYPENAME);                                      foreach (string str in mp.FieldNames)                                      {                                          FIELD_INFO xFieldInfo;                                          xFieldInfo = mProcess.mDebugInfoDb.GetFieldInfoByName(str);                                          var inf = new DebugLocalInfo();                                          inf.IsReference = true;                                          inf.Type = xFieldInfo.TYPE;                                          inf.Offset = xFieldInfo.OFFSET;                                          inf.Pointer = (uint)(xPointer + xFieldInfo.OFFSET + 12);                                          inf.Name = GetFieldName(xFieldInfo);                                          this.m_variableInformation.Children.Add(new AD7Property(inf' this.mProcess' this.mStackFrame));                                      }                                      propertyInfo.bstrValue = String.Format("{0} (0x{1})"' xPointer' xPointer.ToString("X").ToUpper());                                  }                                  catch (Exception ex)                                  {                                      if (ex.GetType().Name == "SQLiteException")                                      {                                          //Ignore but warn user                                          propertyInfo.bstrValue = "SQLiteException. Could not get type information for " + mDebugInfo.TYPENAME;                                      }                                      else                                      {                                          throw new Exception("Unexpected error in AD7Property.cs:459"' ex);                                      }                                  }                              }                          }                      }                      propertyInfo.dwFields |= enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE;                  }                    if (dwFields.HasFlag(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_ATTRIB))                  {                      // The sample does not support writing of values displayed in the debugger' so mark them all as read-only.                      propertyInfo.dwAttrib = enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_VALUE_READONLY;                        if (this.m_variableInformation.Children.Count > 0)                      {                          propertyInfo.dwAttrib |= enum_DBG_ATTRIB_FLAGS.DBG_ATTRIB_OBJ_IS_EXPANDABLE;                      }                  }                    propertyInfo.pProperty = (IDebugProperty2)this;                  propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  // If the debugger has asked for the property' or the property has children (meaning it is a pointer in the sample)                  // then set the pProperty field so the debugger can call back when the children are enumerated.                  //if (((dwFields & (uint)enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP) != 0)                  //|| (this.m_variableInformation.child != null))                  //{                  //    propertyInfo.pProperty = (IDebugProperty2)this;                  //    propertyInfo.dwFields |= (enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_PROP);                  //}              }              catch              {              }
Magic Number,Cosmos.VS.DebugEngine,AsmSource,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\AsmSource.cs,GetSourceForLabels,The following statement contains a magic number: using (var xSR = new StreamReader(aAsmFile' Encoding.ASCII))              {                  string xLine;                  while (true)                  {                      xLine = xSR.ReadLine();                      if (xLine == null)                      {                          break;                      }                        var xParts = xLine.Trim().Split(' ');                      if (xParts.Length > 0 && xParts[0].EndsWith(":"))                      {                          if (aLabels.Contains(xParts[0]))                          {                              // Found the first match' break.                              break;                          }                      }                  }                  var lineCount = 0;                  // Extract the pertinent lines                  while (xLine != null)                  {                      if (lineCount > 100)                      {                          break;                      }                      var xParts = xLine.Trim().Split(' ');                      if (xParts.Length > 0 && xParts[0].EndsWith(":"))                      {                          // Its a label' lets check it                          if (xParts.Length > 1 && xParts[1] == ";Asm")                          {                              // ASM label                              xCode.AppendLine(xLine);                              lineCount ++;                          }                          else if (aLabels.Contains(xParts[0]))                          {                               // Normal label                              xCode.AppendLine(xLine);                              lineCount ++;                          }                          else                          {                              // Label with unrecognized comment' or IL label that doesn't match.                              // We are done.                              break;                          }                      }                      else                      { // Not a label' just output it                          xCode.AppendLine(xLine);                      }                      xLine = xSR.ReadLine();                  }              }
Magic Number,Cosmos.VS.DebugEngine.Commands,BaseDebugCommand,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\BaseDebugCommand.cs,IsQueryParameterList,The following statement contains a magic number: ushort hi = (ushort)(nCmdexecopt >> 16);
Magic Number,Cosmos.VS.DebugEngine.Engine.Impl,EngineUtils,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Engine.Impl\EngineUtils.cs,BuildCommandLine,The following statement contains a magic number: if (exe[0] == '\"') {          startQuote = string.Empty;          if (exe.Length == 1) {            //throw new ComponentException(Constants.E_WIN32_INVALID_NAME);          }            // If there are any more quotes' it needs to be the last character          int endQuote = exe.IndexOf('\"'' 1);          if (endQuote > 0) {            if (exe.Length == 2 || endQuote != exe.Length - 1) {              //throw new ComponentException(Constants.E_WIN32_INVALID_NAME);            }            afterExe = string.Empty;          }        } else {          // If it doesn't start with a quote' it shouldn't have any          if (exe.IndexOf('\"') >= 0) {            //throw new ComponentException(Constants.E_WIN32_INVALID_NAME);          }        }
Magic Number,Cosmos.VS.DebugEngine.Engine.Impl,WorkerThread,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Engine.Impl\OperationThread.cs,ThreadFunc,The following statement contains a magic number: while (!fQuit)              {                  //if ((m_debuggedProcess != null) && (m_debuggedProcess.IsPumpingDebugEvents))                  {                      //m_debuggedProcess.WaitForAndDispatchDebugEvent(ResumeEventPumpFlags.ResumeWithExceptionHandled);                  }                    // If the other thread is dispatching a command' execute it now.                  bool fReceivedCommand = m_opSet.WaitOne(new TimeSpan(0' 0' 0' 0' 100)' false);                    if (fReceivedCommand)                  {                      if (m_fSyncOp)                      {                          try                          {                              m_op();                          }                          catch (Exception opException)                          {                              m_opException = opException;                          }                      }                      else                      {                          m_op();                      }                        fQuit = (m_op == m_quitOperation);                      if (!fQuit)                      {                          m_op = null;                      }                        m_opComplete.Set();                      m_opSet.Reset();                  }              }
Magic Number,Cosmos.VS.DebugEngine.Utilities,Extensions,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Utilities\Extensions.cs,GetFullName,The following statement contains a magic number: var xBuilder = new StringBuilder(256);
Missing Default,Cosmos.VS.DebugEngine.Commands,DebugCommandHandler,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugCommandHandler.cs,Execute,The following switch statement is missing a default case: switch (nCmdID)              {                  case CmdIDList.DebugLaunchCmdID:                      if (OnDebugLaunch != null)                      {                          return OnDebugLaunch(nCmdExecOpt' pvaIn' pvaOut);                      }                      break;                  case CmdIDList.DebugExecCmdID:                      if (OnDebugExec != null)                      {                          return OnDebugExec(nCmdExecOpt' pvaIn' pvaOut);                      }                      break;                  case CmdIDList.DebugLogCmdID:                      if (OnDebugLog != null)                      {                          return OnDebugLog(nCmdExecOpt' pvaIn' pvaOut);                      }                      break;              }
Missing Default,Cosmos.VS.DebugEngine.Commands,DebugCommandHandler,C:\repos\CosmosOS_Cosmos\source\Cosmos.VS.DebugEngine\Commands\DebugCommandHandler.cs,Query,The following switch statement is missing a default case: switch (prgCmds[0].cmdID)              {                  case CmdIDList.DebugLaunchCmdID:                  case CmdIDList.DebugExecCmdID:                  case CmdIDList.DebugLogCmdID:                      prgCmds[0].cmdf |= (uint)(OLECMDF.OLECMDF_SUPPORTED | OLECMDF.OLECMDF_ENABLED | OLECMDF.OLECMDF_INVISIBLE);                      return VSConstants.S_OK;              }
