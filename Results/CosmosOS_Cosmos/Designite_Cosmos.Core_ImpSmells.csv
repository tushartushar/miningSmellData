Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,Cyclomatic complexity of the method is 13
Complex Method,Cosmos.Core.Memory.Old,Heap,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\Old_Heap.cs,MemAlloc,Cyclomatic complexity of the method is 11
Complex Method,Cosmos.Core.Memory.Old,Heap,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\Old_Heap.cs,ScanDataLookupTable,Cyclomatic complexity of the method is 8
Long Parameter List,Cosmos.Core,CosmosRuntimeType,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\CosmosRuntimeType.cs,GetConstructorImpl,The method has 5 parameters. Parameters: bindingAttr' binder' callConvention' types' modifiers
Long Parameter List,Cosmos.Core,CosmosRuntimeType,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\CosmosRuntimeType.cs,InvokeMember,The method has 8 parameters. Parameters: name' invokeAttr' binder' target' args' modifiers' culture' namedParameters
Long Parameter List,Cosmos.Core,CosmosRuntimeType,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\CosmosRuntimeType.cs,GetMethodImpl,The method has 6 parameters. Parameters: name' bindingAttr' binder' callConvention' types' modifiers
Long Parameter List,Cosmos.Core,CosmosRuntimeType,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\CosmosRuntimeType.cs,GetPropertyImpl,The method has 6 parameters. Parameters: name' bindingAttr' binder' returnType' types' modifiers
Long Parameter List,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The method has 5 parameters. Parameters: aEIP' aDescription' aName' ctx' lastKnownAddressValue
Long Statement,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleInterrupt_09,The length of the statement  "            HandleException(aContext.EIP' "Coprocessor Segment Overrun Exception"' "Coprocessor Segment Overrun Exception"' ref aContext); " is 126.
Long Statement,Cosmos.Core.Memory.Old,Heap,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\Old_Heap.cs,MemAlloc,The length of the statement  "                    mDebugger.Send("    Something seriously weird happened: we could create a new DataLookupTable (with new entries)' but couldn't allocate a new handle from it."); " is 160.
Complex Conditional,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The conditional expression  "(*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12"  is complex.
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Check_RSD,The following statement contains a magic number: for (int i = 0; i < 20; i++)                  sum += *(check++);
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: for (int i = 19; i >= 16; i--)              {                  addr += (*(ptr + i));                  addr = (i == 16) ? addr : addr << 8;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: for (int i = 19; i >= 16; i--)              {                  addr += (*(ptr + i));                  addr = (i == 16) ? addr : addr << 8;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: for (int i = 19; i >= 16; i--)              {                  addr += (*(ptr + i));                  addr = (i == 16) ? addr : addr << 8;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: for (int i = 19; i >= 16; i--)              {                  addr += (*(ptr + i));                  addr = (i == 16) ? addr : addr << 8;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: ptr += 4;
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: for (int i = 3; i >= 0; i--)              {                  addr += (*(ptr + i));                  addr = (i == 0) ? addr : addr << 8;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: for (int i = 3; i >= 0; i--)              {                  addr += (*(ptr + i));                  addr = (i == 0) ? addr : addr << 8;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: ptr -= 4;
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,Init,The following statement contains a magic number: if (ptr != null && acpiCheckHeader(ptr' "RSDT") == 0)              {                  addr = 0;                  int entrys = length;                  entrys = (entrys - 36) / 4;                  ptr += 36;                  byte* yeuse;                    while (0 < entrys--)                  {                      for (int i = 3; i >= 0; i--)                      {                          addr += (*(ptr + i));                          addr = (i == 0) ? addr : addr << 8;                      }                        yeuse = (byte*)addr;                      Facp = yeuse;                        if (acpiCheckHeader((byte*)facpget(0)' "DSDT") == 0)                      {                          byte* S5Addr = (byte*)facpget(0) + 36;                          int dsdtLength = *(facpget(0) + 1) - 36;                            while (0 < dsdtLength--)                          {                              if (Compare("_S5_"' S5Addr) == 0)                                  break;                              S5Addr++;                          }                            if (dsdtLength > 0)                          {                              if ((*(S5Addr - 1) == 0x08 || (*(S5Addr - 2) == 0x08 && *(S5Addr - 1) == '\\')) && *(S5Addr + 4) == 0x12)                              {                                  S5Addr += 5;                                  S5Addr += ((*S5Addr & 0xC0) >> 6) + 2;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPa = (short)(*(S5Addr) << 10);                                  S5Addr++;                                  if (*S5Addr == 0x0A)                                      S5Addr++;                                  SLP_TYPb = (short)(*(S5Addr) << 10);                                  SMI_CMD = facpget(1);                                  ACPI_ENABLE = facpbget(0);                                  ACPI_DISABLE = facpbget(1);                                  PM1a_CNT = facpget(2);                                  PM1b_CNT = facpget(3);                                  PM1_CNT_LEN = facpbget(3);                                  SLP_EN = 1 << 13;                                  SCI_EN = 1;                                    smiIO = new IOPort((ushort)SMI_CMD);                                  pm1aIO = new IOPort((ushort)PM1a_CNT);                                  pm1bIO = new IOPort((ushort)PM1b_CNT);                                    return true;                              }                          }                      }                      ptr += 4;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,RSDPAddress,The following statement contains a magic number: for (uint addr = 0xE0000; addr < 0x100000; addr += 4)                  if (Compare("RSD PTR "' (byte*)addr) == 0)                      if (Check_RSD(addr))                          return addr;
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,RSDPAddress,The following statement contains a magic number: for (uint addr = ebda_address; addr < ebda_address + 1024; addr += 4)                  if (Compare("RSD PTR "' (byte*)addr) == 0)                      return addr;
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,RSDPAddress,The following statement contains a magic number: for (uint addr = ebda_address; addr < ebda_address + 1024; addr += 4)                  if (Compare("RSD PTR "' (byte*)addr) == 0)                      return addr;
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,acpiCheckRSDPtr,The following statement contains a magic number: if (Compare(sig' (byte*)rsdp) == 0)              {                  bptr = (byte*)ptr;                    for (i = 0; i < 20; i++)                  {                      check += *bptr;                      bptr++;                  }                    if (check == 0)                  {                      Compare("RSDT"' (byte*)rsdp->RsdtAddress);                        if (rsdp->RsdtAddress != 0)                          return (uint*)rsdp->RsdtAddress;                  }              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpbget,The following statement contains a magic number: switch (number)              {                  case 0:                      return *(Facp + 52);                  case 1:                      return *(Facp + 53);                  case 2:                      return *(Facp + 89);                  default:                      return 0;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpbget,The following statement contains a magic number: switch (number)              {                  case 0:                      return *(Facp + 52);                  case 1:                      return *(Facp + 53);                  case 2:                      return *(Facp + 89);                  default:                      return 0;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpbget,The following statement contains a magic number: switch (number)              {                  case 0:                      return *(Facp + 52);                  case 1:                      return *(Facp + 53);                  case 2:                      return *(Facp + 89);                  default:                      return 0;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpbget,The following statement contains a magic number: switch (number)              {                  case 0:                      return *(Facp + 52);                  case 1:                      return *(Facp + 53);                  case 2:                      return *(Facp + 89);                  default:                      return 0;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpget,The following statement contains a magic number: switch (number)              {                  case 0:                      return (int*)*((int*)(Facp + 40));                  case 1:                      return (int*)*((int*)(Facp + 48));                  case 2:                      return (int*)*((int*)(Facp + 64));                  case 3:                      return (int*)*((int*)(Facp + 68));                  default:                      return null;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpget,The following statement contains a magic number: switch (number)              {                  case 0:                      return (int*)*((int*)(Facp + 40));                  case 1:                      return (int*)*((int*)(Facp + 48));                  case 2:                      return (int*)*((int*)(Facp + 64));                  case 3:                      return (int*)*((int*)(Facp + 68));                  default:                      return null;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpget,The following statement contains a magic number: switch (number)              {                  case 0:                      return (int*)*((int*)(Facp + 40));                  case 1:                      return (int*)*((int*)(Facp + 48));                  case 2:                      return (int*)*((int*)(Facp + 64));                  case 3:                      return (int*)*((int*)(Facp + 68));                  default:                      return null;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpget,The following statement contains a magic number: switch (number)              {                  case 0:                      return (int*)*((int*)(Facp + 40));                  case 1:                      return (int*)*((int*)(Facp + 48));                  case 2:                      return (int*)*((int*)(Facp + 64));                  case 3:                      return (int*)*((int*)(Facp + 68));                  default:                      return null;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpget,The following statement contains a magic number: switch (number)              {                  case 0:                      return (int*)*((int*)(Facp + 40));                  case 1:                      return (int*)*((int*)(Facp + 48));                  case 2:                      return (int*)*((int*)(Facp + 64));                  case 3:                      return (int*)*((int*)(Facp + 68));                  default:                      return null;              }
Magic Number,Cosmos.Core,ACPI,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ACPI.cs,facpget,The following statement contains a magic number: switch (number)              {                  case 0:                      return (int*)*((int*)(Facp + 40));                  case 1:                      return (int*)*((int*)(Facp + 48));                  case 2:                      return (int*)*((int*)(Facp + 64));                  case 3:                      return (int*)*((int*)(Facp + 68));                  default:                      return null;              }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleInterrupt_35,The following statement contains a magic number: aContext.EAX *= 2;
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleInterrupt_35,The following statement contains a magic number: aContext.EBX *= 2;
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleInterrupt_35,The following statement contains a magic number: aContext.ECX *= 2;
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleInterrupt_35,The following statement contains a magic number: aContext.EDX *= 2;
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,HandleException,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                  PutErrorChar(0' 00' ' ');                  PutErrorChar(0' 01' '*');                  PutErrorChar(0' 02' '*');                  PutErrorChar(0' 03' '*');                  PutErrorChar(0' 04' ' ');                  PutErrorChar(0' 05' 'C');                  PutErrorChar(0' 06' 'P');                  PutErrorChar(0' 07' 'U');                  PutErrorChar(0' 08' ' ');                  PutErrorChar(0' 09' 'E');                  PutErrorChar(0' 10' 'x');                  PutErrorChar(0' 11' 'c');                  PutErrorChar(0' 12' 'e');                  PutErrorChar(0' 13' 'p');                  PutErrorChar(0' 14' 't');                  PutErrorChar(0' 15' 'i');                  PutErrorChar(0' 16' 'o');                  PutErrorChar(0' 17' 'n');                  PutErrorChar(0' 18' ' ');                  PutErrorChar(0' 19' 'x');                  PutErrorChar(0' 20' xHex[(int)((ctx.Interrupt >> 4) & 0xF)]);                  PutErrorChar(0' 21' xHex[(int)(ctx.Interrupt & 0xF)]);                  PutErrorChar(0' 22' ' ');                  PutErrorChar(0' 23' '*');                  PutErrorChar(0' 24' '*');                  PutErrorChar(0' 25' '*');                  PutErrorChar(0' 26' ' ');                    if (lastKnownAddressValue != 0) {                      PutErrorString(1' 0' "Last known address: 0x");                        PutErrorChar(1' 22' xHex[(int)((lastKnownAddressValue >> 28) & 0xF)]);                      PutErrorChar(1' 23' xHex[(int)((lastKnownAddressValue >> 24) & 0xF)]);                      PutErrorChar(1' 24' xHex[(int)((lastKnownAddressValue >> 20) & 0xF)]);                      PutErrorChar(1' 25' xHex[(int)((lastKnownAddressValue >> 16) & 0xF)]);                      PutErrorChar(1' 26' xHex[(int)((lastKnownAddressValue >> 12) & 0xF)]);                      PutErrorChar(1' 27' xHex[(int)((lastKnownAddressValue >> 8) & 0xF)]);                      PutErrorChar(1' 28' xHex[(int)((lastKnownAddressValue >> 4) & 0xF)]);                      PutErrorChar(1' 29' xHex[(int)(lastKnownAddressValue & 0xF)]);                  }                }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,PutErrorChar,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                    xAddress += ((line * 80) + col) * 2;                    xAddress[0] = (byte)c;                  xAddress[1] = 0x0C;              }
Magic Number,Cosmos.Core,INTs,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\INTs.cs,PutErrorChar,The following statement contains a magic number: unsafe              {                  byte* xAddress = (byte*)0xB8000;                    xAddress += ((line * 80) + col) * 2;                    xAddress[0] = (byte)c;                  xAddress[1] = 0x0C;              }
Magic Number,Cosmos.Core,IOPortBase,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOPort.cs,Read8,The following statement contains a magic number: for (int i = 0; i < aData.Length / 2; i++) {                  xValue = Read16(Port);                  aData[i * 2] = (byte)xValue;                  aData[i * 2 + 1] = (byte)(xValue >> 8);              }
Magic Number,Cosmos.Core,IOPortBase,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOPort.cs,Read8,The following statement contains a magic number: for (int i = 0; i < aData.Length / 2; i++) {                  xValue = Read16(Port);                  aData[i * 2] = (byte)xValue;                  aData[i * 2 + 1] = (byte)(xValue >> 8);              }
Magic Number,Cosmos.Core,IOPortBase,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOPort.cs,Read8,The following statement contains a magic number: for (int i = 0; i < aData.Length / 2; i++) {                  xValue = Read16(Port);                  aData[i * 2] = (byte)xValue;                  aData[i * 2 + 1] = (byte)(xValue >> 8);              }
Magic Number,Cosmos.Core,IOPortBase,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOPort.cs,Read8,The following statement contains a magic number: for (int i = 0; i < aData.Length / 2; i++) {                  xValue = Read16(Port);                  aData[i * 2] = (byte)xValue;                  aData[i * 2 + 1] = (byte)(xValue >> 8);              }
Magic Number,Cosmos.Core,MemoryOperations,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\MemoryOperations.cs,Fill,The following statement contains a magic number: fixed (uint* destPtr = dest)              {                  Fill(destPtr' value' dest.Length * 4);              }
Magic Number,Cosmos.Core,MemoryOperations,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\MemoryOperations.cs,Fill,The following statement contains a magic number: fixed (int* destPtr = dest)              {                  Fill(destPtr' value' dest.Length * 4);              }
Magic Number,Cosmos.Core,MemoryOperations,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\MemoryOperations.cs,Fill,The following statement contains a magic number: fixed (ushort* destPtr = dest)              {                  Fill(destPtr' value' dest.Length * 2);              }
Magic Number,Cosmos.Core,MemoryOperations,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\MemoryOperations.cs,Fill,The following statement contains a magic number: fixed (short* destPtr = dest)              {                  Fill(destPtr' value' dest.Length * 2);              }
Magic Number,Cosmos.Core,PIC,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\PIC.cs,Remap,The following statement contains a magic number: Master.Data.Byte = 4;
Magic Number,Cosmos.Core,PIC,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\PIC.cs,Remap,The following statement contains a magic number: Slave.Data.Byte = 2;
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core,ProcessorInformation,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\ProcessorInformation.cs,GetVendorName,The following statement contains a magic number: if (CanReadCPUID() > 0)              {                  int[] raw = new int[3];                    fixed (int* ptr = raw)                      FetchCPUVendor(ptr);                    return new string(new char[] {                      (char)(raw[0] >> 24)'                      (char)((raw[0] >> 16) & 0xff)'                      (char)((raw[0] >> 8) & 0xff)'                      (char)(raw[0] & 0xff)'                      (char)(raw[1] >> 24)'                      (char)((raw[1] >> 16) & 0xff)'                      (char)((raw[1] >> 8) & 0xff)'                      (char)(raw[1] & 0xff)'                      (char)(raw[2] >> 24)'                      (char)((raw[2] >> 16) & 0xff)'                      (char)((raw[2] >> 8) & 0xff)'                      (char)(raw[2] & 0xff)'                  });              }              else                  return "\0";
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: SectorCount = new IOPortWrite(xBAR0' 2);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: LBA0 = new IOPort(xBAR0' 3);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: LBA1 = new IOPort(xBAR0' 4);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: LBA2 = new IOPort(xBAR0' 5);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: Command = new IOPortWrite(xBAR0' 7);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: Status = new IOPortRead(xBAR0' 7);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: DeviceSelect = new IOPortWrite(xBAR0' 6);
Magic Number,Cosmos.Core.IOGroup,ATA,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\ATA.cs,ATA,The following statement contains a magic number: Control = new IOPortWrite(xBAR1' 2);
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: if (comPortNumber > 4 && comPortNumber != 0)              {                  throw new Exception("Cosmos.Core->IOGroup->COM.cs-> ERROR: Unknown COM Port.");              }
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: switch (comPortNumber)              {                  case 1:                      portBase = 0x3F8;                      break;                  case 2:                      portBase = 0x2F8;                      break;                  case 3:                      portBase = 0x3E8;                      break;                  case 4:                      portBase = 0x2E8;                      break;              }
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: switch (comPortNumber)              {                  case 1:                      portBase = 0x3F8;                      break;                  case 2:                      portBase = 0x2F8;                      break;                  case 3:                      portBase = 0x3E8;                      break;                  case 4:                      portBase = 0x2E8;                      break;              }
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: switch (comPortNumber)              {                  case 1:                      portBase = 0x3F8;                      break;                  case 2:                      portBase = 0x2F8;                      break;                  case 3:                      portBase = 0x3E8;                      break;                  case 4:                      portBase = 0x2E8;                      break;              }
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: FIFOControl = new IOPort(unchecked((ushort)(portBase + 2)));
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: LineControl = new IOPort(unchecked((ushort)(portBase + 3)));
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: ModemControl = new IOPort(unchecked((ushort)(portBase + 4)));
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: LineStatus = new IOPort(unchecked((ushort)(portBase + 5)));
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: ModemStatus = new IOPort(unchecked((ushort)(portBase + 6)));
Magic Number,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following statement contains a magic number: Scratch = new IOPort(unchecked((ushort)(portBase + 7)));
Magic Number,Cosmos.Core.Memory,HeapLarge,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapLarge.cs,Alloc,The following statement contains a magic number: xPtr[2] = 0;
Magic Number,Cosmos.Core.Memory,HeapLarge,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapLarge.cs,Alloc,The following statement contains a magic number: xPtr[3] = 0;
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: Native xMaxItemSize = (RAT.PageSize - PrefixBytes) / 4 - PrefixItemBytes;
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(16);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(24);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(48);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(64);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(128);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(256);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,Init,The following statement contains a magic number: CreatePage(512);
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,CreatePage,The following statement contains a magic number: xPtr[2] = xItemCount;
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,CreatePage,The following statement contains a magic number: xPtr = xPtr + 3;
Magic Number,Cosmos.Core.Memory,HeapSmall,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\HeapSmall.cs,CreatePage,The following statement contains a magic number: for (Native i = 0; i < xItemCount; i++) {          byte* xSlotPtr = (byte*)xPtr + i * xSlotSize;          Native* xMetaDataPtr = (Native*)xSlotPtr;          xMetaDataPtr[0] = 0; // Actual data size. 0 is empty.          xMetaDataPtr[1] = 0; // Ref count          xMetaDataPtr[2] = 0; // Ptr to first        }
Magic Number,Cosmos.Core.Memory.Old,GlobalSystemInfo,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\GlobalSystemInfo.cs,EnsureInitialized,The following statement contains a magic number: if (mGlobalInformationTable == null)              {                  // todo: should we align this structure somehow?                    var xEndOfKernel = CPU.GetEndOfKernel();                  xEndOfKernel = xEndOfKernel + (1024 * 1024); // for now' skip 1 MB                  CPU.ZeroFill(xEndOfKernel' (uint)(sizeof(GlobalInformationTable) + TotalDataLookupTableSize) * 4);                  mGlobalInformationTable = (GlobalInformationTable*)xEndOfKernel;                  uint xFirstDataLookupLocation = (uint)(xEndOfKernel + sizeof(GlobalInformationTable));                  Debugger.DoSend("Setting FirstDataLookupTable to ");                  Debugger.DoSendNumber(xFirstDataLookupLocation);                  mGlobalInformationTable->FirstDataLookupTable = (DataLookupTable*)xFirstDataLookupLocation;                  Debugger.DoSend("FirstDataLookupTable was set to ");                  Debugger.DoSendNumber((uint)mGlobalInformationTable->FirstDataLookupTable);              }
Magic Number,Cosmos.Core.Memory.Old,GlobalSystemInfo,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\GlobalSystemInfo.cs,EnsureInitialized,The following statement contains a magic number: if (mGlobalInformationTable == null)              {                  // todo: should we align this structure somehow?                    var xEndOfKernel = CPU.GetEndOfKernel();                  xEndOfKernel = xEndOfKernel + (1024 * 1024); // for now' skip 1 MB                  CPU.ZeroFill(xEndOfKernel' (uint)(sizeof(GlobalInformationTable) + TotalDataLookupTableSize) * 4);                  mGlobalInformationTable = (GlobalInformationTable*)xEndOfKernel;                  uint xFirstDataLookupLocation = (uint)(xEndOfKernel + sizeof(GlobalInformationTable));                  Debugger.DoSend("Setting FirstDataLookupTable to ");                  Debugger.DoSendNumber(xFirstDataLookupLocation);                  mGlobalInformationTable->FirstDataLookupTable = (DataLookupTable*)xFirstDataLookupLocation;                  Debugger.DoSend("FirstDataLookupTable was set to ");                  Debugger.DoSendNumber((uint)mGlobalInformationTable->FirstDataLookupTable);              }
Magic Number,Cosmos.Core.Memory.Old,GlobalSystemInfo,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\GlobalSystemInfo.cs,EnsureInitialized,The following statement contains a magic number: if (mGlobalInformationTable == null)              {                  // todo: should we align this structure somehow?                    var xEndOfKernel = CPU.GetEndOfKernel();                  xEndOfKernel = xEndOfKernel + (1024 * 1024); // for now' skip 1 MB                  CPU.ZeroFill(xEndOfKernel' (uint)(sizeof(GlobalInformationTable) + TotalDataLookupTableSize) * 4);                  mGlobalInformationTable = (GlobalInformationTable*)xEndOfKernel;                  uint xFirstDataLookupLocation = (uint)(xEndOfKernel + sizeof(GlobalInformationTable));                  Debugger.DoSend("Setting FirstDataLookupTable to ");                  Debugger.DoSendNumber(xFirstDataLookupLocation);                  mGlobalInformationTable->FirstDataLookupTable = (DataLookupTable*)xFirstDataLookupLocation;                  Debugger.DoSend("FirstDataLookupTable was set to ");                  Debugger.DoSendNumber((uint)mGlobalInformationTable->FirstDataLookupTable);              }
Magic Number,Cosmos.Core.Memory.Old,Heap,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\Old_Heap.cs,EnsureIsInitialized,The following statement contains a magic number: if (!mInitialized)              {                  mInitialized = true;                  DoInitialize((CPU.GetAmountOfRAM() - 1) * 1024 * 1024);                  //DoInitialize(4 * 1024 * 1024' 16 * 1024 * 1024);              }
Magic Number,Cosmos.Core.Memory.Old,Heap,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\Memory\Old\Old_Heap.cs,EnsureIsInitialized,The following statement contains a magic number: if (!mInitialized)              {                  mInitialized = true;                  DoInitialize((CPU.GetAmountOfRAM() - 1) * 1024 * 1024);                  //DoInitialize(4 * 1024 * 1024' 16 * 1024 * 1024);              }
Missing Default,Cosmos.Core.IOGroup,COM,C:\repos\CosmosOS_Cosmos\source\Cosmos.Core\IOGroup\COM.cs,COM,The following switch statement is missing a default case: switch (comPortNumber)              {                  case 1:                      portBase = 0x3F8;                      break;                  case 2:                      portBase = 0x2F8;                      break;                  case 3:                      portBase = 0x3E8;                      break;                  case 4:                      portBase = 0x2E8;                      break;              }
