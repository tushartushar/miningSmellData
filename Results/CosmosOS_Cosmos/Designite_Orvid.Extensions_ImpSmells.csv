Implementation smell,Namespace,Class,File,Method,Description
Long Method,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The method has 120 lines of code.
Long Method,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The method has 103 lines of code.
Long Method,System,IntXStringConverter,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FastToString,The method has 100 lines of code.
Long Method,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The method has 147 lines of code.
Long Method,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The method has 143 lines of code.
Complex Method,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,Cyclomatic complexity of the method is 8
Complex Method,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,Cyclomatic complexity of the method is 10
Complex Method,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,Cyclomatic complexity of the method is 16
Complex Method,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseDivMod,Cyclomatic complexity of the method is 17
Complex Method,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,System,OpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sh,Cyclomatic complexity of the method is 8
Complex Method,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,Cyclomatic complexity of the method is 8
Complex Method,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,ToType,Cyclomatic complexity of the method is 17
Long Parameter List,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 9 parameters. Parameters: digits1' digitsBuffer1' length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 9 parameters. Parameters: digitsPtr1' digitsBufferPtr1' length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The method has 9 parameters. Parameters: digits1' digitsBuffer1' length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The method has 9 parameters. Parameters: digitsPtr1' digitsBufferPtr1' length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseDivMod,The method has 9 parameters. Parameters: digitsPtr1' digitsBufferPtr1' length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult
Long Parameter List,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The method has 5 parameters. Parameters: digits1' length1' digits2' length2' digitsRes
Long Parameter List,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicMultiply,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Pow2Parse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseParse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicParse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The method has 6 parameters. Parameters: digitsPtr' length' maxLength' bufferPtr' newLength' rightShift
Long Parameter List,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FhtButterfly,The method has 6 parameters. Parameters: slice1' slice2' index1' index2' cos' sin
Long Parameter List,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFhtButterfly,The method has 6 parameters. Parameters: slice1' slice2' index1' index2' cos' sin
Long Parameter List,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFhtButterfly2,The method has 6 parameters. Parameters: slice1' slice2' index1' index2' cos' sin
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The method has 5 parameters. Parameters: digits1' length1' digits2' length2' digitsRes
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The method has 5 parameters. Parameters: digits1' length1' digits2' length2' digitsRes
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 5 parameters. Parameters: digits1' length1' int2' divRes' modRes
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 5 parameters. Parameters: digitsPtr1' length1' int2' divResPtr' modRes
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Shr,The method has 6 parameters. Parameters: digits' offset' length' digitsRes' resOffset' rightShift
Long Parameter List,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Shr,The method has 5 parameters. Parameters: digitsPtr' length' digitsResPtr' rightShift' resHasOffset
Long Statement,System,Half,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,ToChar,The length of the statement  "            throw new InvalidCastException(string.Format(CultureInfo.CurrentCulture' "Invalid cast from '{0}' to '{1}'."' "Half"' "Char")); " is 127.
Long Statement,System,Half,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,ToDateTime,The length of the statement  "            throw new InvalidCastException(string.Format(CultureInfo.CurrentCulture' "Invalid cast from '{0}' to '{1}'."' "Half"' "DateTime")); " is 131.
Long Statement,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Fraction,The length of the statement  "                return new Quad((~QuadhighestBit & (bits << shift)) | (QuadhighestBit & value.SignificandBits)' value.Exponent - shift); " is 120.
Long Statement,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The length of the statement  "                throw new ArgumentOutOfRangeException("Cannot raise a negative number to a non-integer exponent' as this yields an imaginary number."); " is 135.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                    return ClassicDivMod(digits1' digitsBuffer1' ref length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult); " is 126.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                fixed (uint* digitsPtr1 = digits1' digitsBufferPtr1 = digitsBuffer1' digitsPtr2 = digits2' digitsBufferPtr2 = digitsBuffer2 != null ? digitsBuffer2 : digits1' digitsResPtr = digitsRes != null ? digitsRes : digits1) " is 214.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                    return ClassicDivMod(digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 141.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                uint resultLength = BaseDivMod(digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 151.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                uint[] int2OppositeDigits = NewtonHelper.GetIntegerOpposite(digitsPtr2' length2' length1' digitsBufferPtr1' out int2OppositeLength' out int2OppositeRightShift); " is 160.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The length of the statement  "                fixed (uint* digitsPtr1 = digits1' digitsBufferPtr1 = digitsBuffer1' digitsPtr2 = digits2' digitsBufferPtr2 = digitsBuffer2' digitsResPtr = digitsRes != null ? digitsRes : digits1) " is 180.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The length of the statement  "                uint resultLength = BaseDivMod(digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 151.
Long Statement,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The length of the statement  "                        if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1[iLen2 - 2]) " is 134.
Long Statement,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The length of the statement  "                //            throw new FhtMultiplicationException(string.Format("FHT multiplication returned invalid result for IntX objects with lengths {0} and {1}."' length1' length2)); " is 173.
Long Statement,System,StrRepHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,AssertAlphabet,The length of the statement  "                    throw new ArgumentException(string.Format("Alphabet is too small to represent numbers in base {0}."' numberBase)' "alphabet"); " is 126.
Long Statement,System,OpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sh,The length of the statement  "                uint newLength = (uint)(newBitCount / Constants.DigitBitCount + (newBitCount % Constants.DigitBitCount == 0 ? 0UL : 1UL)); " is 122.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //because the MSB of both significands is 1' the MSB of the result will also be 1' and the product of low bits on both significands is dropped (and thus we can skip its calculation) " is 181.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplierSignificand & lowWordMask)) >> 32); " is 153.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "                this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | ((significandBits << 1) & ~highestBit); " is 126.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //because the MSB of both significands is 1' the MSB of the result will also be 1' and the product of low bits on both significands is dropped (and thus we can skip its calculation) " is 181.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.SignificandBits & lowWordMask)) >> 32); " is 158.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "                    this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | ((significandBits << 1) & ~highestBit); " is 131.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "                this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | (significandBits & ~highestBit); " is 124.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ////because the MSB of both significands is 1' the MSB of the result will also be 1' and the product of low bits on both significands is dropped (and thus we can skip its calculation) " is 183.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //ulong significandBits = high1 * high2 + (((this.Significand & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.Significand & lowWordMask)) >> 32); " is 152.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //    this.Significand = (ulong)zeroMask & ((this.Significand ^ multiplier.Significand) & highestBit) | ((significandBits << 1) & ~highestBit); " is 143.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ////this.Significand = (ulong)zeroMask & ((this.Significand ^ multiplier.Significand) & highestBit) | ((significandBits << (int)(1 ^ (significandBits >> 63))) & ~highestBit); " is 174.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ////this.Exponent = (zeroMask & (this.Exponent + multiplier.Exponent - 1 + 64 + (long)(significandBits >> 63))) | (~zeroMask & long.MinValue); " is 142.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "            if ((this.SignificandBits ^ valueSignificand) >= highestBit) //this and value have different signs--use subtraction instead " is 123.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) + ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent)); " is 125.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (valueSignificand | highestBit) + ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent)); " is 125.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent). " is 165.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "            if ((this.SignificandBits ^ value.SignificandBits) >= highestBit) //this and value have different signs--use subtraction instead " is 128.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) + ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent)); " is 131.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (value.SignificandBits | highestBit) + ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent)); " is 131.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent). " is 165.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "            if ((this.SignificandBits ^ valueSignificand) >= highestBit) //this and value have different signs--use addition instead             " is 120.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) - ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent)); " is 125.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                ulong bits = (valueSignificand | highestBit) - ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent)); " is 125.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = valueSignificand - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 155.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = this.SignificandBits - valueSignificand; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 155.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "            if ((this.SignificandBits ^ value.SignificandBits) >= highestBit) //this and value have different signs--use addition instead             " is 125.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) - ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent)); " is 131.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                ulong bits = (value.SignificandBits | highestBit) - ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent)); " is 131.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = value.SignificandBits - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 160.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = this.SignificandBits - value.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 160.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The length of the statement  "                this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ valueSignificand) & highestBit); " is 124.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The length of the statement  "                this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit); " is 131.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The length of the statement  "                this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit); " is 124.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Parse,The length of the statement  "            //Smarter way is to break the numeric string into chunks and parse each of them using long's parse method' then combine. " is 120.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                        return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x")); " is 128.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                        return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x")); " is 137.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                            return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1); " is 137.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                    return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString()); " is 130.
Long Statement,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                        return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString(); " is 131.
Complex Conditional,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The conditional expression  "length1 < Constants.AutoFhtLengthLowerBound || length2 < Constants.AutoFhtLengthLowerBound ||                      length1 > Constants.AutoFhtLengthUpperBound || length2 > Constants.AutoFhtLengthUpperBound"  is complex.
Magic Number,System,Half,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GetTypeCode,The following statement contains a magic number: return (TypeCode)255;
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,ConvertMantissa,The following statement contains a magic number: uint m = (uint)(i << 13);
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: uint[] mantissaTable = new uint[2048];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1; i < 1024; i++)                  {                      mantissaTable[i] = ConvertMantissa(i);                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)                  {                      mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)                  {                      mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)                  {                      mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: for (int i = 1024; i < 2048; i++)                  {                      mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: uint[] exponentTable = new uint[64];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 1; i < 31; i++)                  {                      exponentTable[i] = (uint)(i << 23);                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 1; i < 31; i++)                  {                      exponentTable[i] = (uint)(i << 23);                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[31] = 0x47800000;
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[32] = 0x80000000;
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)                  {                      exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)                  {                      exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)                  {                      exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: for (int i = 33; i < 63; i++)                  {                      exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[63] = 0xc7800000;
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: ushort[] offsetTable = new ushort[64];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 1; i < 32; i++)                  {                      offsetTable[i] = 1024;                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 1; i < 32; i++)                  {                      offsetTable[i] = 1024;                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[32] = 0;
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 33; i < 64; i++)                  {                      offsetTable[i] = 1024;                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 33; i < 64; i++)                  {                      offsetTable[i] = 1024;                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: for (int i = 33; i < 64; i++)                  {                      offsetTable[i] = 1024;                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: ushort[] baseTable = new ushort[512];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          baseTable[i | 0x000] = 0x0000;                          baseTable[i | 0x100] = 0x8000;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          baseTable[i | 0x000] = (ushort)(0x0400 >> (18 + e));                          baseTable[i | 0x100] = (ushort)((0x0400 >> (18 + e)) | 0x8000);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          baseTable[i | 0x000] = (ushort)((15 - e) << 10);                          baseTable[i | 0x100] = (ushort)(((15 - e) << 10) | 0x8000);                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          baseTable[i | 0x000] = 0x7c00;                          baseTable[i | 0x100] = 0xfc00;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: sbyte[] shiftTable = new sbyte[512];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: for (int i = 0; i < 256; ++i)                  {                      sbyte e = (sbyte)(127 - i);                      if (e > 24)                      { // Very small numbers map to zero                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else if (e > 14)                      { // Small numbers map to denorms                          shiftTable[i | 0x000] = (sbyte)(e - 1);                          shiftTable[i | 0x100] = (sbyte)(e - 1);                      }                      else if (e >= -15)                      { // Normal numbers just lose precision                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                      else if (e > -128)                      { // Large numbers map to Infinity                          shiftTable[i | 0x000] = 24;                          shiftTable[i | 0x100] = 24;                      }                      else                      { // Infinity and NaN's stay Infinity and NaN's                          shiftTable[i | 0x000] = 13;                          shiftTable[i | 0x100] = 13;                      }                  }
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,SingleToHalf,The following statement contains a magic number: ushort result = (ushort)(baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Magic Number,System,HalfHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,SingleToHalf,The following statement contains a magic number: ushort result = (ushort)(baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x == 0) return (64);
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x00000000FFFFFFFF) { n = n + 32; x = x << 32; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x00000000FFFFFFFF) { n = n + 32; x = x << 32; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x0000FFFFFFFFFFFF) { n = n + 16; x = x << 16; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x0000FFFFFFFFFFFF) { n = n + 16; x = x << 16; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x00FFFFFFFFFFFFFF) { n = n + 8; x = x << 8; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x00FFFFFFFFFFFFFF) { n = n + 8; x = x << 8; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x0FFFFFFFFFFFFFFF) { n = n + 4; x = x << 4; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x0FFFFFFFFFFFFFFF) { n = n + 4; x = x << 4; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x3FFFFFFFFFFFFFFF) { n = n + 2; x = x << 2; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: if (x <= 0x3FFFFFFFFFFFFFFF) { n = n + 2; x = x << 2; }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Truncate,The following statement contains a magic number: if (value.Exponent <= -64)                   return Quad.Zero;              else if (value.Exponent >= 0)                  return value;              else              {                  //clear least significant "-value.exponent" bits that come after the binary point by shifting                  return new Quad((value.SignificandBits >> (int)(-value.Exponent)) << (int)(-value.Exponent)' value.Exponent);              }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Fraction,The following statement contains a magic number: if (value.Exponent >= 0) return Quad.Zero; //no fraction              else if (value.Exponent <= -64) return value; //all fraction (or zero)              else              {                  //clear most significant 64+value.exponent bits before the binary point                  ulong bits = (value.SignificandBits << (int)(64 + value.Exponent)) >> (int)(64 + value.Exponent);                  if (bits == 0) return Quad.Zero; //value is an integer                    int shift = Quadnlz(bits); //renormalize                                    return new Quad((~QuadhighestBit & (bits << shift)) | (QuadhighestBit & value.SignificandBits)' value.Exponent - shift);              }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Fraction,The following statement contains a magic number: if (value.Exponent >= 0) return Quad.Zero; //no fraction              else if (value.Exponent <= -64) return value; //all fraction (or zero)              else              {                  //clear most significant 64+value.exponent bits before the binary point                  ulong bits = (value.SignificandBits << (int)(64 + value.Exponent)) >> (int)(64 + value.Exponent);                  if (bits == 0) return Quad.Zero; //value is an integer                    int shift = Quadnlz(bits); //renormalize                                    return new Quad((~QuadhighestBit & (bits << shift)) | (QuadhighestBit & value.SignificandBits)' value.Exponent - shift);              }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Fraction,The following statement contains a magic number: if (value.Exponent >= 0) return Quad.Zero; //no fraction              else if (value.Exponent <= -64) return value; //all fraction (or zero)              else              {                  //clear most significant 64+value.exponent bits before the binary point                  ulong bits = (value.SignificandBits << (int)(64 + value.Exponent)) >> (int)(64 + value.Exponent);                  if (bits == 0) return Quad.Zero; //value is an integer                    int shift = Quadnlz(bits); //renormalize                                    return new Quad((~QuadhighestBit & (bits << shift)) | (QuadhighestBit & value.SignificandBits)' value.Exponent - shift);              }
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Log2,The following statement contains a magic number: return Math.Log(value.SignificandBits | QuadhighestBit' 2) + value.Exponent;
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Log,The following statement contains a magic number: return Math.Log(value.SignificandBits | QuadhighestBit) + value.Exponent * 0.69314718055994530941723212145818;
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The following statement contains a magic number: double resultSignificand = Math.Pow((double)new Quad(value.SignificandBits' -63)' exponent);
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The following statement contains a magic number: double resultExponent = (value.Exponent + 63) * exponent;
Magic Number,System,MathExtensions,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The following statement contains a magic number: resultSignificand *= Math.Pow(2' resultExponent % 1);
Magic Number,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The following statement contains a magic number: fixed (uint* oppositePtr = int2OppositeDigits' quotPtr = quotDigits)                  {                      // Multiply                      quotLength = IntXMultiplier.Multiply(oppositePtr' int2OppositeLength' digitsPtr1' length1' quotPtr);                        // Calculate shift                      uint shiftOffset = (uint)(int2OppositeRightShift / Constants.DigitBitCount);                      int shiftCount = (int)(int2OppositeRightShift % Constants.DigitBitCount);                        // Get the very first bit of the shifted part                      uint highestLostBit;                      if (shiftCount == 0)                      {                          highestLostBit = quotPtr[shiftOffset - 1] >> 31;                      }                      else                      {                          highestLostBit = quotPtr[shiftOffset] >> (shiftCount - 1) & 1U;                      }                        // After this result must be shifted to the right - this is required                      quotLength = DigitOpHelper.Shr(quotPtr + shiftOffset' quotLength - shiftOffset' quotPtr' shiftCount' false);                        // Maybe quotient must be corrected                      if (highestLostBit == 1U)                      {                          quotLength = DigitOpHelper.Add(quotPtr' quotLength' &highestLostBit' 1U' quotPtr);                      }                        // Check quotient - finally it might be too big.                      // For this we must multiply quotient by divider                      uint quotDivLength;                      uint[] quotDivDigits = new uint[quotLength + length2];                      fixed (uint* quotDivPtr = quotDivDigits)                      {                          quotDivLength = IntXMultiplier.Multiply(quotPtr' quotLength' digitsPtr2' length2' quotDivPtr);                            int cmpRes = DigitOpHelper.Cmp(quotDivPtr' quotDivLength' digitsPtr1' length1);                          if (cmpRes > 0)                          {                              highestLostBit = 1;                              quotLength = DigitOpHelper.Sub(quotPtr' quotLength' &highestLostBit' 1U' quotPtr);                              quotDivLength = DigitOpHelper.Sub(quotDivPtr' quotDivLength' digitsPtr2' length2' quotDivPtr);                          }                            // Now everything is ready and prepared to return results                            // First maybe fill remainder                          if ((resultFlags & DivModResultFlags.Mod) != 0)                          {                              length1 = DigitOpHelper.Sub(digitsPtr1' length1' quotDivPtr' quotDivLength' digitsBufferPtr1);                          }                            // And finally fill quotient                          if ((resultFlags & DivModResultFlags.Div) != 0)                          {                              DigitHelper.DigitsBlockCopy(quotPtr' digitsResPtr' quotLength);                          }                          else                          {                              quotLength = 0;                          }                            // Return some arrays to pool                          ArrayPool<uint>.Instance.AddArray(int2OppositeDigits);                            return quotLength;                      }                  }
Magic Number,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The following statement contains a magic number: int shift1 = 31 - Bits.Msb(digitsPtr2[length2 - 1]);
Magic Number,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The following statement contains a magic number: uint preLastDigit2 = digitsBufferPtr2[length2 - 2];
Magic Number,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The following statement contains a magic number: for (uint i = maxLength' iLen2 = length1' j' ji; i <= maxLength; --i' --iLen2)                  {                      isMaxLength = iLen2 == length1;                        // Calculate estimates                      if (isMaxLength)                      {                          longDigit = digitsBufferPtr1[iLen2 - 1];                      }                      else                      {                          longDigit = (ulong)digitsBufferPtr1[iLen2] << Constants.DigitBitCount | digitsBufferPtr1[iLen2 - 1];                      }                        divEst = longDigit / lastDigit2;                      modEst = longDigit - divEst * lastDigit2;                        // Check estimate (maybe correct it)                      for (; ; )                      {                          if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1[iLen2 - 2])                          {                              --divEst;                              modEst += lastDigit2;                              if (modEst < Constants.BitCountStepOf2) continue;                          }                          break;                      }                      divRes = (uint)divEst;                        // Multiply and subtract                      k = 0;                      for (j = 0' ji = i; j < length2; ++j' ++ji)                      {                          mulRes = (ulong)divRes * digitsBufferPtr2[j];                          t = digitsBufferPtr1[ji] - k - (long)(mulRes & 0xFFFFFFFF);                          digitsBufferPtr1[ji] = (uint)t;                          k = (long)(mulRes >> Constants.DigitBitCount) - (t >> Constants.DigitBitCount);                      }                        if (!isMaxLength)                      {                          t = digitsBufferPtr1[iLen2] - k;                          digitsBufferPtr1[iLen2] = (uint)t;                      }                      else                      {                          t = -k;                      }                        // Correct result if subtracted too much                      if (t < 0)                      {                          --divRes;                            k = 0;                          for (j = 0' ji = i; j < length2; ++j' ++ji)                          {                              t = (long)digitsBufferPtr1[ji] + digitsBufferPtr2[j] + k;                              digitsBufferPtr1[ji] = (uint)t;                              k = t >> Constants.DigitBitCount;                          }                            if (!isMaxLength)                          {                              digitsBufferPtr1[iLen2] = (uint)(k + digitsBufferPtr1[iLen2]);                          }                      }                        // Maybe save div result                      if (divNeeded)                      {                          digitsResPtr[i] = divRes;                      }                  }
Magic Number,System,IntXDivider,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseDivMod,The following statement contains a magic number: if (cmpResult == -2)                  {                      cmpResult = DigitOpHelper.Cmp(digitsPtr1' length1' digitsPtr2' length2);                  }
Magic Number,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The following statement contains a magic number: if (newLength >> 32 != 0)                  {                      throw new ArgumentException("One of the operated big integers is too big.");                  }
Magic Number,System,IntXMultiplier,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicMultiply,The following statement contains a magic number: for (; digitsPtr2 < digitsPtr2End; ++digitsPtr2' ++digitsResPtr)                  {                      // Check for zero (sometimes may help). There is no sense to make this check in internal cycle -                      // it would give performance gain only here                      if (*digitsPtr2 == 0) continue;                        c = 0;                      for (ptr1 = digitsPtr1' ptrRes = digitsResPtr; ptr1 < digitsPtr1End; ++ptr1' ++ptrRes)                      {                          c += (ulong)*digitsPtr2 * *ptr1 + *ptrRes;                          *ptrRes = (uint)c;                          c >>= 32;                      }                      *ptrRes = (uint)c;                  }
Magic Number,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The following statement contains a magic number: if (numberBase < 2 || numberBase > charToDigits.Count)                  {                      throw new ArgumentException("Base is invalid."' "numberBase");                  }
Magic Number,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The following statement contains a magic number: fixed (uint* valueDigitsStartPtr = valueDigits' valueDigitsStartPtr2 = valueDigits2)                  {                      // In the string first digit means last in digits array                      uint* valueDigitsPtr = valueDigitsStartPtr + valueLength - 1;                      uint* valueDigitsPtr2 = valueDigitsStartPtr2 + valueLength - 1;                        // Reverse copy characters into digits                      fixed (char* valueStartPtr = value)                      {                          char* valuePtr = valueStartPtr + startIndex;                          char* valueEndPtr = valuePtr + valueLength;                          for (; valuePtr < valueEndPtr; ++valuePtr' --valueDigitsPtr' --valueDigitsPtr2)                          {                              // Get digit itself - this call will throw an exception if char is invalid                              *valueDigitsPtr = StrRepHelper.GetDigit(charToDigits' *valuePtr' numberBase);                                // Set length of this digit (zero for zero)                              *valueDigitsPtr2 = *valueDigitsPtr == 0U ? 0U : 1U;                          }                      }                        // We have retrieved lengths array from pool - it needs to be cleared before using                      DigitHelper.SetBlockDigits(valueDigitsStartPtr2 + valueLength' digitsLength - valueLength' 0);                        // Now start from the digit arrays beginning                      valueDigitsPtr = valueDigitsStartPtr;                      valueDigitsPtr2 = valueDigitsStartPtr2;                        // Here base in needed power will be stored                      IntX baseInt = null;                        // Temporary variables used on swapping                      uint[] tempDigits;                      uint* tempPtr;                        // Variables used in cycle                      uint* ptr1' ptr2' valueDigitsPtrEnd;                      uint loLength' hiLength;                        // Outer cycle instead of recursion                      for (uint innerStep = 1' outerStep = 2; innerStep < digitsLength; innerStep <<= 1' outerStep <<= 1)                      {                          // Maybe baseInt must be multiplied by itself                          baseInt = baseInt == null ? numberBase : baseInt * baseInt;                            // Using unsafe here                          fixed (uint* baseDigitsPtr = baseInt._digits)                          {                              // Start from arrays beginning                              ptr1 = valueDigitsPtr;                              ptr2 = valueDigitsPtr2;                                // vauleDigits array end                              valueDigitsPtrEnd = valueDigitsPtr + digitsLength;                                // Cycle thru all digits and their lengths                              for (; ptr1 < valueDigitsPtrEnd; ptr1 += outerStep' ptr2 += outerStep)                              {                                  // Get lengths of "lower" and "higher" value parts                                  loLength = *ptr2;                                  hiLength = *(ptr2 + innerStep);                                    if (hiLength != 0)                                  {                                      // We always must clear an array before multiply                                      DigitHelper.SetBlockDigits(ptr2' outerStep' 0U);                                        // Multiply per baseInt                                      hiLength = IntXMultiplier.Multiply(baseDigitsPtr' baseInt._length' ptr1 + innerStep' hiLength' ptr2);                                  }                                    // Sum results                                  if (hiLength != 0 || loLength != 0)                                  {                                      *ptr1 = DigitOpHelper.Add(ptr2' hiLength' ptr1' loLength' ptr2);                                  }                                  else                                  {                                      *ptr1 = 0U;                                  }                              }                          }                            // After inner cycle valueDigits will contain lengths and valueDigits2 will contain actual values                          // so we need to swap them here                          tempDigits = valueDigits;                          valueDigits = valueDigits2;                          valueDigits2 = tempDigits;                            tempPtr = valueDigitsPtr;                          valueDigitsPtr = valueDigitsPtr2;                          valueDigitsPtr2 = tempPtr;                      }                  }
Magic Number,System,IntXParser,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicParse,The following statement contains a magic number: for (int i = startIndex; i <= endIndex; ++i)                  {                      digit = StrRepHelper.GetDigit(charToDigits' value[i]' numberBase);                        // Next multiply existing values by base and add this value to them                      if (newLength == 0)                      {                          if (digit != 0)                          {                              digitsRes[0] = (uint)digit;                              newLength = 1;                          }                      }                      else                      {                          for (uint j = 0; j < newLength; ++j)                          {                              digit += digitsRes[j] * numberBaseLong;                              digitsRes[j] = (uint)digit;                              digit >>= 32;                          }                          if (digit != 0)                          {                              digitsRes[newLength++] = (uint)digit;                          }                      }                  }
Magic Number,System,IntXStringConverter,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ToString,The following statement contains a magic number: if (numberBase < 2 || numberBase > 65536)                  {                      throw new ArgumentException("Base must be between 2 and 65536."' "numberBase");                  }
Magic Number,System,IntXStringConverter,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ToString,The following statement contains a magic number: if (numberBase < 2 || numberBase > 65536)                  {                      throw new ArgumentException("Base must be between 2 and 65536."' "numberBase");                  }
Magic Number,System,IntXStringConverter,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FastToString,The following statement contains a magic number: fixed (uint* resultPtr1Const = resultArray' resultPtr2Const = resultArray2' tempBufferPtr = tempBuffer)                  {                      // Results pointers which will be modified (on swap)                      uint* resultPtr1 = resultPtr1Const;                      uint* resultPtr2 = resultPtr2Const;                        // Temporary variables used on swapping                      uint[] tempArray;                      uint* tempPtr;                        // Variables used in cycle                      uint* ptr1' ptr2' ptr1end;                      uint loLength;                        // Outer cycle instead of recursion                      for (uint innerStep = resultLength >> 1' outerStep = resultLength; innerStep > 0; innerStep >>= 1' outerStep >>= 1)                      {                          // Prepare pointers                          ptr1 = resultPtr1;                          ptr2 = resultPtr2;                          ptr1end = resultPtr1 + resultLength;                            // Get baseInt from stack and fix it too                          baseInt = (IntX)baseIntStack.Pop();                          fixed (uint* baseIntPtr = baseInt._digits)                          {                              // Cycle thru all digits and their lengths                              for (; ptr1 < ptr1end; ptr1 += outerStep' ptr2 += outerStep)                              {                                  // Divide ptr1 (with length in *ptr2) by baseIntPtr here.                                  // Results are stored in ptr2 & (ptr2 + innerStep)' lengths - in *ptr1 and (*ptr1 + innerStep)                                  loLength = *ptr2;                                  *(ptr1 + innerStep) = IntXDivider.DivMod(                                      ptr1'                                      ptr2'                                      ref loLength'                                      baseIntPtr'                                      tempBufferPtr'                                      baseInt._length'                                      ptr2 + innerStep'                                      DivModResultFlags.Div | DivModResultFlags.Mod'                                      -2);                                  *ptr1 = loLength;                              }                          }                            // After inner cycle resultArray will contain lengths and resultArray2 will contain actual values                          // so we need to swap them here                          tempArray = resultArray;                          resultArray = resultArray2;                          resultArray2 = tempArray;                            tempPtr = resultPtr1;                          resultPtr1 = resultPtr2;                          resultPtr2 = tempPtr;                      }                        // Retrieve real output length                      outputLength = DigitHelper.GetRealDigitsLength(resultArray2' outputLength);                        // Create output array                      outputArray = new uint[outputLength];                        // Copy each digit but only if length is not null                      fixed (uint* outputPtr = outputArray)                      {                          for (uint i = 0; i < outputLength; ++i)                          {                              if (resultPtr2[i] != 0)                              {                                  outputPtr[i] = resultPtr1[i];                              }                          }                      }                  }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if (x == 0) return 32;
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 16) == 0) { n += 16; x <<= 16; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 16) == 0) { n += 16; x <<= 16; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 16) == 0) { n += 16; x <<= 16; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 24) == 0) { n += 8; x <<= 8; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 24) == 0) { n += 8; x <<= 8; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 24) == 0) { n += 8; x <<= 8; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 28) == 0) { n += 4; x <<= 4; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 28) == 0) { n += 4; x <<= 4; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 28) == 0) { n += 4; x <<= 4; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 30) == 0) { n += 2; x <<= 2; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 30) == 0) { n += 2; x <<= 2; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: if ((x >> 30) == 0) { n += 2; x <<= 2; }
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: return n - (int)(x >> 31);
Magic Number,System,Bits,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Msb,The following statement contains a magic number: return 31 - Nlz(x);
Magic Number,System,Constants,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Constants,The following statement contains a magic number: for (int i = 10; i < BaseLowerChars.Length; i++)                  {                      BaseCharToDigits.Add(BaseLowerChars[i]' (uint)i);                  }
Magic Number,System,OpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Cmp,The following statement contains a magic number: if (isNull1 || isNull2)                  {                      if (throwNullException)                      {                          throw new ArgumentNullException(isNull1 ? "int1" : "int2"' "Can't use null in comparsion operations.");                      }                      else                      {                          return isNull1 && isNull2 ? 0 : -2;                      }                  }
Magic Number,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: if (msb != 2)                  {                      // Shift to the left (via actually right shift)                      int leftShift = (2 - msb + Constants.DigitBitCount) % Constants.DigitBitCount;                      length = DigitOpHelper.Shr(digitsPtr' length' bufferPtr + 1' Constants.DigitBitCount - leftShift' true) + 1U;                  }                  else                  {                      // Simply use the same digits without any shifting                      bufferPtr = digitsPtr;                  }
Magic Number,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: if (msb != 2)                  {                      // Shift to the left (via actually right shift)                      int leftShift = (2 - msb + Constants.DigitBitCount) % Constants.DigitBitCount;                      length = DigitOpHelper.Shr(digitsPtr' length' bufferPtr + 1' Constants.DigitBitCount - leftShift' true) + 1U;                  }                  else                  {                      // Simply use the same digits without any shifting                      bufferPtr = digitsPtr;                  }
Magic Number,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf)                  {                      uint* resultPtr = resultPtrFixed;                      uint* resultSqrPtr = resultSqrPtrFixed;                        // Cache two first digits                      uint bufferDigitN1 = bufferPtr[length - 1];                      uint bufferDigitN2 = bufferPtr[length - 2];                        // Prepare result.                      // Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4                      // (last division is not floored - here we emulate fixed point)                      resultDigits[0] = 32 / bufferDigitN1;                      resultLength = 1;                        // Prepare variables                      uint nextBufferTempStorage = 0;                      int nextBufferTempShift;                      uint nextBufferLength = 1U;                      uint* nextBufferPtr = &nextBufferTempStorage;                        ulong bitsAfterDotResult;                      ulong bitsAfterDotResultSqr;                      ulong bitsAfterDotNextBuffer;                      ulong bitShift;                      uint shiftOffset;                        uint* tempPtr;                      uint[] tempDigits;                        // Iterate 'till result will be precise enough                      for (int k = 0; k < lengthLog2Bits; ++k)                      {                          // Get result squared                          resultLengthSqr = IntXMultiplier.Multiply(                              resultPtr'                              resultLength'                              resultPtr'                              resultLength'                              resultSqrPtr);                            // Calculate current result bits after dot                          bitsAfterDotResult = (1UL << k) + 1UL;                          bitsAfterDotResultSqr = bitsAfterDotResult << 1;                            // Here we will get the next portion of data from bufferPtr                          if (k < 4)                          {                              // For now buffer intermediate has length 1 and we will use this fact                              nextBufferTempShift = 1 << (k + 1);                              nextBufferTempStorage =                                  bufferDigitN1 << nextBufferTempShift |                                  bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;                          }                          else                          {                              // Determine length to get from bufferPtr                              nextBufferLength = System.Math.Min((1U << (k - 4)) + 1U' length);                              nextBufferPtr = bufferPtr + (length - nextBufferLength);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;                          }                            // Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot                          resultLengthSqrBuf = IntXMultiplier.Multiply(                              resultSqrPtr'                              resultLengthSqr'                              nextBufferPtr'                              nextBufferLength'                              resultSqrBufPtr);                            bitsAfterDotNextBuffer += bitsAfterDotResultSqr;                            // Now calculate 2 * result - resultSqrBufPtr                          --bitsAfterDotResult;                          --bitsAfterDotResultSqr;                            // Shift result on a needed amount of bits to the left                          bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                          resultLength =                              shiftOffset + 1U +                              DigitOpHelper.Shr(                                  resultPtr'                                  resultLength'                                  resultSqrPtr + shiftOffset + 1U'                                  Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)'                                  true);                            // Swap resultPtr and resultSqrPtr pointers                          tempPtr = resultPtr;                          resultPtr = resultSqrPtr;                          resultSqrPtr = tempPtr;                            tempDigits = resultDigits;                          resultDigits = resultDigitsSqr;                          resultDigitsSqr = tempDigits;                            DigitHelper.SetBlockDigits(resultPtr' shiftOffset' 0U);                            bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                            if (shiftOffset < resultLengthSqrBuf)                          {                              // Shift resultSqrBufPtr on a needed amount of bits to the right                              resultLengthSqrBuf = DigitOpHelper.Shr(                                  resultSqrBufPtr + shiftOffset'                                  resultLengthSqrBuf - shiftOffset'                                  resultSqrBufPtr'                                  (int)(bitShift % Constants.DigitBitCount)'                                  false);                                // Now perform actual subtraction                              resultLength = DigitOpHelper.Sub(                                  resultPtr'                                  resultLength'                                  resultSqrBufPtr'                                  resultLengthSqrBuf'                                  resultPtr);                          }                          else                          {                              // Actually we can assume resultSqrBufPtr == 0 here and have nothing to do                          }                      }                  }
Magic Number,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf)                  {                      uint* resultPtr = resultPtrFixed;                      uint* resultSqrPtr = resultSqrPtrFixed;                        // Cache two first digits                      uint bufferDigitN1 = bufferPtr[length - 1];                      uint bufferDigitN2 = bufferPtr[length - 2];                        // Prepare result.                      // Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4                      // (last division is not floored - here we emulate fixed point)                      resultDigits[0] = 32 / bufferDigitN1;                      resultLength = 1;                        // Prepare variables                      uint nextBufferTempStorage = 0;                      int nextBufferTempShift;                      uint nextBufferLength = 1U;                      uint* nextBufferPtr = &nextBufferTempStorage;                        ulong bitsAfterDotResult;                      ulong bitsAfterDotResultSqr;                      ulong bitsAfterDotNextBuffer;                      ulong bitShift;                      uint shiftOffset;                        uint* tempPtr;                      uint[] tempDigits;                        // Iterate 'till result will be precise enough                      for (int k = 0; k < lengthLog2Bits; ++k)                      {                          // Get result squared                          resultLengthSqr = IntXMultiplier.Multiply(                              resultPtr'                              resultLength'                              resultPtr'                              resultLength'                              resultSqrPtr);                            // Calculate current result bits after dot                          bitsAfterDotResult = (1UL << k) + 1UL;                          bitsAfterDotResultSqr = bitsAfterDotResult << 1;                            // Here we will get the next portion of data from bufferPtr                          if (k < 4)                          {                              // For now buffer intermediate has length 1 and we will use this fact                              nextBufferTempShift = 1 << (k + 1);                              nextBufferTempStorage =                                  bufferDigitN1 << nextBufferTempShift |                                  bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;                          }                          else                          {                              // Determine length to get from bufferPtr                              nextBufferLength = System.Math.Min((1U << (k - 4)) + 1U' length);                              nextBufferPtr = bufferPtr + (length - nextBufferLength);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;                          }                            // Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot                          resultLengthSqrBuf = IntXMultiplier.Multiply(                              resultSqrPtr'                              resultLengthSqr'                              nextBufferPtr'                              nextBufferLength'                              resultSqrBufPtr);                            bitsAfterDotNextBuffer += bitsAfterDotResultSqr;                            // Now calculate 2 * result - resultSqrBufPtr                          --bitsAfterDotResult;                          --bitsAfterDotResultSqr;                            // Shift result on a needed amount of bits to the left                          bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                          resultLength =                              shiftOffset + 1U +                              DigitOpHelper.Shr(                                  resultPtr'                                  resultLength'                                  resultSqrPtr + shiftOffset + 1U'                                  Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)'                                  true);                            // Swap resultPtr and resultSqrPtr pointers                          tempPtr = resultPtr;                          resultPtr = resultSqrPtr;                          resultSqrPtr = tempPtr;                            tempDigits = resultDigits;                          resultDigits = resultDigitsSqr;                          resultDigitsSqr = tempDigits;                            DigitHelper.SetBlockDigits(resultPtr' shiftOffset' 0U);                            bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                            if (shiftOffset < resultLengthSqrBuf)                          {                              // Shift resultSqrBufPtr on a needed amount of bits to the right                              resultLengthSqrBuf = DigitOpHelper.Shr(                                  resultSqrBufPtr + shiftOffset'                                  resultLengthSqrBuf - shiftOffset'                                  resultSqrBufPtr'                                  (int)(bitShift % Constants.DigitBitCount)'                                  false);                                // Now perform actual subtraction                              resultLength = DigitOpHelper.Sub(                                  resultPtr'                                  resultLength'                                  resultSqrBufPtr'                                  resultLengthSqrBuf'                                  resultPtr);                          }                          else                          {                              // Actually we can assume resultSqrBufPtr == 0 here and have nothing to do                          }                      }                  }
Magic Number,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf)                  {                      uint* resultPtr = resultPtrFixed;                      uint* resultSqrPtr = resultSqrPtrFixed;                        // Cache two first digits                      uint bufferDigitN1 = bufferPtr[length - 1];                      uint bufferDigitN2 = bufferPtr[length - 2];                        // Prepare result.                      // Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4                      // (last division is not floored - here we emulate fixed point)                      resultDigits[0] = 32 / bufferDigitN1;                      resultLength = 1;                        // Prepare variables                      uint nextBufferTempStorage = 0;                      int nextBufferTempShift;                      uint nextBufferLength = 1U;                      uint* nextBufferPtr = &nextBufferTempStorage;                        ulong bitsAfterDotResult;                      ulong bitsAfterDotResultSqr;                      ulong bitsAfterDotNextBuffer;                      ulong bitShift;                      uint shiftOffset;                        uint* tempPtr;                      uint[] tempDigits;                        // Iterate 'till result will be precise enough                      for (int k = 0; k < lengthLog2Bits; ++k)                      {                          // Get result squared                          resultLengthSqr = IntXMultiplier.Multiply(                              resultPtr'                              resultLength'                              resultPtr'                              resultLength'                              resultSqrPtr);                            // Calculate current result bits after dot                          bitsAfterDotResult = (1UL << k) + 1UL;                          bitsAfterDotResultSqr = bitsAfterDotResult << 1;                            // Here we will get the next portion of data from bufferPtr                          if (k < 4)                          {                              // For now buffer intermediate has length 1 and we will use this fact                              nextBufferTempShift = 1 << (k + 1);                              nextBufferTempStorage =                                  bufferDigitN1 << nextBufferTempShift |                                  bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;                          }                          else                          {                              // Determine length to get from bufferPtr                              nextBufferLength = System.Math.Min((1U << (k - 4)) + 1U' length);                              nextBufferPtr = bufferPtr + (length - nextBufferLength);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;                          }                            // Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot                          resultLengthSqrBuf = IntXMultiplier.Multiply(                              resultSqrPtr'                              resultLengthSqr'                              nextBufferPtr'                              nextBufferLength'                              resultSqrBufPtr);                            bitsAfterDotNextBuffer += bitsAfterDotResultSqr;                            // Now calculate 2 * result - resultSqrBufPtr                          --bitsAfterDotResult;                          --bitsAfterDotResultSqr;                            // Shift result on a needed amount of bits to the left                          bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                          resultLength =                              shiftOffset + 1U +                              DigitOpHelper.Shr(                                  resultPtr'                                  resultLength'                                  resultSqrPtr + shiftOffset + 1U'                                  Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)'                                  true);                            // Swap resultPtr and resultSqrPtr pointers                          tempPtr = resultPtr;                          resultPtr = resultSqrPtr;                          resultSqrPtr = tempPtr;                            tempDigits = resultDigits;                          resultDigits = resultDigitsSqr;                          resultDigitsSqr = tempDigits;                            DigitHelper.SetBlockDigits(resultPtr' shiftOffset' 0U);                            bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                            if (shiftOffset < resultLengthSqrBuf)                          {                              // Shift resultSqrBufPtr on a needed amount of bits to the right                              resultLengthSqrBuf = DigitOpHelper.Shr(                                  resultSqrBufPtr + shiftOffset'                                  resultLengthSqrBuf - shiftOffset'                                  resultSqrBufPtr'                                  (int)(bitShift % Constants.DigitBitCount)'                                  false);                                // Now perform actual subtraction                              resultLength = DigitOpHelper.Sub(                                  resultPtr'                                  resultLength'                                  resultSqrBufPtr'                                  resultLengthSqrBuf'                                  resultPtr);                          }                          else                          {                              // Actually we can assume resultSqrBufPtr == 0 here and have nothing to do                          }                      }                  }
Magic Number,System,NewtonHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: fixed (uint* resultPtrFixed = resultDigits' resultSqrPtrFixed = resultDigitsSqr' resultSqrBufPtr = resultDigitsSqrBuf)                  {                      uint* resultPtr = resultPtrFixed;                      uint* resultSqrPtr = resultSqrPtrFixed;                        // Cache two first digits                      uint bufferDigitN1 = bufferPtr[length - 1];                      uint bufferDigitN2 = bufferPtr[length - 2];                        // Prepare result.                      // Initially result = floor(32 / (4*v1 + 2*v2 + v3)) / 4                      // (last division is not floored - here we emulate fixed point)                      resultDigits[0] = 32 / bufferDigitN1;                      resultLength = 1;                        // Prepare variables                      uint nextBufferTempStorage = 0;                      int nextBufferTempShift;                      uint nextBufferLength = 1U;                      uint* nextBufferPtr = &nextBufferTempStorage;                        ulong bitsAfterDotResult;                      ulong bitsAfterDotResultSqr;                      ulong bitsAfterDotNextBuffer;                      ulong bitShift;                      uint shiftOffset;                        uint* tempPtr;                      uint[] tempDigits;                        // Iterate 'till result will be precise enough                      for (int k = 0; k < lengthLog2Bits; ++k)                      {                          // Get result squared                          resultLengthSqr = IntXMultiplier.Multiply(                              resultPtr'                              resultLength'                              resultPtr'                              resultLength'                              resultSqrPtr);                            // Calculate current result bits after dot                          bitsAfterDotResult = (1UL << k) + 1UL;                          bitsAfterDotResultSqr = bitsAfterDotResult << 1;                            // Here we will get the next portion of data from bufferPtr                          if (k < 4)                          {                              // For now buffer intermediate has length 1 and we will use this fact                              nextBufferTempShift = 1 << (k + 1);                              nextBufferTempStorage =                                  bufferDigitN1 << nextBufferTempShift |                                  bufferDigitN2 >> (Constants.DigitBitCount - nextBufferTempShift);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;                          }                          else                          {                              // Determine length to get from bufferPtr                              nextBufferLength = System.Math.Min((1U << (k - 4)) + 1U' length);                              nextBufferPtr = bufferPtr + (length - nextBufferLength);                                // Calculate amount of bits after dot (simple formula here)                              bitsAfterDotNextBuffer = (ulong)(nextBufferLength - 1U) * Constants.DigitBitCount + 3UL;                          }                            // Multiply result ^ 2 and nextBuffer + calculate new amount of bits after dot                          resultLengthSqrBuf = IntXMultiplier.Multiply(                              resultSqrPtr'                              resultLengthSqr'                              nextBufferPtr'                              nextBufferLength'                              resultSqrBufPtr);                            bitsAfterDotNextBuffer += bitsAfterDotResultSqr;                            // Now calculate 2 * result - resultSqrBufPtr                          --bitsAfterDotResult;                          --bitsAfterDotResultSqr;                            // Shift result on a needed amount of bits to the left                          bitShift = bitsAfterDotResultSqr - bitsAfterDotResult;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                          resultLength =                              shiftOffset + 1U +                              DigitOpHelper.Shr(                                  resultPtr'                                  resultLength'                                  resultSqrPtr + shiftOffset + 1U'                                  Constants.DigitBitCount - (int)(bitShift % Constants.DigitBitCount)'                                  true);                            // Swap resultPtr and resultSqrPtr pointers                          tempPtr = resultPtr;                          resultPtr = resultSqrPtr;                          resultSqrPtr = tempPtr;                            tempDigits = resultDigits;                          resultDigits = resultDigitsSqr;                          resultDigitsSqr = tempDigits;                            DigitHelper.SetBlockDigits(resultPtr' shiftOffset' 0U);                            bitShift = bitsAfterDotNextBuffer - bitsAfterDotResultSqr;                          shiftOffset = (uint)(bitShift / Constants.DigitBitCount);                            if (shiftOffset < resultLengthSqrBuf)                          {                              // Shift resultSqrBufPtr on a needed amount of bits to the right                              resultLengthSqrBuf = DigitOpHelper.Shr(                                  resultSqrBufPtr + shiftOffset'                                  resultLengthSqrBuf - shiftOffset'                                  resultSqrBufPtr'                                  (int)(bitShift % Constants.DigitBitCount)'                                  false);                                // Now perform actual subtraction                              resultLength = DigitOpHelper.Sub(                                  resultPtr'                                  resultLength'                                  resultSqrBufPtr'                                  resultLengthSqrBuf'                                  resultPtr);                          }                          else                          {                              // Actually we can assume resultSqrBufPtr == 0 here and have nothing to do                          }                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,The following statement contains a magic number: double normalizeMultiplier = 0.5 / length;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,The following statement contains a magic number: for (uint i = 0; i < length; ++i)                  {                      // Get data digit (don't forget it might be balanced)                      dataDigit = slice[i] * normalizeMultiplier;                        // Round to the nearest                      dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5) + carryInt;                        // Get next carry floored; maybe modify data digit                      carry = dataDigitInt / DoubleDataBase;                      if (carry < 0)                      {                          carry += carry % 1.0;                      }                      carryInt = (long)carry;                        dataDigitInt -= carryInt << DoubleDataDigitShift;                      if (dataDigitInt < 0)                      {                          dataDigitInt += DoubleDataBaseInt;                          --carryInt;                      }                        // Maybe add to the digits                      if (i < unitCount)                      {                          unitDigitsPtr[i] = (byte)dataDigitInt;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,The following statement contains a magic number: for (uint i = 0; i < length; ++i)                  {                      // Get data digit (don't forget it might be balanced)                      dataDigit = slice[i] * normalizeMultiplier;                        // Round to the nearest                      dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5) + carryInt;                        // Get next carry floored; maybe modify data digit                      carry = dataDigitInt / DoubleDataBase;                      if (carry < 0)                      {                          carry += carry % 1.0;                      }                      carryInt = (long)carry;                        dataDigitInt -= carryInt << DoubleDataDigitShift;                      if (dataDigitInt < 0)                      {                          dataDigitInt += DoubleDataBaseInt;                          --carryInt;                      }                        // Maybe add to the digits                      if (i < unitCount)                      {                          unitDigitsPtr[i] = (byte)dataDigitInt;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht,The following statement contains a magic number: if (length == 4)                  {                      Fht4(slice);                      return;                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht,The following statement contains a magic number: uint lengthDiv4 = length >> 2;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: double d2 = slice[2];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: double d3 = slice[3];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: slice[2] = d02 + d13;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: slice[3] = d02 - d13;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: slice[0] *= 2.0 * slice2[0];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: slice[1] *= 2.0 * slice2[1];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2)                  {                      for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2)                      {                          d11 = slice[index1];                          d12 = slice[index2];                          d21 = slice2[index1];                          d22 = slice2[index2];                            ad = d11 + d12;                          sd = d11 - d12;                            slice[index1] = d21 * ad + d22 * sd;                          slice[index2] = d22 * ad - d21 * sd;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2)                  {                      for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2)                      {                          d11 = slice[index1];                          d12 = slice[index2];                          d21 = slice2[index1];                          d22 = slice2[index2];                            ad = d11 + d12;                          sd = d11 - d12;                            slice[index1] = d21 * ad + d22 * sd;                          slice[index2] = d22 * ad - d21 * sd;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2)                  {                      for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2)                      {                          d11 = slice[index1];                          d12 = slice[index2];                          d21 = slice2[index1];                          d22 = slice2[index2];                            ad = d11 + d12;                          sd = d11 - d12;                            slice[index1] = d21 * ad + d22 * sd;                          slice[index2] = d22 * ad - d21 * sd;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2)                  {                      for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2)                      {                          d11 = slice[index1];                          d12 = slice[index2];                          d21 = slice2[index1];                          d22 = slice2[index2];                            ad = d11 + d12;                          sd = d11 - d12;                            slice[index1] = d21 * ad + d22 * sd;                          slice[index2] = d22 * ad - d21 * sd;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2)                  {                      for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2)                      {                          d11 = slice[index1];                          d12 = slice[index2];                          d21 = slice2[index1];                          d22 = slice2[index2];                            ad = d11 + d12;                          sd = d11 - d12;                            slice[index1] = d21 * ad + d22 * sd;                          slice[index2] = d22 * ad - d21 * sd;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: for (uint stepStart = 2' stepEnd = 4' index1' index2; stepStart < length; stepStart *= 2' stepEnd *= 2)                  {                      for (index1 = stepStart' index2 = stepEnd - 1; index1 < stepEnd; index1 += 2' index2 -= 2)                      {                          d11 = slice[index1];                          d12 = slice[index2];                          d21 = slice2[index1];                          d22 = slice2[index2];                            ad = d11 + d12;                          sd = d11 - d12;                            slice[index1] = d21 * ad + d22 * sd;                          slice[index2] = d22 * ad - d21 * sd;                      }                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht,The following statement contains a magic number: if (length == 8)                  {                      ReverseFht8(slice);                      return;                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht,The following statement contains a magic number: uint lengthDiv4 = length >> 2;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d2 = slice[2];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d3 = slice[3];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d4 = slice[4];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d5 = slice[5];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d6 = slice[6];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d7 = slice[7];
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[4] = daa0123 - daa4567;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[2] = dsa0123 + dsa4567;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[6] = dsa0123 - dsa4567;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[5] = das0123 - ds45;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[3] = dss0123 + ds67;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[7] = dss0123 - ds67;
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FillSineTable,The following statement contains a magic number: for (int i = 0' p = 1; i < sineTable.Length; ++i' p *= 2)                  {                      sineTable[i] = System.Math.Sin(System.Math.PI / p);                  }
Magic Number,System,FhtHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetInitialTrigValues,The following statement contains a magic number: valuesPtr->TableCos *= -2.0 * valuesPtr->TableCos;
Magic Number,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The following statement contains a magic number: for (uint i = 0; i < length2; ++i)                  {                      c += (ulong)digitsPtr1[i] + digitsPtr2[i];                      digitsResPtr[i] = (uint)c;                      c >>= 32;                  }
Magic Number,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The following statement contains a magic number: for (uint i = length2; i < length1; ++i)                  {                      c += digitsPtr1[i];                      digitsResPtr[i] = (uint)c;                      c >>= 32;                  }
Magic Number,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The following statement contains a magic number: for (uint i = 0; i < length2; ++i)                  {                      c = (ulong)digitsPtr1[i] - digitsPtr2[i] - c;                      digitsResPtr[i] = (uint)c;                      c >>= 63;                  }
Magic Number,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The following statement contains a magic number: for (uint i = length2; i < length1; ++i)                  {                      c = digitsPtr1[i] - c;                      digitsResPtr[i] = (uint)c;                      c >>= 63;                  }
Magic Number,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Cmp,The following statement contains a magic number: if (res != -2) return res;
Magic Number,System,DigitOpHelper,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,CmpLen,The following statement contains a magic number: return length1 == 0 ? 0 : -2;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x == 0) return (64);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x00000000FFFFFFFF) { n = n + 32; x = x << 32; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x00000000FFFFFFFF) { n = n + 32; x = x << 32; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x0000FFFFFFFFFFFF) { n = n + 16; x = x << 16; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x0000FFFFFFFFFFFF) { n = n + 16; x = x << 16; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x00FFFFFFFFFFFFFF) { n = n + 8; x = x << 8; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x00FFFFFFFFFFFFFF) { n = n + 8; x = x << 8; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x0FFFFFFFFFFFFFFF) { n = n + 4; x = x << 4; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x0FFFFFFFFFFFFFFF) { n = n + 4; x = x << 4; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x3FFFFFFFFFFFFFFF) { n = n + 2; x = x << 2; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: if (x <= 0x3FFFFFFFFFFFFFFF) { n = n + 2; x = x << 2; }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: long multiplierExponent = (((long)bits >> 52) & 0x7ffL);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (multiplierExponent == 0)              {                  if (multiplierSignificand == 0)                  {                      //multiplication by 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                      return;                  }                    int firstSetPosition = nlz(multiplierSignificand);                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << firstSetPosition);                  multiplierExponent -= firstSetPosition - 1 + 1075;              }                          else              {                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << 11);                  multiplierExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (multiplierExponent == 0)              {                  if (multiplierSignificand == 0)                  {                      //multiplication by 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                      return;                  }                    int firstSetPosition = nlz(multiplierSignificand);                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << firstSetPosition);                  multiplierExponent -= firstSetPosition - 1 + 1075;              }                          else              {                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << 11);                  multiplierExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (multiplierExponent == 0)              {                  if (multiplierSignificand == 0)                  {                      //multiplication by 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                      return;                  }                    int firstSetPosition = nlz(multiplierSignificand);                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << firstSetPosition);                  multiplierExponent -= firstSetPosition - 1 + 1075;              }                          else              {                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << 11);                  multiplierExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (multiplierExponent == 0)              {                  if (multiplierSignificand == 0)                  {                      //multiplication by 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                      return;                  }                    int firstSetPosition = nlz(multiplierSignificand);                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << firstSetPosition);                  multiplierExponent -= firstSetPosition - 1 + 1075;              }                          else              {                  multiplierSignificand = (highestBit & bits) | (multiplierSignificand << 11);                  multiplierExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high1 = (this.SignificandBits | highestBit) >> 32;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high2 = (multiplierSignificand | highestBit) >> 32;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplierSignificand & lowWordMask)) >> 32);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplierSignificand & lowWordMask)) >> 32);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (significandBits < (1UL << 63))              {                  if (this.Exponent == long.MinValue)                      return; //we're already 0                    this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | ((significandBits << 1) & ~highestBit);                  this.Exponent = this.Exponent + multiplierExponent - 1 + 64;              }              else              {                  this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | (significandBits & ~highestBit);                  this.Exponent = this.Exponent + multiplierExponent + 64;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (significandBits < (1UL << 63))              {                  if (this.Exponent == long.MinValue)                      return; //we're already 0                    this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | ((significandBits << 1) & ~highestBit);                  this.Exponent = this.Exponent + multiplierExponent - 1 + 64;              }              else              {                  this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | (significandBits & ~highestBit);                  this.Exponent = this.Exponent + multiplierExponent + 64;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (significandBits < (1UL << 63))              {                  if (this.Exponent == long.MinValue)                      return; //we're already 0                    this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | ((significandBits << 1) & ~highestBit);                  this.Exponent = this.Exponent + multiplierExponent - 1 + 64;              }              else              {                  this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | (significandBits & ~highestBit);                  this.Exponent = this.Exponent + multiplierExponent + 64;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high1 = (this.SignificandBits | highestBit) >> 32;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high2 = (multiplier.SignificandBits | highestBit) >> 32;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.SignificandBits & lowWordMask)) >> 32);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.SignificandBits & lowWordMask)) >> 32);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (significandBits < (1UL << 63))              {                                  //Checking for zeros here is significantly faster (~15%) on my machine than at the beginning'                  //because this branch is rarely taken.  This is acceptable because a zero will have a significand of 0'                  //and thus (when the significant bit is erroneously OR'd to it) multiplying by that zero cannot yield a value                  //of significandBits greater than or equal to 1 << 63.                  if (this.Exponent == long.MinValue || multiplier.Exponent == long.MinValue)                  {                      this.Exponent = long.MinValue;                      this.SignificandBits = 0;                  }                  else                  {                      this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | ((significandBits << 1) & ~highestBit);                      this.Exponent = this.Exponent + multiplier.Exponent - 1 + 64;                  }                }              else              {                  this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | (significandBits & ~highestBit);                  this.Exponent = this.Exponent + multiplier.Exponent + 64;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (significandBits < (1UL << 63))              {                                  //Checking for zeros here is significantly faster (~15%) on my machine than at the beginning'                  //because this branch is rarely taken.  This is acceptable because a zero will have a significand of 0'                  //and thus (when the significant bit is erroneously OR'd to it) multiplying by that zero cannot yield a value                  //of significandBits greater than or equal to 1 << 63.                  if (this.Exponent == long.MinValue || multiplier.Exponent == long.MinValue)                  {                      this.Exponent = long.MinValue;                      this.SignificandBits = 0;                  }                  else                  {                      this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | ((significandBits << 1) & ~highestBit);                      this.Exponent = this.Exponent + multiplier.Exponent - 1 + 64;                  }                }              else              {                  this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | (significandBits & ~highestBit);                  this.Exponent = this.Exponent + multiplier.Exponent + 64;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: if (significandBits < (1UL << 63))              {                                  //Checking for zeros here is significantly faster (~15%) on my machine than at the beginning'                  //because this branch is rarely taken.  This is acceptable because a zero will have a significand of 0'                  //and thus (when the significant bit is erroneously OR'd to it) multiplying by that zero cannot yield a value                  //of significandBits greater than or equal to 1 << 63.                  if (this.Exponent == long.MinValue || multiplier.Exponent == long.MinValue)                  {                      this.Exponent = long.MinValue;                      this.SignificandBits = 0;                  }                  else                  {                      this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | ((significandBits << 1) & ~highestBit);                      this.Exponent = this.Exponent + multiplier.Exponent - 1 + 64;                  }                }              else              {                  this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | (significandBits & ~highestBit);                  this.Exponent = this.Exponent + multiplier.Exponent + 64;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: long valueExponent = (((long)doubleBits >> 52) & 0x7ffL);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //addition with 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //addition with 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //addition with 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //addition with 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (this.Exponent > valueExponent)              {                  if (this.Exponent >= valueExponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) + ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent));                        if (bits < highestBit) //this can only happen in an overflow                        {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits >> 1);                          this.Exponent = this.Exponent + 1;                      }                      else                      {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits & ~highestBit);                          //this.Exponent = this.Exponent; //exponent stays the same                      }                  }              }              else if (this.Exponent < valueExponent)              {                  if (valueExponent >= this.Exponent + 64)                  {                      this.SignificandBits = valueSignificand; //too small to matter                      this.Exponent = valueExponent;                  }                  else                  {                      ulong bits = (valueSignificand | highestBit) + ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent));                        if (bits < highestBit) //this can only happen in an overflow                                          {                          this.SignificandBits = (valueSignificand & highestBit) | (bits >> 1);                          this.Exponent = valueExponent + 1;                      }                      else                      {                          this.SignificandBits = (valueSignificand & highestBit) | (bits & ~highestBit);                          this.Exponent = valueExponent;                      }                  }              }              else //expDiff == 0              {                  if (this.Exponent == long.MinValue) //verify that we're not adding two 0's                      return; //we are already 0' so just return                    //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent).                  this.SignificandBits = ((this.SignificandBits + valueSignificand) >> 1) | (this.SignificandBits & highestBit);                  this.Exponent = this.Exponent + 1;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (this.Exponent > valueExponent)              {                  if (this.Exponent >= valueExponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) + ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent));                        if (bits < highestBit) //this can only happen in an overflow                        {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits >> 1);                          this.Exponent = this.Exponent + 1;                      }                      else                      {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits & ~highestBit);                          //this.Exponent = this.Exponent; //exponent stays the same                      }                  }              }              else if (this.Exponent < valueExponent)              {                  if (valueExponent >= this.Exponent + 64)                  {                      this.SignificandBits = valueSignificand; //too small to matter                      this.Exponent = valueExponent;                  }                  else                  {                      ulong bits = (valueSignificand | highestBit) + ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent));                        if (bits < highestBit) //this can only happen in an overflow                                          {                          this.SignificandBits = (valueSignificand & highestBit) | (bits >> 1);                          this.Exponent = valueExponent + 1;                      }                      else                      {                          this.SignificandBits = (valueSignificand & highestBit) | (bits & ~highestBit);                          this.Exponent = valueExponent;                      }                  }              }              else //expDiff == 0              {                  if (this.Exponent == long.MinValue) //verify that we're not adding two 0's                      return; //we are already 0' so just return                    //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent).                  this.SignificandBits = ((this.SignificandBits + valueSignificand) >> 1) | (this.SignificandBits & highestBit);                  this.Exponent = this.Exponent + 1;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (this.Exponent > value.Exponent)              {                  if (this.Exponent >= value.Exponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) + ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent));                        if (bits < highestBit) //this can only happen in an overflow                        {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits >> 1);                          this.Exponent = this.Exponent + 1;                      }                      else                      {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits & ~highestBit);                          //this.Exponent = this.Exponent; //exponent stays the same                      }                  }              }              else if (this.Exponent < value.Exponent)              {                  if (value.Exponent >= this.Exponent + 64)                  {                      this.SignificandBits = value.SignificandBits; //too small to matter                      this.Exponent = value.Exponent;                  }                  else                  {                      ulong bits = (value.SignificandBits | highestBit) + ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent));                        if (bits < highestBit) //this can only happen in an overflow                                          {                          this.SignificandBits = (value.SignificandBits & highestBit) | (bits >> 1);                          this.Exponent = value.Exponent + 1;                      }                      else                      {                          this.SignificandBits = (value.SignificandBits & highestBit) | (bits & ~highestBit);                          this.Exponent = value.Exponent;                      }                  }              }              else //expDiff == 0              {                  if (this.Exponent == long.MinValue) //verify that we're not adding two 0's                      return; //we are already 0' so just return                                    //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent).                  this.SignificandBits = ((this.SignificandBits + value.SignificandBits) >> 1) | (this.SignificandBits & highestBit);                  this.Exponent = this.Exponent + 1;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: if (this.Exponent > value.Exponent)              {                  if (this.Exponent >= value.Exponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) + ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent));                        if (bits < highestBit) //this can only happen in an overflow                        {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits >> 1);                          this.Exponent = this.Exponent + 1;                      }                      else                      {                          this.SignificandBits = (this.SignificandBits & highestBit) | (bits & ~highestBit);                          //this.Exponent = this.Exponent; //exponent stays the same                      }                  }              }              else if (this.Exponent < value.Exponent)              {                  if (value.Exponent >= this.Exponent + 64)                  {                      this.SignificandBits = value.SignificandBits; //too small to matter                      this.Exponent = value.Exponent;                  }                  else                  {                      ulong bits = (value.SignificandBits | highestBit) + ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent));                        if (bits < highestBit) //this can only happen in an overflow                                          {                          this.SignificandBits = (value.SignificandBits & highestBit) | (bits >> 1);                          this.Exponent = value.Exponent + 1;                      }                      else                      {                          this.SignificandBits = (value.SignificandBits & highestBit) | (bits & ~highestBit);                          this.Exponent = value.Exponent;                      }                  }              }              else //expDiff == 0              {                  if (this.Exponent == long.MinValue) //verify that we're not adding two 0's                      return; //we are already 0' so just return                                    //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent).                  this.SignificandBits = ((this.SignificandBits + value.SignificandBits) >> 1) | (this.SignificandBits & highestBit);                  this.Exponent = this.Exponent + 1;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: long valueExponent = (((long)doubleBits >> 52) & 0x7ffL);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //subtraction by 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //subtraction by 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //subtraction by 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //subtraction by 0                                          return;                  }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (this.Exponent > valueExponent)              {                  if (this.Exponent >= valueExponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) - ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent));                        //make sure MSB is 1                                             int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }              }              else if (this.Exponent < valueExponent) //must subtract our significand from value' and switch the sign              {                  if (valueExponent >= this.Exponent + 64)                  {                      this.SignificandBits = valueSignificand ^ highestBit;                      this.Exponent = valueExponent;                      return;                  }                    ulong bits = (valueSignificand | highestBit) - ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent));                    //make sure MSB is 1                                         int highestBitPos = nlz(bits);                  this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~valueSignificand & highestBit);                  this.Exponent = valueExponent - highestBitPos;              }              else // (this.Exponent == valueExponent)              {                  if (valueSignificand > this.SignificandBits) //must switch sign                  {                      ulong bits = valueSignificand - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~valueSignificand & highestBit);                      this.Exponent = valueExponent - highestBitPos;                  }                  else if (valueSignificand < this.SignificandBits) //sign remains the same                  {                      ulong bits = this.SignificandBits - valueSignificand; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }                  else //this == value                  {                      //result is 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                  }              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (this.Exponent > valueExponent)              {                  if (this.Exponent >= valueExponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) - ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent));                        //make sure MSB is 1                                             int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }              }              else if (this.Exponent < valueExponent) //must subtract our significand from value' and switch the sign              {                  if (valueExponent >= this.Exponent + 64)                  {                      this.SignificandBits = valueSignificand ^ highestBit;                      this.Exponent = valueExponent;                      return;                  }                    ulong bits = (valueSignificand | highestBit) - ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent));                    //make sure MSB is 1                                         int highestBitPos = nlz(bits);                  this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~valueSignificand & highestBit);                  this.Exponent = valueExponent - highestBitPos;              }              else // (this.Exponent == valueExponent)              {                  if (valueSignificand > this.SignificandBits) //must switch sign                  {                      ulong bits = valueSignificand - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~valueSignificand & highestBit);                      this.Exponent = valueExponent - highestBitPos;                  }                  else if (valueSignificand < this.SignificandBits) //sign remains the same                  {                      ulong bits = this.SignificandBits - valueSignificand; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }                  else //this == value                  {                      //result is 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                  }              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (this.Exponent > value.Exponent)              {                  if (this.Exponent >= value.Exponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) - ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent));                        //make sure MSB is 1                                             int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }              }              else if (this.Exponent < value.Exponent) //must subtract our significand from value' and switch the sign              {                  if (value.Exponent >= this.Exponent + 64)                  {                      this.SignificandBits = value.SignificandBits ^ highestBit;                      this.Exponent = value.Exponent;                      return;                  }                    ulong bits = (value.SignificandBits | highestBit) - ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent));                    //make sure MSB is 1                                         int highestBitPos = nlz(bits);                  this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~value.SignificandBits & highestBit);                  this.Exponent = value.Exponent - highestBitPos;              }              else // (this.Exponent == value.Exponent)              {                                  if (value.SignificandBits > this.SignificandBits) //must switch sign                  {                      ulong bits = value.SignificandBits - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~value.SignificandBits & highestBit);                      this.Exponent = value.Exponent - highestBitPos;                  }                  else if (value.SignificandBits < this.SignificandBits) //sign remains the same                  {                      ulong bits = this.SignificandBits - value.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }                  else //this == value                  {                      //result is 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                  }              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: if (this.Exponent > value.Exponent)              {                  if (this.Exponent >= value.Exponent + 64)                      return; //value too small to make a difference                  else                  {                      ulong bits = (this.SignificandBits | highestBit) - ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent));                        //make sure MSB is 1                                             int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }              }              else if (this.Exponent < value.Exponent) //must subtract our significand from value' and switch the sign              {                  if (value.Exponent >= this.Exponent + 64)                  {                      this.SignificandBits = value.SignificandBits ^ highestBit;                      this.Exponent = value.Exponent;                      return;                  }                    ulong bits = (value.SignificandBits | highestBit) - ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent));                    //make sure MSB is 1                                         int highestBitPos = nlz(bits);                  this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~value.SignificandBits & highestBit);                  this.Exponent = value.Exponent - highestBitPos;              }              else // (this.Exponent == value.Exponent)              {                                  if (value.SignificandBits > this.SignificandBits) //must switch sign                  {                      ulong bits = value.SignificandBits - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (~value.SignificandBits & highestBit);                      this.Exponent = value.Exponent - highestBitPos;                  }                  else if (value.SignificandBits < this.SignificandBits) //sign remains the same                  {                      ulong bits = this.SignificandBits - value.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway                      int highestBitPos = nlz(bits);                      this.SignificandBits = ((bits << highestBitPos) & ~highestBit) | (this.SignificandBits & highestBit);                      this.Exponent = this.Exponent - highestBitPos;                  }                  else //this == value                  {                      //result is 0                      this.SignificandBits = 0;                      this.Exponent = long.MinValue;                  }              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: long valueExponent = (((long)doubleBits >> 52) & 0x7ffL);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //division by 0                      throw new DivideByZeroException();                                      }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //division by 0                      throw new DivideByZeroException();                                      }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //division by 0                      throw new DivideByZeroException();                                      }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (valueExponent == 0)              {                  if (valueSignificand == 0)                  {                      //division by 0                      throw new DivideByZeroException();                                      }                    int firstSetPosition = nlz(valueSignificand);                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << firstSetPosition);                  valueExponent -= firstSetPosition - 1 + 1075;              }              else              {                  valueSignificand = (highestBit & doubleBits) | (valueSignificand << 11);                  valueExponent -= 11 + 1075;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand >= divisorAdjSignificand)              {                  //need to make this's significand smaller than divisor's                  adjExponent = 1;                  un1 = (this.SignificandBits & 1) << 31;                  thisAdjSignificand = thisAdjSignificand >> 1;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: vn1 = divisorAdjSignificand >> 32;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand < (1UL << 63))              {                  this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ valueSignificand) & highestBit);                  this.Exponent = this.Exponent - (valueExponent + 64) - 1 + adjExponent;              }              else              {                  this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ valueSignificand) & highestBit);                  this.Exponent = this.Exponent - (valueExponent + 64) + adjExponent;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand < (1UL << 63))              {                  this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ valueSignificand) & highestBit);                  this.Exponent = this.Exponent - (valueExponent + 64) - 1 + adjExponent;              }              else              {                  this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ valueSignificand) & highestBit);                  this.Exponent = this.Exponent - (valueExponent + 64) + adjExponent;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand < (1UL << 63))              {                  this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ valueSignificand) & highestBit);                  this.Exponent = this.Exponent - (valueExponent + 64) - 1 + adjExponent;              }              else              {                  this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ valueSignificand) & highestBit);                  this.Exponent = this.Exponent - (valueExponent + 64) + adjExponent;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand >= divisorAdjSignificand)              {                  //need to make this's significand smaller than divisor's                  adjExponent = 1;                  un1 = (this.SignificandBits & 1) << 31;                  thisAdjSignificand = thisAdjSignificand >> 1;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: vn1 = divisorAdjSignificand >> 32;
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand < (1UL << 63))              {                  this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit);                  this.Exponent = this.Exponent - (divisor.Exponent + 64) - 1 + adjExponent;              }              else              {                  this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit);                  this.Exponent = this.Exponent - (divisor.Exponent + 64) + adjExponent;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand < (1UL << 63))              {                  this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit);                  this.Exponent = this.Exponent - (divisor.Exponent + 64) - 1 + adjExponent;              }              else              {                  this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit);                  this.Exponent = this.Exponent - (divisor.Exponent + 64) + adjExponent;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: if (thisAdjSignificand < (1UL << 63))              {                  this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit);                  this.Exponent = this.Exponent - (divisor.Exponent + 64) - 1 + adjExponent;              }              else              {                  this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit);                  this.Exponent = this.Exponent - (divisor.Exponent + 64) + adjExponent;              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,IntegerString,The following statement contains a magic number: if (quad.Exponent <= -64) return "0";
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,GetHashCode,The following statement contains a magic number: return SignificandBits.GetHashCode() ^ (expHash << 16 | expHash >> 16);
Magic Number,System,Quad,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,GetHashCode,The following statement contains a magic number: return SignificandBits.GetHashCode() ^ (expHash << 16 | expHash >> 16);
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hash = 17;  				hash = hash * 23 + low.GetHashCode();  				hash = hash * 23 + high.GetHashCode();  				return hash;  			}
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hash = 17;  				hash = hash * 23 + low.GetHashCode();  				hash = hash * 23 + high.GetHashCode();  				return hash;  			}
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hash = 17;  				hash = hash * 23 + low.GetHashCode();  				hash = hash * 23 + high.GetHashCode();  				return hash;  			}
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: uint left3 = (uint)(left.high >> 32);
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: uint left1 = (uint)(left.low >> 32);
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: ulong right3 = (uint)(right.high >> 32);
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: ulong right1 = (uint)(right.low >> 32);
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value10 = (Int128)(left1 * right0) << 32;
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value30 = new Int128(0' (long)((left3 * right0) << 32));
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value01 = (Int128)(left0 * right1) << 32;
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value21 = new Int128(0' (long)((left2 * right1) << 32));
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value12 = new Int128(0' (long)((left1 * right2) << 32));
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value03 = new Int128(0' (long)((left0 * right3) << 32));
Magic Number,SharpAssembler.Core,Int128,C:\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,UnsignedDivRem,The following statement contains a magic number: for (int i = 0; i < 128; i++)  			{  				remainder <<= 1;  				if (quotient < 0)  					remainder.low |= 1;  				quotient <<= 1;    				if (remainder >= divisor)  				{  					remainder -= divisor;  					quotient++;  				}  			}
