Implementation smell,Namespace,Class,File,Method,Description
Long Method,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The method has 120 lines of code.
Long Method,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The method has 103 lines of code.
Long Method,System,IntXStringConverter,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FastToString,The method has 100 lines of code.
Long Method,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The method has 147 lines of code.
Long Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The method has 143 lines of code.
Complex Method,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,Cyclomatic complexity of the method is 8
Complex Method,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,Cyclomatic complexity of the method is 12
Complex Method,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,Cyclomatic complexity of the method is 16
Complex Method,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseDivMod,Cyclomatic complexity of the method is 17
Complex Method,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,System,OpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sh,Cyclomatic complexity of the method is 10
Complex Method,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,Cyclomatic complexity of the method is 8
Complex Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,Cyclomatic complexity of the method is 8
Complex Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,Cyclomatic complexity of the method is 12
Complex Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,Cyclomatic complexity of the method is 11
Complex Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,Cyclomatic complexity of the method is 8
Complex Method,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,Cyclomatic complexity of the method is 35
Complex Method,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,ToType,Cyclomatic complexity of the method is 17
Long Parameter List,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 9 parameters. Parameters: digits1' digitsBuffer1' length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 9 parameters. Parameters: digitsPtr1' digitsBufferPtr1' length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The method has 9 parameters. Parameters: digits1' digitsBuffer1' length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The method has 9 parameters. Parameters: digitsPtr1' digitsBufferPtr1' length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult
Long Parameter List,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseDivMod,The method has 9 parameters. Parameters: digitsPtr1' digitsBufferPtr1' length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult
Long Parameter List,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The method has 5 parameters. Parameters: digits1' length1' digits2' length2' digitsRes
Long Parameter List,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicMultiply,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Pow2Parse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseParse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicParse,The method has 6 parameters. Parameters: value' startIndex' endIndex' numberBase' charToDigits' digitsRes
Long Parameter List,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The method has 6 parameters. Parameters: digitsPtr' length' maxLength' bufferPtr' newLength' rightShift
Long Parameter List,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FhtButterfly,The method has 6 parameters. Parameters: slice1' slice2' index1' index2' cos' sin
Long Parameter List,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFhtButterfly,The method has 6 parameters. Parameters: slice1' slice2' index1' index2' cos' sin
Long Parameter List,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFhtButterfly2,The method has 6 parameters. Parameters: slice1' slice2' index1' index2' cos' sin
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The method has 5 parameters. Parameters: digits1' length1' digits2' length2' digitsRes
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The method has 5 parameters. Parameters: digits1' length1' digits2' length2' digitsRes
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The method has 5 parameters. Parameters: digitsPtr1' length1' digitsPtr2' length2' digitsResPtr
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 5 parameters. Parameters: digits1' length1' int2' divRes' modRes
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The method has 5 parameters. Parameters: digitsPtr1' length1' int2' divResPtr' modRes
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Shr,The method has 6 parameters. Parameters: digits' offset' length' digitsRes' resOffset' rightShift
Long Parameter List,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Shr,The method has 5 parameters. Parameters: digitsPtr' length' digitsResPtr' rightShift' resHasOffset
Long Statement,System,Half,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,ToChar,The length of the statement  "            throw new InvalidCastException(string.Format(CultureInfo.CurrentCulture' "Invalid cast from '{0}' to '{1}'."' "Half"' "Char")); " is 127.
Long Statement,System,Half,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,ToDateTime,The length of the statement  "            throw new InvalidCastException(string.Format(CultureInfo.CurrentCulture' "Invalid cast from '{0}' to '{1}'."' "Half"' "DateTime")); " is 131.
Long Statement,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Fraction,The length of the statement  "                return new Quad((~QuadhighestBit & (bits << shift)) | (QuadhighestBit & value.SignificandBits)' value.Exponent - shift); " is 120.
Long Statement,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The length of the statement  "                throw new ArgumentOutOfRangeException("Cannot raise a negative number to a non-integer exponent' as this yields an imaginary number."); " is 135.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                    return ClassicDivMod(digits1' digitsBuffer1' ref length1' digits2' digitsBuffer2' length2' digitsRes' resultFlags' cmpResult); " is 126.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                fixed (uint* digitsPtr1 = digits1' digitsBufferPtr1 = digitsBuffer1' digitsPtr2 = digits2' digitsBufferPtr2 = digitsBuffer2 != null ? digitsBuffer2 : digits1' digitsResPtr = digitsRes != null ? digitsRes : digits1) " is 214.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                    return ClassicDivMod(digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 141.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                uint resultLength = BaseDivMod(digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 151.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The length of the statement  "                uint[] int2OppositeDigits = NewtonHelper.GetIntegerOpposite(digitsPtr2' length2' length1' digitsBufferPtr1' out int2OppositeLength' out int2OppositeRightShift); " is 160.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The length of the statement  "                fixed (uint* digitsPtr1 = digits1' digitsBufferPtr1 = digitsBuffer1' digitsPtr2 = digits2' digitsBufferPtr2 = digitsBuffer2' digitsResPtr = digitsRes != null ? digitsRes : digits1) " is 180.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The length of the statement  "                uint resultLength = BaseDivMod(digitsPtr1' digitsBufferPtr1' ref length1' digitsPtr2' digitsBufferPtr2' length2' digitsResPtr' resultFlags' cmpResult); " is 151.
Long Statement,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The length of the statement  "                        if (divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1[iLen2 - 2]) " is 134.
Long Statement,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The length of the statement  "                //            throw new FhtMultiplicationException(string.Format("FHT multiplication returned invalid result for IntX objects with lengths {0} and {1}."' length1' length2)); " is 173.
Long Statement,System,StrRepHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,AssertAlphabet,The length of the statement  "                    throw new ArgumentException(string.Format("Alphabet is too small to represent numbers in base {0}."' numberBase)' "alphabet"); " is 126.
Long Statement,System,OpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sh,The length of the statement  "                uint newLength = (uint)(newBitCount / Constants.DigitBitCount + (newBitCount % Constants.DigitBitCount == 0 ? 0UL : 1UL)); " is 122.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //because the MSB of both significands is 1' the MSB of the result will also be 1' and the product of low bits on both significands is dropped (and thus we can skip its calculation) " is 181.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplierSignificand & lowWordMask)) >> 32); " is 153.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "                this.SignificandBits = ((this.SignificandBits ^ multiplierSignificand) & highestBit) | ((significandBits << 1) & ~highestBit); " is 126.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //because the MSB of both significands is 1' the MSB of the result will also be 1' and the product of low bits on both significands is dropped (and thus we can skip its calculation) " is 181.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.SignificandBits & lowWordMask)) >> 32); " is 158.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "                    this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | ((significandBits << 1) & ~highestBit); " is 131.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "                this.SignificandBits = ((this.SignificandBits ^ multiplier.SignificandBits) & highestBit) | (significandBits & ~highestBit); " is 124.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ////because the MSB of both significands is 1' the MSB of the result will also be 1' and the product of low bits on both significands is dropped (and thus we can skip its calculation) " is 183.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //ulong significandBits = high1 * high2 + (((this.Significand & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.Significand & lowWordMask)) >> 32); " is 152.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            //    this.Significand = (ulong)zeroMask & ((this.Significand ^ multiplier.Significand) & highestBit) | ((significandBits << 1) & ~highestBit); " is 143.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ////this.Significand = (ulong)zeroMask & ((this.Significand ^ multiplier.Significand) & highestBit) | ((significandBits << (int)(1 ^ (significandBits >> 63))) & ~highestBit); " is 174.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The length of the statement  "            ////this.Exponent = (zeroMask & (this.Exponent + multiplier.Exponent - 1 + 64 + (long)(significandBits >> 63))) | (~zeroMask & long.MinValue); " is 142.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "            if ((this.SignificandBits ^ valueSignificand) >= highestBit) //this and value have different signs--use subtraction instead " is 123.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) + ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent)); " is 125.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (valueSignificand | highestBit) + ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent)); " is 125.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent). " is 165.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "            if ((this.SignificandBits ^ value.SignificandBits) >= highestBit) //this and value have different signs--use subtraction instead " is 128.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) + ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent)); " is 131.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                    ulong bits = (value.SignificandBits | highestBit) + ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent)); " is 131.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The length of the statement  "                //the MSB must have the same sign' so the MSB will become 0' and logical overflow is guaranteed in this situation (so we can shift right and increment the exponent). " is 165.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "            if ((this.SignificandBits ^ valueSignificand) >= highestBit) //this and value have different signs--use addition instead             " is 120.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) - ((valueSignificand | highestBit) >> (int)(this.Exponent - valueExponent)); " is 125.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                ulong bits = (valueSignificand | highestBit) - ((this.SignificandBits | highestBit) >> (int)(valueExponent - this.Exponent)); " is 125.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = valueSignificand - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 155.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = this.SignificandBits - valueSignificand; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 155.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "            if ((this.SignificandBits ^ value.SignificandBits) >= highestBit) //this and value have different signs--use addition instead             " is 125.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = (this.SignificandBits | highestBit) - ((value.SignificandBits | highestBit) >> (int)(this.Exponent - value.Exponent)); " is 131.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                ulong bits = (value.SignificandBits | highestBit) - ((this.SignificandBits | highestBit) >> (int)(value.Exponent - this.Exponent)); " is 131.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = value.SignificandBits - this.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 160.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The length of the statement  "                    ulong bits = this.SignificandBits - value.SignificandBits; //notice that we don't worry about de-implicitizing the MSB--it'd be eliminated by subtraction anyway " is 160.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The length of the statement  "                this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ valueSignificand) & highestBit); " is 124.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The length of the statement  "                this.SignificandBits = (~highestBit & (thisAdjSignificand << 1)) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit); " is 131.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The length of the statement  "                this.SignificandBits = (~highestBit & thisAdjSignificand) | ((this.SignificandBits ^ divisor.SignificandBits) & highestBit); " is 124.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Parse,The length of the statement  "            //Smarter way is to break the numeric string into chunks and parse each of them using long's parse method' then combine. " is 120.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                        return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x")); " is 128.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                        return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x")); " is 137.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                            return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1); " is 137.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                    return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString()); " is 130.
Long Statement,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The length of the statement  "                        return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString(); " is 131.
Complex Conditional,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The conditional expression  "length1 < Constants.AutoFhtLengthLowerBound || length2 < Constants.AutoFhtLengthLowerBound ||                      length1 > Constants.AutoFhtLengthUpperBound || length2 > Constants.AutoFhtLengthUpperBound"  is complex.
Magic Number,System,Half,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GetTypeCode,The following statement contains a magic number: return (TypeCode)255;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,ConvertMantissa,The following statement contains a magic number: uint m = (uint)(i << 13);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: uint[] mantissaTable = new uint[2048];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: i < 1024
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: mantissaTable[i] = (uint)(0x38000000 + ((i - 1024) << 13));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateMantissaTable,The following statement contains a magic number: i < 2048
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: uint[] exponentTable = new uint[64];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[i] = (uint)(i << 23);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: i < 31
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[31] = 0x47800000;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[32] = 0x80000000;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[i] = (uint)(0x80000000 + ((i - 32) << 23));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: i < 63
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateExponentTable,The following statement contains a magic number: exponentTable[63] = 0xc7800000;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: ushort[] offsetTable = new ushort[64];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[i] = 1024;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: i < 32
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[32] = 0;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: offsetTable[i] = 1024;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateOffsetTable,The following statement contains a magic number: i < 64
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: ushort[] baseTable = new ushort[512];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: sbyte e = (sbyte)(127 - i);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: e > 24
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateBaseTable,The following statement contains a magic number: i < 256
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: sbyte[] shiftTable = new sbyte[512];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: sbyte e = (sbyte)(127 - i);
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: shiftTable[i | 0x000] = 24;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: shiftTable[i | 0x100] = 24;
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: e > 24
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,GenerateShiftTable,The following statement contains a magic number: i < 256
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,HalfToSingle,The following statement contains a magic number: uint result = mantissaTable[offsetTable[half.value >> 10] + (half.value & 0x3ff)] + exponentTable[half.value >> 10];
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,SingleToHalf,The following statement contains a magic number: ushort result = (ushort)(baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Magic Number,System,HalfHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Half.cs,SingleToHalf,The following statement contains a magic number: ushort result = (ushort)(baseTable[(value >> 23) & 0x1ff] + ((value & 0x007fffff) >> shiftTable[value >> 23]));
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: return (64);
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: n = n + 32;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: x = x << 32;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: n = n + 16;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: x = x << 16;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: n = n + 8;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: x = x << 8;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: n = n + 4;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: x = x << 4;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: n = n + 2;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Quadnlz,The following statement contains a magic number: x = x << 2;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Truncate,The following statement contains a magic number: value.Exponent <= -64
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Log2,The following statement contains a magic number: return Math.Log(value.SignificandBits | QuadhighestBit' 2) + value.Exponent;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Log,The following statement contains a magic number: return Math.Log(value.SignificandBits | QuadhighestBit) + value.Exponent * 0.69314718055994530941723212145818;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The following statement contains a magic number: double resultSignificand = Math.Pow((double)new Quad(value.SignificandBits' -63)' exponent);
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The following statement contains a magic number: double resultExponent = (value.Exponent + 63) * exponent;
Magic Number,System,MathExtensions,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Math.cs,Pow,The following statement contains a magic number: resultSignificand *= Math.Pow(2' resultExponent % 1);
Magic Number,System,IntX,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ToString,The following statement contains a magic number: return ToString(10U' true);
Magic Number,System,IntX,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The following statement contains a magic number: return IntXParser.Parse(value' 10U' Constants.BaseCharToDigits' true);
Magic Number,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,DivMod,The following statement contains a magic number: highestLostBit = quotPtr[shiftOffset - 1] >> 31;
Magic Number,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The following statement contains a magic number: int shift1 = 31 - Bits.Msb(digitsPtr2[length2 - 1]);
Magic Number,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The following statement contains a magic number: uint preLastDigit2 = digitsBufferPtr2[length2 - 2];
Magic Number,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicDivMod,The following statement contains a magic number: divEst == Constants.BitCountStepOf2 || divEst * preLastDigit2 > (modEst << Constants.DigitBitCount) + digitsBufferPtr1[iLen2 - 2]
Magic Number,System,IntXDivider,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,BaseDivMod,The following statement contains a magic number: cmpResult == -2
Magic Number,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Multiply,The following statement contains a magic number: newLength >> 32 != 0
Magic Number,System,IntXMultiplier,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ClassicMultiply,The following statement contains a magic number: c >>= 32;
Magic Number,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The following statement contains a magic number: numberBase < 2 || numberBase > charToDigits.Count
Magic Number,System,IntXParser,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Parse,The following statement contains a magic number: numberBase = 16U;
Magic Number,System,IntXStringConverter,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ToString,The following statement contains a magic number: numberBase < 2 || numberBase > 65536
Magic Number,System,IntXStringConverter,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ToString,The following statement contains a magic number: numberBase < 2 || numberBase > 65536
Magic Number,System,IntXStringConverter,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ToString,The following statement contains a magic number: uint lengthCoef = isBigBase ? (uint)System.Math.Ceiling(System.Math.Log10(numberBase)) + 2U : 1U;
Magic Number,System,IntXStringConverter,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,FastToString,The following statement contains a magic number: *(ptr1 + innerStep) = IntXDivider.DivMod(                                      ptr1'                                      ptr2'                                      ref loLength'                                      baseIntPtr'                                      tempBufferPtr'                                      baseInt._length'                                      ptr2 + innerStep'                                      DivModResultFlags.Div | DivModResultFlags.Mod'                                      -2);
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: return 32;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: n += 16;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: x <<= 16;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: (x >> 16) == 0
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: n += 8;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: x <<= 8;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: (x >> 24) == 0
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: n += 4;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: x <<= 4;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: (x >> 28) == 0
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: n += 2;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: x <<= 2;
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: (x >> 30) == 0
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Nlz,The following statement contains a magic number: return n - (int)(x >> 31);
Magic Number,System,Bits,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Msb,The following statement contains a magic number: return 31 - Nlz(x);
Magic Number,System,Constants,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Constants,The following statement contains a magic number: BaseCharToDigits = StrRepHelper.CharDictionaryFromAlphabet(new string(BaseUpperChars)' 16U);
Magic Number,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: int leftShift = (2 - msb + Constants.DigitBitCount) % Constants.DigitBitCount;
Magic Number,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: msb != 2
Magic Number,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: uint bufferDigitN2 = bufferPtr[length - 2];
Magic Number,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: resultDigits[0] = 32 / bufferDigitN1;
Magic Number,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: bitsAfterDotNextBuffer = (ulong)nextBufferTempShift + 3UL;
Magic Number,System,NewtonHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetIntegerOpposite,The following statement contains a magic number: k < 4
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,The following statement contains a magic number: double normalizeMultiplier = 0.5 / length;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,The following statement contains a magic number: dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5) + carryInt;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ConvertDoubleToDigits,The following statement contains a magic number: dataDigitInt = (long)(dataDigit < 0 ? dataDigit - 0.5 : dataDigit + 0.5) + carryInt;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht,The following statement contains a magic number: length == 4
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht,The following statement contains a magic number: uint lengthDiv4 = length >> 2;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: double d2 = slice[2];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: double d3 = slice[3];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: slice[2] = d02 + d13;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Fht4,The following statement contains a magic number: slice[3] = d02 - d13;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: slice[0] *= 2.0 * slice2[0];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,MultiplyFhtResults,The following statement contains a magic number: slice[1] *= 2.0 * slice2[1];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht,The following statement contains a magic number: length == 8
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht,The following statement contains a magic number: uint lengthDiv4 = length >> 2;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d2 = slice[2];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d3 = slice[3];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d4 = slice[4];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d5 = slice[5];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d6 = slice[6];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: double d7 = slice[7];
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[4] = daa0123 - daa4567;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[2] = dsa0123 + dsa4567;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[6] = dsa0123 - dsa4567;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[5] = das0123 - ds45;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[3] = dss0123 + ds67;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,ReverseFht8,The following statement contains a magic number: slice[7] = dss0123 - ds67;
Magic Number,System,FhtHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,GetInitialTrigValues,The following statement contains a magic number: valuesPtr->TableCos *= -2.0 * valuesPtr->TableCos;
Magic Number,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Add,The following statement contains a magic number: c >>= 32;
Magic Number,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The following statement contains a magic number: c >>= 63;
Magic Number,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Sub,The following statement contains a magic number: c >>= 63;
Magic Number,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,Cmp,The following statement contains a magic number: res != -2
Magic Number,System,DigitOpHelper,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Oyster.IntX.cs,CmpLen,The following statement contains a magic number: return length1 == 0 ? 0 : -2;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: return (64);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: n = n + 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: x = x << 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: n = n + 16;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: x = x << 16;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: n = n + 8;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: x = x << 8;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: n = n + 4;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: x = x << 4;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: n = n + 2;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,nlz,The following statement contains a magic number: x = x << 2;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: long multiplierExponent = (((long)bits >> 52) & 0x7ffL);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: multiplierExponent -= firstSetPosition - 1 + 1075;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high1 = (this.SignificandBits | highestBit) >> 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high2 = (multiplierSignificand | highestBit) >> 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplierSignificand & lowWordMask)) >> 32);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplierSignificand & lowWordMask)) >> 32);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: this.Exponent = this.Exponent + multiplierExponent - 1 + 64;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: significandBits < (1UL << 63)
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high1 = (this.SignificandBits | highestBit) >> 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong high2 = (multiplier.SignificandBits | highestBit) >> 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.SignificandBits & lowWordMask)) >> 32);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: ulong significandBits = high1 * high2 + (((this.SignificandBits & lowWordMask) * high2) >> 32) + ((high1 * (multiplier.SignificandBits & lowWordMask)) >> 32);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Multiply,The following statement contains a magic number: significandBits < (1UL << 63)
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: long valueExponent = (((long)doubleBits >> 52) & 0x7ffL);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: valueExponent -= firstSetPosition - 1 + 1075;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: this.Exponent >= valueExponent + 64
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Add,The following statement contains a magic number: this.Exponent >= value.Exponent + 64
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: long valueExponent = (((long)doubleBits >> 52) & 0x7ffL);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: valueExponent -= firstSetPosition - 1 + 1075;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: this.Exponent >= valueExponent + 64
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Subtract,The following statement contains a magic number: this.Exponent >= value.Exponent + 64
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: long valueExponent = (((long)doubleBits >> 52) & 0x7ffL);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: valueExponent -= firstSetPosition - 1 + 1075;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: un1 = (this.SignificandBits & 1) << 31;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: vn1 = divisorAdjSignificand >> 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: this.Exponent = this.Exponent - (valueExponent + 64) - 1 + adjExponent;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: thisAdjSignificand < (1UL << 63)
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: un1 = (this.SignificandBits & 1) << 31;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: vn1 = divisorAdjSignificand >> 32;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: this.Exponent = this.Exponent - (divisor.Exponent + 64) - 1 + adjExponent;
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Divide,The following statement contains a magic number: thisAdjSignificand < (1UL << 63)
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,Parse,The following statement contains a magic number: result += fractional * (MathExtensions.Pow(new Quad(10L' 0)' -right.Length));
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,ToString,The following statement contains a magic number: switch (format)              {                  case QuadrupleStringFormat.HexExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                      else                          return (SignificandBits | highestBit).ToString("x") + "*2^" + (Exponent >= 0 ? Exponent.ToString("x") : "-" + (-Exponent).ToString("x"));                    case QuadrupleStringFormat.DecimalExponential:                      if (SignificandBits >= highestBit)                          return "-" + SignificandBits.ToString() + "*2^" + Exponent.ToString();                      else                          return (SignificandBits | highestBit).ToString() + "*2^" + Exponent.ToString();                    case QuadrupleStringFormat.ScientificApproximate:                      if (Exponent >= -1022 && Exponent <= 1023) //can be represented as double (albeit with a precision loss)                          return ((double)this).ToString(System.Globalization.CultureInfo.InvariantCulture);                        double dVal = (double)new Quad(SignificandBits' -61);                      double dExp = base2to10Multiplier * (Exponent + 61);                        string sign = "";                      if (dVal < 0)                      {                          sign = "-";                          dVal = -dVal;                      }                        if (dExp >= 0)                          dVal *= Math.Pow(10' (dExp % 1));                      else                          dVal *= Math.Pow(10' -((-dExp) % 1));                        long iExp = (long)Math.Truncate(dExp);                        while (dVal >= 10) { iExp++; dVal /= 10; }                      while (dVal < 1) { iExp--; dVal *= 10; }                        if (iExp >= -10 && iExp < 0)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formatting; use default behavior.                          else                              return sign + "0." + new string('0'' (int)((-iExp) - 1)) + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture).Remove(1' 1);                      }                      else if (iExp >= 0 && iExp <= 10)                      {                          string dValString = dVal.ToString(System.Globalization.CultureInfo.InvariantCulture);                          if (dValString[1] != '.')                              goto returnScientific; //unexpected formating; use default behavior.                          else                          {                              dValString = dValString.Remove(1' 1);                              if (iExp < dValString.Length - 1)                                  return sign + dValString.Substring(0' 1 + (int)iExp) + "." + dValString.Substring(1 + (int)iExp);                              else                                  return sign + dValString + new string('0'' (int)iExp - (dValString.Length - 1)) + ".0";                          }                      }                    returnScientific:                      return sign + dVal.ToString(System.Globalization.CultureInfo.InvariantCulture) + "E" + (iExp >= 0 ? "+" + iExp : iExp.ToString());                    case QuadrupleStringFormat.ScientificExact:                      if (this == Zero) return "0";                      if (MathExtensions.Fraction(this) == Zero && this.Exponent <= 0) //integer value that we can output directly                          return (this.SignificandBits >= highestBit ? "-" : "") + ((this.SignificandBits | highestBit) >> (int)(-this.Exponent)).ToString();                        Quad absValue = MathExtensions.Abs(this);                        long e = 0;                      if (absValue < One)                      {                          while (true)                          {                              if (absValue < en18)                              {                                  absValue.Multiply(e19);                                  e -= 19;                              }                              else if (absValue < en9)                              {                                  absValue.Multiply(e10);                                  e -= 10;                              }                              else if (absValue < en4)                              {                                  absValue.Multiply(e5);                                  e -= 5;                              }                              else if (absValue < en2)                              {                                  absValue.Multiply(e3);                                  e -= 3;                              }                              else if (absValue < One)                              {                                  absValue.Multiply(e1);                                  e -= 1;                              }                              else                                  break;                          }                      }                      else                      {                          while (true)                          {                              if (absValue >= e19)                              {                                  absValue.Divide(e19);                                  e += 19;                              }                              else if (absValue >= e10)                              {                                  absValue.Divide(e10);                                  e += 10;                              }                              else if (absValue >= e5)                              {                                  absValue.Divide(e5);                                  e += 5;                              }                              else if (absValue >= e3)                              {                                  absValue.Divide(e3);                                  e += 3;                              }                              else if (absValue >= e1)                              {                                  absValue.Divide(e1);                                  e += 1;                              }                              else                                  break;                          }                      }                        //absValue is now in the interval [1'10)                      StringBuilder result = new StringBuilder();                        result.Append(IntegerString(absValue'1) + ".");                        while ((absValue = MathExtensions.Fraction(absValue)) > Zero)                      {                          absValue.Multiply(e19);                          result.Append(IntegerString(absValue' 19));                      }                        string resultString = result.ToString().TrimEnd('0'); //trim excess 0's at the end                      if (resultString[resultString.Length - 1] == '.') resultString += "0"; //e.g. 1.0 instead of 1.                        return (this.SignificandBits >= highestBit ? "-" : "") + resultString + "e" + (e >= 0 ? "+" : "") + e;                    default:                      throw new ArgumentException("Unknown format requested");              }
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,IntegerString,The following statement contains a magic number: quad.Exponent <= -64
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,GetHashCode,The following statement contains a magic number: return SignificandBits.GetHashCode() ^ (expHash << 16 | expHash >> 16);
Magic Number,System,Quad,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Quad.cs,GetHashCode,The following statement contains a magic number: return SignificandBits.GetHashCode() ^ (expHash << 16 | expHash >> 16);
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + low.GetHashCode();
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,GetHashCode,The following statement contains a magic number: hash = hash * 23 + high.GetHashCode();
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: uint left3 = (uint)(left.high >> 32);
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: uint left1 = (uint)(left.low >> 32);
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: ulong right3 = (uint)(right.high >> 32);
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: ulong right1 = (uint)(right.low >> 32);
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value10 = (Int128)(left1 * right0) << 32;
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value30 = new Int128(0' (long)((left3 * right0) << 32));
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value01 = (Int128)(left0 * right1) << 32;
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value21 = new Int128(0' (long)((left2 * right1) << 32));
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value12 = new Int128(0' (long)((left1 * right2) << 32));
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,Multiply,The following statement contains a magic number: Int128 value03 = new Int128(0' (long)((left0 * right3) << 32));
Magic Number,SharpAssembler.Core,Int128,D:\research\architectureSmells\repos\CosmosOS_Cosmos\Users\Orvid\Orvid.Extensions\System\Int128.cs,UnsignedDivRem,The following statement contains a magic number: i < 128
