Implementation smell,Namespace,Class,File,Method,Description
Long Method,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Code,The method has 114 lines of code.
Long Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The method has 449 lines of code.
Long Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CodeOneBlock,The method has 156 lines of code.
Long Method,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The method has 122 lines of code.
Long Method,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The method has 162 lines of code.
Long Method,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The method has 154 lines of code.
Long Method,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The method has 173 lines of code.
Complex Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 14
Complex Method,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,Cyclomatic complexity of the method is 21
Long Parameter List,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,Orvid.Compression,RangeBitTreeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Parameter List,Orvid.Compression,ICoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Identifier,Orvid.Compression,LZMABase,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The length of the statement  "                            UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 130.
Long Statement,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The length of the statement  "                                    UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 130.
Long Statement,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,FillDistancesPrices,The length of the statement  "                    _posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - LZMABase.kNumAlignBits) << RangeBitEncoder.kNumBitPriceShiftBits); " is 123.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The length of the statement  "                    if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes) " is 201.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,button1_Click,The length of the statement  "            //Orvid.Graphics.Image i = opfFont.GetCharacter(Int32.Parse(textBox2.Text)' Orvid.Graphics.FontSupport.FontStyle.Normal); " is 121.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,CompressionComboBox_SelectedIndexChanged,The length of the statement  "            CompressionMode = (CompressionType)Enum.Parse(typeof(CompressionType)' (String)CompressionComboBox.Items[CompressionComboBox.SelectedIndex]); " is 141.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The length of the statement  "                    i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic); " is 156.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The length of the statement  "                        i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear); " is 157.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The length of the statement  "                        i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor); " is 164.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The length of the statement  "            this.ConvertButton.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.5F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 162.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The length of the statement  "            this.CompressionComboBox.SelectedIndexChanged += new System.EventHandler(this.CompressionComboBox_SelectedIndexChanged); " is 120.
Long Statement,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The length of the statement  "            this.pictureBox2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  outStream.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Compress,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  outStream.WriteByte((Byte)(fileSize >> (8 * i)));
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decompress,The following statement contains a magic number: byte[] properties2 = new byte[5];
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decompress,The following statement contains a magic number: if (newInStream.Read(properties2' 0' 5) != 5)                  throw (new Exception("input .lzma is too short"));
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decompress,The following statement contains a magic number: if (newInStream.Read(properties2' 0' 5) != 5)                  throw (new Exception("input .lzma is too short"));
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int v = newInStream.ReadByte();                  if (v < 0)                      throw (new Exception("Can't Read 1"));                  outSize |= ((long)(byte)v) << (8 * i);              }
Magic Number,Orvid.Compression,LZMACoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decompress,The following statement contains a magic number: for (int i = 0; i < 8; i++)              {                  int v = newInStream.ReadByte();                  if (v < 0)                      throw (new Exception("Can't Read 1"));                  outSize |= ((long)(byte)v) << (8 * i);              }
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;                  else if (Index < 10) Index -= 3;                  else Index -= 6;
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,Orvid.Compression,State,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)              {                  m_DictionarySize = dictionarySize;                  m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);                  uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));                  m_OutWindow.Create(blockSize);              }
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)                  throw new Exception();
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)                  throw new Exception();
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)              {                  // UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);                  // while(nowPos64 < next)                  {                      uint posState = (uint)nowPos64 & m_PosStateMask;                      if (m_IsMatchDecoders[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                      {                          byte b;                          byte prevByte = m_OutWindow.GetByte(0);                          if (!state.IsCharState())                              b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'                                  (uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));                          else                              b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);                          m_OutWindow.PutByte(b);                          state.UpdateChar();                          nowPos64++;                      }                      else                      {                          uint len;                          if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)                          {                              if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)                              {                                  if (m_IsRep0LongDecoders[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)                                  {                                      state.UpdateShortRep();                                      m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));                                      nowPos64++;                                      continue;                                  }                              }                              else                              {                                  UInt32 distance;                                  if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                  {                                      distance = rep1;                                  }                                  else                                  {                                      if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)                                          distance = rep2;                                      else                                      {                                          distance = rep3;                                          rep3 = rep2;                                      }                                      rep2 = rep1;                                  }                                  rep1 = rep0;                                  rep0 = distance;                              }                              len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + LZMABase.kMatchMinLen;                              state.UpdateRep();                          }                          else                          {                              rep3 = rep2;                              rep2 = rep1;                              rep1 = rep0;                              len = LZMABase.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);                              state.UpdateMatch();                              uint posSlot = m_PosSlotDecoder[LZMABase.GetLenToPosState(len)].Decode(m_RangeDecoder);                              if (posSlot >= LZMABase.kStartPosModelIndex)                              {                                  int numDirectBits = (int)((posSlot >> 1) - 1);                                  rep0 = ((2 | (posSlot & 1)) << numDirectBits);                                  if (posSlot < LZMABase.kEndPosModelIndex)                                      rep0 += RangeBitTreeDecoder.ReverseDecode(m_PosDecoders'                                              rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);                                  else                                  {                                      rep0 += (m_RangeDecoder.DecodeDirectBits(                                          numDirectBits - LZMABase.kNumAlignBits) << LZMABase.kNumAlignBits);                                      rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);                                  }                              }                              else                                  rep0 = posSlot;                          }                          if (rep0 >= nowPos64 || rep0 >= m_DictionarySizeCheck)                          {                              if (rep0 == 0xFFFFFFFF)                                  break;                              throw new Exception();                          }                          m_OutWindow.CopyBlock(rep0' len);                          nowPos64 += len;                      }                  }              }
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)                  throw new Exception();
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Orvid.Compression,LZMADecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,Orvid.Compression,LiteralDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,Orvid.Compression,Decoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do                      {                          uint matchBit = (uint)(matchByte >> 7) & 1;                          matchByte <<= 1;                          uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                          symbol = (symbol << 1) | bit;                          if (matchBit != bit)                          {                              while (symbol < 0x100)                                  symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                              break;                          }                      }                      while (symbol < 0x100);
Magic Number,Orvid.Compression,Decoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do                      {                          uint matchBit = (uint)(matchByte >> 7) & 1;                          matchByte <<= 1;                          uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);                          symbol = (symbol << 1) | bit;                          if (matchBit != bit)                          {                              while (symbol < 0x100)                                  symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);                              break;                          }                      }                      while (symbol < 0x100);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,LZMAEncoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,LZMAEncoder,The following statement contains a magic number: int c = 2;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,LZMAEncoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)              {                  UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));                  for (UInt32 j = 0; j < k; j++' c++)                      g_FastPos[c] = slotFast;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))                  return g_FastPos[pos];
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                  return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                  return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))                  return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                  return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                  return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))                  return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                  return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                  return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))                  return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)              {                  LZBinTree bt = new LZBinTree();                  int numHashBytes = 4;                  if (_matchFinderType == EMatchFinderType.BT2)                      numHashBytes = 2;                  bt.SetType(numHashBytes);                  _matchFinder = bt;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)              {                  LZBinTree bt = new LZBinTree();                  int numHashBytes = 4;                  if (_matchFinderType == EMatchFinderType.BT2)                      numHashBytes = 2;                  bt.SetType(numHashBytes);                  _matchFinder = bt;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)              {                  lenRes = _matchDistances[numDistancePairs - 2];                  if (lenRes == _numFastBytes)                      lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'                          LZMABase.kMatchMaxLen - lenRes);              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)              {                  price = _isRepG0[state.Index].GetPrice0();                  price += _isRep0Long[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();              }              else              {                  price = _isRepG0[state.Index].GetPrice1();                  if (repIndex == 1)                      price += _isRepG1[state.Index].GetPrice0();                  else                  {                      price += _isRepG1[state.Index].GetPrice1();                      price += _isRepG2[state.Index].GetPrice(repIndex - 2);                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)              {                  backRes = 0xFFFFFFFF;                  return 1;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)              {                  backRes = (UInt32)0xFFFFFFFF;                  return 1;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)              {                  backRes = (UInt32)0xFFFFFFFF;                  return 1;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: if (lenEnd < 2)              {                  backRes = _optimum[1].BackPrev;                  return 1;              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: do                  _optimum[len--].Price = kIfinityPrice;              while (len >= 2);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < LZMABase.kNumRepDistances; i++)              {                  UInt32 repLen = repLens[i];                  if (repLen < 2)                      continue;                  UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                  do                  {                      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                      Optimal optimum = _optimum[repLen];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = i;                          optimum.Prev1IsChar = false;                      }                  }                  while (--repLen >= 2);              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < LZMABase.kNumRepDistances; i++)              {                  UInt32 repLen = repLens[i];                  if (repLen < 2)                      continue;                  UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                  do                  {                      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                      Optimal optimum = _optimum[repLen];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = i;                          optimum.Prev1IsChar = false;                      }                  }                  while (--repLen >= 2);              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < LZMABase.kNumRepDistances; i++)              {                  UInt32 repLen = repLens[i];                  if (repLen < 2)                      continue;                  UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);                  do                  {                      UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);                      Optimal optimum = _optimum[repLen];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = i;                          optimum.Prev1IsChar = false;                      }                  }                  while (--repLen >= 2);              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)              {                  UInt32 offs = 0;                  while (len > _matchDistances[offs])                      offs += 2;                  for (; ; len++)                  {                      UInt32 distance = _matchDistances[offs + 1];                      UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                      Optimal optimum = _optimum[len];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = distance + LZMABase.kNumRepDistances;                          optimum.Prev1IsChar = false;                      }                      if (len == _matchDistances[offs])                      {                          offs += 2;                          if (offs == numDistancePairs)                              break;                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)              {                  UInt32 offs = 0;                  while (len > _matchDistances[offs])                      offs += 2;                  for (; ; len++)                  {                      UInt32 distance = _matchDistances[offs + 1];                      UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);                      Optimal optimum = _optimum[len];                      if (curAndLenPrice < optimum.Price)                      {                          optimum.Price = curAndLenPrice;                          optimum.PosPrev = 0;                          optimum.BackPrev = distance + LZMABase.kNumRepDistances;                          optimum.Prev1IsChar = false;                      }                      if (len == _matchDistances[offs])                      {                          offs += 2;                          if (offs == numDistancePairs)                              break;                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetOptimum,The following statement contains a magic number: while (true)              {                  cur++;                  if (cur == lenEnd)                      return Backward(out backRes' cur);                  UInt32 newLen;                  ReadMatchDistances(out newLen' out numDistancePairs);                  if (newLen >= _numFastBytes)                  {                      _numDistancePairs = numDistancePairs;                      _longestMatchLength = newLen;                      _longestMatchWasFound = true;                      return Backward(out backRes' cur);                  }                  position++;                  UInt32 posPrev = _optimum[cur].PosPrev;                  LZMABase.State state;                  if (_optimum[cur].Prev1IsChar)                  {                      posPrev--;                      if (_optimum[cur].Prev2)                      {                          state = _optimum[_optimum[cur].PosPrev2].State;                          if (_optimum[cur].BackPrev2 < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      else                          state = _optimum[posPrev].State;                      state.UpdateChar();                  }                  else                      state = _optimum[posPrev].State;                  if (posPrev == cur - 1)                  {                      if (_optimum[cur].IsShortRep())                          state.UpdateShortRep();                      else                          state.UpdateChar();                  }                  else                  {                      UInt32 pos;                      if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)                      {                          posPrev = _optimum[cur].PosPrev2;                          pos = _optimum[cur].BackPrev2;                          state.UpdateRep();                      }                      else                      {                          pos = _optimum[cur].BackPrev;                          if (pos < LZMABase.kNumRepDistances)                              state.UpdateRep();                          else                              state.UpdateMatch();                      }                      Optimal opt = _optimum[posPrev];                      if (pos < LZMABase.kNumRepDistances)                      {                          if (pos == 0)                          {                              reps[0] = opt.Backs0;                              reps[1] = opt.Backs1;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 1)                          {                              reps[0] = opt.Backs1;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs2;                              reps[3] = opt.Backs3;                          }                          else if (pos == 2)                          {                              reps[0] = opt.Backs2;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs3;                          }                          else                          {                              reps[0] = opt.Backs3;                              reps[1] = opt.Backs0;                              reps[2] = opt.Backs1;                              reps[3] = opt.Backs2;                          }                      }                      else                      {                          reps[0] = (pos - LZMABase.kNumRepDistances);                          reps[1] = opt.Backs0;                          reps[2] = opt.Backs1;                          reps[3] = opt.Backs2;                      }                  }                  _optimum[cur].State = state;                  _optimum[cur].Backs0 = reps[0];                  _optimum[cur].Backs1 = reps[1];                  _optimum[cur].Backs2 = reps[2];                  _optimum[cur].Backs3 = reps[3];                  UInt32 curPrice = _optimum[cur].Price;                    currentByte = _matchFinder.GetIndexByte(0 - 1);                  matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));                    posState = (position & _posStateMask);                    UInt32 curAnd1Price = curPrice +                      _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice0() +                      _literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).                      GetPrice(!state.IsCharState()' matchByte' currentByte);                    Optimal nextOptimum = _optimum[cur + 1];                    bool nextIsChar = false;                  if (curAnd1Price < nextOptimum.Price)                  {                      nextOptimum.Price = curAnd1Price;                      nextOptimum.PosPrev = cur;                      nextOptimum.MakeAsChar();                      nextIsChar = true;                  }                    matchPrice = curPrice + _isMatch[(state.Index << LZMABase.kNumPosStatesBitsMax) + posState].GetPrice1();                  repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();                    if (matchByte == currentByte &&                      !(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))                  {                      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);                      if (shortRepPrice <= nextOptimum.Price)                      {                          nextOptimum.Price = shortRepPrice;                          nextOptimum.PosPrev = cur;                          nextOptimum.MakeAsShortRep();                          nextIsChar = true;                      }                  }                    UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;                  numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);                  numAvailableBytes = numAvailableBytesFull;                    if (numAvailableBytes < 2)                      continue;                  if (numAvailableBytes > _numFastBytes)                      numAvailableBytes = _numFastBytes;                  if (!nextIsChar && matchByte != currentByte)                  {                      // try Literal + rep0                      UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);                      UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);                      if (lenTest2 >= 2)                      {                          LZMABase.State state2 = state;                          state2.UpdateChar();                          UInt32 posStateNext = (position + 1) & _posStateMask;                          UInt32 nextRepMatchPrice = curAnd1Price +                              _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +                              _isRep[state2.Index].GetPrice1();                          {                              UInt32 offset = cur + 1 + lenTest2;                              while (lenEnd < offset)                                  _optimum[++lenEnd].Price = kIfinityPrice;                              UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(                                  0' lenTest2' state2' posStateNext);                              Optimal optimum = _optimum[offset];                              if (curAndLenPrice < optimum.Price)                              {                                  optimum.Price = curAndLenPrice;                                  optimum.PosPrev = cur + 1;                                  optimum.BackPrev = 0;                                  optimum.Prev1IsChar = true;                                  optimum.Prev2 = false;                              }                          }                      }                  }                    UInt32 startLen = 2; // speed optimization                     for (UInt32 repIndex = 0; repIndex < LZMABase.kNumRepDistances; repIndex++)                  {                      UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);                      if (lenTest < 2)                          continue;                      UInt32 lenTestTemp = lenTest;                      do                      {                          while (lenEnd < cur + lenTest)                              _optimum[++lenEnd].Price = kIfinityPrice;                          UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = repIndex;                              optimum.Prev1IsChar = false;                          }                      }                      while (--lenTest >= 2);                      lenTest = lenTestTemp;                        if (repIndex == 0)                          startLen = lenTest + 1;                        // if (_maxMode)                      if (lenTest < numAvailableBytesFull)                      {                          UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                          UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);                          if (lenTest2 >= 2)                          {                              LZMABase.State state2 = state;                              state2.UpdateRep();                              UInt32 posStateNext = (position + lenTest) & _posStateMask;                              UInt32 curAndLenCharPrice =                                      repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +                                      _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                      _literalEncoder.GetSubCoder(position + lenTest'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'                                      _matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'                                      _matchFinder.GetIndexByte((Int32)lenTest - 1));                              state2.UpdateChar();                              posStateNext = (position + lenTest + 1) & _posStateMask;                              UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                              UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                // for(; lenTest2 >= 2; lenTest2--)                              {                                  UInt32 offset = lenTest + 1 + lenTest2;                                  while (lenEnd < cur + offset)                                      _optimum[++lenEnd].Price = kIfinityPrice;                                  UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                  Optimal optimum = _optimum[cur + offset];                                  if (curAndLenPrice < optimum.Price)                                  {                                      optimum.Price = curAndLenPrice;                                      optimum.PosPrev = cur + lenTest + 1;                                      optimum.BackPrev = 0;                                      optimum.Prev1IsChar = true;                                      optimum.Prev2 = true;                                      optimum.PosPrev2 = cur;                                      optimum.BackPrev2 = repIndex;                                  }                              }                          }                      }                  }                    if (newLen > numAvailableBytes)                  {                      newLen = numAvailableBytes;                      for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;                      _matchDistances[numDistancePairs] = newLen;                      numDistancePairs += 2;                  }                  if (newLen >= startLen)                  {                      normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();                      while (lenEnd < cur + newLen)                          _optimum[++lenEnd].Price = kIfinityPrice;                        UInt32 offs = 0;                      while (startLen > _matchDistances[offs])                          offs += 2;                        for (UInt32 lenTest = startLen; ; lenTest++)                      {                          UInt32 curBack = _matchDistances[offs + 1];                          UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);                          Optimal optimum = _optimum[cur + lenTest];                          if (curAndLenPrice < optimum.Price)                          {                              optimum.Price = curAndLenPrice;                              optimum.PosPrev = cur;                              optimum.BackPrev = curBack + LZMABase.kNumRepDistances;                              optimum.Prev1IsChar = false;                          }                            if (lenTest == _matchDistances[offs])                          {                              if (lenTest < numAvailableBytesFull)                              {                                  UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);                                  UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);                                  if (lenTest2 >= 2)                                  {                                      LZMABase.State state2 = state;                                      state2.UpdateMatch();                                      UInt32 posStateNext = (position + lenTest) & _posStateMask;                                      UInt32 curAndLenCharPrice = curAndLenPrice +                                          _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +                                          _literalEncoder.GetSubCoder(position + lenTest'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).                                          GetPrice(true'                                          _matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'                                          _matchFinder.GetIndexByte((Int32)lenTest - 1));                                      state2.UpdateChar();                                      posStateNext = (position + lenTest + 1) & _posStateMask;                                      UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << LZMABase.kNumPosStatesBitsMax) + posStateNext].GetPrice1();                                      UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();                                        UInt32 offset = lenTest + 1 + lenTest2;                                      while (lenEnd < cur + offset)                                          _optimum[++lenEnd].Price = kIfinityPrice;                                      curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);                                      optimum = _optimum[cur + offset];                                      if (curAndLenPrice < optimum.Price)                                      {                                          optimum.Price = curAndLenPrice;                                          optimum.PosPrev = cur + lenTest + 1;                                          optimum.BackPrev = 0;                                          optimum.Prev1IsChar = true;                                          optimum.Prev2 = true;                                          optimum.PosPrev2 = cur;                                          optimum.BackPrev2 = curBack + LZMABase.kNumRepDistances;                                      }                                  }                              }                              offs += 2;                              if (offs == numDistancePairs)                                  break;                          }                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < LZMABase.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                          pos -= LZMABase.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= LZMABase.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < LZMABase.kEndPosModelIndex)                                  RangeBitTreeEncoder.ReverseEncode(_posEncoders'  baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= LZMABase.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < LZMABase.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                          pos -= LZMABase.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= LZMABase.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < LZMABase.kEndPosModelIndex)                                  RangeBitTreeEncoder.ReverseEncode(_posEncoders'  baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= LZMABase.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < LZMABase.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                          pos -= LZMABase.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= LZMABase.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < LZMABase.kEndPosModelIndex)                                  RangeBitTreeEncoder.ReverseEncode(_posEncoders'  baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= LZMABase.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)              {                  UInt32 pos;                  UInt32 len = GetOptimum((UInt32)nowPos64' out pos);                    UInt32 posState = ((UInt32)nowPos64) & _posStateMask;                  UInt32 complexState = (_state.Index << LZMABase.kNumPosStatesBitsMax) + posState;                  if (len == 1 && pos == 0xFFFFFFFF)                  {                      _isMatch[complexState].Encode(_rangeEncoder' 0);                      Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));                      LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);                      if (!_state.IsCharState())                      {                          Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));                          subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);                      }                      else                          subCoder.Encode(_rangeEncoder' curByte);                      _previousByte = curByte;                      _state.UpdateChar();                  }                  else                  {                      _isMatch[complexState].Encode(_rangeEncoder' 1);                      if (pos < LZMABase.kNumRepDistances)                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 1);                          if (pos == 0)                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 0);                              if (len == 1)                                  _isRep0Long[complexState].Encode(_rangeEncoder' 0);                              else                                  _isRep0Long[complexState].Encode(_rangeEncoder' 1);                          }                          else                          {                              _isRepG0[_state.Index].Encode(_rangeEncoder' 1);                              if (pos == 1)                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 0);                              else                              {                                  _isRepG1[_state.Index].Encode(_rangeEncoder' 1);                                  _isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);                              }                          }                          if (len == 1)                              _state.UpdateShortRep();                          else                          {                              _repMatchLenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                              _state.UpdateRep();                          }                          UInt32 distance = _repDistances[pos];                          if (pos != 0)                          {                              for (UInt32 i = pos; i >= 1; i--)                                  _repDistances[i] = _repDistances[i - 1];                              _repDistances[0] = distance;                          }                      }                      else                      {                          _isRep[_state.Index].Encode(_rangeEncoder' 0);                          _state.UpdateMatch();                          _lenEncoder.Encode(_rangeEncoder' len - LZMABase.kMatchMinLen' posState);                          pos -= LZMABase.kNumRepDistances;                          UInt32 posSlot = GetPosSlot(pos);                          UInt32 lenToPosState = LZMABase.GetLenToPosState(len);                          _posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);                            if (posSlot >= LZMABase.kStartPosModelIndex)                          {                              int footerBits = (int)((posSlot >> 1) - 1);                              UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                              UInt32 posReduced = pos - baseVal;                                if (posSlot < LZMABase.kEndPosModelIndex)                                  RangeBitTreeEncoder.ReverseEncode(_posEncoders'  baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);                              else                              {                                  _rangeEncoder.EncodeDirectBits(posReduced >> LZMABase.kNumAlignBits' footerBits - LZMABase.kNumAlignBits);                                  _posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & LZMABase.kAlignMask);                                  _alignPriceCount++;                              }                          }                          UInt32 distance = pos;                          for (UInt32 i = LZMABase.kNumRepDistances - 1; i >= 1; i--)                              _repDistances[i] = _repDistances[i - 1];                          _repDistances[0] = distance;                          _matchPriceCount++;                      }                      _previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));                  }                  _additionalOffset -= len;                  nowPos64 += len;                  if (_additionalOffset == 0)                  {                      // if (!_fastMode)                      if (_matchPriceCount >= (1 << 7))                          FillDistancesPrices();                      if (_alignPriceCount >= LZMABase.kAlignTableSize)                          FillAlignPrices();                      inSize = nowPos64;                      outSize = _rangeEncoder.GetProcessedSizeAdd();                      if (_matchFinder.GetNumAvailableBytes() == 0)                      {                          Flush((UInt32)nowPos64);                          return;                      }                        if (nowPos64 - progressPosValuePrev >= (1 << 12))                      {                          _finished = false;                          finished = false;                          return;                      }                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  properties[1 + i] = (Byte)(_dictionarySize >> (8 * i));
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)                  properties[1 + i] = (Byte)(_dictionarySize >> (8 * i));
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = LZMABase.kStartPosModelIndex; i < LZMABase.kNumFullDistances; i++)              {                  UInt32 posSlot = GetPosSlot(i);                  int footerBits = (int)((posSlot >> 1) - 1);                  UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);                  tempPrices[i] = RangeBitTreeEncoder.ReverseGetPrice(_posEncoders' baseVal - posSlot - 1' footerBits' i - baseVal);              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)              {                  object prop = properties[i];                  switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                  throw new Exception();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new Exception();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new Exception();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new Exception(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new Exception();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                  throw new Exception();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                  throw new Exception();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                  throw new Exception(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new Exception();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new Exception();                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)              {                  object prop = properties[i];                  switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                  throw new Exception();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new Exception();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new Exception();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new Exception(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new Exception();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                  throw new Exception();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                  throw new Exception();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                  throw new Exception(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new Exception();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new Exception();                  }              }
Magic Number,Orvid.Compression,LZMAEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)              {                  object prop = properties[i];                  switch (propIDs[i])                  {                      case CoderPropID.NumFastBytes:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 numFastBytes = (Int32)prop;                              if (numFastBytes < 5 || numFastBytes > LZMABase.kMatchMaxLen)                                  throw new Exception();                              _numFastBytes = (UInt32)numFastBytes;                              break;                          }                      case CoderPropID.Algorithm:                          {                              break;                          }                      case CoderPropID.MatchFinder:                          {                              if (!(prop is String))                                  throw new Exception();                              EMatchFinderType matchFinderIndexPrev = _matchFinderType;                              int m = FindMatchFinder(((string)prop).ToUpper());                              if (m < 0)                                  throw new Exception();                              _matchFinderType = (EMatchFinderType)m;                              if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)                              {                                  _dictionarySizePrev = 0xFFFFFFFF;                                  _matchFinder = null;                              }                              break;                          }                      case CoderPropID.DictionarySize:                          {                              const int kDicLogSizeMaxCompress = 30;                              if (!(prop is Int32))                                  throw new Exception(); ;                              Int32 dictionarySize = (Int32)prop;                              if (dictionarySize < (UInt32)(1 << LZMABase.kDicLogSizeMin) ||                                  dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))                                  throw new Exception();                              _dictionarySize = (UInt32)dictionarySize;                              int dicLogSize;                              for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)                                  if (dictionarySize <= ((UInt32)(1) << dicLogSize))                                      break;                              _distTableSize = (UInt32)dicLogSize * 2;                              break;                          }                      case CoderPropID.PosStateBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumPosStatesBitsEncodingMax)                                  throw new Exception();                              _posStateBits = (int)v;                              _posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;                              break;                          }                      case CoderPropID.LitPosBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumLitPosStatesBitsEncodingMax)                                  throw new Exception();                              _numLiteralPosStateBits = (int)v;                              break;                          }                      case CoderPropID.LitContextBits:                          {                              if (!(prop is Int32))                                  throw new Exception();                              Int32 v = (Int32)prop;                              if (v < 0 || v > (UInt32)LZMABase.kNumLitContextBitsMax)                                  throw new Exception(); ;                              _numLiteralContextBits = (int)v;                              break;                          }                      case CoderPropID.EndMarker:                          {                              if (!(prop is Boolean))                                  throw new Exception();                              SetWriteEndMarkerMode((Boolean)prop);                              break;                          }                      default:                          throw new Exception();                  }              }
Magic Number,Orvid.Compression,LiteralEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                      {                          uint bit = (uint)((symbol >> i) & 1);                          m_Encoders[context].Encode(rangeEncoder' bit);                          context = (context << 1) | bit;                      }
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                      {                          uint bit = (uint)((symbol >> i) & 1);                          uint state = context;                          if (same)                          {                              uint matchBit = (uint)((matchByte >> i) & 1);                              state += ((1 + matchBit) << 8);                              same = (matchBit == bit);                          }                          m_Encoders[state].Encode(rangeEncoder' bit);                          context = (context << 1) | bit;                      }
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)                      {                          uint bit = (uint)((symbol >> i) & 1);                          uint state = context;                          if (same)                          {                              uint matchBit = (uint)((matchByte >> i) & 1);                              state += ((1 + matchBit) << 8);                              same = (matchBit == bit);                          }                          m_Encoders[state].Encode(rangeEncoder' bit);                          context = (context << 1) | bit;                      }
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,Orvid.Compression,Encoder2,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)                      {                          for (; i >= 0; i--)                          {                              uint matchBit = (uint)(matchByte >> i) & 1;                              uint bit = (uint)(symbol >> i) & 1;                              price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);                              context = (context << 1) | bit;                              if (matchBit != bit)                              {                                  i--;                                  break;                              }                          }                      }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)              {                  kNumHashDirectBytes = 0;                  kMinMatchCheck = 4;                  kFixHashSize = kHash2Size + kHash3Size;              }              else              {                  kNumHashDirectBytes = 2;                  kMinMatchCheck = 2 + 1;                  kFixHashSize = 0;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)              {                  kNumHashDirectBytes = 0;                  kMinMatchCheck = 4;                  kFixHashSize = kHash2Size + kHash3Size;              }              else              {                  kNumHashDirectBytes = 2;                  kMinMatchCheck = 2 + 1;                  kFixHashSize = 0;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)              {                  kNumHashDirectBytes = 0;                  kMinMatchCheck = 4;                  kFixHashSize = kHash2Size + kHash3Size;              }              else              {                  kNumHashDirectBytes = 2;                  kMinMatchCheck = 2 + 1;                  kFixHashSize = 0;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)                  throw new Exception();
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +                      matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)                  _son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)              {                  hs = historySize - 1;                  hs |= (hs >> 1);                  hs |= (hs >> 2);                  hs |= (hs >> 4);                  hs |= (hs >> 8);                  hs >>= 1;                  hs |= 0xFFFF;                  if (hs > (1 << 24))                      hs >>= 1;                  _hashMask = hs;                  hs++;                  hs += kFixHashSize;              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                  hash2Value = temp & (kHash2Size - 1);                  temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                  hash3Value = temp & (kHash3Size - 1);                  hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;              }              else                  hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)              {                  UInt32 curMatch2 = _hash[hash2Value];                  UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];                  _hash[hash2Value] = _pos;                  _hash[kHash3Offset + hash3Value] = _pos;                  if (curMatch2 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])                      {                          distances[offset++] = maxLen = 2;                          distances[offset++] = _pos - curMatch2 - 1;                      }                  if (curMatch3 > matchMinPos)                      if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])                      {                          if (curMatch3 == curMatch2)                              offset -= 2;                          distances[offset++] = maxLen = 3;                          distances[offset++] = _pos - curMatch3 - 1;                          curMatch2 = curMatch3;                      }                  if (offset != 0 && curMatch2 == curMatch)                  {                      offset -= 2;                      maxLen = kStartMaxLen;                  }              }
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Skip,The following statement contains a magic number: do              {                  UInt32 lenLimit;                  if (_pos + _matchMaxLen <= _streamPos)                      lenLimit = _matchMaxLen;                  else                  {                      lenLimit = _streamPos - _pos;                      if (lenLimit < kMinMatchCheck)                      {                          MovePos();                          continue;                      }                  }                    UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;                  UInt32 cur = _bufferOffset + _pos;                    UInt32 hashValue;                    if (HASH_ARRAY)                  {                      UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];                      UInt32 hash2Value = temp & (kHash2Size - 1);                      _hash[hash2Value] = _pos;                      temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);                      UInt32 hash3Value = temp & (kHash3Size - 1);                      _hash[kHash3Offset + hash3Value] = _pos;                      hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;                  }                  else                      hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);                    UInt32 curMatch = _hash[kFixHashSize + hashValue];                  _hash[kFixHashSize + hashValue] = _pos;                    UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;                  UInt32 ptr1 = (_cyclicBufferPos << 1);                    UInt32 len0' len1;                  len0 = len1 = kNumHashDirectBytes;                    UInt32 count = _cutValue;                  while (true)                  {                      if (curMatch <= matchMinPos || count-- == 0)                      {                          _son[ptr0] = _son[ptr1] = kEmptyHashValue;                          break;                      }                        UInt32 delta = _pos - curMatch;                      UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?                                  (_cyclicBufferPos - delta) :                                  (_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;                        UInt32 pby1 = _bufferOffset + curMatch;                      UInt32 len = Math.Min(len0' len1);                      if (_bufferBase[pby1 + len] == _bufferBase[cur + len])                      {                          while (++len != lenLimit)                              if (_bufferBase[pby1 + len] != _bufferBase[cur + len])                                  break;                          if (len == lenLimit)                          {                              _son[ptr1] = _son[cyclicPos];                              _son[ptr0] = _son[cyclicPos + 1];                              break;                          }                      }                      if (_bufferBase[pby1 + len] < _bufferBase[cur + len])                      {                          _son[ptr1] = curMatch;                          ptr1 = cyclicPos + 1;                          curMatch = _son[ptr1];                          len1 = len;                      }                      else                      {                          _son[ptr0] = curMatch;                          ptr0 = cyclicPos;                          curMatch = _son[ptr0];                          len0 = len;                      }                  }                  MovePos();              }              while (--num != 0);
Magic Number,Orvid.Compression,LZBinTree,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      if ((r & 1) != 0)                          r = (r >> 1) ^ kPoly;                      else                          r >>= 1;                  Table[i] = r;              }
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)              {                  uint r = i;                  for (int j = 0; j < 8; j++)                      if ((r & 1) != 0)                          r = (r >> 1) ^ kPoly;                      else                          r >>= 1;                  Table[i] = r;              }
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,Orvid.Compression,CRC,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)                  _value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  ShiftLow();
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)              {                  Range <<= 8;                  ShiftLow();              }
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)              {                  byte temp = _cache;                  do                  {                      Stream.WriteByte((byte)(temp + (Low >> 32)));                      temp = 0xFF;                  } while (--_cacheSize != 0);                    _cache = (byte)(((uint)Low) >> 24);              }
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)              {                  byte temp = _cache;                  do                  {                      Stream.WriteByte((byte)(temp + (Low >> 32)));                      temp = 0xFF;                  } while (--_cacheSize != 0);                    _cache = (byte)(((uint)Low) >> 24);              }
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)              {                  byte temp = _cache;                  do                  {                      Stream.WriteByte((byte)(temp + (Low >> 32)));                      temp = 0xFF;                  } while (--_cacheSize != 0);                    _cache = (byte)(((uint)Low) >> 24);              }
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)              {                  Range >>= 1;                  if (((v >> i) & 1) == 1)                      Low += Range;                  if (Range < kTopValue)                  {                      Range <<= 8;                      ShiftLow();                  }              }
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)              {                  Range <<= 8;                  ShiftLow();              }
Magic Number,Orvid.Compression,RangeEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize + Stream.Position - StartPosition + 4;
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)                  Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)              {                  Code = (Code << 8) | (byte)Stream.ReadByte();                  Range <<= 8;              }
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)              {                  range >>= 1;                  uint t = (code - range) >> 31;                  code -= range & (t - 1);                  result = (result << 1) | (1 - t);                    if (range < kTopValue)                  {                      code = (code << 8) | (byte)Stream.ReadByte();                      range <<= 8;                  }              }
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)              {                  range >>= 1;                  uint t = (code - range) >> 31;                  code -= range & (t - 1);                  result = (result << 1) | (1 - t);                    if (range < kTopValue)                  {                      code = (code << 8) | (byte)Stream.ReadByte();                      range <<= 8;                  }              }
Magic Number,Orvid.Compression,RangeDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)              {                  range >>= 1;                  uint t = (code - range) >> 31;                  code -= range & (t - 1);                  result = (result << 1) | (1 - t);                    if (range < kTopValue)                  {                      code = (code << 8) | (byte)Stream.ReadByte();                      range <<= 8;                  }              }
Magic Number,Orvid.Compression,RangeBitEncoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Encode,The following statement contains a magic number: if (encoder.Range < RangeEncoder.kTopValue)              {                  encoder.Range <<= 8;                  encoder.ShiftLow();              }
Magic Number,Orvid.Compression,RangeBitDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,Orvid.Compression,RangeBitDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,Orvid.Compression,RangeBitDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,Orvid.Compression,RangeBitDecoder,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\LZMACoder.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)              {                  rangeDecoder.Range = newBound;                  Prob += (kBitModelTotal - Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 0;              }              else              {                  rangeDecoder.Range -= newBound;                  rangeDecoder.Code -= newBound;                  Prob -= (Prob) >> kNumMoveBits;                  if (rangeDecoder.Range < RangeDecoder.kTopValue)                  {                      rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();                      rangeDecoder.Range <<= 8;                  }                  return 1;              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertButton_Click,The following statement contains a magic number: if (OutputFileName == null || OutputFileName == "")              {                  MessageBox.Show("Invalid File Name!");              }              else              {                  //FileStream str;                  FileStream final;                  dynamic strm;                    #region Already Exists                  if (File.Exists(OutputFileName))                  {                      if (MessageBox.Show("A file at '" + OutputFileName + "' already exists! Would you like to overwrite it?"' "File Already Exists"' MessageBoxButtons.YesNoCancel) == System.Windows.Forms.DialogResult.Yes)                      {                        }                      else                      {                          return;                      }                  }                  else                  {                      File.Create(OutputFileName).Close();                  }                  #endregion                    #region Compression Config                  //if (CompressionMode == CompressionType.Deflate)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new DeflateStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  //else if (CompressionMode == CompressionType.GZip)                  //{                  //    str = new FileStream(OutputFileName' FileMode.Truncate);                  //    strm = new GZipStream(str' System.IO.Compression.CompressionMode.Compress);                  //    final = null;                  //}                  if (CompressionMode == CompressionType.LZMA)                  {                      if (File.Exists(OutputFileName + ".uncmpr"))                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      strm = File.Create(OutputFileName + ".uncmpr");                      final = new FileStream(OutputFileName' FileMode.Truncate);                  }                  else                  {                      strm = new FileStream(OutputFileName' FileMode.Truncate);                      final = null;                  }                  #endregion                    BinaryWriter br = new BinaryWriter(strm);                    br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0); // Write the 8 empty bytes of the header                  br.Write((byte)0);                  br.Write((byte)0);                  br.Write((byte)0);                    byte[] buffer;                  br.Write((UInt16)47); // write the format version.                      string FontName = (string)FontComboBox.SelectedItem;                    buffer = ASCIIEncoding.ASCII.GetBytes(FontName);                  int i = 256 - buffer.Length;                  if (i < 0)                  {                      throw new Exception("Font Name is to long!");                  }                  else                  {                      br.Write(buffer);                      for (int i2 = 0; i2 < i; i2++)                      {                          br.Write((byte)0); // Fill the rest of the 256 bytes.                      }                  }                    System.Windows.Media.Typeface t = new System.Windows.Media.Typeface(FontName);                  System.Windows.Media.GlyphTypeface glyph;                  if (t.TryGetGlyphTypeface(out glyph))                  {                      t = null;                      IDictionary<int' ushort> charKeyMap = (IDictionary<int' ushort>)glyph.CharacterToGlyphMap;                      glyph = null;                      SortedSet<int> chars = new SortedSet<int>();                      foreach (KeyValuePair<int' ushort> c in charKeyMap)                      {                          chars.Add(c.Key);                      }                      charKeyMap = null;                      Font f = new Font(FontName' 128' GraphicsUnit.Pixel);                        UInt64 charsToWrite = (ulong)chars.Count;// *16;                      br.Write(charsToWrite); // Write the number of chars to read.                        int prevChar = 0;                        for (byte style = 0; style < 1; style++)                      {                          f = new Font(FontName' 64' (FontStyle)style' GraphicsUnit.Pixel);                          foreach (int ch in chars)                          {                              Bitmap Backend = new Bitmap(1' 1);                              Graphics g = Graphics.FromImage(Backend);                              SizeF sz = g.MeasureString(new String(new char[] { (char)ch })' f);                              byte height = (byte)Math.Ceiling(sz.Height + 2);                              byte width = (byte)Math.Ceiling(sz.Width + 4);                              Backend = new Bitmap(width' height);                              g = Graphics.FromImage(Backend);                              g.Clear(Color.White);                                g.DrawString(new String(new char[] { (char)ch })' f' new SolidBrush(Color.Black)' 2' 2);                              g.Flush(System.Drawing.Drawing2D.FlushIntention.Flush);                              if (prevChar + 1 == ch)                              {                                  br.Write((byte)255); // write that it's incremented from the previous char.                              }                              else                              {                                  br.Write((byte)0); // write that it's not incremented from the previous char.                                  br.Write((UInt32)ch); // Write the char number.                              }                              pictureBox1.Image = Backend;                              pictureBox1.Refresh();                                br.Write((byte)style); // write it's style                              br.Write((byte)height); // write the height                              br.Write((byte)width); // write the width                              buffer = ConvertToByteArray(Backend);                              br.Write(buffer);                              prevChar = ch;                          }                          strm.Flush();                          System.GC.Collect();                      }                        if (CompressionMode == CompressionType.LZMA)                      {                          strm.Position = 0;                          buffer = new byte[strm.Length];                          strm.Read(buffer' 0' (Int32)strm.Length);                          buffer = Orvid.Compression.LZMACoder.Compress(buffer);                          final.WriteByte(255);                          final.Write(buffer' 0' buffer.Length);                          final.Flush();                          final.Close();                          final.Dispose();                      }                        strm.Flush();                      strm.Close();                      strm.Dispose();                      if (CompressionMode == CompressionType.LZMA)                      {                          File.Delete(OutputFileName + ".uncmpr");                      }                      //pictureBox1.Image = null;                        MessageBox.Show("Conversion Completed Successfully!");                  }                  else                  {                      throw new Exception("Unable to load the glyph typeface!");                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertToByteArray,The following statement contains a magic number: for (int x = 0; x < b.Width; x++)              {                  for (int y = 0; y < b.Height; y++)                  {                      curPix = b.GetPixel(x' y);                      //if (curPix != White)                      //{                      //    if (curPix == Black)                      //    {                      //        br.Write(false);                      //        bitnum++;                      //        br.Write(false);                      //        bitnum++;                      //    }                      //    else // Write that it's a greyscale pixel' and it's value.                      //    {                      //        br.Write(false);                      //        bitnum++;                      //        br.Write(true);                      //        bitnum++;                              br.Write(GetGreyscaleByte(curPix));                              bitnum += 8;                      //    }                      //}                      //else                      //{                      //    br.Write(true);                      //    bitnum++;                      //}                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertToByteArray,The following statement contains a magic number: byte[] arr2 = new byte[m.Length + 4];
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertToByteArray,The following statement contains a magic number: Array.Copy(tmp' arr2' 4);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertToByteArray,The following statement contains a magic number: Array.Copy(tmp' 0' arr2' 4' m.Length);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,GetGreyscaleByte,The following statement contains a magic number: return (byte)((0.2125 * c.R) + (0.7154 * c.G) + (0.0721 * c.B));
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,GetGreyscaleByte,The following statement contains a magic number: return (byte)((0.2125 * c.R) + (0.7154 * c.G) + (0.0721 * c.B));
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,GetGreyscaleByte,The following statement contains a magic number: return (byte)((0.2125 * c.R) + (0.7154 * c.G) + (0.0721 * c.B));
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The following statement contains a magic number: if (!thso)              {                  FileStream s = new FileStream(Path.GetFullPath("Building.png")' FileMode.Open);                  Orvid.Graphics.ImageFormats.PngImage p = new Orvid.Graphics.ImageFormats.PngImage();                  Orvid.Graphics.Image i = p.Load(s);                  s.Close();                  s.Dispose();                  Bitmap b = new Bitmap(i.Width' i.Height);                  for (uint x = 0; x < i.Width; x++)                  {                      for (uint y = 0; y < i.Height; y++)                      {                          b.SetPixel((int)x' (int)y' i.GetPixel(x' y));                      }                  }                  pictureBox1.Image = b;                  thso = true;              }              else              {                  if (!t2)                  {                      Bitmap b = (Bitmap)pictureBox1.Image;                      Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                          }                      }                      i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic);                      Bitmap b2 = new Bitmap(i.Width' i.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                          }                      }                      pictureBox2.Image = b2;                      pictureBox2.Size = new Size(b2.Width' b2.Height);                      t2 = true;                  }                  else                  {                      if (!t3)                      {                          Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t3 = true;                      }                      else                      {                            Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t2 = false;                          t3 = false;                      }                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The following statement contains a magic number: if (!thso)              {                  FileStream s = new FileStream(Path.GetFullPath("Building.png")' FileMode.Open);                  Orvid.Graphics.ImageFormats.PngImage p = new Orvid.Graphics.ImageFormats.PngImage();                  Orvid.Graphics.Image i = p.Load(s);                  s.Close();                  s.Dispose();                  Bitmap b = new Bitmap(i.Width' i.Height);                  for (uint x = 0; x < i.Width; x++)                  {                      for (uint y = 0; y < i.Height; y++)                      {                          b.SetPixel((int)x' (int)y' i.GetPixel(x' y));                      }                  }                  pictureBox1.Image = b;                  thso = true;              }              else              {                  if (!t2)                  {                      Bitmap b = (Bitmap)pictureBox1.Image;                      Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                          }                      }                      i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic);                      Bitmap b2 = new Bitmap(i.Width' i.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                          }                      }                      pictureBox2.Image = b2;                      pictureBox2.Size = new Size(b2.Width' b2.Height);                      t2 = true;                  }                  else                  {                      if (!t3)                      {                          Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t3 = true;                      }                      else                      {                            Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t2 = false;                          t3 = false;                      }                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The following statement contains a magic number: if (!thso)              {                  FileStream s = new FileStream(Path.GetFullPath("Building.png")' FileMode.Open);                  Orvid.Graphics.ImageFormats.PngImage p = new Orvid.Graphics.ImageFormats.PngImage();                  Orvid.Graphics.Image i = p.Load(s);                  s.Close();                  s.Dispose();                  Bitmap b = new Bitmap(i.Width' i.Height);                  for (uint x = 0; x < i.Width; x++)                  {                      for (uint y = 0; y < i.Height; y++)                      {                          b.SetPixel((int)x' (int)y' i.GetPixel(x' y));                      }                  }                  pictureBox1.Image = b;                  thso = true;              }              else              {                  if (!t2)                  {                      Bitmap b = (Bitmap)pictureBox1.Image;                      Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                          }                      }                      i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic);                      Bitmap b2 = new Bitmap(i.Width' i.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                          }                      }                      pictureBox2.Image = b2;                      pictureBox2.Size = new Size(b2.Width' b2.Height);                      t2 = true;                  }                  else                  {                      if (!t3)                      {                          Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t3 = true;                      }                      else                      {                            Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t2 = false;                          t3 = false;                      }                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The following statement contains a magic number: if (!thso)              {                  FileStream s = new FileStream(Path.GetFullPath("Building.png")' FileMode.Open);                  Orvid.Graphics.ImageFormats.PngImage p = new Orvid.Graphics.ImageFormats.PngImage();                  Orvid.Graphics.Image i = p.Load(s);                  s.Close();                  s.Dispose();                  Bitmap b = new Bitmap(i.Width' i.Height);                  for (uint x = 0; x < i.Width; x++)                  {                      for (uint y = 0; y < i.Height; y++)                      {                          b.SetPixel((int)x' (int)y' i.GetPixel(x' y));                      }                  }                  pictureBox1.Image = b;                  thso = true;              }              else              {                  if (!t2)                  {                      Bitmap b = (Bitmap)pictureBox1.Image;                      Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                          }                      }                      i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic);                      Bitmap b2 = new Bitmap(i.Width' i.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                          }                      }                      pictureBox2.Image = b2;                      pictureBox2.Size = new Size(b2.Width' b2.Height);                      t2 = true;                  }                  else                  {                      if (!t3)                      {                          Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t3 = true;                      }                      else                      {                            Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t2 = false;                          t3 = false;                      }                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The following statement contains a magic number: if (!thso)              {                  FileStream s = new FileStream(Path.GetFullPath("Building.png")' FileMode.Open);                  Orvid.Graphics.ImageFormats.PngImage p = new Orvid.Graphics.ImageFormats.PngImage();                  Orvid.Graphics.Image i = p.Load(s);                  s.Close();                  s.Dispose();                  Bitmap b = new Bitmap(i.Width' i.Height);                  for (uint x = 0; x < i.Width; x++)                  {                      for (uint y = 0; y < i.Height; y++)                      {                          b.SetPixel((int)x' (int)y' i.GetPixel(x' y));                      }                  }                  pictureBox1.Image = b;                  thso = true;              }              else              {                  if (!t2)                  {                      Bitmap b = (Bitmap)pictureBox1.Image;                      Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                          }                      }                      i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic);                      Bitmap b2 = new Bitmap(i.Width' i.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                          }                      }                      pictureBox2.Image = b2;                      pictureBox2.Size = new Size(b2.Width' b2.Height);                      t2 = true;                  }                  else                  {                      if (!t3)                      {                          Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t3 = true;                      }                      else                      {                            Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t2 = false;                          t3 = false;                      }                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,TestButton2_Click,The following statement contains a magic number: if (!thso)              {                  FileStream s = new FileStream(Path.GetFullPath("Building.png")' FileMode.Open);                  Orvid.Graphics.ImageFormats.PngImage p = new Orvid.Graphics.ImageFormats.PngImage();                  Orvid.Graphics.Image i = p.Load(s);                  s.Close();                  s.Dispose();                  Bitmap b = new Bitmap(i.Width' i.Height);                  for (uint x = 0; x < i.Width; x++)                  {                      for (uint y = 0; y < i.Height; y++)                      {                          b.SetPixel((int)x' (int)y' i.GetPixel(x' y));                      }                  }                  pictureBox1.Image = b;                  thso = true;              }              else              {                  if (!t2)                  {                      Bitmap b = (Bitmap)pictureBox1.Image;                      Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                          }                      }                      i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bicubic);                      Bitmap b2 = new Bitmap(i.Width' i.Height);                      for (uint x = 0; x < i.Width; x++)                      {                          for (uint y = 0; y < i.Height; y++)                          {                              b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                          }                      }                      pictureBox2.Image = b2;                      pictureBox2.Size = new Size(b2.Width' b2.Height);                      t2 = true;                  }                  else                  {                      if (!t3)                      {                          Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 4' b.Height / 4)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.Bilinear);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t3 = true;                      }                      else                      {                            Bitmap b = (Bitmap)pictureBox1.Image;                          Orvid.Graphics.Image i = new Orvid.Graphics.Image(b.Width' b.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  i.SetPixel(x' y' b.GetPixel((int)x' (int)y));                              }                          }                          i = Orvid.Graphics.ImageManipulator.Resize(i' new Orvid.Graphics.Vec2(b.Width / 2' b.Height / 2)' Orvid.Graphics.ImageManipulator.ScalingAlgorithm.NearestNeighbor);                          Bitmap b2 = new Bitmap(i.Width' i.Height);                          for (uint x = 0; x < i.Width; x++)                          {                              for (uint y = 0; y < i.Height; y++)                              {                                  b2.SetPixel((int)x' (int)y' i.GetPixel(x' y));                              }                          }                          pictureBox2.Image = b2;                          pictureBox2.Size = new Size(b2.Width' b2.Height);                          t2 = false;                          t3 = false;                      }                  }              }
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(80' 119);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(80' 119);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(31' 13);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(31' 13);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.FontComboBox.Location = new System.Drawing.Point(117' 116);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.FontComboBox.Location = new System.Drawing.Point(117' 116);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.FontComboBox.Size = new System.Drawing.Size(200' 21);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.FontComboBox.Size = new System.Drawing.Size(200' 21);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(50' 150);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(50' 150);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(61' 13);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(61' 13);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 2;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(117' 147);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(117' 147);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(200' 20);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(200' 20);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.TabIndex = 3;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BrowseButton.Location = new System.Drawing.Point(323' 144);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BrowseButton.Location = new System.Drawing.Point(323' 144);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BrowseButton.Size = new System.Drawing.Size(75' 23);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BrowseButton.Size = new System.Drawing.Size(75' 23);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BrowseButton.TabIndex = 4;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ConvertButton.Location = new System.Drawing.Point(181' 268);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ConvertButton.Location = new System.Drawing.Point(181' 268);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ConvertButton.Size = new System.Drawing.Size(87' 31);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ConvertButton.Size = new System.Drawing.Size(87' 31);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ConvertButton.TabIndex = 5;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Location = new System.Drawing.Point(12' 12);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Size = new System.Drawing.Size(32' 32);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.Size = new System.Drawing.Size(32' 32);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox1.TabIndex = 6;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(301' 268);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(301' 268);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(75' 23);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(75' 23);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 7;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.CompressionComboBox.Location = new System.Drawing.Point(117' 173);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.CompressionComboBox.Location = new System.Drawing.Point(117' 173);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.CompressionComboBox.Size = new System.Drawing.Size(200' 21);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.CompressionComboBox.Size = new System.Drawing.Size(200' 21);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.CompressionComboBox.TabIndex = 8;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(2' 176);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(2' 176);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(109' 13);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(109' 13);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 9;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox2.Location = new System.Drawing.Point(311' 12);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox2.Location = new System.Drawing.Point(311' 12);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox2.Size = new System.Drawing.Size(32' 32);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox2.Size = new System.Drawing.Size(32' 32);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pictureBox2.TabIndex = 10;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Location = new System.Drawing.Point(288' 242);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Location = new System.Drawing.Point(288' 242);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Size = new System.Drawing.Size(100' 20);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Size = new System.Drawing.Size(100' 20);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.TabIndex = 11;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.TestButton2.Location = new System.Drawing.Point(42' 268);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.TestButton2.Location = new System.Drawing.Point(42' 268);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.TestButton2.Size = new System.Drawing.Size(75' 44);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.TestButton2.Size = new System.Drawing.Size(75' 44);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.TestButton2.TabIndex = 12;
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(449' 363);
Magic Number,TTF2OPFF_Converter,Form1,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(449' 363);
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,Write,The following statement contains a magic number: if (curBitIndx == 8)                  {                      base.Write(ConvertToByte(curByte));                      this.curBitIndx = 0;                      this.curByte = new bool[8];                  }
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,Write,The following statement contains a magic number: if (curBitIndx == 8)                  {                      base.Write(ConvertToByte(curByte));                      this.curBitIndx = 0;                      this.curByte = new bool[8];                  }
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,Write,The following statement contains a magic number: for (byte i = 0; i < 8; i++)                  {                      this.Write(ba[i]);                  }
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,Write,The following statement contains a magic number: for (byte i = 0; i < 32; i++)                  {                      this.Write(ba[i]);                  }
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,Write,The following statement contains a magic number: for (byte i = 0; i < 64; i++)                  {                      this.Write(ba[i]);                  }
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,Write,The following statement contains a magic number: for (byte i = 0; i < 16; i++)                  {                      this.Write(ba[i]);                  }
Magic Number,TTF2OPFF_Converter,BinaryWriter,C:\repos\CosmosOS_Cosmos\Tools\TTF2OPFF Converter\Form1.cs,ConvertToByte,The following statement contains a magic number: for (int i = 0; i < 8; i++)                  {                      if (bools[i])                      {                          b |= (byte)(((byte)1) << bitIndex);                      }                      bitIndex++;                  }
