Implementation smell,Namespace,Class,File,Method,Description
Long Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,Code,The method has 114 lines of code.
Long Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The method has 453 lines of code.
Long Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,CodeOneBlock,The method has 160 lines of code.
Long Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,SetCoderProperties,The method has 103 lines of code.
Long Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The method has 125 lines of code.
Complex Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,Cyclomatic complexity of the method is 58
Complex Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,CodeOneBlock,Cyclomatic complexity of the method is 15
Complex Method,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,Cyclomatic complexity of the method is 21
Long Parameter List,KeyczarTool.Minified.Diminish.SevenZip,ICoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\ICoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Code,The method has 5 parameters. Parameters: inStream' outStream' inSize' outSize' progress
Long Parameter List,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,BitTreeEncoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoderBitTree.cs,ReverseEncode,The method has 5 parameters. Parameters: Models' startIndex' rangeEncoder' NumBitLevels' symbol
Long Identifier,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Base,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,,The length of the parameter kNumLitPosStatesBitsEncodingMax is 31.
Long Statement,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The length of the statement  "									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1(); " is 126.
Long Statement,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,FillDistancesPrices,The length of the statement  "					_posSlotPrices[st + posSlot] += ((((posSlot >> 1) - 1) - Base.kNumAlignBits) << RangeCoder.BitEncoder.kNumBitPriceShiftBits); " is 125.
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,CRC,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Common\CRC.cs,CRC,The following statement contains a magic number: Table = new uint[256];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,CRC,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,CRC,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Common\CRC.cs,CRC,The following statement contains a magic number: for (uint i = 0; i < 256; i++)  			{  				uint r = i;  				for (int j = 0; j < 8; j++)  					if ((r & 1) != 0)  						r = (r >> 1) ^ kPoly;  					else  						r >>= 1;  				Table[i] = r;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,CRC,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Common\CRC.cs,UpdateByte,The following statement contains a magic number: _value = Table[(((byte)(_value)) ^ b)] ^ (_value >> 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,CRC,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Common\CRC.cs,Update,The following statement contains a magic number: for (uint i = 0; i < size; i++)  				_value = Table[(((byte)(_value)) ^ data[offset + i])] ^ (_value >> 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Encode,The following statement contains a magic number: var properties = new object[]                                    {                                        0x800000'                                        2'                                        3'                                        0'                                        2'                                        0x8'                                        "bt4"'                                        false                                    };
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Encode,The following statement contains a magic number: var properties = new object[]                                    {                                        0x800000'                                        2'                                        3'                                        0'                                        2'                                        0x8'                                        "bt4"'                                        false                                    };
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Encode,The following statement contains a magic number: var properties = new object[]                                    {                                        0x800000'                                        2'                                        3'                                        0'                                        2'                                        0x8'                                        "bt4"'                                        false                                    };
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Decode,The following statement contains a magic number: var properties = new byte[5];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Decode,The following statement contains a magic number: input.Read(properties' 0' 5);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Decode,The following statement contains a magic number: var bytesize = new byte[8];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip,Zipper,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\Zipper.cs,Decode,The following statement contains a magic number: input.Read(bytesize' 0' 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateChar,The following statement contains a magic number: if (Index < 4) Index = 0;  				else if (Index < 10) Index -= 3;  				else Index -= 6;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateMatch,The following statement contains a magic number: Index = (uint)(Index < 7 ? 7 : 10);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 8 : 11);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,UpdateShortRep,The following statement contains a magic number: Index = (uint)(Index < 7 ? 9 : 11);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,State,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaBase.cs,IsCharState,The following statement contains a magic number: return Index < 7;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDictionarySize,The following statement contains a magic number: if (m_DictionarySize != dictionarySize)  			{  				m_DictionarySize = dictionarySize;  				m_DictionarySizeCheck = Math.Max(m_DictionarySize' 1);  				uint blockSize = Math.Max(m_DictionarySizeCheck' (1 << 12));  				m_OutWindow.Create(blockSize);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lp > 8)  				throw new InvalidParamException();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetLiteralProperties,The following statement contains a magic number: if (lc > 8)  				throw new InvalidParamException();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,Code,The following statement contains a magic number: while (nowPos64 < outSize64)  			{  				// UInt64 next = Math.Min(nowPos64 + (1 << 18)' outSize64);  					// while(nowPos64 < next)  				{  					uint posState = (uint)nowPos64 & m_PosStateMask;  					if (m_IsMatchDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  					{  						byte b;  						byte prevByte = m_OutWindow.GetByte(0);  						if (!state.IsCharState())  							b = m_LiteralDecoder.DecodeWithMatchByte(m_RangeDecoder'  								(uint)nowPos64' prevByte' m_OutWindow.GetByte(rep0));  						else  							b = m_LiteralDecoder.DecodeNormal(m_RangeDecoder' (uint)nowPos64' prevByte);  						m_OutWindow.PutByte(b);  						state.UpdateChar();  						nowPos64++;  					}  					else  					{  						uint len;  						if (m_IsRepDecoders[state.Index].Decode(m_RangeDecoder) == 1)  						{  							if (m_IsRepG0Decoders[state.Index].Decode(m_RangeDecoder) == 0)  							{  								if (m_IsRep0LongDecoders[(state.Index << Base.kNumPosStatesBitsMax) + posState].Decode(m_RangeDecoder) == 0)  								{  									state.UpdateShortRep();  									m_OutWindow.PutByte(m_OutWindow.GetByte(rep0));  									nowPos64++;  									continue;  								}  							}  							else  							{  								UInt32 distance;  								if (m_IsRepG1Decoders[state.Index].Decode(m_RangeDecoder) == 0)  								{  									distance = rep1;  								}  								else  								{  									if (m_IsRepG2Decoders[state.Index].Decode(m_RangeDecoder) == 0)  										distance = rep2;  									else  									{  										distance = rep3;  										rep3 = rep2;  									}  									rep2 = rep1;  								}  								rep1 = rep0;  								rep0 = distance;  							}  							len = m_RepLenDecoder.Decode(m_RangeDecoder' posState) + Base.kMatchMinLen;  							state.UpdateRep();  						}  						else  						{  							rep3 = rep2;  							rep2 = rep1;  							rep1 = rep0;  							len = Base.kMatchMinLen + m_LenDecoder.Decode(m_RangeDecoder' posState);  							state.UpdateMatch();  							uint posSlot = m_PosSlotDecoder[Base.GetLenToPosState(len)].Decode(m_RangeDecoder);  							if (posSlot >= Base.kStartPosModelIndex)  							{  								int numDirectBits = (int)((posSlot >> 1) - 1);  								rep0 = ((2 | (posSlot & 1)) << numDirectBits);  								if (posSlot < Base.kEndPosModelIndex)  									rep0 += BitTreeDecoder.ReverseDecode(m_PosDecoders'  											rep0 - posSlot - 1' m_RangeDecoder' numDirectBits);  								else  								{  									rep0 += (m_RangeDecoder.DecodeDirectBits(  										numDirectBits - Base.kNumAlignBits) << Base.kNumAlignBits);  									rep0 += m_PosAlignDecoder.ReverseDecode(m_RangeDecoder);  								}  							}  							else  								rep0 = posSlot;  						}  						if (rep0 >= m_OutWindow.TrainSize + nowPos64 || rep0 >= m_DictionarySizeCheck)  						{  							if (rep0 == 0xFFFFFFFF)  								break;  							throw new DataErrorException();  						}  						m_OutWindow.CopyBlock(rep0' len);  						nowPos64 += len;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: if (properties.Length < 5)  				throw new InvalidParamException();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lc = properties[0] % 9;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int remainder = properties[0] / 9;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int lp = remainder % 5;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: int pb = remainder / 5;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,SetDecoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				dictionarySize += ((UInt32)(properties[1 + i])) << (i * 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,LiteralDecoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,GetState,The following statement contains a magic number: return ((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits));
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Decoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaDecoder.cs,DecodeWithMatchByte,The following statement contains a magic number: do  					{  						uint matchBit = (uint)(matchByte >> 7) & 1;  						matchByte <<= 1;  						uint bit = m_Decoders[((1 + matchBit) << 8) + symbol].Decode(rangeDecoder);  						symbol = (symbol << 1) | bit;  						if (matchBit != bit)  						{  							while (symbol < 0x100)  								symbol = (symbol << 1) | m_Decoders[symbol].Decode(rangeDecoder);  							break;  						}  					}  					while (symbol < 0x100);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: const Byte kFastSlots = 22;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: int c = 2;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Encoder,The following statement contains a magic number: for (Byte slotFast = 2; slotFast < kFastSlots; slotFast++)  			{  				UInt32 k = ((UInt32)1 << ((slotFast >> 1) - 1));  				for (UInt32 j = 0; j < k; j++' c++)  					g_FastPos[c] = slotFast;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 11))  				return g_FastPos[pos];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: if (pos < (1 << 21))  				return (UInt32)(g_FastPos[pos >> 10] + 20);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 20] + 40);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 17))  				return (UInt32)(g_FastPos[pos >> 6] + 12);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: if (pos < (1 << 27))  				return (UInt32)(g_FastPos[pos >> 16] + 32);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPosSlot2,The following statement contains a magic number: return (UInt32)(g_FastPos[pos >> 26] + 52);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Create,The following statement contains a magic number: if (_matchFinder == null)  			{  				LZ.BinTree bt = new LZ.BinTree();  				int numHashBytes = 4;  				if (_matchFinderType == EMatchFinderType.BT2)  					numHashBytes = 2;  				bt.SetType(numHashBytes);  				_matchFinder = bt;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,ReadMatchDistances,The following statement contains a magic number: if (numDistancePairs > 0)  			{  				lenRes = _matchDistances[numDistancePairs - 2];  				if (lenRes == _numFastBytes)  					lenRes += _matchFinder.GetMatchLen((int)lenRes - 1' _matchDistances[numDistancePairs - 1]'  						Base.kMatchMaxLen - lenRes);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPureRepPrice,The following statement contains a magic number: if (repIndex == 0)  			{  				price = _isRepG0[state.Index].GetPrice0();  				price += _isRep0Long[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  			}  			else  			{  				price = _isRepG0[state.Index].GetPrice1();  				if (repIndex == 1)  					price += _isRepG1[state.Index].GetPrice0();  				else  				{  					price += _isRepG1[state.Index].GetPrice1();  					price += _isRepG2[state.Index].GetPrice(repIndex - 2);  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (numAvailableBytes < 2)  			{  				backRes = 0xFFFFFFFF;  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (lenMain < 2 && currentByte != matchByte && repLens[repMaxIndex] < 2)  			{  				backRes = (UInt32)0xFFFFFFFF;  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if(lenEnd < 2)  			{  				backRes = _optimum[1].BackPrev;  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs2 = reps[2];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: _optimum[0].Backs3 = reps[3];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: do  				_optimum[len--].Price = kIfinityPrice;  			while (len >= 2);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: for (i = 0; i < Base.kNumRepDistances; i++)  			{  				UInt32 repLen = repLens[i];  				if (repLen < 2)  					continue;  				UInt32 price = repMatchPrice + GetPureRepPrice(i' _state' posState);  				do  				{  					UInt32 curAndLenPrice = price + _repMatchLenEncoder.GetPrice(repLen - 2' posState);  					Optimal optimum = _optimum[repLen];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = i;  						optimum.Prev1IsChar = false;  					}  				}  				while (--repLen >= 2);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: if (len <= lenMain)  			{  				UInt32 offs = 0;  				while (len > _matchDistances[offs])  					offs += 2;  				for (; ; len++)  				{  					UInt32 distance = _matchDistances[offs + 1];  					UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(distance' len' posState);  					Optimal optimum = _optimum[len];  					if (curAndLenPrice < optimum.Price)  					{  						optimum.Price = curAndLenPrice;  						optimum.PosPrev = 0;  						optimum.BackPrev = distance + Base.kNumRepDistances;  						optimum.Prev1IsChar = false;  					}  					if (len == _matchDistances[offs])  					{  						offs += 2;  						if (offs == numDistancePairs)  							break;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetOptimum,The following statement contains a magic number: while (true)  			{  				cur++;  				if (cur == lenEnd)  					return Backward(out backRes' cur);  				UInt32 newLen;  				ReadMatchDistances(out newLen' out numDistancePairs);  				if (newLen >= _numFastBytes)  				{  					_numDistancePairs = numDistancePairs;  					_longestMatchLength = newLen;  					_longestMatchWasFound = true;  					return Backward(out backRes' cur);  				}  				position++;  				UInt32 posPrev = _optimum[cur].PosPrev;  				Base.State state;  				if (_optimum[cur].Prev1IsChar)  				{  					posPrev--;  					if (_optimum[cur].Prev2)  					{  						state = _optimum[_optimum[cur].PosPrev2].State;  						if (_optimum[cur].BackPrev2 < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					else  						state = _optimum[posPrev].State;  					state.UpdateChar();  				}  				else  					state = _optimum[posPrev].State;  				if (posPrev == cur - 1)  				{  					if (_optimum[cur].IsShortRep())  						state.UpdateShortRep();  					else  						state.UpdateChar();  				}  				else  				{  					UInt32 pos;  					if (_optimum[cur].Prev1IsChar && _optimum[cur].Prev2)  					{  						posPrev = _optimum[cur].PosPrev2;  						pos = _optimum[cur].BackPrev2;  						state.UpdateRep();  					}  					else  					{  						pos = _optimum[cur].BackPrev;  						if (pos < Base.kNumRepDistances)  							state.UpdateRep();  						else  							state.UpdateMatch();  					}  					Optimal opt = _optimum[posPrev];  					if (pos < Base.kNumRepDistances)  					{  						if (pos == 0)  						{  							reps[0] = opt.Backs0;  							reps[1] = opt.Backs1;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 1)  						{  							reps[0] = opt.Backs1;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs2;  							reps[3] = opt.Backs3;  						}  						else if (pos == 2)  						{  							reps[0] = opt.Backs2;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs3;  						}  						else  						{  							reps[0] = opt.Backs3;  							reps[1] = opt.Backs0;  							reps[2] = opt.Backs1;  							reps[3] = opt.Backs2;  						}  					}  					else  					{  						reps[0] = (pos - Base.kNumRepDistances);  						reps[1] = opt.Backs0;  						reps[2] = opt.Backs1;  						reps[3] = opt.Backs2;  					}  				}  				_optimum[cur].State = state;  				_optimum[cur].Backs0 = reps[0];  				_optimum[cur].Backs1 = reps[1];  				_optimum[cur].Backs2 = reps[2];  				_optimum[cur].Backs3 = reps[3];  				UInt32 curPrice = _optimum[cur].Price;    				currentByte = _matchFinder.GetIndexByte(0 - 1);  				matchByte = _matchFinder.GetIndexByte((Int32)(0 - reps[0] - 1 - 1));    				posState = (position & _posStateMask);    				UInt32 curAnd1Price = curPrice +  					_isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice0() +  					_literalEncoder.GetSubCoder(position' _matchFinder.GetIndexByte(0 - 2)).  					GetPrice(!state.IsCharState()' matchByte' currentByte);    				Optimal nextOptimum = _optimum[cur + 1];    				bool nextIsChar = false;  				if (curAnd1Price < nextOptimum.Price)  				{  					nextOptimum.Price = curAnd1Price;  					nextOptimum.PosPrev = cur;  					nextOptimum.MakeAsChar();  					nextIsChar = true;  				}    				matchPrice = curPrice + _isMatch[(state.Index << Base.kNumPosStatesBitsMax) + posState].GetPrice1();  				repMatchPrice = matchPrice + _isRep[state.Index].GetPrice1();    				if (matchByte == currentByte &&  					!(nextOptimum.PosPrev < cur && nextOptimum.BackPrev == 0))  				{  					UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(state' posState);  					if (shortRepPrice <= nextOptimum.Price)  					{  						nextOptimum.Price = shortRepPrice;  						nextOptimum.PosPrev = cur;  						nextOptimum.MakeAsShortRep();  						nextIsChar = true;  					}  				}    				UInt32 numAvailableBytesFull = _matchFinder.GetNumAvailableBytes() + 1;  				numAvailableBytesFull = Math.Min(kNumOpts - 1 - cur' numAvailableBytesFull);  				numAvailableBytes = numAvailableBytesFull;    				if (numAvailableBytes < 2)  					continue;  				if (numAvailableBytes > _numFastBytes)  					numAvailableBytes = _numFastBytes;  				if (!nextIsChar && matchByte != currentByte)  				{  					// try Literal + rep0  					UInt32 t = Math.Min(numAvailableBytesFull - 1' _numFastBytes);  					UInt32 lenTest2 = _matchFinder.GetMatchLen(0' reps[0]' t);  					if (lenTest2 >= 2)  					{  						Base.State state2 = state;  						state2.UpdateChar();  						UInt32 posStateNext = (position + 1) & _posStateMask;  						UInt32 nextRepMatchPrice = curAnd1Price +  							_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1() +  							_isRep[state2.Index].GetPrice1();  						{  							UInt32 offset = cur + 1 + lenTest2;  							while (lenEnd < offset)  								_optimum[++lenEnd].Price = kIfinityPrice;  							UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(  								0' lenTest2' state2' posStateNext);  							Optimal optimum = _optimum[offset];  							if (curAndLenPrice < optimum.Price)  							{  								optimum.Price = curAndLenPrice;  								optimum.PosPrev = cur + 1;  								optimum.BackPrev = 0;  								optimum.Prev1IsChar = true;  								optimum.Prev2 = false;  							}  						}  					}  				}    				UInt32 startLen = 2; // speed optimization     				for (UInt32 repIndex = 0; repIndex < Base.kNumRepDistances; repIndex++)  				{  					UInt32 lenTest = _matchFinder.GetMatchLen(0 - 1' reps[repIndex]' numAvailableBytes);  					if (lenTest < 2)  						continue;  					UInt32 lenTestTemp = lenTest;  					do  					{  						while (lenEnd < cur + lenTest)  							_optimum[++lenEnd].Price = kIfinityPrice;  						UInt32 curAndLenPrice = repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = repIndex;  							optimum.Prev1IsChar = false;  						}  					}  					while(--lenTest >= 2);  					lenTest = lenTestTemp;    					if (repIndex == 0)  						startLen = lenTest + 1;    					// if (_maxMode)  					if (lenTest < numAvailableBytesFull)  					{  						UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  						UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' reps[repIndex]' t);  						if (lenTest2 >= 2)  						{  							Base.State state2 = state;  							state2.UpdateRep();  							UInt32 posStateNext = (position + lenTest) & _posStateMask;  							UInt32 curAndLenCharPrice =   									repMatchPrice + GetRepPrice(repIndex' lenTest' state' posState) +   									_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  									_literalEncoder.GetSubCoder(position + lenTest'   									_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).GetPrice(true'  									_matchFinder.GetIndexByte((Int32)((Int32)lenTest - 1 - (Int32)(reps[repIndex] + 1)))'   									_matchFinder.GetIndexByte((Int32)lenTest - 1));  							state2.UpdateChar();  							posStateNext = (position + lenTest + 1) & _posStateMask;  							UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  							UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();  							  							// for(; lenTest2 >= 2; lenTest2--)  							{  								UInt32 offset = lenTest + 1 + lenTest2;  								while(lenEnd < cur + offset)  									_optimum[++lenEnd].Price = kIfinityPrice;  								UInt32 curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  								Optimal optimum = _optimum[cur + offset];  								if (curAndLenPrice < optimum.Price)   								{  									optimum.Price = curAndLenPrice;  									optimum.PosPrev = cur + lenTest + 1;  									optimum.BackPrev = 0;  									optimum.Prev1IsChar = true;  									optimum.Prev2 = true;  									optimum.PosPrev2 = cur;  									optimum.BackPrev2 = repIndex;  								}  							}  						}  					}  				}    				if (newLen > numAvailableBytes)  				{  					newLen = numAvailableBytes;  					for (numDistancePairs = 0; newLen > _matchDistances[numDistancePairs]; numDistancePairs += 2) ;  					_matchDistances[numDistancePairs] = newLen;  					numDistancePairs += 2;  				}  				if (newLen >= startLen)  				{  					normalMatchPrice = matchPrice + _isRep[state.Index].GetPrice0();  					while (lenEnd < cur + newLen)  						_optimum[++lenEnd].Price = kIfinityPrice;    					UInt32 offs = 0;  					while (startLen > _matchDistances[offs])  						offs += 2;    					for (UInt32 lenTest = startLen; ; lenTest++)  					{  						UInt32 curBack = _matchDistances[offs + 1];  						UInt32 curAndLenPrice = normalMatchPrice + GetPosLenPrice(curBack' lenTest' posState);  						Optimal optimum = _optimum[cur + lenTest];  						if (curAndLenPrice < optimum.Price)  						{  							optimum.Price = curAndLenPrice;  							optimum.PosPrev = cur;  							optimum.BackPrev = curBack + Base.kNumRepDistances;  							optimum.Prev1IsChar = false;  						}    						if (lenTest == _matchDistances[offs])  						{  							if (lenTest < numAvailableBytesFull)  							{  								UInt32 t = Math.Min(numAvailableBytesFull - 1 - lenTest' _numFastBytes);  								UInt32 lenTest2 = _matchFinder.GetMatchLen((Int32)lenTest' curBack' t);  								if (lenTest2 >= 2)  								{  									Base.State state2 = state;  									state2.UpdateMatch();  									UInt32 posStateNext = (position + lenTest) & _posStateMask;  									UInt32 curAndLenCharPrice = curAndLenPrice +  										_isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice0() +  										_literalEncoder.GetSubCoder(position + lenTest'  										_matchFinder.GetIndexByte((Int32)lenTest - 1 - 1)).  										GetPrice(true'  										_matchFinder.GetIndexByte((Int32)lenTest - (Int32)(curBack + 1) - 1)'  										_matchFinder.GetIndexByte((Int32)lenTest - 1));  									state2.UpdateChar();  									posStateNext = (position + lenTest + 1) & _posStateMask;  									UInt32 nextMatchPrice = curAndLenCharPrice + _isMatch[(state2.Index << Base.kNumPosStatesBitsMax) + posStateNext].GetPrice1();  									UInt32 nextRepMatchPrice = nextMatchPrice + _isRep[state2.Index].GetPrice1();    									UInt32 offset = lenTest + 1 + lenTest2;  									while (lenEnd < cur + offset)  										_optimum[++lenEnd].Price = kIfinityPrice;  									curAndLenPrice = nextRepMatchPrice + GetRepPrice(0' lenTest2' state2' posStateNext);  									optimum = _optimum[cur + offset];  									if (curAndLenPrice < optimum.Price)  									{  										optimum.Price = curAndLenPrice;  										optimum.PosPrev = cur + lenTest + 1;  										optimum.BackPrev = 0;  										optimum.Prev1IsChar = true;  										optimum.Prev2 = true;  										optimum.PosPrev2 = cur;  										optimum.BackPrev2 = curBack + Base.kNumRepDistances;  									}  								}  							}  							offs += 2;  							if (offs == numDistancePairs)  								break;  						}  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: const int kDif = 7;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,ChangePair,The following statement contains a magic number: return (smallDist < ((UInt32)(1) << (32 - kDif)) && bigDist >= (smallDist << kDif));
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,WriteEndMarker,The following statement contains a magic number: int footerBits = 30;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,CodeOneBlock,The following statement contains a magic number: while (true)  			{  				UInt32 pos;  				UInt32 len = GetOptimum((UInt32)nowPos64' out pos);  				  				UInt32 posState = ((UInt32)nowPos64) & _posStateMask;  				UInt32 complexState = (_state.Index << Base.kNumPosStatesBitsMax) + posState;  				if (len == 1 && pos == 0xFFFFFFFF)  				{  					_isMatch[complexState].Encode(_rangeEncoder' 0);  					Byte curByte = _matchFinder.GetIndexByte((Int32)(0 - _additionalOffset));  					LiteralEncoder.Encoder2 subCoder = _literalEncoder.GetSubCoder((UInt32)nowPos64' _previousByte);  					if (!_state.IsCharState())  					{  						Byte matchByte = _matchFinder.GetIndexByte((Int32)(0 - _repDistances[0] - 1 - _additionalOffset));  						subCoder.EncodeMatched(_rangeEncoder' matchByte' curByte);  					}  					else  						subCoder.Encode(_rangeEncoder' curByte);  					_previousByte = curByte;  					_state.UpdateChar();  				}  				else  				{  					_isMatch[complexState].Encode(_rangeEncoder' 1);  					if (pos < Base.kNumRepDistances)  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 1);  						if (pos == 0)  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 0);  							if (len == 1)  								_isRep0Long[complexState].Encode(_rangeEncoder' 0);  							else  								_isRep0Long[complexState].Encode(_rangeEncoder' 1);  						}  						else  						{  							_isRepG0[_state.Index].Encode(_rangeEncoder' 1);  							if (pos == 1)  								_isRepG1[_state.Index].Encode(_rangeEncoder' 0);  							else  							{  								_isRepG1[_state.Index].Encode(_rangeEncoder' 1);  								_isRepG2[_state.Index].Encode(_rangeEncoder' pos - 2);  							}  						}  						if (len == 1)  							_state.UpdateShortRep();  						else  						{  							_repMatchLenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  							_state.UpdateRep();  						}  						UInt32 distance = _repDistances[pos];  						if (pos != 0)  						{  							for (UInt32 i = pos; i >= 1; i--)  								_repDistances[i] = _repDistances[i - 1];  							_repDistances[0] = distance;  						}  					}  					else  					{  						_isRep[_state.Index].Encode(_rangeEncoder' 0);  						_state.UpdateMatch();  						_lenEncoder.Encode(_rangeEncoder' len - Base.kMatchMinLen' posState);  						pos -= Base.kNumRepDistances;  						UInt32 posSlot = GetPosSlot(pos);  						UInt32 lenToPosState = Base.GetLenToPosState(len);  						_posSlotEncoder[lenToPosState].Encode(_rangeEncoder' posSlot);    						if (posSlot >= Base.kStartPosModelIndex)  						{  							int footerBits = (int)((posSlot >> 1) - 1);  							UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  							UInt32 posReduced = pos - baseVal;    							if (posSlot < Base.kEndPosModelIndex)  								RangeCoder.BitTreeEncoder.ReverseEncode(_posEncoders'  										baseVal - posSlot - 1' _rangeEncoder' footerBits' posReduced);  							else  							{  								_rangeEncoder.EncodeDirectBits(posReduced >> Base.kNumAlignBits' footerBits - Base.kNumAlignBits);  								_posAlignEncoder.ReverseEncode(_rangeEncoder' posReduced & Base.kAlignMask);  								_alignPriceCount++;  							}  						}  						UInt32 distance = pos;  						for (UInt32 i = Base.kNumRepDistances - 1; i >= 1; i--)  							_repDistances[i] = _repDistances[i - 1];  						_repDistances[0] = distance;  						_matchPriceCount++;  					}  					_previousByte = _matchFinder.GetIndexByte((Int32)(len - 1 - _additionalOffset));  				}  				_additionalOffset -= len;  				nowPos64 += len;  				if (_additionalOffset == 0)  				{  					// if (!_fastMode)  					if (_matchPriceCount >= (1 << 7))  						FillDistancesPrices();  					if (_alignPriceCount >= Base.kAlignTableSize)  						FillAlignPrices();  					inSize = nowPos64;  					outSize = _rangeEncoder.GetProcessedSizeAdd();  					if (_matchFinder.GetNumAvailableBytes() == 0)  					{  						Flush((UInt32)nowPos64);  						return;  					}    					if (nowPos64 - progressPosValuePrev >= (1 << 12))  					{  						_finished = false;  						finished = false;  						return;  					}  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: properties[0] = (Byte)((_posStateBits * 5 + _numLiteralPosStateBits) * 9 + _numLiteralContextBits);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,WriteCoderProperties,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				properties[1 + i] = (Byte)((_dictionarySize >> (8 * i)) & 0xFF);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,FillDistancesPrices,The following statement contains a magic number: for (UInt32 i = Base.kStartPosModelIndex; i < Base.kNumFullDistances; i++)  			{   				UInt32 posSlot = GetPosSlot(i);  				int footerBits = (int)((posSlot >> 1) - 1);  				UInt32 baseVal = ((2 | (posSlot & 1)) << footerBits);  				tempPrices[i] = BitTreeEncoder.ReverseGetPrice(_posEncoders'   					baseVal - posSlot - 1' footerBits' i - baseVal);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,SetCoderProperties,The following statement contains a magic number: for (UInt32 i = 0; i < properties.Length; i++)  			{  				object prop = properties[i];  				switch (propIDs[i])  				{  					case CoderPropID.NumFastBytes:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 numFastBytes = (Int32)prop;  						if (numFastBytes < 5 || numFastBytes > Base.kMatchMaxLen)  							throw new InvalidParamException();  						_numFastBytes = (UInt32)numFastBytes;  						break;  					}  					case CoderPropID.Algorithm:  					{  						/*  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 maximize = (Int32)prop;  						_fastMode = (maximize == 0);  						_maxMode = (maximize >= 2);  						*/  						break;  					}  					case CoderPropID.MatchFinder:  					{  						if (!(prop is String))  							throw new InvalidParamException();  						EMatchFinderType matchFinderIndexPrev = _matchFinderType;  						int m = FindMatchFinder(((string)prop).ToUpper());  						if (m < 0)  							throw new InvalidParamException();  						_matchFinderType = (EMatchFinderType)m;  						if (_matchFinder != null && matchFinderIndexPrev != _matchFinderType)  							{  							_dictionarySizePrev = 0xFFFFFFFF;  							_matchFinder = null;  							}  						break;  					}  					case CoderPropID.DictionarySize:  					{  						const int kDicLogSizeMaxCompress = 30;  						if (!(prop is Int32))  							throw new InvalidParamException(); ;  						Int32 dictionarySize = (Int32)prop;  						if (dictionarySize < (UInt32)(1 << Base.kDicLogSizeMin) ||  							dictionarySize > (UInt32)(1 << kDicLogSizeMaxCompress))  							throw new InvalidParamException();  						_dictionarySize = (UInt32)dictionarySize;  						int dicLogSize;  						for (dicLogSize = 0; dicLogSize < (UInt32)kDicLogSizeMaxCompress; dicLogSize++)  							if (dictionarySize <= ((UInt32)(1) << dicLogSize))  								break;  						_distTableSize = (UInt32)dicLogSize * 2;  						break;  					}  					case CoderPropID.PosStateBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_posStateBits = (int)v;  						_posStateMask = (((UInt32)1) << (int)_posStateBits) - 1;  						break;  					}  					case CoderPropID.LitPosBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitPosStatesBitsEncodingMax)  							throw new InvalidParamException();  						_numLiteralPosStateBits = (int)v;  						break;  					}  					case CoderPropID.LitContextBits:  					{  						if (!(prop is Int32))  							throw new InvalidParamException();  						Int32 v = (Int32)prop;  						if (v < 0 || v > (UInt32)Base.kNumLitContextBitsMax)  							throw new InvalidParamException(); ;  						_numLiteralContextBits = (int)v;  						break;  					}  					case CoderPropID.EndMarker:  					{  						if (!(prop is Boolean))  							throw new InvalidParamException();  						SetWriteEndMarkerMode((Boolean)prop);  						break;  					}  					default:  						throw new InvalidParamException();  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,LiteralEncoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetSubCoder,The following statement contains a magic number: return m_Coders[((pos & m_PosMask) << m_NumPrevBits) + (uint)(prevByte >> (8 - m_NumPrevBits))];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,Encode,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						m_Encoders[context].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,EncodeMatched,The following statement contains a magic number: for (int i = 7; i >= 0; i--)  					{  						uint bit = (uint)((symbol >> i) & 1);  						uint state = context;  						if (same)  						{  							uint matchBit = (uint)((matchByte >> i) & 1);  							state += ((1 + matchBit) << 8);  							same = (matchBit == bit);  						}  						m_Encoders[state].Encode(rangeEncoder' bit);  						context = (context << 1) | bit;  					}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: int i = 7;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZMA,Encoder2,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZMA\LzmaEncoder.cs,GetPrice,The following statement contains a magic number: if (matchMode)  					{  						for (; i >= 0; i--)  						{  							uint matchBit = (uint)(matchByte >> i) & 1;  							uint bit = (uint)(symbol >> i) & 1;  							price += m_Encoders[((1 + matchBit) << 8) + context].GetPrice(bit);  							context = (context << 1) | bit;  							if (matchBit != bit)  							{  								i--;  								break;  							}  						}  					}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: HASH_ARRAY = (numHashBytes > 2);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,SetType,The following statement contains a magic number: if (HASH_ARRAY)  			{  				kNumHashDirectBytes = 0;  				kMinMatchCheck = 4;  				kFixHashSize = kHash2Size + kHash3Size;  			}  			else  			{  				kNumHashDirectBytes = 2;  				kMinMatchCheck = 2 + 1;  				kFixHashSize = 0;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (historySize > kMaxValForNormalize - 256)  				throw new Exception();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: _cutValue = 16 + (matchMaxLen >> 1);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: UInt32 windowReservSize = (historySize + keepAddBufferBefore +  					matchMaxLen + keepAddBufferAfter) / 2 + 256;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (_cyclicBufferSize != cyclicBufferSize)  				_son = new UInt32[(_cyclicBufferSize = cyclicBufferSize) * 2];
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Create,The following statement contains a magic number: if (HASH_ARRAY)  			{  				hs = historySize - 1;  				hs |= (hs >> 1);  				hs |= (hs >> 2);  				hs |= (hs >> 4);  				hs |= (hs >> 8);  				hs >>= 1;  				hs |= 0xFFFF;  				if (hs > (1 << 24))  					hs >>= 1;  				_hashMask = hs;  				hs++;  				hs += kFixHashSize;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  				hash2Value = temp & (kHash2Size - 1);  				temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  				hash3Value = temp & (kHash3Size - 1);  				hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  			}  			else  				hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,GetMatches,The following statement contains a magic number: if (HASH_ARRAY)  			{  				UInt32 curMatch2 = _hash[hash2Value];  				UInt32 curMatch3 = _hash[kHash3Offset + hash3Value];  				_hash[hash2Value] = _pos;  				_hash[kHash3Offset + hash3Value] = _pos;  				if (curMatch2 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch2] == _bufferBase[cur])  					{  						distances[offset++] = maxLen = 2;  						distances[offset++] = _pos - curMatch2 - 1;  					}  				if (curMatch3 > matchMinPos)  					if (_bufferBase[_bufferOffset + curMatch3] == _bufferBase[cur])  					{  						if (curMatch3 == curMatch2)  							offset -= 2;  						distances[offset++] = maxLen = 3;  						distances[offset++] = _pos - curMatch3 - 1;  						curMatch2 = curMatch3;  					}  				if (offset != 0 && curMatch2 == curMatch)  				{  					offset -= 2;  					maxLen = kStartMaxLen;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Skip,The following statement contains a magic number: do  			{  				UInt32 lenLimit;  				if (_pos + _matchMaxLen <= _streamPos)  					lenLimit = _matchMaxLen;  				else  				{  					lenLimit = _streamPos - _pos;  					if (lenLimit < kMinMatchCheck)  					{  						MovePos();  						continue;  					}  				}    				UInt32 matchMinPos = (_pos > _cyclicBufferSize) ? (_pos - _cyclicBufferSize) : 0;  				UInt32 cur = _bufferOffset + _pos;    				UInt32 hashValue;    				if (HASH_ARRAY)  				{  					UInt32 temp = CRC.Table[_bufferBase[cur]] ^ _bufferBase[cur + 1];  					UInt32 hash2Value = temp & (kHash2Size - 1);  					_hash[hash2Value] = _pos;  					temp ^= ((UInt32)(_bufferBase[cur + 2]) << 8);  					UInt32 hash3Value = temp & (kHash3Size - 1);  					_hash[kHash3Offset + hash3Value] = _pos;  					hashValue = (temp ^ (CRC.Table[_bufferBase[cur + 3]] << 5)) & _hashMask;  				}  				else  					hashValue = _bufferBase[cur] ^ ((UInt32)(_bufferBase[cur + 1]) << 8);    				UInt32 curMatch = _hash[kFixHashSize + hashValue];  				_hash[kFixHashSize + hashValue] = _pos;    				UInt32 ptr0 = (_cyclicBufferPos << 1) + 1;  				UInt32 ptr1 = (_cyclicBufferPos << 1);    				UInt32 len0' len1;  				len0 = len1 = kNumHashDirectBytes;    				UInt32 count = _cutValue;  				while (true)  				{  					if (curMatch <= matchMinPos || count-- == 0)  					{  						_son[ptr0] = _son[ptr1] = kEmptyHashValue;  						break;  					}    					UInt32 delta = _pos - curMatch;  					UInt32 cyclicPos = ((delta <= _cyclicBufferPos) ?  								(_cyclicBufferPos - delta) :  								(_cyclicBufferPos - delta + _cyclicBufferSize)) << 1;    					UInt32 pby1 = _bufferOffset + curMatch;  					UInt32 len = Math.Min(len0' len1);  					if (_bufferBase[pby1 + len] == _bufferBase[cur + len])  					{  						while (++len != lenLimit)  							if (_bufferBase[pby1 + len] != _bufferBase[cur + len])  								break;  						if (len == lenLimit)  						{  							_son[ptr1] = _son[cyclicPos];  							_son[ptr0] = _son[cyclicPos + 1];  							break;  						}  					}  					if (_bufferBase[pby1 + len] < _bufferBase[cur + len])  					{  						_son[ptr1] = curMatch;  						ptr1 = cyclicPos + 1;  						curMatch = _son[ptr1];  						len1 = len;  					}  					else  					{  						_son[ptr0] = curMatch;  						ptr0 = cyclicPos;  						curMatch = _son[ptr0];  						len0 = len;  					}  				}  				MovePos();  			}  			while (--num != 0);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.LZ,BinTree,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\LZ\LzBinTree.cs,Normalize,The following statement contains a magic number: NormalizeLinks(_son' _cyclicBufferSize * 2' subValue);
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,FlushData,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				ShiftLow();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Encode,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: if ((uint)Low < (uint)0xFF000000 || (uint)(Low >> 32) == 1)  			{  				byte temp = _cache;  				do  				{  					Stream.WriteByte((byte)(temp + (Low >> 32)));  					temp = 0xFF;  				}  				while (--_cacheSize != 0);  				_cache = (byte)(((uint)Low) >> 24);  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,ShiftLow,The following statement contains a magic number: Low = ((uint)Low) << 8;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,EncodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits - 1; i >= 0; i--)  			{  				Range >>= 1;  				if (((v >> i) & 1) == 1)  					Low += Range;  				if (Range < kTopValue)  				{  					Range <<= 8;  					ShiftLow();  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,EncodeBit,The following statement contains a magic number: while (Range < kTopValue)  			{  				Range <<= 8;  				ShiftLow();  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Encoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,GetProcessedSizeAdd,The following statement contains a magic number: return _cacheSize +  				Stream.Position - StartPosition + 4;
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Init,The following statement contains a magic number: for (int i = 0; i < 5; i++)  				Code = (Code << 8) | (byte)Stream.ReadByte();
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Normalize,The following statement contains a magic number: while (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,Normalize2,The following statement contains a magic number: if (Range < kTopValue)  			{  				Code = (Code << 8) | (byte)Stream.ReadByte();  				Range <<= 8;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,Decoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoder.cs,DecodeDirectBits,The following statement contains a magic number: for (int i = numTotalBits; i > 0; i--)  			{  				range >>= 1;  				/*  				result <<= 1;  				if (code >= range)  				{  					code -= range;  					result |= 1;  				}  				*/  				uint t = (code - range) >> 31;  				code -= range & (t - 1);  				result = (result << 1) | (1 - t);    				if (range < kTopValue)  				{  					code = (code << 8) | (byte)Stream.ReadByte();  					range <<= 8;  				}  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,BitEncoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoderBit.cs,Encode,The following statement contains a magic number: if (encoder.Range < Encoder.kTopValue)  			{  				encoder.Range <<= 8;  				encoder.ShiftLow();  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
Magic Number,KeyczarTool.Minified.Diminish.SevenZip.Compression.RangeCoder,BitDecoder,C:\repos\jbtule_keyczar-dotnet\Keyczar\KeyczarTool.Minified\Diminish\src\7zipsdk\RangeCoder\RangeCoderBit.cs,Decode,The following statement contains a magic number: if (rangeDecoder.Code < newBound)  			{  				rangeDecoder.Range = newBound;  				Prob += (kBitModelTotal - Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 0;  			}  			else  			{  				rangeDecoder.Range -= newBound;  				rangeDecoder.Code -= newBound;  				Prob -= (Prob) >> kNumMoveBits;  				if (rangeDecoder.Range < Decoder.kTopValue)  				{  					rangeDecoder.Code = (rangeDecoder.Code << 8) | (byte)rangeDecoder.Stream.ReadByte();  					rangeDecoder.Range <<= 8;  				}  				return 1;  			}
