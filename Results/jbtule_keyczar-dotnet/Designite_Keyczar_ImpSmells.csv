Implementation smell,Namespace,Class,File,Method,Description
Long Method,Keyczar,Crypter,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypter.cs,Decrypt,The method has 109 lines of code.
Complex Method,Keyczar.Util,Secure,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\Secure.cs,Equals,Cyclomatic complexity of the method is 10
Complex Method,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,Cyclomatic complexity of the method is 11
Long Parameter List,Keyczar,SessionCrypter,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\SessionCrypter.cs,SessionCrypter,The method has 5 parameters. Parameters: keyEncrypter' signer' keySize' symmetricKeyType' keyPacker
Long Parameter List,Keyczar,Signer,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Signer.cs,Sign,The method has 6 parameters. Parameters: input' outstream' prefixData' postfixData' signatureData' inputLength
Long Parameter List,Keyczar,TimeoutVerifierHelper,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\TimeoutVerifier.cs,Verify,The method has 5 parameters. Parameters: input' signature' prefixData' postfixData' inputLength
Long Parameter List,Keyczar,Verifier,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Verifier.cs,Verify,The method has 5 parameters. Parameters: input' signature' prefixData' postfixData' inputLength
Long Parameter List,Keyczar.Crypto.Streams,SymmetricStream,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\Streams\SymmetricStream.cs,SymmetricStream,The method has 6 parameters. Parameters: cipher' output' iv' tagSize' initFunc' encrypt
Long Parameter List,Keyczar.Unofficial,SymmetricAeadStream,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\SymmetricAeadStream.cs,SymmetricAeadStream,The method has 6 parameters. Parameters: makeCipher' outStream' nonce' tagLength' initFunc' encrypt
Long Statement,Keyczar,AttachedSignerHelper,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\AttachedSigner.cs,Sign,The length of the statement  "                base.Sign(input' signedData' prefixData: null' postfixData: hidden' signatureData: Tuple.Create(fullLength' position' input)' inputLength: inputLength); " is 152.
Long Statement,Keyczar,HelperAttachedVerify,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\AttachedVerifier.cs,VerifyHidden,The length of the statement  "                            var verified= Verify(signedMessageLimtedLength' sigStream.ToArray()' prefixData: null' postfixData: hidden' inputLength: inputLength); " is 134.
Long Statement,Keyczar.Util,Secure,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\Secure.cs,Equals,The length of the statement  "                throw new ArgumentOutOfRangeException("maxCount"' "maxCount' startindex cannot be set so that there isn't a comparison."); " is 122.
Virtual Method Call from Constructor,Keyczar,Keyczar,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Keyczar.cs,Keyczar,The constructor "Keyczar" calls a virtual method "GetKeyHash".
Magic Number,Keyczar,HelperAttachedVerify,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\AttachedVerifier.cs,VerifyHidden,The following statement contains a magic number: using (var reader = new NondestructiveBinaryReader(input))                  {                      var header = reader.ReadBytes(HeaderLength);                      var length = Utility.ToInt32(reader.ReadBytes(4));                        if (fullLength < input.Position + length)                      {                          throw new InvalidCryptoDataException("Data doesn't appear to have signatures attached!");                      }                        using(var sigStream = new MemoryStream())                      {                          using (Utility.ResetStreamWhenFinished(input))                          {                              sigStream.Write(header' 0' header.Length);                              input.Seek(length' SeekOrigin.Current);                              while (reader.Peek() != -1 && input.Position < fullLength)                              {                                  var adjustedBufferSize = (int)Math.Min(BufferSize' (fullLength - input.Position));                                  var buffer = reader.ReadBytes(adjustedBufferSize);                                  sigStream.Write(buffer' 0' buffer.Length);                              }                               sigStream.Flush();                          }                          using (var signedMessageLimtedLength = new NondestructivePositionLengthLimitingStream(input))                          {                              signedMessageLimtedLength.SetLength(length);                              if (verifiedMessage != null)                              {                                  using (Utility.ResetStreamWhenFinished(input))                                  {                                      signedMessageLimtedLength.CopyTo(verifiedMessage);                                  }                              }                              var verified= Verify(signedMessageLimtedLength' sigStream.ToArray()' prefixData: null' postfixData: hidden' inputLength: inputLength);                              input.Seek(fullLength' SeekOrigin.Begin);                              return verified;                          }                      }                  }
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: Aes.KeySizes<AesKey>(128' 192' 256).DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: Aes.KeySizes<AesKey>(128' 192' 256).DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: Aes.KeySizes<AesKey>(128' 192' 256).DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: HmacSha1.KeySizes<HmacSha1Key>(256).DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: DsaPriv.KeySizes<DsaPrivateKey>(1024).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: DsaPub.KeySizes<DsaPublicKey>(1024).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: RsaPriv.KeySizes<RsaPrivateKey>(2048' 1024' 4096).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: RsaPriv.KeySizes<RsaPrivateKey>(2048' 1024' 4096).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: RsaPriv.KeySizes<RsaPrivateKey>(2048' 1024' 4096).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: RsaPub.KeySizes<RsaPublicKey>(2048' 1024' 4096).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: RsaPub.KeySizes<RsaPublicKey>(2048' 1024' 4096).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,KeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Metadata\KeyType.cs,KeyType,The following statement contains a magic number: RsaPub.KeySizes<RsaPublicKey>(2048' 1024' 4096).IsAsymmetric().DefineSpec();
Magic Number,Keyczar,SimpleAesHmacSha1KeyPacker,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\SessionCrypter.cs,Pack,The following statement contains a magic number: int outputSize = (1 + inputArrays.Length)*4;
Magic Number,Keyczar,SimpleAesHmacSha1KeyPacker,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\SessionCrypter.cs,Unpack,The following statement contains a magic number: using (Stream input = new MemoryStream(data))                  {                      var lengthBuffer = new byte[4];                      input.Read(lengthBuffer' 0' lengthBuffer.Length);                      int numArrays = Utility.ToInt32(lengthBuffer);                      byte[][] output = new byte[numArrays][];                      for (int i = 0; i < numArrays; i++)                      {                          input.Read(lengthBuffer' 0' lengthBuffer.Length);                          int len = Utility.ToInt32(lengthBuffer);                          byte[] array = new byte[len];                          input.Read(array' 0' array.Length);                          output[i] = array;                      }                      return new AesKey()                                 {                                     AesKeyBytes = output[0]'                                     HmacKey = new HmacSha1Key() {HmacKeyBytes = output[1]}'                                     Mode = "CBC"                                 };                  }
Magic Number,Keyczar,TimeoutVerifier,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\TimeoutVerifier.cs,FromDateTime,The following statement contains a magic number: return (long)((date.ToUniversalTime() - new DateTime(1970' 1' 1'0'0'0'DateTimeKind.Utc)).TotalMilliseconds);
Magic Number,Keyczar.Compat,Export,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Compat\Export.cs,ExportPrimaryAsPkcs,The following statement contains a magic number: using (var key = keySet.GetKey(i))              {                  using (var stream = new FileStream(location' FileMode.Create))                  using (var writer = new StreamWriter(stream))                  {                      var pemWriter = new Org.BouncyCastle.Utilities.IO.Pem.PemWriter(writer);                        AsymmetricKeyParameter writeKey;                      if (!(key is IPrivateKey))                      {                          if (key.KeyType == KeyType.DsaPub)                          {                              var dsaKey = (DsaPublicKey) key;                              writeKey = new DsaPublicKeyParameters(dsaKey.Y.ToBouncyBigInteger()'                                                                    new DsaParameters(                                                                        dsaKey.P.ToBouncyBigInteger()'                                                                        dsaKey.Q.ToBouncyBigInteger()'                                                                        dsaKey.G.ToBouncyBigInteger()));                          }                          else if (key is IRsaPublicKey)                          {                              var rsaKey = (IRsaPublicKey) key;                              writeKey = new RsaKeyParameters(false'                                                              rsaKey.Modulus.ToBouncyBigInteger()'                                                              rsaKey.PublicExponent.ToBouncyBigInteger());                          }                          else                          {                              throw new InvalidKeyTypeException("Non exportable key type.");                          }                            pemWriter.WriteObject(new MiscPemGenerator(writeKey));                      }                      else                      {                          if (key.KeyType == KeyType.DsaPriv)                          {                              var dsaKey = (DsaPrivateKey) key;                              writeKey = new DsaPrivateKeyParameters(dsaKey.X.ToBouncyBigInteger()'                                                                     new DsaParameters(                                                                         dsaKey.PublicKey.P.ToBouncyBigInteger()'                                                                         dsaKey.PublicKey.Q.ToBouncyBigInteger()'                                                                         dsaKey.PublicKey.G.ToBouncyBigInteger()));                          }                          else if (key is IRsaPrivateKey)                          {                              var rsaKey = (IRsaPrivateKey) key;                              writeKey = new RsaPrivateCrtKeyParameters(                                  rsaKey.PublicKey.Modulus.ToBouncyBigInteger()'                                  rsaKey.PublicKey.PublicExponent.ToBouncyBigInteger()'                                  rsaKey.PrivateExponent.ToBouncyBigInteger()'                                  rsaKey.PrimeP.ToBouncyBigInteger()'                                  rsaKey.PrimeQ.ToBouncyBigInteger()'                                  rsaKey.PrimeExponentP.ToBouncyBigInteger()'                                  rsaKey.PrimeExponentQ.ToBouncyBigInteger()'                                  rsaKey.CrtCoefficient.ToBouncyBigInteger());                          }                          else                          {                              throw new InvalidKeyTypeException("Non exportable key type.");                          }                            pemWriter.WriteObject(new Pkcs8Generator(writeKey' Pkcs8Generator.PbeSha1_RC2_128)                                                    {                                                        Password = (passwordPrompt() ?? String.Empty).ToCharArray()'                                                        SecureRandom = Secure.Random'                                                        IterationCount = 4096                                                    });                      }                  }              }
Magic Number,Keyczar.Crypto,AesKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\AesKey.cs,GenerateKey,The following statement contains a magic number: AesKeyBytes = new byte[size/8];
Magic Number,Keyczar.Crypto,DsaPrivateKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\DsaPrivateKey.cs,GenerateKey,The following statement contains a magic number: paramgen.Init(size' 100' Secure.Random);
Magic Number,Keyczar.Crypto,DsaPublicKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\DsaPublicKey.cs,GetDigest,The following statement contains a magic number: if (qSize <= 160)                  return new Sha1Digest();
Magic Number,Keyczar.Crypto,DsaPublicKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\DsaPublicKey.cs,GetDigest,The following statement contains a magic number: if (qSize <= 224)                  return new Sha224Digest();
Magic Number,Keyczar.Crypto,DsaPublicKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\DsaPublicKey.cs,GetDigest,The following statement contains a magic number: if (qSize <= 256)                  return new Sha256Digest();
Magic Number,Keyczar.Crypto,DsaPublicKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\DsaPublicKey.cs,GetDigest,The following statement contains a magic number: if (qSize <= 384)                  return new Sha384Digest();
Magic Number,Keyczar.Crypto,HmacSha1Key,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\HmacSha1Key.cs,GenerateKey,The following statement contains a magic number: HmacKeyBytes = new byte[size/8];
Magic Number,Keyczar.Crypto,RsaPrivateSignKeyBase<TPublicKey>,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\RsaPrivateSignKeyBase.cs,GetSigningStream,The following statement contains a magic number: return new DigestStream(signer' Size/8);
Magic Number,Keyczar.Crypto,RsaPublicSignKeyBase,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Crypto\RsaPublicSignKeyBase.cs,GetVerifyingStream,The following statement contains a magic number: return new DigestStream(signer' Size/8);
Magic Number,Keyczar.Pbe,PbeKeyStore,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,EncryptKeyData,The following statement contains a magic number: var pks = new PbeKeyStore()                            {                                Cipher = PbeKeyType.Aes128'                                Hmac = PbeHashType.HmacSha1'                                IterationCount = iterationCount'                                Salt = new byte[16]                            };
Magic Number,Keyczar.Pbe,PbeKeyStore,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,EncryptKeyData,The following statement contains a magic number: var pbeKey = new PbeAesKey() {Size = 128};
Magic Number,Keyczar.Pbe,PbeKeyStore,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,EncryptKeyData,The following statement contains a magic number: pbeKey.AesKeyBytes = pks.GetDerivedBytes(pbeKey.Size/8' passwordPrompt);
Magic Number,Keyczar.Pbe,PbeKeyStore,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,GetDerivedBytes,The following statement contains a magic number: var key = (KeyParameter) pdb.GenerateDerivedMacParameters(length*8);
Magic Number,Keyczar.Pbe,PbeKeyStore,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,DecryptKeyData,The following statement contains a magic number: if (Cipher == PbeKeyType.Aes128)              {                  key.Size = 128;              }              else              {                  throw new InvalidKeySetException("Unknown Pbe Cipher");              }
Magic Number,Keyczar.Pbe,PbeKeyStore,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,DecryptKeyData,The following statement contains a magic number: key.AesKeyBytes = GetDerivedBytes(key.Size/8' passwordPrompt);
Magic Number,Keyczar.Pbe,PbeAesKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\KeySet\Pbe\PbeKeyStore.cs,PbeAesKey,The following statement contains a magic number: IV = new byte[16];
Magic Number,Keyczar.Unofficial,AesAeadKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\AesAeadKey.cs,AesAeadKey,The following statement contains a magic number: IVLength = 12;
Magic Number,Keyczar.Unofficial,AesAeadKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\AesAeadKey.cs,GenerateKey,The following statement contains a magic number: AesKeyBytes = new byte[size/8];
Magic Number,Keyczar.Unofficial,AesAeadKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\AesAeadKey.cs,GetFallbackKeyHash,The following statement contains a magic number: if (IVLength == 16 && Mode == GcmMode)              {                  //Pre IVLength property existing key hash                  list.Add(Utility.HashKey(Keyczar.KeyHashLength' Utility.GetBytes(AesKeyBytes.Length)'                                           Encoding.UTF8.GetBytes(Mode)' AesKeyBytes));              }
Magic Number,Keyczar.Unofficial,AesAeadKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\AesAeadKey.cs,GetEncryptingStream,The following statement contains a magic number: return new SymmetricAeadStream(                  GetMode()'                  output'                  randomNonce'                  TagLength'                  (nonce' cipher' authdata' encrypt) =>                  cipher.Init(encrypt' new AeadParameters(GetKeyParameters()' TagLength*8' nonce' authdata))'                  encrypt: true                  );
Magic Number,Keyczar.Unofficial,AesAeadKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\AesAeadKey.cs,GetDecryptingStream,The following statement contains a magic number: return new SymmetricAeadStream(                  GetMode()'                  output'                  new byte[IVLength]'                  TagLength'                  (nonce' cipher' additionalData' encrypt) =>                  cipher.Init(encrypt' new AeadParameters(GetKeyParameters()' TagLength*8' nonce' additionalData))'                  encrypt: false                  );
Magic Number,Keyczar.Unofficial,RsaPrivateSignKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\RsaPrivateSignKey.cs,DigestForSize,The following statement contains a magic number: if (size <= 1024)                  return RsaPublicSignKey.Sha1Digest;
Magic Number,Keyczar.Unofficial,RsaPrivateSignKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\RsaPrivateSignKey.cs,DigestForSize,The following statement contains a magic number: if (size <= 2048)                  return RsaPublicSignKey.Sha224Digest;
Magic Number,Keyczar.Unofficial,RsaPrivateSignKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\RsaPrivateSignKey.cs,DigestForSize,The following statement contains a magic number: if (size <= 3072)                  return RsaPublicSignKey.Sha256Digest;
Magic Number,Keyczar.Unofficial,RsaPrivateSignKey,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\RsaPrivateSignKey.cs,DigestForSize,The following statement contains a magic number: if (size <= 7680)                  return RsaPublicSignKey.Sha384Digest;
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: AesAead.KeySizes<AesAeadKey>(256' 192' 128).IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: AesAead.KeySizes<AesAeadKey>(256' 192' 128).IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: AesAead.KeySizes<AesAeadKey>(256' 192' 128).IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPrivSign.KeySizes<RsaPrivateSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPrivSign.KeySizes<RsaPrivateSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPrivSign.KeySizes<RsaPrivateSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPrivSign.KeySizes<RsaPrivateSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPubSign.KeySizes<RsaPublicSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPubSign.KeySizes<RsaPublicSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPubSign.KeySizes<RsaPublicSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Unofficial,UnofficialKeyType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Unofficial\UnofficialKeyType.cs,UnofficialKeyType,The following statement contains a magic number: RSAPubSign.KeySizes<RsaPublicSignKey>(2048' 3072' 4096' 1024).IsAsymmetric().IsUnofficial().DefineSpec();
Magic Number,Keyczar.Util,StringType,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\StringEnum.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (Identifier.GetHashCode()*397) ^ GetType().GetHashCode();              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,WebSafeBase64,The following statement contains a magic number: for (int i = 0; i < WHITESPACE.Length; i++)              {                  DECODE[WHITESPACE[i]] = -2;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,GetByte,The following statement contains a magic number: if (i < 0 || i > 127 || DECODE[i] == -1)              {                  throw new Base64DecodingException("Invalid Encoding");              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,IsWhiteSpace,The following statement contains a magic number: return DECODE[i] == -2;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: int inputBlocks = input.Length/3;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: int remainder = input.Length%3;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: int outputLen = inputBlocks*4;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: switch (remainder)              {                  case 1:                      outputLen += 2;                      break;                  case 2:                      outputLen += 3;                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: switch (remainder)              {                  case 1:                      outputLen += 2;                      break;                  case 2:                      outputLen += 3;                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: switch (remainder)              {                  case 1:                      outputLen += 2;                      break;                  case 2:                      outputLen += 3;                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: for (int i = 0; i < inputBlocks; i++)              {                  int buffer = (0xFF & input[inPos++]) << 16 | (0xFF & input[inPos++]) << 8                               | (0xFF & input[inPos++]);                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  outChar[outPos++] = ALPHABET[buffer & 0x3F];              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: for (int i = 0; i < inputBlocks; i++)              {                  int buffer = (0xFF & input[inPos++]) << 16 | (0xFF & input[inPos++]) << 8                               | (0xFF & input[inPos++]);                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  outChar[outPos++] = ALPHABET[buffer & 0x3F];              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: for (int i = 0; i < inputBlocks; i++)              {                  int buffer = (0xFF & input[inPos++]) << 16 | (0xFF & input[inPos++]) << 8                               | (0xFF & input[inPos++]);                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  outChar[outPos++] = ALPHABET[buffer & 0x3F];              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: for (int i = 0; i < inputBlocks; i++)              {                  int buffer = (0xFF & input[inPos++]) << 16 | (0xFF & input[inPos++]) << 8                               | (0xFF & input[inPos++]);                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  outChar[outPos++] = ALPHABET[buffer & 0x3F];              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: for (int i = 0; i < inputBlocks; i++)              {                  int buffer = (0xFF & input[inPos++]) << 16 | (0xFF & input[inPos++]) << 8                               | (0xFF & input[inPos++]);                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  outChar[outPos++] = ALPHABET[buffer & 0x3F];              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following statement contains a magic number: if (remainder > 0)              {                  int buffer = (0xFF & input[inPos++]) << 16;                  if (remainder == 2)                  {                      buffer |= (0xFF & input[inPos++]) << 8;                  }                  outChar[outPos++] = ALPHABET[(buffer >> 18) & 0x3F];                  outChar[outPos++] = ALPHABET[(buffer >> 12) & 0x3F];                  if (remainder == 2)                  {                      outChar[outPos++] = ALPHABET[(buffer >> 6) & 0x3F];                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: int inputBlocks = inLen/4;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: int remainder = inLen%4;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: int outputLen = inputBlocks*3;
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (remainder)              {                  case 1:                      throw new Base64DecodingException("Invalid Length");                  case 2:                      outputLen += 1;                      break;                  case 3:                      outputLen += 2;                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (remainder)              {                  case 1:                      throw new Base64DecodingException("Invalid Length");                  case 2:                      outputLen += 1;                      break;                  case 3:                      outputLen += 2;                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (remainder)              {                  case 1:                      throw new Base64DecodingException("Invalid Length");                  case 2:                      outputLen += 1;                      break;                  case 3:                      outputLen += 2;                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: for (int i = 0; i < inLen + whiteSpaceChars; i++)              {                  if (!IsWhiteSpace(input[i]))                  {                      buffer = (buffer << 6) | GetByte(input[i]);                      buffCount++;                  }                  if (buffCount == 4)                  {                      outChar[outPos++] = (byte) (buffer >> 16);                      outChar[outPos++] = (byte) (buffer >> 8);                      outChar[outPos++] = (byte) buffer;                      buffer = 0;                      buffCount = 0;                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: for (int i = 0; i < inLen + whiteSpaceChars; i++)              {                  if (!IsWhiteSpace(input[i]))                  {                      buffer = (buffer << 6) | GetByte(input[i]);                      buffCount++;                  }                  if (buffCount == 4)                  {                      outChar[outPos++] = (byte) (buffer >> 16);                      outChar[outPos++] = (byte) (buffer >> 8);                      outChar[outPos++] = (byte) buffer;                      buffer = 0;                      buffCount = 0;                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: for (int i = 0; i < inLen + whiteSpaceChars; i++)              {                  if (!IsWhiteSpace(input[i]))                  {                      buffer = (buffer << 6) | GetByte(input[i]);                      buffCount++;                  }                  if (buffCount == 4)                  {                      outChar[outPos++] = (byte) (buffer >> 16);                      outChar[outPos++] = (byte) (buffer >> 8);                      outChar[outPos++] = (byte) buffer;                      buffer = 0;                      buffCount = 0;                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: for (int i = 0; i < inLen + whiteSpaceChars; i++)              {                  if (!IsWhiteSpace(input[i]))                  {                      buffer = (buffer << 6) | GetByte(input[i]);                      buffCount++;                  }                  if (buffCount == 4)                  {                      outChar[outPos++] = (byte) (buffer >> 16);                      outChar[outPos++] = (byte) (buffer >> 8);                      outChar[outPos++] = (byte) buffer;                      buffer = 0;                      buffCount = 0;                  }              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (buffCount)              {                  case 2:                      outChar[outPos++] = (byte) (buffer >> 4);                      break;                  case 3:                      outChar[outPos++] = (byte) (buffer >> 10);                      outChar[outPos++] = (byte) (buffer >> 2);                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (buffCount)              {                  case 2:                      outChar[outPos++] = (byte) (buffer >> 4);                      break;                  case 3:                      outChar[outPos++] = (byte) (buffer >> 10);                      outChar[outPos++] = (byte) (buffer >> 2);                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (buffCount)              {                  case 2:                      outChar[outPos++] = (byte) (buffer >> 4);                      break;                  case 3:                      outChar[outPos++] = (byte) (buffer >> 10);                      outChar[outPos++] = (byte) (buffer >> 2);                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (buffCount)              {                  case 2:                      outChar[outPos++] = (byte) (buffer >> 4);                      break;                  case 3:                      outChar[outPos++] = (byte) (buffer >> 10);                      outChar[outPos++] = (byte) (buffer >> 2);                      break;              }
Magic Number,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following statement contains a magic number: switch (buffCount)              {                  case 2:                      outChar[outPos++] = (byte) (buffer >> 4);                      break;                  case 3:                      outChar[outPos++] = (byte) (buffer >> 10);                      outChar[outPos++] = (byte) (buffer >> 2);                      break;              }
Missing Default,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Encode,The following switch statement is missing a default case: switch (remainder)              {                  case 1:                      outputLen += 2;                      break;                  case 2:                      outputLen += 3;                      break;              }
Missing Default,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following switch statement is missing a default case: switch (remainder)              {                  case 1:                      throw new Base64DecodingException("Invalid Length");                  case 2:                      outputLen += 1;                      break;                  case 3:                      outputLen += 2;                      break;              }
Missing Default,Keyczar.Util,WebSafeBase64,C:\repos\jbtule_keyczar-dotnet\Keyczar\Keyczar\Util\WebBase64Converter.cs,Decode,The following switch statement is missing a default case: switch (buffCount)              {                  case 2:                      outChar[outPos++] = (byte) (buffer >> 4);                      break;                  case 3:                      outChar[outPos++] = (byte) (buffer >> 10);                      outChar[outPos++] = (byte) (buffer >> 2);                      break;              }
