Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The method has 9 parameters. Parameters: kernel' inPixels' outPixels' width' height' alpha' premultiply' unpremultiply' edgeAction
Long Statement,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,ApplyChromaKey,The length of the statement  "                        if (Abs(hsb.Hue' keyHsb.Hue) < ToleranceHue && Abs(hsb.Saturation' keyHsb.Saturation) < ToleranceSaturnation && Abs(hsb.Brightness' keyHsb.Brightness) < ToleranceBrightness) { " is 175.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,Sharpen,The length of the statement  "            var tempBitmapData = tempBitmap.LockBits(new Rectangle(0' 0' tempBitmap.Width' tempBitmap.Height)' ImageLockMode.ReadWrite' tempBitmap.PixelFormat); " is 148.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,Sharpen,The length of the statement  "            var outBitmapData = outBitmap.LockBits(new Rectangle(0' 0' outBitmap.Width' outBitmap.Height)' ImageLockMode.ReadWrite' outBitmap.PixelFormat); " is 143.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ApplyGaussianBlur,The length of the statement  "            FastGaussianBlurFilter.ConvolveAndTranspose(kernel' bitmapData' tempBitmapData' bitmapData.Width' bitmapData.Height' UseAlpha' UseAlpha && PremultiplyAlpha' false' ConvolveFilter.EdgeMode.Clamp); " is 195.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ApplyGaussianBlur,The length of the statement  "            FastGaussianBlurFilter.ConvolveAndTranspose(kernel' tempBitmapData' outBitmapData' bitmapData.Height' bitmapData.Width' UseAlpha' false' UseAlpha && PremultiplyAlpha' ConvolveFilter.EdgeMode.Clamp); " is 198.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,Run,The length of the statement  "            var tempBitmapData = tempBitmap.LockBits(new Rectangle(0' 0' tempBitmap.Width' tempBitmap.Height)' ImageLockMode.ReadWrite' tempBitmap.PixelFormat); " is 148.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,Run,The length of the statement  "            ConvolveAndTranspose(Kernel' bitmapData' tempBitmapData' bitmapData.Width' bitmapData.Height' UseAlpha' UseAlpha && PremultiplyAlpha' false' EdgeMode.Clamp); " is 157.
Long Statement,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,Run,The length of the statement  "            ConvolveAndTranspose(Kernel' tempBitmapData' bitmapData' bitmapData.Height' bitmapData.Width' UseAlpha' false' UseAlpha && PremultiplyAlpha' EdgeMode.Clamp); " is 157.
Complex Conditional,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The conditional expression  "unpremultiply && hasAlpha && a != 0 && a != 255"  is complex.
Magic Number,Kaliko.ImageLibrary.FastFilters,FastContrastFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastContrastFilter.cs,ChangeContrast,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(bitmapData.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastContrastFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastContrastFilter.cs,ChangeContrast,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var red = currentLine[x];                          var green = currentLine[x + 1];                          var blue = currentLine[x + 2];                            currentLine[x] = lookupTable[red];                          currentLine[x + 1] = lookupTable[green];                          currentLine[x + 2] = lookupTable[blue];                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastContrastFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastContrastFilter.cs,ChangeContrast,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var red = currentLine[x];                          var green = currentLine[x + 1];                          var blue = currentLine[x + 2];                            currentLine[x] = lookupTable[red];                          currentLine[x + 1] = lookupTable[green];                          currentLine[x + 2] = lookupTable[blue];                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastBrightnessFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastBrightnessFilter.cs,ChangeBrightness,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(bitmapData.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastBrightnessFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastBrightnessFilter.cs,ChangeBrightness,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var red = currentLine[x];                          var green = currentLine[x + 1];                          var blue = currentLine[x + 2];                            currentLine[x] = lookupTable[red];                          currentLine[x + 1] = lookupTable[green];                          currentLine[x + 2] = lookupTable[blue];                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastBrightnessFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastBrightnessFilter.cs,ChangeBrightness,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var red = currentLine[x];                          var green = currentLine[x + 1];                          var blue = currentLine[x + 2];                            currentLine[x] = lookupTable[red];                          currentLine[x + 1] = lookupTable[green];                          currentLine[x + 2] = lookupTable[blue];                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: KeyColor = Color.FromArgb(0' 255' 0);
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: ToleranceHue = 10;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: ToleranceSaturnation = 0.7f;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: ToleranceBrightness = 0.5f;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: ToleranceHue = 10;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: ToleranceSaturnation = 0.7f;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,FastChromaKeyFilter,The following statement contains a magic number: ToleranceBrightness = 0.5f;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,ApplyChromaKey,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(bitmapData.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,ApplyChromaKey,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y * bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var red = currentLine[x];                          var green = currentLine[x + 1];                          var blue = currentLine[x + 2];                          var hsb = ColorSpaceHelper.RGBtoHSB(red' green' blue);                            if (Abs(hsb.Hue' keyHsb.Hue) < ToleranceHue && Abs(hsb.Saturation' keyHsb.Saturation) < ToleranceSaturnation && Abs(hsb.Brightness' keyHsb.Brightness) < ToleranceBrightness) {                              currentLine[x + 3] = 0;                          }                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,ApplyChromaKey,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y * bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var red = currentLine[x];                          var green = currentLine[x + 1];                          var blue = currentLine[x + 2];                          var hsb = ColorSpaceHelper.RGBtoHSB(red' green' blue);                            if (Abs(hsb.Hue' keyHsb.Hue) < ToleranceHue && Abs(hsb.Saturation' keyHsb.Saturation) < ToleranceSaturnation && Abs(hsb.Brightness' keyHsb.Brightness) < ToleranceBrightness) {                              currentLine[x + 3] = 0;                          }                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastChromaKeyFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastChromaKeyFilter.cs,ValidateParameters,The following statement contains a magic number: ToleranceHue < 0 || ToleranceHue > 360
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,FastUnsharpMaskFilter,The following statement contains a magic number: _radius = radius*3.14f;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ClampByte,The following statement contains a magic number: return 255;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ClampByte,The following statement contains a magic number: value > 255
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ApplyMask,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(bitmapData.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ApplyMask,The following statement contains a magic number: Parallel.For(0' height' y => {                  var currentOriginalLine = byteStart + (y*bitmapData.Stride);                  var currentBlurredLine = outStart + (y*bitmapData.Stride);                    for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                      var r1 = currentOriginalLine[x];                      var g1 = currentOriginalLine[x + 1];                      var b1 = currentOriginalLine[x + 2];                        var r2 = currentBlurredLine[x];                      var g2 = currentBlurredLine[x + 1];                      var b2 = currentBlurredLine[x + 2];                        if (Abs(r1' r2) >= threshold) {                          r1 = ClampByte(((amount + 1)*(r1 - r2) + r2));                      }                      if (Abs(g1' g2) >= threshold) {                          g1 = ClampByte(((amount + 1)*(g1 - g2) + g2));                      }                      if (Abs(b1' b2) >= threshold) {                          b1 = ClampByte(((amount + 1)*(b1 - b2) + b2));                      }                      currentOriginalLine[x] = r1;                      currentOriginalLine[x + 1] = g1;                      currentOriginalLine[x + 2] = b1;                  }              });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ApplyMask,The following statement contains a magic number: Parallel.For(0' height' y => {                  var currentOriginalLine = byteStart + (y*bitmapData.Stride);                  var currentBlurredLine = outStart + (y*bitmapData.Stride);                    for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                      var r1 = currentOriginalLine[x];                      var g1 = currentOriginalLine[x + 1];                      var b1 = currentOriginalLine[x + 2];                        var r2 = currentBlurredLine[x];                      var g2 = currentBlurredLine[x + 1];                      var b2 = currentBlurredLine[x + 2];                        if (Abs(r1' r2) >= threshold) {                          r1 = ClampByte(((amount + 1)*(r1 - r2) + r2));                      }                      if (Abs(g1' g2) >= threshold) {                          g1 = ClampByte(((amount + 1)*(g1 - g2) + g2));                      }                      if (Abs(b1' b2) >= threshold) {                          b1 = ClampByte(((amount + 1)*(b1 - b2) + b2));                      }                      currentOriginalLine[x] = r1;                      currentOriginalLine[x + 1] = g1;                      currentOriginalLine[x + 2] = b1;                  }              });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastUnsharpMaskFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastUnsharpMaskFilter.cs,ApplyMask,The following statement contains a magic number: Parallel.For(0' height' y => {                  var currentOriginalLine = byteStart + (y*bitmapData.Stride);                  var currentBlurredLine = outStart + (y*bitmapData.Stride);                    for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                      var r1 = currentOriginalLine[x];                      var g1 = currentOriginalLine[x + 1];                      var b1 = currentOriginalLine[x + 2];                        var r2 = currentBlurredLine[x];                      var g2 = currentBlurredLine[x + 1];                      var b2 = currentBlurredLine[x + 2];                        if (Abs(r1' r2) >= threshold) {                          r1 = ClampByte(((amount + 1)*(r1 - r2) + r2));                      }                      if (Abs(g1' g2) >= threshold) {                          g1 = ClampByte(((amount + 1)*(g1 - g2) + g2));                      }                      if (Abs(b1' b2) >= threshold) {                          b1 = ClampByte(((amount + 1)*(b1 - b2) + b2));                      }                      currentOriginalLine[x] = r1;                      currentOriginalLine[x + 1] = g1;                      currentOriginalLine[x + 2] = b1;                  }              });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastDesaturationFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastDesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(bitmapData.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastDesaturationFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastDesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var gray = (byte)(.299*currentLine[x + 2] + .587*currentLine[x + 1] + .114*currentLine[x]);                          currentLine[x] = currentLine[x + 1] = currentLine[x + 2] = gray;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastDesaturationFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastDesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var gray = (byte)(.299*currentLine[x + 2] + .587*currentLine[x + 1] + .114*currentLine[x]);                          currentLine[x] = currentLine[x + 1] = currentLine[x + 2] = gray;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastDesaturationFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastDesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var gray = (byte)(.299*currentLine[x + 2] + .587*currentLine[x + 1] + .114*currentLine[x]);                          currentLine[x] = currentLine[x + 1] = currentLine[x + 2] = gray;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastDesaturationFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastDesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var gray = (byte)(.299*currentLine[x + 2] + .587*currentLine[x + 1] + .114*currentLine[x]);                          currentLine[x] = currentLine[x + 1] = currentLine[x + 2] = gray;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastDesaturationFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastDesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = startOffset + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          var gray = (byte)(.299*currentLine[x + 2] + .587*currentLine[x + 1] + .114*currentLine[x]);                          currentLine[x] = currentLine[x + 1] = currentLine[x + 2] = gray;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastInvertFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastInvertFilter.cs,InvertImage,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(bitmapData.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastInvertFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastInvertFilter.cs,InvertImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = byteStart + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          currentLine[x] = (byte)(currentLine[x] ^ 255);                          currentLine[x + 1] = (byte)(currentLine[x + 1] ^ 255);                          currentLine[x + 2] = (byte)(currentLine[x + 2] ^ 255);                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastInvertFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastInvertFilter.cs,InvertImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = byteStart + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          currentLine[x] = (byte)(currentLine[x] ^ 255);                          currentLine[x + 1] = (byte)(currentLine[x + 1] ^ 255);                          currentLine[x + 2] = (byte)(currentLine[x + 2] ^ 255);                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastInvertFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastInvertFilter.cs,InvertImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = byteStart + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          currentLine[x] = (byte)(currentLine[x] ^ 255);                          currentLine[x + 1] = (byte)(currentLine[x + 1] ^ 255);                          currentLine[x + 2] = (byte)(currentLine[x + 2] ^ 255);                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastInvertFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastInvertFilter.cs,InvertImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = byteStart + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          currentLine[x] = (byte)(currentLine[x] ^ 255);                          currentLine[x + 1] = (byte)(currentLine[x + 1] ^ 255);                          currentLine[x + 2] = (byte)(currentLine[x + 2] ^ 255);                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastInvertFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastInvertFilter.cs,InvertImage,The following statement contains a magic number: Parallel.For(0' height' y => {                      var currentLine = byteStart + (y*bitmapData.Stride);                      for (var x = 0; x < widthInBytes; x = x + bytesPerPixel) {                          currentLine[x] = (byte)(currentLine[x] ^ 255);                          currentLine[x + 1] = (byte)(currentLine[x + 1] ^ 255);                          currentLine[x + 2] = (byte)(currentLine[x + 2] ^ 255);                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: var halfKernalWidth = kernel.Width/2;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: var bytesPerPixel = Image.GetPixelFormatSize(inPixels.PixelFormat)/8;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following statement contains a magic number: Parallel.For(0' height' y => {                      var index = y;                      var baseOffset = y*width;                        for (var x = 0; x < width; x++) {                          var r = 0f;                          var g = 0f;                          var b = 0f;                          var a = 0f;                            for (var col = -halfKernalWidth; col <= halfKernalWidth; col++) {                              var f = matrix[halfKernalWidth + col];                              if (f == 0) {                                  continue;                              }                                var offsetX = x + col;                              if (offsetX < 0) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              else if (offsetX >= width) {                                  switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }                              }                              var sourceOffset = sourceStart + ((baseOffset + offsetX)*bytesPerPixel);                              var sourceR = sourceOffset[0];                              var sourceG = sourceOffset[1];                              var sourceB = sourceOffset[2];                              byte sourceA = 0;                              if (hasAlpha) {                                  sourceA = sourceOffset[3];                              }                                if (premultiply && hasAlpha) {                                  var alphaMultiply = sourceA*(1.0f/255.0f);                                  sourceR = (byte)(sourceR*alphaMultiply);                                  sourceG = (byte)(sourceG*alphaMultiply);                                  sourceB = (byte)(sourceB*alphaMultiply);                              }                                if (hasAlpha) {                                  a += f*sourceA;                              }                              r += f*sourceR;                              g += f*sourceG;                              b += f*sourceB;                          }                            if (unpremultiply && hasAlpha && a != 0 && a != 255) {                              var f = 255.0f / a;                              r *= f;                              g *= f;                              b *= f;                          }                            var destinationA = alpha ? ClampByte((int)(a + 0.5)) : (byte)0xff;                          var destinationR = ClampByte(r + 0.5);                          var destinationG = ClampByte(g + 0.5);                          var destinationB = ClampByte(b + 0.5);                            var destOffset = destinationStart + (index*bytesPerPixel);                            destOffset[0] = destinationR;                          destOffset[1] = destinationG;                          destOffset[2] = destinationB;                          if (hasAlpha) {                              destOffset[3] = destinationA;                          }                          index += height;                      }                  });
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ClampByte,The following statement contains a magic number: return 255;
Magic Number,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ClampByte,The following statement contains a magic number: value > 255
Missing Default,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following switch statement is missing a default case: switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = 0;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }
Missing Default,Kaliko.ImageLibrary.FastFilters,FastGaussianBlurFilter,D:\research\architectureSmells\repos\fschultz_NetImageLibrary\FastFilters\FastGaussianBlur.cs,ConvolveAndTranspose,The following switch statement is missing a default case: switch (edgeAction) {                                      case EdgeMode.Clamp:                                          offsetX = width - 1;                                          break;                                      case EdgeMode.Wrap:                                          offsetX = (x + width)%width;                                          break;                                  }
