Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Kaliko.ImageLibrary,TextField,C:\repos\fschultz_NetImageLibrary\TextField.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,Cyclomatic complexity of the method is 9
Complex Method,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,Cyclomatic complexity of the method is 9
Long Parameter List,Kaliko.ImageLibrary,ImageOutput,C:\repos\fschultz_NetImageLibrary\ImageOutput.cs,SaveStream,The method has 5 parameters. Parameters: image' stream' quality' imageFormat' saveResolution
Long Parameter List,Kaliko.ImageLibrary,ImageOutput,C:\repos\fschultz_NetImageLibrary\ImageOutput.cs,SaveFile,The method has 5 parameters. Parameters: image' fileName' quality' imageFormat' saveResolution
Long Parameter List,Kaliko.ImageLibrary,KalikoImage,C:\repos\fschultz_NetImageLibrary\KalikoImage.cs,DrawScaledImage,The method has 6 parameters. Parameters: destinationImage' sourceImage' x' y' width' height
Long Parameter List,Kaliko.ImageLibrary,KalikoImage,C:\repos\fschultz_NetImageLibrary\KalikoImage.cs,DrawScaledImage,The method has 6 parameters. Parameters: destImage' sourceImage' x' y' width' height
Long Parameter List,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The method has 6 parameters. Parameters: r1' g1' b1' r2' g2' b2
Long Parameter List,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Convolve,The method has 6 parameters. Parameters: kernel' inPixels' outPixels' width' height' edgeAction
Long Parameter List,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Convolve,The method has 7 parameters. Parameters: kernel' inPixels' outPixels' width' height' alpha' edgeAction
Long Parameter List,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The method has 7 parameters. Parameters: kernel' inPixels' outPixels' width' height' alpha' edgeAction
Long Parameter List,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The method has 7 parameters. Parameters: kernel' inPixels' outPixels' width' height' alpha' edgeAction
Long Parameter List,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The method has 7 parameters. Parameters: kernel' inPixels' outPixels' width' height' alpha' edgeAction
Long Parameter List,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The method has 9 parameters. Parameters: kernel' inPixels' outPixels' width' height' alpha' premultiply' unpremultiply' edgeAction
Long Statement,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ApplyChromaKey,The length of the statement  "                if (Math.Abs(hsb.Hue - keyHsb.Hue) < ToleranceHue && Math.Abs(hsb.Saturation - keyHsb.Saturation) < ToleranceSaturnation && Math.Abs(hsb.Brightness - keyHsb.Brightness) < ToleranceBrightness) { " is 193.
Long Statement,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,Run,The length of the statement  "                ConvolveAndTranspose(Kernel' inPixels' outPixels' image.Width' image.Height' UseAlpha' UseAlpha && PremultiplyAlpha' false' EdgeMode.Clamp); " is 140.
Long Statement,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,Run,The length of the statement  "                ConvolveAndTranspose(Kernel' outPixels' inPixels' image.Height' image.Width' UseAlpha' false' UseAlpha && PremultiplyAlpha' EdgeMode.Clamp); " is 140.
Long Statement,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The length of the statement  "                GaussianBlurFilter.ConvolveAndTranspose(kernel' inPixels' workPixels' image.Width' image.Height' true' true' false' ConvolveFilter.EdgeMode.Clamp); " is 147.
Long Statement,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The length of the statement  "                GaussianBlurFilter.ConvolveAndTranspose(kernel' workPixels' outPixels' image.Height' image.Width' true' false' true' ConvolveFilter.EdgeMode.Clamp); " is 148.
Long Statement,Kaliko.ImageLibrary.Scaling,CropScaling,C:\repos\fschultz_NetImageLibrary\Scaling\CropScaling.cs,DrawResizedImage,The length of the statement  "            KalikoImage.DrawScaledImage(resizedImage' sourceImage' (_targetSize.Width - calculatedSize.Width) / 2' (_targetSize.Height - calculatedSize.Height) / 2' calculatedSize.Width' calculatedSize.Height); " is 198.
Long Statement,Kaliko.ImageLibrary.Scaling,PadScaling,C:\repos\fschultz_NetImageLibrary\Scaling\PadScaling.cs,DrawResizedImage,The length of the statement  "            KalikoImage.DrawScaledImage(resizedImage' sourceImage' (_targetSize.Width - calculatedSize.Width) / 2' (_targetSize.Height - calculatedSize.Height) / 2' calculatedSize.Width' calculatedSize.Height); " is 198.
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,ColorHandler,C:\repos\fschultz_NetImageLibrary\ColorHandler.cs,StringToColor,The following statement contains a magic number: if(colorString.Length == 3) {                  // Convert from RGB-form                  color = Color.FromArgb(255' (c & 0xf00) >> 8' (c & 0x0f0) >> 4' (c & 0x00f));              }              else {                  // Convert from RRGGBB-form                  color = Color.FromArgb(255' (c & 0xff0000) >> 16' (c & 0x00ff00) >> 8' (c & 0x0000ff));              }
Magic Number,Kaliko.ImageLibrary,KalikoImage,C:\repos\fschultz_NetImageLibrary\KalikoImage.cs,KalikoImage,The following statement contains a magic number: string prefix = filepath.Length > 8 ? filepath.Substring(0' 8).ToLower() : "";
Magic Number,Kaliko.ImageLibrary,KalikoImage,C:\repos\fschultz_NetImageLibrary\KalikoImage.cs,KalikoImage,The following statement contains a magic number: string prefix = filepath.Length > 8 ? filepath.Substring(0' 8).ToLower() : "";
Magic Number,Kaliko.ImageLibrary,KalikoImage,C:\repos\fschultz_NetImageLibrary\KalikoImage.cs,LoadImageFromUrl,The following statement contains a magic number: var data = new byte[256];
Magic Number,Kaliko.ImageLibrary,TextField,C:\repos\fschultz_NetImageLibrary\TextField.cs,Draw,The following statement contains a magic number: if (Font == null) {                  Font = image.Font ?? new Font("Arial"' 32' FontStyle.Bold' GraphicsUnit.Pixel);              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,CIEXYZ,C:\repos\fschultz_NetImageLibrary\ColorSpace\CIEXYZ.cs,CIEXYZ,The following statement contains a magic number: this.x = (x > 0.9505) ? 0.9505 : ((x < 0) ? 0 : x);
Magic Number,Kaliko.ImageLibrary.ColorSpace,CIEXYZ,C:\repos\fschultz_NetImageLibrary\ColorSpace\CIEXYZ.cs,CIEXYZ,The following statement contains a magic number: this.x = (x > 0.9505) ? 0.9505 : ((x < 0) ? 0 : x);
Magic Number,Kaliko.ImageLibrary.ColorSpace,CIEXYZ,C:\repos\fschultz_NetImageLibrary\ColorSpace\CIEXYZ.cs,CIEXYZ,The following statement contains a magic number: this.z = (z > 1.089) ? 1.089 : ((z < 0) ? 0 : z);
Magic Number,Kaliko.ImageLibrary.ColorSpace,CIEXYZ,C:\repos\fschultz_NetImageLibrary\ColorSpace\CIEXYZ.cs,CIEXYZ,The following statement contains a magic number: this.z = (z > 1.089) ? 1.089 : ((z < 0) ? 0 : z);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: return GetColorDistance(color1[0]' color1[1]' color1[2]' color2[0]' color2[1]' color2[2]);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: return GetColorDistance(color1[0]' color1[1]' color1[2]' color2[0]' color2[1]' color2[2]);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: double[] rgb1 = new double[] {                  (double)c1.R/255.0'                  (double)c1.G/255.0'                  (double)c1.B/255.0              };
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: double[] rgb1 = new double[] {                  (double)c1.R/255.0'                  (double)c1.G/255.0'                  (double)c1.B/255.0              };
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: double[] rgb1 = new double[] {                  (double)c1.R/255.0'                  (double)c1.G/255.0'                  (double)c1.B/255.0              };
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: double[] rgb2 = new double[] {                  (double)c2.R/255.0'                  (double)c2.G/255.0'                  (double)c2.B/255.0              };
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: double[] rgb2 = new double[] {                  (double)c2.R/255.0'                  (double)c2.G/255.0'                  (double)c2.B/255.0              };
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: double[] rgb2 = new double[] {                  (double)c2.R/255.0'                  (double)c2.G/255.0'                  (double)c2.B/255.0              };
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: return GetColorDistance(rgb1[0]' rgb1[1]' rgb1[2]' rgb2[0]' rgb2[1]' rgb2[2]);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetColorDistance,The following statement contains a magic number: return GetColorDistance(rgb1[0]' rgb1[1]' rgb1[2]' rgb2[0]' rgb2[1]' rgb2[2]);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetWheelColors,The following statement contains a magic number: int colorCount = 6*256;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetWheelColors,The following statement contains a magic number: int colorCount = 6*256;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetWheelColors,The following statement contains a magic number: for (int i = 0; i < colorCount; i++) {                  temp = HSBtoColor((int)((double)(i*255.0)/colorCount)' 255' 255);                  colors[i] = Color.FromArgb(alpha' temp.R' temp.G' temp.B);              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetWheelColors,The following statement contains a magic number: for (int i = 0; i < colorCount; i++) {                  temp = HSBtoColor((int)((double)(i*255.0)/colorCount)' 255' 255);                  colors[i] = Color.FromArgb(alpha' temp.R' temp.G' temp.B);              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetWheelColors,The following statement contains a magic number: for (int i = 0; i < colorCount; i++) {                  temp = HSBtoColor((int)((double)(i*255.0)/colorCount)' 255' 255);                  colors[i] = Color.FromArgb(alpha' temp.R' temp.G' temp.B);              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: Color[] colors = new Color[256*6];
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: Color[] colors = new Color[256*6];
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i] = Color.FromArgb(alpha' 255' i' 0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i] = Color.FromArgb(alpha' 255' i' 0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256)] = Color.FromArgb(alpha' 255 - i' 255' 0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256)] = Color.FromArgb(alpha' 255 - i' 255' 0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256)] = Color.FromArgb(alpha' 255 - i' 255' 0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256)] = Color.FromArgb(alpha' 255 - i' 255' 0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*2)] = Color.FromArgb(alpha' 0' 255' i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*2)] = Color.FromArgb(alpha' 0' 255' i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*2)] = Color.FromArgb(alpha' 0' 255' i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*2)] = Color.FromArgb(alpha' 0' 255' i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*3)] = Color.FromArgb(alpha' 0' 255 - i' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*3)] = Color.FromArgb(alpha' 0' 255 - i' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*3)] = Color.FromArgb(alpha' 0' 255 - i' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*3)] = Color.FromArgb(alpha' 0' 255 - i' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*3)] = Color.FromArgb(alpha' 0' 255 - i' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*4)] = Color.FromArgb(alpha' i' 0' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*4)] = Color.FromArgb(alpha' i' 0' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*4)] = Color.FromArgb(alpha' i' 0' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*4)] = Color.FromArgb(alpha' i' 0' 255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*5)] = Color.FromArgb(alpha' 255' 0' 255 - i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*5)] = Color.FromArgb(alpha' 255' 0' 255 - i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*5)] = Color.FromArgb(alpha' 255' 0' 255 - i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*5)] = Color.FromArgb(alpha' 255' 0' 255 - i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: for (int i = 0; i < 256; i++) colors[i + (256*5)] = Color.FromArgb(alpha' 255' 0' 255 - i);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetSpectrumColors,The following statement contains a magic number: return GetSpectrumColors(255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetIntFromHex,The following statement contains a magic number: switch (strHex) {                  case ("A"): {                      return 10;                  }                  case ("B"): {                      return 11;                  }                  case ("C"): {                      return 12;                  }                  case ("D"): {                      return 13;                  }                  case ("E"): {                      return 14;                  }                  case ("F"): {                      return 15;                  }                  default: {                      return int.Parse(strHex);                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetIntFromHex,The following statement contains a magic number: switch (strHex) {                  case ("A"): {                      return 10;                  }                  case ("B"): {                      return 11;                  }                  case ("C"): {                      return 12;                  }                  case ("D"): {                      return 13;                  }                  case ("E"): {                      return 14;                  }                  case ("F"): {                      return 15;                  }                  default: {                      return int.Parse(strHex);                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetIntFromHex,The following statement contains a magic number: switch (strHex) {                  case ("A"): {                      return 10;                  }                  case ("B"): {                      return 11;                  }                  case ("C"): {                      return 12;                  }                  case ("D"): {                      return 13;                  }                  case ("E"): {                      return 14;                  }                  case ("F"): {                      return 15;                  }                  default: {                      return int.Parse(strHex);                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetIntFromHex,The following statement contains a magic number: switch (strHex) {                  case ("A"): {                      return 10;                  }                  case ("B"): {                      return 11;                  }                  case ("C"): {                      return 12;                  }                  case ("D"): {                      return 13;                  }                  case ("E"): {                      return 14;                  }                  case ("F"): {                      return 15;                  }                  default: {                      return int.Parse(strHex);                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetIntFromHex,The following statement contains a magic number: switch (strHex) {                  case ("A"): {                      return 10;                  }                  case ("B"): {                      return 11;                  }                  case ("C"): {                      return 12;                  }                  case ("D"): {                      return 13;                  }                  case ("E"): {                      return 14;                  }                  case ("F"): {                      return 15;                  }                  default: {                      return int.Parse(strHex);                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,GetIntFromHex,The following statement contains a magic number: switch (strHex) {                  case ("A"): {                      return 10;                  }                  case ("B"): {                      return 11;                  }                  case ("C"): {                      return 12;                  }                  case ("D"): {                      return 13;                  }                  case ("E"): {                      return 14;                  }                  case ("F"): {                      return 15;                  }                  default: {                      return int.Parse(strHex);                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HexToColor,The following statement contains a magic number: if (hexColor != String.Empty) {                  hexColor = hexColor.Trim();                  if (hexColor[0] == '#') hexColor = hexColor.Substring(1' hexColor.Length - 1);                    r = hexColor.Substring(0' 2);                  g = hexColor.Substring(2' 2);                  b = hexColor.Substring(4' 2);                    r = Convert.ToString(16*GetIntFromHex(r.Substring(0' 1)) + GetIntFromHex(r.Substring(1' 1)));                  g = Convert.ToString(16*GetIntFromHex(g.Substring(0' 1)) + GetIntFromHex(g.Substring(1' 1)));                  b = Convert.ToString(16*GetIntFromHex(b.Substring(0' 1)) + GetIntFromHex(b.Substring(1' 1)));                    return Color.FromArgb(Convert.ToInt32(r)' Convert.ToInt32(g)' Convert.ToInt32(b));              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: if (hsb.Saturation == 0) {                  r = g = b = hsb.Brightness;              }              else {                  // the color wheel consists of 6 sectors. Figure out which sector you're in.                  double sectorPos = hsb.Hue/60.0;                  int sectorNumber = (int)(Math.Floor(sectorPos));                  // get the fractional part of the sector                  double fractionalSector = sectorPos - sectorNumber;                    // calculate values for the three axes of the color.                   double p = hsb.Brightness*(1.0 - hsb.Saturation);                  double q = hsb.Brightness*(1.0 - (hsb.Saturation*fractionalSector));                  double t = hsb.Brightness*(1.0 - (hsb.Saturation*(1 - fractionalSector)));                    // assign the fractional colors to r' g' and b based on the sector the angle is in.                  switch (sectorNumber) {                      case 0:                          r = hsb.Brightness;                          g = t;                          b = p;                          break;                      case 1:                          r = q;                          g = hsb.Brightness;                          b = p;                          break;                      case 2:                          r = p;                          g = hsb.Brightness;                          b = t;                          break;                      case 3:                          r = p;                          g = q;                          b = hsb.Brightness;                          break;                      case 4:                          r = t;                          g = p;                          b = hsb.Brightness;                          break;                      case 5:                          r = hsb.Brightness;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: if (hsb.Saturation == 0) {                  r = g = b = hsb.Brightness;              }              else {                  // the color wheel consists of 6 sectors. Figure out which sector you're in.                  double sectorPos = hsb.Hue/60.0;                  int sectorNumber = (int)(Math.Floor(sectorPos));                  // get the fractional part of the sector                  double fractionalSector = sectorPos - sectorNumber;                    // calculate values for the three axes of the color.                   double p = hsb.Brightness*(1.0 - hsb.Saturation);                  double q = hsb.Brightness*(1.0 - (hsb.Saturation*fractionalSector));                  double t = hsb.Brightness*(1.0 - (hsb.Saturation*(1 - fractionalSector)));                    // assign the fractional colors to r' g' and b based on the sector the angle is in.                  switch (sectorNumber) {                      case 0:                          r = hsb.Brightness;                          g = t;                          b = p;                          break;                      case 1:                          r = q;                          g = hsb.Brightness;                          b = p;                          break;                      case 2:                          r = p;                          g = hsb.Brightness;                          b = t;                          break;                      case 3:                          r = p;                          g = q;                          b = hsb.Brightness;                          break;                      case 4:                          r = t;                          g = p;                          b = hsb.Brightness;                          break;                      case 5:                          r = hsb.Brightness;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: if (hsb.Saturation == 0) {                  r = g = b = hsb.Brightness;              }              else {                  // the color wheel consists of 6 sectors. Figure out which sector you're in.                  double sectorPos = hsb.Hue/60.0;                  int sectorNumber = (int)(Math.Floor(sectorPos));                  // get the fractional part of the sector                  double fractionalSector = sectorPos - sectorNumber;                    // calculate values for the three axes of the color.                   double p = hsb.Brightness*(1.0 - hsb.Saturation);                  double q = hsb.Brightness*(1.0 - (hsb.Saturation*fractionalSector));                  double t = hsb.Brightness*(1.0 - (hsb.Saturation*(1 - fractionalSector)));                    // assign the fractional colors to r' g' and b based on the sector the angle is in.                  switch (sectorNumber) {                      case 0:                          r = hsb.Brightness;                          g = t;                          b = p;                          break;                      case 1:                          r = q;                          g = hsb.Brightness;                          b = p;                          break;                      case 2:                          r = p;                          g = hsb.Brightness;                          b = t;                          break;                      case 3:                          r = p;                          g = q;                          b = hsb.Brightness;                          break;                      case 4:                          r = t;                          g = p;                          b = hsb.Brightness;                          break;                      case 5:                          r = hsb.Brightness;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: if (hsb.Saturation == 0) {                  r = g = b = hsb.Brightness;              }              else {                  // the color wheel consists of 6 sectors. Figure out which sector you're in.                  double sectorPos = hsb.Hue/60.0;                  int sectorNumber = (int)(Math.Floor(sectorPos));                  // get the fractional part of the sector                  double fractionalSector = sectorPos - sectorNumber;                    // calculate values for the three axes of the color.                   double p = hsb.Brightness*(1.0 - hsb.Saturation);                  double q = hsb.Brightness*(1.0 - (hsb.Saturation*fractionalSector));                  double t = hsb.Brightness*(1.0 - (hsb.Saturation*(1 - fractionalSector)));                    // assign the fractional colors to r' g' and b based on the sector the angle is in.                  switch (sectorNumber) {                      case 0:                          r = hsb.Brightness;                          g = t;                          b = p;                          break;                      case 1:                          r = q;                          g = hsb.Brightness;                          b = p;                          break;                      case 2:                          r = p;                          g = hsb.Brightness;                          b = t;                          break;                      case 3:                          r = p;                          g = q;                          b = hsb.Brightness;                          break;                      case 4:                          r = t;                          g = p;                          b = hsb.Brightness;                          break;                      case 5:                          r = hsb.Brightness;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: if (hsb.Saturation == 0) {                  r = g = b = hsb.Brightness;              }              else {                  // the color wheel consists of 6 sectors. Figure out which sector you're in.                  double sectorPos = hsb.Hue/60.0;                  int sectorNumber = (int)(Math.Floor(sectorPos));                  // get the fractional part of the sector                  double fractionalSector = sectorPos - sectorNumber;                    // calculate values for the three axes of the color.                   double p = hsb.Brightness*(1.0 - hsb.Saturation);                  double q = hsb.Brightness*(1.0 - (hsb.Saturation*fractionalSector));                  double t = hsb.Brightness*(1.0 - (hsb.Saturation*(1 - fractionalSector)));                    // assign the fractional colors to r' g' and b based on the sector the angle is in.                  switch (sectorNumber) {                      case 0:                          r = hsb.Brightness;                          g = t;                          b = p;                          break;                      case 1:                          r = q;                          g = hsb.Brightness;                          b = p;                          break;                      case 2:                          r = p;                          g = hsb.Brightness;                          b = t;                          break;                      case 3:                          r = p;                          g = q;                          b = hsb.Brightness;                          break;                      case 4:                          r = t;                          g = p;                          b = hsb.Brightness;                          break;                      case 5:                          r = hsb.Brightness;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' r*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' g*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' b*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' r*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' g*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' b*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' r*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' g*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' b*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoColor,The following statement contains a magic number: if (h > 360 || s > 1 || b > 1) {                  hue = ((double)h/255.0*360.0)%360.0;                  sat = (double)s/255.0;                  val = (double)b/255.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoColor,The following statement contains a magic number: if (h > 360 || s > 1 || b > 1) {                  hue = ((double)h/255.0*360.0)%360.0;                  sat = (double)s/255.0;                  val = (double)b/255.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoColor,The following statement contains a magic number: if (h > 360 || s > 1 || b > 1) {                  hue = ((double)h/255.0*360.0)%360.0;                  sat = (double)s/255.0;                  val = (double)b/255.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoColor,The following statement contains a magic number: if (h > 360 || s > 1 || b > 1) {                  hue = ((double)h/255.0*360.0)%360.0;                  sat = (double)s/255.0;                  val = (double)b/255.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoColor,The following statement contains a magic number: if (h > 360 || s > 1 || b > 1) {                  hue = ((double)h/255.0*360.0)%360.0;                  sat = (double)s/255.0;                  val = (double)b/255.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoColor,The following statement contains a magic number: if (h > 360 || s > 1 || b > 1) {                  hue = ((double)h/255.0*360.0)%360.0;                  sat = (double)s/255.0;                  val = (double)b/255.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSLtoRGB,The following statement contains a magic number: if (s == 0) {                  // achromatic color (gray scale)                  return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' l*255.0)))                      );              }              else {                  double q = (l < 0.5) ? (l*(1.0 + s)) : (l + s - (l*s));                  double p = (2.0*l) - q;                    double Hk = h/360.0;                  double[] T = new double[3];                  T[0] = Hk + (1.0/3.0); // Tr                  T[1] = Hk; // Tb                  T[2] = Hk - (1.0/3.0); // Tg                    for (int i = 0; i < 3; i++) {                      if (T[i] < 0) T[i] += 1.0;                      if (T[i] > 1) T[i] -= 1.0;                        if ((T[i]*6) < 1) {                          T[i] = p + ((q - p)*6.0*T[i]);                      }                      else if ((T[i]*2.0) < 1) //(1.0/6.0)<=T[i] && T[i]<0.5                      {                          T[i] = q;                      }                      else if ((T[i]*3.0) < 2) // 0.5<=T[i] && T[i]<(2.0/3.0)                      {                          T[i] = p + (q - p)*((2.0/3.0) - T[i])*6.0;                      }                      else T[i] = p;                  }                    return new RGB(                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[0]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[1]*255.0)))'                      Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' T[2]*255.0)))                      );              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: double nRed = (double)red/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: double nGreen = (double)green/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: double nBlue = (double)blue/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (max == min) {                  h = 0; // undefined              }              else if (max == nRed && nGreen >= nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min);              }              else if (max == nRed && nGreen < nBlue) {                  h = 60.0*(nGreen - nBlue)/(max - min) + 360.0;              }              else if (max == nGreen) {                  h = 60.0*(nBlue - nRed)/(max - min) + 120.0;              }              else if (max == nBlue) {                  h = 60.0*(nRed - nGreen)/(max - min) + 240.0;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: l = (max + min)/2.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (l == 0 || max == min) {                  s = 0;              }              else if (0 < l && l <= 0.5) {                  s = (max - min)/(max + min);              }              else if (l > 0.5) {                  s = (max - min)/(2 - (max + min)); //(max-min > 0)?              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (l == 0 || max == min) {                  s = 0;              }              else if (0 < l && l <= 0.5) {                  s = (max - min)/(max + min);              }              else if (l > 0.5) {                  s = (max - min)/(2 - (max + min)); //(max-min > 0)?              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSL,The following statement contains a magic number: if (l == 0 || max == min) {                  s = 0;              }              else if (0 < l && l <= 0.5) {                  s = (max - min)/(max + min);              }              else if (l > 0.5) {                  s = (max - min)/(2 - (max + min)); //(max-min > 0)?              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: double r = ((double)red/255.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: double g = ((double)green/255.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: double b = ((double)blue/255.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoHSB,The following statement contains a magic number: if (max == r && g >= b) {                  if (max - min == 0) h = 0.0;                  else h = 60*(g - b)/(max - min);              }              else if (max == r && g < b) {                  h = 60*(g - b)/(max - min) + 360;              }              else if (max == g) {                  h = 60*(b - r)/(max - min) + 120;              }              else if (max == b) {                  h = 60*(r - g)/(max - min) + 240;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoCMYK,The following statement contains a magic number: double c = (double)(255 - red)/255;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoCMYK,The following statement contains a magic number: double c = (double)(255 - red)/255;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoCMYK,The following statement contains a magic number: double m = (double)(255 - green)/255;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoCMYK,The following statement contains a magic number: double m = (double)(255 - green)/255;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoCMYK,The following statement contains a magic number: double y = (double)(255 - blue)/255;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoCMYK,The following statement contains a magic number: double y = (double)(255 - blue)/255;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: double nRed = (double)red/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: double nGreen = (double)green/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: double nBlue = (double)blue/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.Y = 0.299*nRed + 0.587*nGreen + 0.114*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.Y = 0.299*nRed + 0.587*nGreen + 0.114*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.Y = 0.299*nRed + 0.587*nGreen + 0.114*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.U = -0.1471376975169300226*nRed - 0.2888623024830699774*nGreen + 0.436*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.U = -0.1471376975169300226*nRed - 0.2888623024830699774*nGreen + 0.436*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.U = -0.1471376975169300226*nRed - 0.2888623024830699774*nGreen + 0.436*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.V = 0.615*nRed - 0.5149857346647646220*nGreen - 0.1000142653352353780*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.V = 0.615*nRed - 0.5149857346647646220*nGreen - 0.1000142653352353780*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoYUV,The following statement contains a magic number: yuv.V = 0.615*nRed - 0.5149857346647646220*nGreen - 0.1000142653352353780*nBlue;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double rLinear = (double)red/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double gLinear = (double)green/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double bLinear = (double)blue/255.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double r = (rLinear > 0.04045) ? Math.Pow((rLinear + 0.055)/(1 + 0.055)' 2.2) : (rLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double r = (rLinear > 0.04045) ? Math.Pow((rLinear + 0.055)/(1 + 0.055)' 2.2) : (rLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double r = (rLinear > 0.04045) ? Math.Pow((rLinear + 0.055)/(1 + 0.055)' 2.2) : (rLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double r = (rLinear > 0.04045) ? Math.Pow((rLinear + 0.055)/(1 + 0.055)' 2.2) : (rLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double r = (rLinear > 0.04045) ? Math.Pow((rLinear + 0.055)/(1 + 0.055)' 2.2) : (rLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double g = (gLinear > 0.04045) ? Math.Pow((gLinear + 0.055)/(1 + 0.055)' 2.2) : (gLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double g = (gLinear > 0.04045) ? Math.Pow((gLinear + 0.055)/(1 + 0.055)' 2.2) : (gLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double g = (gLinear > 0.04045) ? Math.Pow((gLinear + 0.055)/(1 + 0.055)' 2.2) : (gLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double g = (gLinear > 0.04045) ? Math.Pow((gLinear + 0.055)/(1 + 0.055)' 2.2) : (gLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double g = (gLinear > 0.04045) ? Math.Pow((gLinear + 0.055)/(1 + 0.055)' 2.2) : (gLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double b = (bLinear > 0.04045) ? Math.Pow((bLinear + 0.055)/(1 + 0.055)' 2.2) : (bLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double b = (bLinear > 0.04045) ? Math.Pow((bLinear + 0.055)/(1 + 0.055)' 2.2) : (bLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double b = (bLinear > 0.04045) ? Math.Pow((bLinear + 0.055)/(1 + 0.055)' 2.2) : (bLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double b = (bLinear > 0.04045) ? Math.Pow((bLinear + 0.055)/(1 + 0.055)' 2.2) : (bLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: double b = (bLinear > 0.04045) ? Math.Pow((bLinear + 0.055)/(1 + 0.055)' 2.2) : (bLinear/12.92);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,RGBtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (r*0.4124 + g*0.3576 + b*0.1805)'                  (r*0.2126 + g*0.7152 + b*0.0722)'                  (r*0.0193 + g*0.1192 + b*0.9505)                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,CMYKtoColor,The following statement contains a magic number: int red = Convert.ToInt32((1 - cmyk.Cyan)*(1 - cmyk.Black)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,CMYKtoColor,The following statement contains a magic number: int green = Convert.ToInt32((1 - cmyk.Magenta)*(1 - cmyk.Black)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,CMYKtoColor,The following statement contains a magic number: int blue = Convert.ToInt32((1 - cmyk.Yellow)*(1 - cmyk.Black)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,CMYKtoRGB,The following statement contains a magic number: int red = Convert.ToInt32((1.0 - c)*(1.0 - k)*255.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,CMYKtoRGB,The following statement contains a magic number: int green = Convert.ToInt32((1.0 - m)*(1.0 - k)*255.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,CMYKtoRGB,The following statement contains a magic number: int blue = Convert.ToInt32((1.0 - y)*(1.0 - k)*255.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Red = Convert.ToInt32((y + 1.139837398373983740*v)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Red = Convert.ToInt32((y + 1.139837398373983740*v)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Green = Convert.ToInt32((y - 0.3946517043589703515*u - 0.5805986066674976801*v)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Green = Convert.ToInt32((y - 0.3946517043589703515*u - 0.5805986066674976801*v)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Green = Convert.ToInt32((y - 0.3946517043589703515*u - 0.5805986066674976801*v)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Blue = Convert.ToInt32((y + 2.032110091743119266*u)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,YUVtoRGB,The following statement contains a magic number: rgb.Blue = Convert.ToInt32((y + 2.032110091743119266*u)*255);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: double[] Clinear = new double[3];
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[0] = x*3.2410 - y*1.5374 - z*0.4986;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[0] = x*3.2410 - y*1.5374 - z*0.4986;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[0] = x*3.2410 - y*1.5374 - z*0.4986;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[1] = -x*0.9692 + y*1.8760 - z*0.0416;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[1] = -x*0.9692 + y*1.8760 - z*0.0416;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[1] = -x*0.9692 + y*1.8760 - z*0.0416;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[2] = x*0.0556 - y*0.2040 + z*1.0570;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[2] = x*0.0556 - y*0.2040 + z*1.0570;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[2] = x*0.0556 - y*0.2040 + z*1.0570;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: Clinear[2] = x*0.0556 - y*0.2040 + z*1.0570;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: for (int i = 0; i < 3; i++) {                  Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92*Clinear[i] : (1 + 0.055)*Math.Pow(Clinear[i]' (1.0/2.4)) - 0.055;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: for (int i = 0; i < 3; i++) {                  Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92*Clinear[i] : (1 + 0.055)*Math.Pow(Clinear[i]' (1.0/2.4)) - 0.055;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: for (int i = 0; i < 3; i++) {                  Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92*Clinear[i] : (1 + 0.055)*Math.Pow(Clinear[i]' (1.0/2.4)) - 0.055;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: for (int i = 0; i < 3; i++) {                  Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92*Clinear[i] : (1 + 0.055)*Math.Pow(Clinear[i]' (1.0/2.4)) - 0.055;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: for (int i = 0; i < 3; i++) {                  Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92*Clinear[i] : (1 + 0.055)*Math.Pow(Clinear[i]' (1.0/2.4)) - 0.055;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: for (int i = 0; i < 3; i++) {                  Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92*Clinear[i] : (1 + 0.055)*Math.Pow(Clinear[i]' (1.0/2.4)) - 0.055;              }
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[0]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[1]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[2]*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[0]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[1]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[2]*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[0]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[1]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[2]*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoRGB,The following statement contains a magic number: return new RGB(                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[0]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[1]*255.0)))'                  Convert.ToInt32(Double.Parse(String.Format("{0:0.00}"' Clinear[2]*255.0)))                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,Fxyz,The following statement contains a magic number: return ((t > 0.008856) ? Math.Pow(t' (1.0/3.0)) : (7.787*t + 16.0/116.0));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,Fxyz,The following statement contains a magic number: return ((t > 0.008856) ? Math.Pow(t' (1.0/3.0)) : (7.787*t + 16.0/116.0));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,Fxyz,The following statement contains a magic number: return ((t > 0.008856) ? Math.Pow(t' (1.0/3.0)) : (7.787*t + 16.0/116.0));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,Fxyz,The following statement contains a magic number: return ((t > 0.008856) ? Math.Pow(t' (1.0/3.0)) : (7.787*t + 16.0/116.0));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,Fxyz,The following statement contains a magic number: return ((t > 0.008856) ? Math.Pow(t' (1.0/3.0)) : (7.787*t + 16.0/116.0));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoLab,The following statement contains a magic number: lab.L = 116.0*Fxyz(y/CIEXYZ.D65.Y) - 16;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoLab,The following statement contains a magic number: lab.L = 116.0*Fxyz(y/CIEXYZ.D65.Y) - 16;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoLab,The following statement contains a magic number: lab.A = 500.0*(Fxyz(x/CIEXYZ.D65.X) - Fxyz(y/CIEXYZ.D65.Y));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,XYZtoLab,The following statement contains a magic number: lab.B = 200.0*(Fxyz(y/CIEXYZ.D65.Y) - Fxyz(z/CIEXYZ.D65.Z));
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: double theta = 6.0/29.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: double theta = 6.0/29.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: double fy = (l + 16)/116.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: double fy = (l + 16)/116.0;
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: double fx = fy + (a/500.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: double fz = fy - (b/200.0);
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,LabtoXYZ,The following statement contains a magic number: return new CIEXYZ(                  (fx > theta) ? CIEXYZ.D65.X*(fx*fx*fx) : (fx - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.X'                  (fy > theta) ? CIEXYZ.D65.Y*(fy*fy*fy) : (fy - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Y'                  (fz > theta) ? CIEXYZ.D65.Z*(fz*fz*fz) : (fz - 16.0/116.0)*3*(theta*theta)*CIEXYZ.D65.Z                  );
Magic Number,Kaliko.ImageLibrary.ColorSpace,HSB,C:\repos\fschultz_NetImageLibrary\ColorSpace\HSB.cs,HSB,The following statement contains a magic number: hue = (h > 360) ? 360 : ((h < 0) ? 0 : h);
Magic Number,Kaliko.ImageLibrary.ColorSpace,HSB,C:\repos\fschultz_NetImageLibrary\ColorSpace\HSB.cs,HSB,The following statement contains a magic number: hue = (h > 360) ? 360 : ((h < 0) ? 0 : h);
Magic Number,Kaliko.ImageLibrary.ColorSpace,HSL,C:\repos\fschultz_NetImageLibrary\ColorSpace\HSL.cs,HSL,The following statement contains a magic number: hue = (h > 360) ? 360 : ((h < 0) ? 0 : h);
Magic Number,Kaliko.ImageLibrary.ColorSpace,HSL,C:\repos\fschultz_NetImageLibrary\ColorSpace\HSL.cs,HSL,The following statement contains a magic number: hue = (h > 360) ? 360 : ((h < 0) ? 0 : h);
Magic Number,Kaliko.ImageLibrary.ColorSpace,RGB,C:\repos\fschultz_NetImageLibrary\ColorSpace\RGB.cs,RGB,The following statement contains a magic number: red = (R > 255) ? 255 : ((R < 0) ? 0 : R);
Magic Number,Kaliko.ImageLibrary.ColorSpace,RGB,C:\repos\fschultz_NetImageLibrary\ColorSpace\RGB.cs,RGB,The following statement contains a magic number: red = (R > 255) ? 255 : ((R < 0) ? 0 : R);
Magic Number,Kaliko.ImageLibrary.ColorSpace,RGB,C:\repos\fschultz_NetImageLibrary\ColorSpace\RGB.cs,RGB,The following statement contains a magic number: green = (G > 255) ? 255 : ((G < 0) ? 0 : G);
Magic Number,Kaliko.ImageLibrary.ColorSpace,RGB,C:\repos\fschultz_NetImageLibrary\ColorSpace\RGB.cs,RGB,The following statement contains a magic number: green = (G > 255) ? 255 : ((G < 0) ? 0 : G);
Magic Number,Kaliko.ImageLibrary.ColorSpace,RGB,C:\repos\fschultz_NetImageLibrary\ColorSpace\RGB.cs,RGB,The following statement contains a magic number: blue = (B > 255) ? 255 : ((B < 0) ? 0 : B);
Magic Number,Kaliko.ImageLibrary.ColorSpace,RGB,C:\repos\fschultz_NetImageLibrary\ColorSpace\RGB.cs,RGB,The following statement contains a magic number: blue = (B > 255) ? 255 : ((B < 0) ? 0 : B);
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,BrightnessFilter,The following statement contains a magic number: _brightness = 1 + ((double)changeInBrightness / 100);
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,BuildLookupTable,The following statement contains a magic number: var lookupTable = new byte[256];
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,BuildLookupTable,The following statement contains a magic number: for(var i = 0;i < 256;i++) {                  var val = (int)Math.Round(i * _brightness);                  if(val < 0) {                      val = 0;                  }                  else if(val > 255) {                      val = 255;                  }                  lookupTable[i] = (byte)val;              }
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,BuildLookupTable,The following statement contains a magic number: for(var i = 0;i < 256;i++) {                  var val = (int)Math.Round(i * _brightness);                  if(val < 0) {                      val = 0;                  }                  else if(val > 255) {                      val = 255;                  }                  lookupTable[i] = (byte)val;              }
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,BuildLookupTable,The following statement contains a magic number: for(var i = 0;i < 256;i++) {                  var val = (int)Math.Round(i * _brightness);                  if(val < 0) {                      val = 0;                  }                  else if(val > 255) {                      val = 255;                  }                  lookupTable[i] = (byte)val;              }
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,ChangeBrightness,The following statement contains a magic number: for(int i = 0' l = byteArray.Length;i < l;i += 4) {                  byteArray[i] = lookupTable[byteArray[i]];          // b                  byteArray[i + 1] = lookupTable[byteArray[i + 1]];  // g                  byteArray[i + 2] = lookupTable[byteArray[i + 2]];  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,ChangeBrightness,The following statement contains a magic number: for(int i = 0' l = byteArray.Length;i < l;i += 4) {                  byteArray[i] = lookupTable[byteArray[i]];          // b                  byteArray[i + 1] = lookupTable[byteArray[i + 1]];  // g                  byteArray[i + 2] = lookupTable[byteArray[i + 2]];  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,BrightnessFilter,C:\repos\fschultz_NetImageLibrary\Filters\BrightnessFilter.cs,ChangeBrightness,The following statement contains a magic number: for(int i = 0' l = byteArray.Length;i < l;i += 4) {                  byteArray[i] = lookupTable[byteArray[i]];          // b                  byteArray[i + 1] = lookupTable[byteArray[i + 1]];  // g                  byteArray[i + 2] = lookupTable[byteArray[i + 2]];  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ChromaKeyFilter,The following statement contains a magic number: KeyColor = Color.FromArgb(0' 255' 0);
Magic Number,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ChromaKeyFilter,The following statement contains a magic number: ToleranceHue = 10;
Magic Number,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ChromaKeyFilter,The following statement contains a magic number: ToleranceHue = 10;
Magic Number,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ApplyChromaKey,The following statement contains a magic number: for (int i = 0; i < pixels.Length; i++) {                  int rgb = pixels[i];                    int red = (rgb >> 16) & 0xff;                  int green = (rgb >> 8) & 0xff;                  int blue = rgb & 0xff;                  HSB hsb = ColorSpaceHelper.RGBtoHSB(red' green' blue);                    if (Math.Abs(hsb.Hue - keyHsb.Hue) < ToleranceHue && Math.Abs(hsb.Saturation - keyHsb.Saturation) < ToleranceSaturnation && Math.Abs(hsb.Brightness - keyHsb.Brightness) < ToleranceBrightness) {                      pixels[i] = rgb & 0xffffff;                  }                  else {                      pixels[i] = rgb;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ApplyChromaKey,The following statement contains a magic number: for (int i = 0; i < pixels.Length; i++) {                  int rgb = pixels[i];                    int red = (rgb >> 16) & 0xff;                  int green = (rgb >> 8) & 0xff;                  int blue = rgb & 0xff;                  HSB hsb = ColorSpaceHelper.RGBtoHSB(red' green' blue);                    if (Math.Abs(hsb.Hue - keyHsb.Hue) < ToleranceHue && Math.Abs(hsb.Saturation - keyHsb.Saturation) < ToleranceSaturnation && Math.Abs(hsb.Brightness - keyHsb.Brightness) < ToleranceBrightness) {                      pixels[i] = rgb & 0xffffff;                  }                  else {                      pixels[i] = rgb;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ChromaKeyFilter,C:\repos\fschultz_NetImageLibrary\Filters\ChromaKeyFilter.cs,ValidateParameters,The following statement contains a magic number: if (ToleranceHue < 0 || ToleranceHue > 360) {                  throw new ArgumentException("ToleranceHue out of range (0..360)");              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,ContrastFilter,The following statement contains a magic number: _contrast = 1 + ((double)changeInContrast / 100);
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,ChangeContrast,The following statement contains a magic number: for(int i = 0' l = byteArray.Length;i < l;i += 4) {                  byteArray[i] = lookupTable[byteArray[i]];          // b                  byteArray[i + 1] = lookupTable[byteArray[i + 1]];  // g                  byteArray[i + 2] = lookupTable[byteArray[i + 2]];  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,ChangeContrast,The following statement contains a magic number: for(int i = 0' l = byteArray.Length;i < l;i += 4) {                  byteArray[i] = lookupTable[byteArray[i]];          // b                  byteArray[i + 1] = lookupTable[byteArray[i + 1]];  // g                  byteArray[i + 2] = lookupTable[byteArray[i + 2]];  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,ChangeContrast,The following statement contains a magic number: for(int i = 0' l = byteArray.Length;i < l;i += 4) {                  byteArray[i] = lookupTable[byteArray[i]];          // b                  byteArray[i + 1] = lookupTable[byteArray[i + 1]];  // g                  byteArray[i + 2] = lookupTable[byteArray[i + 2]];  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: var lookupTable = new byte[256];
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ContrastFilter,C:\repos\fschultz_NetImageLibrary\Filters\ContrastFilter.cs,BuildLookupTable,The following statement contains a magic number: for (var i = 0; i < 256; i++) {                  var value = i/255.0;                  value -= 0.5;                  value *= _contrast;                  value += 0.5;                  value = (int)Math.Round(value*255);                  if (value < 0) {                      value = 0;                  }                  else if (value > 255) {                      value = 255;                  }                  lookupTable[i] = (byte)value;              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: int rows2 = rows/2;
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: int cols2 = cols/2;
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveHV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (0 <= iy && iy < height)                              ioffset = iy*width;                          else if (edgeAction == EdgeMode.Clamp)                              ioffset = y*width;                          else if (edgeAction == EdgeMode.Wrap)                              ioffset = ((iy + height)%height)*width;                          else                              continue;                          int moffset = cols*(row + rows2) + cols2;                          for (int col = -cols2; col <= cols2; col++) {                              float f = matrix[moffset + col];                                if (f != 0) {                                  int ix = x + col;                                  if (!(0 <= ix && ix < width)) {                                      if (edgeAction == EdgeMode.Clamp)                                          ix = x;                                      else if (edgeAction == EdgeMode.Wrap)                                          ix = (x + width)%width;                                      else                                          continue;                                  }                                  int rgb = inPixels[ioffset + ix];                                  a += f*((rgb >> 24) & 0xff);                                  r += f*((rgb >> 16) & 0xff);                                  g += f*((rgb >> 8) & 0xff);                                  b += f*(rgb & 0xff);                              }                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: int cols2 = cols/2;
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveH,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: int rows2 = rows/2;
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,ConvolveFilter,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,ConvolveV,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                        for (int row = -rows2; row <= rows2; row++) {                          int iy = y + row;                          int ioffset;                          if (iy < 0) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = 0;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else if (iy >= height) {                              if (edgeAction == EdgeMode.Clamp)                                  ioffset = (height - 1)*width;                              else if (edgeAction == EdgeMode.Wrap)                                  ioffset = ((y + height)%height)*width;                              else                                  ioffset = iy*width;                          }                          else                              ioffset = iy*width;                            float f = matrix[row + rows2];                            if (f != 0) {                              int rgb = inPixels[ioffset + x];                              a += f*((rgb >> 24) & 0xff);                              r += f*((rgb >> 16) & 0xff);                              g += f*((rgb >> 8) & 0xff);                              b += f*(rgb & 0xff);                          }                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index++] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Clamp,The following statement contains a magic number: if (value > 255) {                  return 255;              }
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Clamp,The following statement contains a magic number: if (value > 255) {                  return 255;              }
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Brightness,The following statement contains a magic number: int r = (rgb >> 16) & 0xff;
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Brightness,The following statement contains a magic number: int g = (rgb >> 8) & 0xff;
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,Brightness,The following statement contains a magic number: return (r + g + b)/3;
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,NearColors,The following statement contains a magic number: int r1 = (rgb1 >> 16) & 0xff;
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,NearColors,The following statement contains a magic number: int g1 = (rgb1 >> 8) & 0xff;
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,NearColors,The following statement contains a magic number: int r2 = (rgb2 >> 16) & 0xff;
Magic Number,Kaliko.ImageLibrary.Filters,PixelUtils,C:\repos\fschultz_NetImageLibrary\Filters\ConvolveFilter.cs,NearColors,The following statement contains a magic number: int g2 = (rgb2 >> 8) & 0xff;
Magic Number,Kaliko.ImageLibrary.Filters,DesaturationFilter,C:\repos\fschultz_NetImageLibrary\Filters\DesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = b[i + 1] = b[i + 2] = (byte)(.299 * b[i + 2] + .587 * b[i + 1] + .114 * b[i]);              }
Magic Number,Kaliko.ImageLibrary.Filters,DesaturationFilter,C:\repos\fschultz_NetImageLibrary\Filters\DesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = b[i + 1] = b[i + 2] = (byte)(.299 * b[i + 2] + .587 * b[i + 1] + .114 * b[i]);              }
Magic Number,Kaliko.ImageLibrary.Filters,DesaturationFilter,C:\repos\fschultz_NetImageLibrary\Filters\DesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = b[i + 1] = b[i + 2] = (byte)(.299 * b[i + 2] + .587 * b[i + 1] + .114 * b[i]);              }
Magic Number,Kaliko.ImageLibrary.Filters,DesaturationFilter,C:\repos\fschultz_NetImageLibrary\Filters\DesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = b[i + 1] = b[i + 2] = (byte)(.299 * b[i + 2] + .587 * b[i + 1] + .114 * b[i]);              }
Magic Number,Kaliko.ImageLibrary.Filters,DesaturationFilter,C:\repos\fschultz_NetImageLibrary\Filters\DesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = b[i + 1] = b[i + 2] = (byte)(.299 * b[i + 2] + .587 * b[i + 1] + .114 * b[i]);              }
Magic Number,Kaliko.ImageLibrary.Filters,DesaturationFilter,C:\repos\fschultz_NetImageLibrary\Filters\DesaturationFilter.cs,DesaturateImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = b[i + 1] = b[i + 2] = (byte)(.299 * b[i + 2] + .587 * b[i + 1] + .114 * b[i]);              }
Magic Number,Kaliko.ImageLibrary.Filters,InvertFilter,C:\repos\fschultz_NetImageLibrary\Filters\InvertFilter.cs,InvertImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = (byte)(255 - b[i]);          // b                  b[i + 1] = (byte)(255 - b[i + 1]);  // g                  b[i + 2] = (byte)(255 - b[i + 2]);  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,InvertFilter,C:\repos\fschultz_NetImageLibrary\Filters\InvertFilter.cs,InvertImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = (byte)(255 - b[i]);          // b                  b[i + 1] = (byte)(255 - b[i + 1]);  // g                  b[i + 2] = (byte)(255 - b[i + 2]);  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,InvertFilter,C:\repos\fschultz_NetImageLibrary\Filters\InvertFilter.cs,InvertImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = (byte)(255 - b[i]);          // b                  b[i + 1] = (byte)(255 - b[i + 1]);  // g                  b[i + 2] = (byte)(255 - b[i + 2]);  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,InvertFilter,C:\repos\fschultz_NetImageLibrary\Filters\InvertFilter.cs,InvertImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = (byte)(255 - b[i]);          // b                  b[i + 1] = (byte)(255 - b[i + 1]);  // g                  b[i + 2] = (byte)(255 - b[i + 2]);  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,InvertFilter,C:\repos\fschultz_NetImageLibrary\Filters\InvertFilter.cs,InvertImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = (byte)(255 - b[i]);          // b                  b[i + 1] = (byte)(255 - b[i + 1]);  // g                  b[i + 2] = (byte)(255 - b[i + 2]);  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,InvertFilter,C:\repos\fschultz_NetImageLibrary\Filters\InvertFilter.cs,InvertImage,The following statement contains a magic number: for(int i = 0' l = b.Length;i < l;i += 4) {                  b[i] = (byte)(255 - b[i]);          // b                  b[i + 1] = (byte)(255 - b[i + 1]);  // g                  b[i + 2] = (byte)(255 - b[i + 2]);  // r              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: int cols2 = cols/2;
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,ConvolveAndTranspose,The following statement contains a magic number: for (int y = 0; y < height; y++) {                  int index = y;                  int ioffset = y*width;                  for (int x = 0; x < width; x++) {                      float r = 0' g = 0' b = 0' a = 0;                      int moffset = cols2;                      for (int col = -cols2; col <= cols2; col++) {                          float f = matrix[moffset + col];                            if (f != 0) {                              int ix = x + col;                              if (ix < 0) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = 0;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              else if (ix >= width) {                                  if (edgeAction == EdgeMode.Clamp)                                      ix = width - 1;                                  else if (edgeAction == EdgeMode.Wrap)                                      ix = (x + width)%width;                              }                              int rgb = inPixels[ioffset + ix];                              int pa = (rgb >> 24) & 0xff;                              int pr = (rgb >> 16) & 0xff;                              int pg = (rgb >> 8) & 0xff;                              int pb = rgb & 0xff;                              if (premultiply) {                                  float a255 = pa*(1.0f/255.0f);                                  pr = (int)(pr*a255);                                  pg = (int)(pg*a255);                                  pb = (int)(pb*a255);                              }                              a += f*pa;                              r += f*pr;                              g += f*pg;                              b += f*pb;                          }                      }                      if (unpremultiply && a != 0 && a != 255) {                          float f = 255.0f/a;                          r *= f;                          g *= f;                          b *= f;                      }                      int ia = alpha ? PixelUtils.Clamp((int)(a + 0.5)) : 0xff;                      int ir = PixelUtils.Clamp((int)(r + 0.5));                      int ig = PixelUtils.Clamp((int)(g + 0.5));                      int ib = PixelUtils.Clamp((int)(b + 0.5));                      outPixels[index] = (ia << 24) | (ir << 16) | (ig << 8) | ib;                      index += height;                  }              }
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,CreateKernel,The following statement contains a magic number: int rows = r*2 + 1;
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,CreateKernel,The following statement contains a magic number: float sigma = radius/3;
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,CreateKernel,The following statement contains a magic number: float sigma22 = 2*sigma*sigma;
Magic Number,Kaliko.ImageLibrary.Filters,GaussianBlurFilter,C:\repos\fschultz_NetImageLibrary\Filters\GaussianBlurFilter.cs,CreateKernel,The following statement contains a magic number: var sigmaPi2 = (float)(2*Math.PI*sigma);
Magic Number,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The following statement contains a magic number: for (int index = 0; index < inPixels.Length; index++) {                  int rgb1 = inPixels[index];                  int r1 = (rgb1 >> 16) & 0xff;                  int g1 = (rgb1 >> 8) & 0xff;                  int b1 = rgb1 & 0xff;                    int rgb2 = outPixels[index];                  int r2 = (rgb2 >> 16) & 0xff;                  int g2 = (rgb2 >> 8) & 0xff;                  int b2 = rgb2 & 0xff;                    if (Math.Abs(r1 - r2) >= threshold) {                      r1 = PixelUtils.Clamp((int)((amount + 1)*(r1 - r2) + r2));                  }                  if (Math.Abs(g1 - g2) >= threshold) {                      g1 = PixelUtils.Clamp((int)((amount + 1)*(g1 - g2) + g2));                  }                  if (Math.Abs(b1 - b2) >= threshold) {                      b1 = PixelUtils.Clamp((int)((amount + 1)*(b1 - b2) + b2));                  }                    inPixels[index] = (int)(rgb1 & 0xff000000) | (r1 << 16) | (g1 << 8) | b1;              }
Magic Number,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The following statement contains a magic number: for (int index = 0; index < inPixels.Length; index++) {                  int rgb1 = inPixels[index];                  int r1 = (rgb1 >> 16) & 0xff;                  int g1 = (rgb1 >> 8) & 0xff;                  int b1 = rgb1 & 0xff;                    int rgb2 = outPixels[index];                  int r2 = (rgb2 >> 16) & 0xff;                  int g2 = (rgb2 >> 8) & 0xff;                  int b2 = rgb2 & 0xff;                    if (Math.Abs(r1 - r2) >= threshold) {                      r1 = PixelUtils.Clamp((int)((amount + 1)*(r1 - r2) + r2));                  }                  if (Math.Abs(g1 - g2) >= threshold) {                      g1 = PixelUtils.Clamp((int)((amount + 1)*(g1 - g2) + g2));                  }                  if (Math.Abs(b1 - b2) >= threshold) {                      b1 = PixelUtils.Clamp((int)((amount + 1)*(b1 - b2) + b2));                  }                    inPixels[index] = (int)(rgb1 & 0xff000000) | (r1 << 16) | (g1 << 8) | b1;              }
Magic Number,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The following statement contains a magic number: for (int index = 0; index < inPixels.Length; index++) {                  int rgb1 = inPixels[index];                  int r1 = (rgb1 >> 16) & 0xff;                  int g1 = (rgb1 >> 8) & 0xff;                  int b1 = rgb1 & 0xff;                    int rgb2 = outPixels[index];                  int r2 = (rgb2 >> 16) & 0xff;                  int g2 = (rgb2 >> 8) & 0xff;                  int b2 = rgb2 & 0xff;                    if (Math.Abs(r1 - r2) >= threshold) {                      r1 = PixelUtils.Clamp((int)((amount + 1)*(r1 - r2) + r2));                  }                  if (Math.Abs(g1 - g2) >= threshold) {                      g1 = PixelUtils.Clamp((int)((amount + 1)*(g1 - g2) + g2));                  }                  if (Math.Abs(b1 - b2) >= threshold) {                      b1 = PixelUtils.Clamp((int)((amount + 1)*(b1 - b2) + b2));                  }                    inPixels[index] = (int)(rgb1 & 0xff000000) | (r1 << 16) | (g1 << 8) | b1;              }
Magic Number,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The following statement contains a magic number: for (int index = 0; index < inPixels.Length; index++) {                  int rgb1 = inPixels[index];                  int r1 = (rgb1 >> 16) & 0xff;                  int g1 = (rgb1 >> 8) & 0xff;                  int b1 = rgb1 & 0xff;                    int rgb2 = outPixels[index];                  int r2 = (rgb2 >> 16) & 0xff;                  int g2 = (rgb2 >> 8) & 0xff;                  int b2 = rgb2 & 0xff;                    if (Math.Abs(r1 - r2) >= threshold) {                      r1 = PixelUtils.Clamp((int)((amount + 1)*(r1 - r2) + r2));                  }                  if (Math.Abs(g1 - g2) >= threshold) {                      g1 = PixelUtils.Clamp((int)((amount + 1)*(g1 - g2) + g2));                  }                  if (Math.Abs(b1 - b2) >= threshold) {                      b1 = PixelUtils.Clamp((int)((amount + 1)*(b1 - b2) + b2));                  }                    inPixels[index] = (int)(rgb1 & 0xff000000) | (r1 << 16) | (g1 << 8) | b1;              }
Magic Number,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The following statement contains a magic number: for (int index = 0; index < inPixels.Length; index++) {                  int rgb1 = inPixels[index];                  int r1 = (rgb1 >> 16) & 0xff;                  int g1 = (rgb1 >> 8) & 0xff;                  int b1 = rgb1 & 0xff;                    int rgb2 = outPixels[index];                  int r2 = (rgb2 >> 16) & 0xff;                  int g2 = (rgb2 >> 8) & 0xff;                  int b2 = rgb2 & 0xff;                    if (Math.Abs(r1 - r2) >= threshold) {                      r1 = PixelUtils.Clamp((int)((amount + 1)*(r1 - r2) + r2));                  }                  if (Math.Abs(g1 - g2) >= threshold) {                      g1 = PixelUtils.Clamp((int)((amount + 1)*(g1 - g2) + g2));                  }                  if (Math.Abs(b1 - b2) >= threshold) {                      b1 = PixelUtils.Clamp((int)((amount + 1)*(b1 - b2) + b2));                  }                    inPixels[index] = (int)(rgb1 & 0xff000000) | (r1 << 16) | (g1 << 8) | b1;              }
Magic Number,Kaliko.ImageLibrary.Filters,UnsharpMaskFilter,C:\repos\fschultz_NetImageLibrary\Filters\UnsharpMaskFilter.cs,Sharpen,The following statement contains a magic number: for (int index = 0; index < inPixels.Length; index++) {                  int rgb1 = inPixels[index];                  int r1 = (rgb1 >> 16) & 0xff;                  int g1 = (rgb1 >> 8) & 0xff;                  int b1 = rgb1 & 0xff;                    int rgb2 = outPixels[index];                  int r2 = (rgb2 >> 16) & 0xff;                  int g2 = (rgb2 >> 8) & 0xff;                  int b2 = rgb2 & 0xff;                    if (Math.Abs(r1 - r2) >= threshold) {                      r1 = PixelUtils.Clamp((int)((amount + 1)*(r1 - r2) + r2));                  }                  if (Math.Abs(g1 - g2) >= threshold) {                      g1 = PixelUtils.Clamp((int)((amount + 1)*(g1 - g2) + g2));                  }                  if (Math.Abs(b1 - b2) >= threshold) {                      b1 = PixelUtils.Clamp((int)((amount + 1)*(b1 - b2) + b2));                  }                    inPixels[index] = (int)(rgb1 & 0xff000000) | (r1 << 16) | (g1 << 8) | b1;              }
Magic Number,Kaliko.ImageLibrary.Scaling,CropScaling,C:\repos\fschultz_NetImageLibrary\Scaling\CropScaling.cs,DrawResizedImage,The following statement contains a magic number: KalikoImage.DrawScaledImage(resizedImage' sourceImage' (_targetSize.Width - calculatedSize.Width) / 2' (_targetSize.Height - calculatedSize.Height) / 2' calculatedSize.Width' calculatedSize.Height);
Magic Number,Kaliko.ImageLibrary.Scaling,CropScaling,C:\repos\fschultz_NetImageLibrary\Scaling\CropScaling.cs,DrawResizedImage,The following statement contains a magic number: KalikoImage.DrawScaledImage(resizedImage' sourceImage' (_targetSize.Width - calculatedSize.Width) / 2' (_targetSize.Height - calculatedSize.Height) / 2' calculatedSize.Width' calculatedSize.Height);
Magic Number,Kaliko.ImageLibrary.Scaling,PadScaling,C:\repos\fschultz_NetImageLibrary\Scaling\PadScaling.cs,DrawResizedImage,The following statement contains a magic number: KalikoImage.DrawScaledImage(resizedImage' sourceImage' (_targetSize.Width - calculatedSize.Width) / 2' (_targetSize.Height - calculatedSize.Height) / 2' calculatedSize.Width' calculatedSize.Height);
Magic Number,Kaliko.ImageLibrary.Scaling,PadScaling,C:\repos\fschultz_NetImageLibrary\Scaling\PadScaling.cs,DrawResizedImage,The following statement contains a magic number: KalikoImage.DrawScaledImage(resizedImage' sourceImage' (_targetSize.Width - calculatedSize.Width) / 2' (_targetSize.Height - calculatedSize.Height) / 2' calculatedSize.Width' calculatedSize.Height);
Missing Default,Kaliko.ImageLibrary.ColorSpace,ColorSpaceHelper,C:\repos\fschultz_NetImageLibrary\ColorSpace\ColorSpaceHelper.cs,HSBtoRGB,The following switch statement is missing a default case: switch (sectorNumber) {                      case 0:                          r = hsb.Brightness;                          g = t;                          b = p;                          break;                      case 1:                          r = q;                          g = hsb.Brightness;                          b = p;                          break;                      case 2:                          r = p;                          g = hsb.Brightness;                          b = t;                          break;                      case 3:                          r = p;                          g = q;                          b = hsb.Brightness;                          break;                      case 4:                          r = t;                          g = p;                          b = hsb.Brightness;                          break;                      case 5:                          r = hsb.Brightness;                          g = p;                          b = q;                          break;                  }
