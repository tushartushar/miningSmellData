Implementation smell,Namespace,Class,File,Method,Description
Long Method,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The method has 154 lines of code.
Complex Method,MarsMiner.Shared,Tools,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Tools.cs,ApplyWordWrap,Cyclomatic complexity of the method is 8
Complex Method,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,Cyclomatic complexity of the method is 24
Complex Method,MarsMiner.Shared.Geometry,World,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\World.cs,GeneratorLoop,Cyclomatic complexity of the method is 11
Long Parameter List,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The method has 5 parameters. Parameters: x' y' z' size' resolution
Long Parameter List,MarsMiner.Shared.Geometry,WorldGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\WorldGenerator.cs,Generate,The method has 5 parameters. Parameters: x' y' z' size' resolution
Long Parameter List,MarsMiner.Shared.Octree,Octree<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Octree.cs,Octree,The method has 5 parameters. Parameters: x' y' z' size' container
Long Parameter List,MarsMiner.Shared.Octree,Octree<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Octree.cs,SetCuboid,The method has 7 parameters. Parameters: x' y' z' width' height' depth' value
Long Parameter List,MarsMiner.Shared.Octree,Octree<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Octree.cs,FindNode,The method has 5 parameters. Parameters: mSize' oX' oY' oZ' oSize
Long Parameter List,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,FindInnerNode,The method has 5 parameters. Parameters: mSize' oX' oY' oZ' oSize
Long Parameter List,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,FindNode,The method has 6 parameters. Parameters: child' mSize' oX' oY' oZ' oSize
Long Parameter List,MarsMiner.Shared.Octree,OctreeLeaf<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeLeaf.cs,FindInnerNode,The method has 5 parameters. Parameters: mSize' oX' oY' oZ' oSize
Long Parameter List,MarsMiner.Shared.Octree,OctreeNode<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeNode.cs,FindNode,The method has 5 parameters. Parameters: mSize' oX' oY' oZ' oSize
Long Parameter List,MarsMiner.Shared.Octree,OctreeNode<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeNode.cs,FindInnerNode,The method has 5 parameters. Parameters: mSize' oX' oY' oZ' oSize
Long Parameter List,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,Cuboid,The method has 6 parameters. Parameters: x' y' z' width' height' depth
Long Parameter List,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,IsIntersecting,The method has 6 parameters. Parameters: x' y' z' width' height' depth
Long Parameter List,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,FindIntersection,The method has 6 parameters. Parameters: x' y' z' width' height' depth
Long Identifier,MarsMiner.Shared.Networking,LocalConnection,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\LocalConnection.cs,,The length of the parameter myClientToServerWaitingPackets is 30.
Long Identifier,MarsMiner.Shared.Networking,LocalConnection,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\LocalConnection.cs,,The length of the parameter myServerToClientWaitingPackets is 30.
Complex Conditional,MarsMiner.Shared.Geometry,Chunk,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\Chunk.cs,FindNode,The conditional expression  "x < X || x >= X + Size || z < Z || z >= Z + Size"  is complex.
Complex Conditional,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The conditional expression  "( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res"  is complex.
Complex Conditional,MarsMiner.Shared.Octree,Octree<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Octree.cs,FindNode,The conditional expression  "x < X || y < Y || z < Z || x >= X + Size || y >= Y + Size || z >= Z + Size"  is complex.
Complex Conditional,MarsMiner.Shared.Octree,Octree<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Octree.cs,FindNode,The conditional expression  "oX < 0 || oY < 0 || oZ < 0 || oX >= mSize || oY >= mSize || oZ >= mSize"  is complex.
Complex Conditional,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,SetCuboid,The conditional expression  "i.X == 0 && i.Y == 0 && i.Z == 0                      && i.Width == i.Height && i.Height == i.Depth && i.Depth == size && ShouldMerge()"  is complex.
Complex Conditional,MarsMiner.Shared.Octree,OctreeLeaf<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeLeaf.cs,SetCuboid,The conditional expression  "i.X == 0 && i.Y == 0 && i.Z == 0                      && i.Width == i.Height && i.Height == i.Depth && i.Depth == size"  is complex.
Complex Conditional,MarsMiner.Shared.Octree,OctreeNode<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeNode.cs,FindNode,The conditional expression  "mSize == oSize && oX == 0 && oY == 0 && oZ == 0"  is complex.
Complex Conditional,MarsMiner.Shared.Octree,OctreeNode<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeNode.cs,FindNode,The conditional expression  "oX < 0 || oY < 0 || oZ < 0 || oX >= mSize                  || oY >= mSize || oZ >= mSize"  is complex.
Virtual Method Call from Constructor,MarsMiner.Shared.Geometry,World,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\World.cs,World,The constructor "World" calls a virtual method "OnInitialize".
Virtual Method Call from Constructor,MarsMiner.Shared.Geometry,World,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\World.cs,World,The constructor "World" calls a virtual method "OnWorldIntitialize".
Magic Number,MarsMiner.Shared,MarsMinerPlugin,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\MarsMinerPlugin.cs,OnWorldIntitialize,The following statement contains a magic number: for ( int i = 1; i < 16; ++i )              {                  BlockType sand = BlockManager.RegisterType( "MarsMiner_Sand"' i - 1 );                  sand.SetComponant( new SolidityBComponant( true ) );              }
Magic Number,MarsMiner.Shared,MarsMinerPlugin,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\MarsMinerPlugin.cs,OnWorldIntitialize,The following statement contains a magic number: for ( int i = 1; i < 16; ++i )              {                  BlockType rock = BlockManager.RegisterType( "MarsMiner_Rock"' i - 1 );                  rock.SetComponant( new SolidityBComponant( true ) );              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myHillyNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 1.0'                  Lacunarity = 2.0'                  Persistence = 0.5              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myHillyNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 1.0'                  Lacunarity = 2.0'                  Persistence = 0.5              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myHillyNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 1.0'                  Lacunarity = 2.0'                  Persistence = 0.5              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myPlainsNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 8.0'                  Lacunarity = 2.0'                  Persistence = 1.0              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myPlainsNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 8.0'                  Lacunarity = 2.0'                  Persistence = 1.0              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myPlainsNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 8.0'                  Lacunarity = 2.0'                  Persistence = 1.0              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myTransNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 1.0 / 32.0'                  Lacunarity = 2.0'                  Persistence = 1.0              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myTransNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 1.0 / 32.0'                  Lacunarity = 2.0'                  Persistence = 1.0              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myTransNoise = new Perlin              {                  Seed = Seed'                  OctaveCount = 6'                  Frequency = 1.0 / 32.0'                  Lacunarity = 2.0'                  Persistence = 1.0              };
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myMinHilly = 768;
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myMaxHilly = 896;
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myMinPlains = 768;
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,PerlinGenerator,The following statement contains a magic number: myMaxPlains = 776;
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: UInt16[] sand = new UInt16[ 15 ];
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: UInt16[] rock = new UInt16[ 15 ];
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: for ( int i = 0; i < 15; ++i )              {                  sand[ i ] = BlockManager.GetID( "MarsMiner_Sand"' i );                  rock[ i ] = BlockManager.GetID( "MarsMiner_Rock"' i );              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: int gradRange = 2;
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: octree.SetCuboid( x' 0' z' size' System.Math.Min( myMinHilly' myMinPlains )' size' rock[ 14 ] );
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,PerlinGenerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\PerlinGenerator.cs,Generate,The following statement contains a magic number: if ( y + size >= min )              {                  int hillDiff = ( myMaxHilly - myMinHilly ) / 2;                  int hillMid = myMinHilly + hillDiff;                  int plainDiff = ( myMinPlains - myMaxPlains ) / 2;                  int plainMid = myMaxPlains + plainDiff;                                    int maxCount = size / resolution;                  double hres = resolution / 2.0;                    int['] heightmap = new int[ maxCount + gradRange * 2' maxCount + gradRange * 2 ];                  double['] gradmap = new double[ maxCount' maxCount ];                    for( int i = 0; i < maxCount + gradRange * 2; ++ i )                  {                      double dx = ( x + ( i - gradRange ) * resolution + hres ) / 256.0;                      for( int j = 0; j < maxCount + gradRange * 2; ++ j )                      {                          double dy = ( z + ( j - gradRange ) * resolution + hres ) / 256.0;                          double hillVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * hillDiff + hillMid' myMinHilly' myMaxHilly );                          double plainVal = Tools.Clamp( myHillyNoise.GetValue( dx' dy' 0.5 ) * plainDiff + plainMid' myMinPlains' myMaxPlains );                          double trans = Tools.Clamp( ( myTransNoise.GetValue( dx' dy' 0.5 ) + 1.0 ) / 2.0' 0.0' 1.0 );                          //trans *= trans;                            int val = (int) System.Math.Floor( trans * hillVal + ( 1 - trans ) * plainVal );                                                    heightmap[ i' j ] = val / resolution * resolution;                      }                  }                    for ( int i = 0; i < maxCount; ++i )                  {                      for ( int j = 0; j < maxCount; ++j )                      {                          double grad = 0;                            for ( int gx = -gradRange; gx <= gradRange; ++gx )                          {                              for ( int gy = -gradRange; gy <= gradRange; ++gy )                              {                                  if( gx == 0 && gy == 0 )                                      continue;                                    double dist = System.Math.Sqrt( gx * gx + gy * gy );                                    int diff = heightmap[ i + gradRange + gx' j + gradRange + gy ]                                      - heightmap[ i + gradRange' j + gradRange ];                                    grad += System.Math.Abs( diff ) / dist;                              }                          }                            gradmap[ i' j ] = grad;                      }                  }                    Cuboid rcuboid = new Cuboid( 0' 0' 0' resolution' 1' resolution );                  Cuboid scuboid = new Cuboid( 0' 0' 0' 1' 1' 1 );                    int['] prev = null;                    for ( int count = 1; count <= maxCount; count <<= 1 )                  {                      int res = size / count;                      hres = res / 2.0;                      int['] cur = new int[ count' count ];                        int sca = res / resolution;                        rcuboid.Width = res;                      rcuboid.Depth = res;                        scuboid.Width = res;                      scuboid.Height = res;                      scuboid.Depth = res;                        for ( int nx = 0; nx < count; ++nx )                      {                          int rx = x + nx * res;                          int px = nx >> 1;                            for ( int nz = 0; nz < count; ++nz )                          {                              int rz = z + nz * res;                              int pz = nz >> 1;                                int realHeight = heightmap[ nx * sca + gradRange' nz * sca + gradRange ];                              int height = realHeight / res * res;                                cur[ nx' nz ] = height;                                int prevHeight = ( count == 1 ? 0 : prev[ px' pz ] );                                rcuboid.X = rx;                              rcuboid.Z = rz;                                rcuboid.Bottom = System.Math.Min( height' prevHeight );                              rcuboid.Top = System.Math.Max( height' prevHeight );                                if( height > prevHeight )                                  octree.SetCuboid( rcuboid' rock[ 14 ] );                              else                                  octree.SetCuboid( rcuboid' empty );                                if ( ( res == 1 || ( resolution > 1 && height == realHeight ) )                                  && gradmap[ nx' nz ] <= 8.0 * res )                              {                                  scuboid.X = rx;                                  scuboid.Y = height - res;                                  scuboid.Z = rz;                                    octree.SetCuboid( scuboid' sand[ 14 ] );                              }                          }                      }                        prev = cur;                  }                    for ( int colxi = 0; colxi < size / resolution; ++colxi )                  {                      int colx = colxi * resolution + x;                        for ( int colzi = 0; colzi < size / resolution; ++colzi )                      {                          int colz = colzi * resolution + z;                            int height = heightmap[ colxi + gradRange' colzi + gradRange ];                            OctreeLeaf<UInt16> curLeaf =                          octree.FindNode( colx' height - resolution' colz' resolution )                              as OctreeLeaf<UInt16>;                            if ( curLeaf != null && curLeaf.Value != empty )                          {                              int[] ns = new int[]                              {                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 1 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange + 0 ]'                                  heightmap[ colxi + gradRange - 1' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 0' colzi + gradRange - 1 ]'                                  heightmap[ colxi + gradRange + 1' colzi + gradRange - 1 ]                              };                                bool[] bs = new bool[ 8 ];                              for ( int i = 0; i < 8; ++i )                                  bs[ i ] = ns[ i ] >= height;                                int index = 0;                                if ( bs[ 5 ] && ( bs[ 3 ] && bs[ 6 ] ) )                                  index |= 1 << 0;                              if ( bs[ 7 ] && ( bs[ 4 ] && bs[ 6 ] ) )                                  index |= 1 << 1;                              if ( bs[ 0 ] && ( bs[ 1 ] && bs[ 3 ] ) )                                  index |= 1 << 2;                              if ( bs[ 2 ] && ( bs[ 1 ] && bs[ 4 ] ) )                                  index |= 1 << 3;                                if ( index > 0 )                                  octree.SetCuboid(                                      colx' height - resolution' colz'                                      resolution' resolution' resolution'                                      (UInt16) ( curLeaf.Value + index - 15 ) );                          }                      }                  }              }
Magic Number,MarsMiner.Shared.Geometry,World,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\World.cs,Generate,The following statement contains a magic number: int xLimit = width  / Chunk.Size / 2;
Magic Number,MarsMiner.Shared.Geometry,World,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\World.cs,Generate,The following statement contains a magic number: int zLimit = height / Chunk.Size / 2;
Magic Number,MarsMiner.Shared.Geometry,World,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Geometry\World.cs,FindChunkID,The following statement contains a magic number: return (UInt16) ( cx << 8 | cz );
Magic Number,MarsMiner.Shared.Networking,LocalConnection,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\LocalConnection.cs,EndReadingClientToServerPacket,The following statement contains a magic number: if ( myLastClientToServerReadPos == myLastClientToServerWritePos && myClientToServerStream.Length >= 2048 )              {                  myClientToServerStream.Position = 0;                  myLastClientToServerReadPos = 0;                  myLastClientToServerWritePos = 0;              }
Magic Number,MarsMiner.Shared.Networking,LocalConnection,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\LocalConnection.cs,EndReadingServerToClientPacket,The following statement contains a magic number: if ( myLastServerToClientReadPos == myLastServerToClientWritePos && myServerToClientStream.Length >= 2048 )              {                  myServerToClientStream.Position = 0;                  myLastServerToClientReadPos = 0;                  myLastServerToClientWritePos = 0;              }
Magic Number,MarsMiner.Shared.Networking,RemoteNetworkedObject,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\Networking.cs,RemoteNetworkedObject,The following statement contains a magic number: TimeOutDelay = 30.0;
Magic Number,MarsMiner.Shared.Networking,RemoteNetworkedObject,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\Networking.cs,RemoteNetworkedObject,The following statement contains a magic number: AliveCheckPeriod = 2.0;
Magic Number,MarsMiner.Shared.Networking,RemoteNetworkedObject,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Networking\Networking.cs,StartPacket,The following statement contains a magic number: stream.Write( BitConverter.GetBytes( type.ID )' 0' 2 );
Magic Number,MarsMiner.Shared.Octree,Face,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Face.cs,Face,The following statement contains a magic number: for ( int i = 0; i < 6; ++i )              {                  if ( ( bitmap & ( 1 << i ) ) != 0 )                  {                      if ( !found )                      {                          Index = i;                          found = true;                      }                      else                      {                          Index = -1;                          break;                      }                  }              }
Magic Number,MarsMiner.Shared.Octree,FaceEnumerator,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\FaceEnumerator.cs,MoveNext,The following statement contains a magic number: while ( ( myBitmap & ( 1 << ++myShift ) ) == 0 )                  if ( myShift >= 8 )                      return false;
Magic Number,MarsMiner.Shared.Octree,Octant,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Octant.cs,Octant,The following statement contains a magic number: Index = x << 2 | y << 1 | z;
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,ReplaceChild,The following statement contains a magic number: for ( int i = 0; i < 8; ++i )              {                  if ( oldChild == myChildren[ i ] )                  {                      myChildren[ i ] = newChild;                        if ( newChild is OctreeLeaf<T> && ShouldMerge() )                          Merge( ( (OctreeLeaf<T>) newChild ).Value );                      return;                  }              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,ShouldMerge,The following statement contains a magic number: for ( int i = 0; i < 8; ++i )              {                  if ( myChildren[ i ] is OctreeBranch<T> )                      return false;                                    T value = ( (OctreeLeaf<T>) myChildren[ i ] ).Value;                    if ( i > 0 && !value.Equals( lastVal ) )                      return false;                    lastVal = value;              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following statement contains a magic number: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,FindInnerNode,The following statement contains a magic number: int child = cX << 2 | cY << 1 | cZ;
Magic Number,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,FindOctantOfChild,The following statement contains a magic number: for ( int i = 0; i < 8; ++i )                  if ( child == myChildren[ i ] )                      return Octant.All[ i ];
Magic Number,MarsMiner.Shared.Octree,OctreeEnumerator<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeEnumerator.cs,OctreeEnumerator,The following statement contains a magic number: if ( Face.HasNone )                  myValidOctants = Octant.All;              else              {                  for ( int i = 0' j = 0; i < 8; ++i )                  {                      if ( Octant.All[ i ].Faces.HasFace( face ) )                          myValidOctants[ j++ ] = Octant.All[ i ];                  }              }
Magic Number,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,GetHashCode,The following statement contains a magic number: return ( X << 16 | Y << 8 | Z ) ^ ( Height << 16 | Depth << 8 | Width );
Magic Number,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,GetHashCode,The following statement contains a magic number: return ( X << 16 | Y << 8 | Z ) ^ ( Height << 16 | Depth << 8 | Width );
Magic Number,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,GetHashCode,The following statement contains a magic number: return ( X << 16 | Y << 8 | Z ) ^ ( Height << 16 | Depth << 8 | Width );
Magic Number,MarsMiner.Shared.Octree,Cuboid,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\Cuboid.cs,GetHashCode,The following statement contains a magic number: return ( X << 16 | Y << 8 | Z ) ^ ( Height << 16 | Depth << 8 | Width );
Missing Default,MarsMiner.Shared.Octree,OctreeBranch<T>,C:\repos\Metapyziks_MarsMiner\MarsMiner.Shared\Octree\OctreeBranch.cs,IsFaceSolid,The following switch statement is missing a default case: switch ( face.Index )              {                  case Face.LeftIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck );                  case Face.RightIndex:                      return                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.BottomIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck );                  case Face.TopIndex:                      return                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );                  case Face.FrontIndex:                      return                          myChildren[ 0 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 2 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 4 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 6 ].IsFaceSolid( face' solidCheck );                  case Face.BackIndex:                      return                          myChildren[ 1 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 3 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 5 ].IsFaceSolid( face' solidCheck ) &&                          myChildren[ 7 ].IsFaceSolid( face' solidCheck );              }
