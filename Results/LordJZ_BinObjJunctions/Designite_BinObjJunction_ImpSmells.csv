Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,DeviceIoControl,The method has 8 parameters.
Long Parameter List,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,CreateFile,The method has 7 parameters.
Long Statement,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The length of the statement  "			bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero); " is 172.
Long Statement,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Delete,The length of the statement  "			bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_DELETE_REPARSE_POINT' inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero); " is 150.
Long Statement,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,InternalGetTarget,The length of the statement  "		bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_GET_REPARSE_POINT' IntPtr.Zero' 0' outBuffer' outBufferSize' out bytesReturned' IntPtr.Zero); " is 160.
Long Statement,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,InternalGetTarget,The length of the statement  "		REPARSE_DATA_BUFFER reparseDataBuffer = (REPARSE_DATA_BUFFER)Marshal.PtrToStructure (outBuffer' typeof(REPARSE_DATA_BUFFER)); " is 125.
Long Statement,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,InternalGetTarget,The length of the statement  "		string targetDir = Encoding.Unicode.GetString (reparseDataBuffer.PathBuffer' reparseDataBuffer.SubstituteNameOffset' reparseDataBuffer.SubstituteNameLength); " is 157.
Long Statement,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,OpenReparsePoint,The length of the statement  "	SafeFileHandle reparsePointHandle = new SafeFileHandle (CreateFile (reparsePoint' accessMode' EFileShare.Read | EFileShare.Write | EFileShare.Delete' IntPtr.Zero' ECreationDisposition.OpenExisting' EFileAttributes.BackupSemantics | EFileAttributes.OpenReparsePoint' IntPtr.Zero)' true); " is 286.
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint (junctionPoint' EFileAccess.GenericWrite)) {  	byte[] targetDirBytes = Encoding.Unicode.GetBytes (NonInterpretedPathPrefix + Path.GetFullPath (targetDir));  	REPARSE_DATA_BUFFER reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  	reparseDataBuffer.SubstituteNameOffset = 0;  	reparseDataBuffer.SubstituteNameLength = (ushort)targetDirBytes.Length;  	reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  	reparseDataBuffer.PrintNameLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	Array.Copy (targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);  	int inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	IntPtr inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to create junction point.");  	}  	finally {  		Marshal.FreeHGlobal (inBuffer);  	}  }  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint (junctionPoint' EFileAccess.GenericWrite)) {  	byte[] targetDirBytes = Encoding.Unicode.GetBytes (NonInterpretedPathPrefix + Path.GetFullPath (targetDir));  	REPARSE_DATA_BUFFER reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  	reparseDataBuffer.SubstituteNameOffset = 0;  	reparseDataBuffer.SubstituteNameLength = (ushort)targetDirBytes.Length;  	reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  	reparseDataBuffer.PrintNameLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	Array.Copy (targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);  	int inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	IntPtr inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to create junction point.");  	}  	finally {  		Marshal.FreeHGlobal (inBuffer);  	}  }  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint (junctionPoint' EFileAccess.GenericWrite)) {  	byte[] targetDirBytes = Encoding.Unicode.GetBytes (NonInterpretedPathPrefix + Path.GetFullPath (targetDir));  	REPARSE_DATA_BUFFER reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  	reparseDataBuffer.SubstituteNameOffset = 0;  	reparseDataBuffer.SubstituteNameLength = (ushort)targetDirBytes.Length;  	reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  	reparseDataBuffer.PrintNameLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	Array.Copy (targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);  	int inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	IntPtr inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to create junction point.");  	}  	finally {  		Marshal.FreeHGlobal (inBuffer);  	}  }  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The following statement contains a magic number: reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The following statement contains a magic number: reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Create,The following statement contains a magic number: try {  	Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  	int bytesReturned;  	bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  	if (!result)  		ThrowLastWin32Error ("Unable to create junction point.");  }  finally {  	Marshal.FreeHGlobal (inBuffer);  }  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Delete,The following statement contains a magic number: using (SafeFileHandle handle = OpenReparsePoint (junctionPoint' EFileAccess.GenericWrite)) {  	REPARSE_DATA_BUFFER reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	int inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	IntPtr inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_DELETE_REPARSE_POINT' inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to delete junction point.");  	}  	finally {  		Marshal.FreeHGlobal (inBuffer);  	}  	try {  		Directory.Delete (junctionPoint);  	}  	catch (IOException ex) {  		throw new IOException ("Unable to delete junction point."' ex);  	}  }  
Magic Number,Monitor.Core.Utilities,JunctionPoint,C:\repos\LordJZ_BinObjJunctions\JunctionPoint.cs,Delete,The following statement contains a magic number: try {  	Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  	int bytesReturned;  	bool result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_DELETE_REPARSE_POINT' inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  	if (!result)  		ThrowLastWin32Error ("Unable to delete junction point.");  }  finally {  	Marshal.FreeHGlobal (inBuffer);  }  
Magic Number,BinObjJunction,Program,C:\repos\LordJZ_BinObjJunctions\Program.cs,Main,The following statement contains a magic number: if (args.Length != 2) {  	Console.Error.WriteLine ("Usage:");  	Console.Error.WriteLine ("  BinObjJunction.exe <solution path> <junctions root path>");  	return 1;  }  
Magic Number,BinObjJunction,Program,C:\repos\LordJZ_BinObjJunctions\Program.cs,ReduceToBinFolder,The following statement contains a magic number: for (int i = 2; i <= 5; i++) {  	if (parts.Length <= i)  		break;  	int binIdx = parts.Length - i;  	if (!parts [binIdx].Equals ("bin"' StringComparison.InvariantCultureIgnoreCase))  		continue;  	folder = string.Join (Path.DirectorySeparatorChar.ToString ()' parts.Take (binIdx + 1));  	binRelative = string.Join (Path.DirectorySeparatorChar.ToString ()' parts.Skip (binIdx + 1));  	break;  }  
Magic Number,BinObjJunction,Program,C:\repos\LordJZ_BinObjJunctions\Program.cs,ReduceToBinFolder,The following statement contains a magic number: for (int i = 2; i <= 5; i++) {  	if (parts.Length <= i)  		break;  	int binIdx = parts.Length - i;  	if (!parts [binIdx].Equals ("bin"' StringComparison.InvariantCultureIgnoreCase))  		continue;  	folder = string.Join (Path.DirectorySeparatorChar.ToString ()' parts.Take (binIdx + 1));  	binRelative = string.Join (Path.DirectorySeparatorChar.ToString ()' parts.Skip (binIdx + 1));  	break;  }  
