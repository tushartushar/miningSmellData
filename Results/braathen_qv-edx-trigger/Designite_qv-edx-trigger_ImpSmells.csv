Implementation smell,Namespace,Class,File,Method,Description
Long Method,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The method has 136 lines of code.
Complex Method,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,Cyclomatic complexity of the method is 11
Long Parameter List,qv_edx_trigger.QMSAPI,IQMS,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,TriggerEDXTask,The method has 5 parameters. Parameters: qdsID' taskNameOrID' password' variableName' variableValues
Long Parameter List,qv_edx_trigger.QMSAPI,IQMS,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,AddSelections,The method has 5 parameters. Parameters: session' fieldContents' lockSelection' toggleSelect' returnSelectedList
Long Parameter List,qv_edx_trigger.QMSAPI,IQMS,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetFieldContentList,The method has 5 parameters. Parameters: session' forFieldName' fieldContentType' index' length
Long Parameter List,qv_edx_trigger.QMSAPI,QMSClient,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,TriggerEDXTask,The method has 5 parameters. Parameters: qdsID' taskNameOrID' password' variableName' variableValues
Long Parameter List,qv_edx_trigger.QMSAPI,QMSClient,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,AddSelections,The method has 5 parameters. Parameters: session' fieldContents' lockSelection' toggleSelect' returnSelectedList
Long Parameter List,qv_edx_trigger.QMSAPI,QMSClient,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetFieldContentList,The method has 5 parameters. Parameters: session' forFieldName' fieldContentType' index' length
Long Identifier,qv_edx_trigger.QMSAPI,DocumentFolderGeneral,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter SendAlertEmailForDocumentAdministratorsField is 44.
Long Identifier,qv_edx_trigger.QMSAPI,TaskReload,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter ScriptParameterValueField1Field is 31.
Long Identifier,qv_edx_trigger.QMSAPI,TaskServerAccess,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter EnableSessionCollaborationField is 31.
Long Identifier,qv_edx_trigger.QMSAPI,TaskDocumentLoadClusterSetting,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter QlikViewServerClusterNodeIdField is 32.
Long Identifier,qv_edx_trigger.QMSAPI,QDSDocumentSessionConfiguration,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter EncryptedSectionAccessUserNameField is 35.
Long Identifier,qv_edx_trigger.QMSAPI,DocumentMetaDataLicensing,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter AllowDynamicCALAssignmentField is 30.
Long Identifier,qv_edx_trigger.QMSAPI,DocumentMetaDataServerAccess,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter EnableSessionCollaborationField is 31.
Long Identifier,qv_edx_trigger.QMSAPI,DocumentMetaDataServerDocumentLoad,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter QlikViewServerClusterNodeIdField is 32.
Long Identifier,qv_edx_trigger.QMSAPI,QVSCluster,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter AlternateDocumentRootFolderField is 32.
Long Identifier,qv_edx_trigger.QMSAPI,QVSDocumentsServer,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter AllowAnonymousServerBookmarkCollaborationField is 46.
Long Identifier,qv_edx_trigger.QMSAPI,QVSDocumentsServer,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter AllowSessionCollaborationField is 30.
Long Identifier,qv_edx_trigger.QMSAPI,QVSDocumentsServer,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter ProhibitQVPXSessionRecoveryField is 32.
Long Identifier,qv_edx_trigger.QMSAPI,QVSFolders,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter UserDocumentAdministratorsField is 31.
Long Identifier,qv_edx_trigger.QMSAPI,QVSLoggingLevel,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter PerformanceLoggingIntervalField is 31.
Long Identifier,qv_edx_trigger.QMSAPI,QVSPerformanceDocument,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter ObjectCalculationTimeLimitField is 31.
Long Identifier,qv_edx_trigger.QMSAPI,QVSPerformanceSessions,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter ConcurrentSessionsTimeoutField is 30.
Long Identifier,qv_edx_trigger.QMSAPI,QVSSecurity,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter AllowServerMacroExecutionField is 30.
Long Identifier,qv_edx_trigger.QMSAPI,QVSSecurity,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter AllowServerSystemAccessMacroExecutionField is 42.
Long Identifier,qv_edx_trigger.QMSAPI,QVSSecurityAuthentication,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter UseDomainAccountForAnonymousField is 33.
Long Identifier,qv_edx_trigger.QMSAPI,QDSGeneral,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter DisableTaskTriggersForDocAdminsField is 36.
Long Identifier,qv_edx_trigger.QMSAPI,GetTimeLimitedRequestKeyResponse,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetTimeLimitedRequestKeyResponse,The length of the parameter GetTimeLimitedRequestKeyResult is 30.
Long Identifier,qv_edx_trigger.QMSAPI,GetTimeLimitedRequestKeyResponse,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,,The length of the parameter GetTimeLimitedRequestKeyResult is 30.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10; " is 122.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1; " is 128.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                                {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}' " is 193.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                                {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }' " is 131.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                                {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}' " is 136.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                                {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}' " is 175.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                                {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}' " is 124.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "                LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" }); " is 144.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress); " is 133.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                    TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues); " is 128.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                            LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties); " is 273.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                                return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting); " is 147.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                                    LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties); " is 123.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                                LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties); " is 122.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                        LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties); " is 122.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "                LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties); " is 141.
Long Statement,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,IsGuid,The length of the statement  "                Regex guidRegEx = new Regex(@"^(\{{0'1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0'1})$"); " is 136.
Long Statement,qv_edx_trigger.QMSAPI,QTServiceClient,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetTimeLimitedRequestKey,The length of the statement  "            qv_edx_trigger.QMSAPI.GetTimeLimitedRequestKeyRequest inValue = new qv_edx_trigger.QMSAPI.GetTimeLimitedRequestKeyRequest(); " is 124.
Long Statement,qv_edx_trigger.QMSAPI,QTServiceClient,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetTimeLimitedRequestKey,The length of the statement  "            qv_edx_trigger.QMSAPI.GetTimeLimitedRequestKeyResponse retVal = ((qv_edx_trigger.QMSAPI.IQTService)(this)).GetTimeLimitedRequestKey(inValue); " is 141.
Long Statement,qv_edx_trigger.QMSAPI,QTServiceClient,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetSystemInformation,The length of the statement  "            qv_edx_trigger.QMSAPI.GetSystemInformationResponse retVal = ((qv_edx_trigger.QMSAPI.IQTService)(this)).GetSystemInformation(inValue); " is 133.
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try              {                  t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10;                  t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1;                  t.Wait = ConfigurationManager.AppSettings["Wait"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Wait"]) : 0;                    var p = new OptionSet()                              {                                  {"t|task="' "{TaskNameOrID} of task to trigger (case-sensitive)"' v => t.TaskNameOrId = v}'                                  {"p|password:"' "{Password} for the task (if required)"' v => t.Password = v}'                                  {"variable:"' "{Name} of variable to change"' v => t.VariableName = v}'                                  {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}'                                  {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }'                                  {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}'                                  {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}'                                  {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}'                                  {"v|verbose"' "Increases the verbosity level"' v => { if (v != null) ++t.Verbosity; }}'                                  {"V|version"' "Show version information"' v => version = v != null}'                                  {"?|h|help"' "Show usage information"' v => help = v != null}'                              };                    p.Parse(args);                    if (help || args.Length == 0)                  {                      ShowHelp(p);                      return;                  }                }              catch (Exception ex)              {                  LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" });                  Environment.ExitCode = 9;                  return;              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try              {                  t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10;                  t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1;                  t.Wait = ConfigurationManager.AppSettings["Wait"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Wait"]) : 0;                    var p = new OptionSet()                              {                                  {"t|task="' "{TaskNameOrID} of task to trigger (case-sensitive)"' v => t.TaskNameOrId = v}'                                  {"p|password:"' "{Password} for the task (if required)"' v => t.Password = v}'                                  {"variable:"' "{Name} of variable to change"' v => t.VariableName = v}'                                  {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}'                                  {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }'                                  {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}'                                  {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}'                                  {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}'                                  {"v|verbose"' "Increases the verbosity level"' v => { if (v != null) ++t.Verbosity; }}'                                  {"V|version"' "Show version information"' v => version = v != null}'                                  {"?|h|help"' "Show usage information"' v => help = v != null}'                              };                    p.Parse(args);                    if (help || args.Length == 0)                  {                      ShowHelp(p);                      return;                  }                }              catch (Exception ex)              {                  LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" });                  Environment.ExitCode = 9;                  return;              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try              {                  t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10;                  t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1;                  t.Wait = ConfigurationManager.AppSettings["Wait"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Wait"]) : 0;                    var p = new OptionSet()                              {                                  {"t|task="' "{TaskNameOrID} of task to trigger (case-sensitive)"' v => t.TaskNameOrId = v}'                                  {"p|password:"' "{Password} for the task (if required)"' v => t.Password = v}'                                  {"variable:"' "{Name} of variable to change"' v => t.VariableName = v}'                                  {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}'                                  {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }'                                  {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}'                                  {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}'                                  {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}'                                  {"v|verbose"' "Increases the verbosity level"' v => { if (v != null) ++t.Verbosity; }}'                                  {"V|version"' "Show version information"' v => version = v != null}'                                  {"?|h|help"' "Show usage information"' v => help = v != null}'                              };                    p.Parse(args);                    if (help || args.Length == 0)                  {                      ShowHelp(p);                      return;                  }                }              catch (Exception ex)              {                  LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" });                  Environment.ExitCode = 9;                  return;              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try              {                  t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10;                  t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1;                  t.Wait = ConfigurationManager.AppSettings["Wait"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Wait"]) : 0;                    var p = new OptionSet()                              {                                  {"t|task="' "{TaskNameOrID} of task to trigger (case-sensitive)"' v => t.TaskNameOrId = v}'                                  {"p|password:"' "{Password} for the task (if required)"' v => t.Password = v}'                                  {"variable:"' "{Name} of variable to change"' v => t.VariableName = v}'                                  {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}'                                  {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }'                                  {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}'                                  {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}'                                  {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}'                                  {"v|verbose"' "Increases the verbosity level"' v => { if (v != null) ++t.Verbosity; }}'                                  {"V|version"' "Show version information"' v => version = v != null}'                                  {"?|h|help"' "Show usage information"' v => help = v != null}'                              };                    p.Parse(args);                    if (help || args.Length == 0)                  {                      ShowHelp(p);                      return;                  }                }              catch (Exception ex)              {                  LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" });                  Environment.ExitCode = 9;                  return;              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try              {                  t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10;                  t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1;                  t.Wait = ConfigurationManager.AppSettings["Wait"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Wait"]) : 0;                    var p = new OptionSet()                              {                                  {"t|task="' "{TaskNameOrID} of task to trigger (case-sensitive)"' v => t.TaskNameOrId = v}'                                  {"p|password:"' "{Password} for the task (if required)"' v => t.Password = v}'                                  {"variable:"' "{Name} of variable to change"' v => t.VariableName = v}'                                  {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}'                                  {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }'                                  {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}'                                  {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}'                                  {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}'                                  {"v|verbose"' "Increases the verbosity level"' v => { if (v != null) ++t.Verbosity; }}'                                  {"V|version"' "Show version information"' v => version = v != null}'                                  {"?|h|help"' "Show usage information"' v => help = v != null}'                              };                    p.Parse(args);                    if (help || args.Length == 0)                  {                      ShowHelp(p);                      return;                  }                }              catch (Exception ex)              {                  LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" });                  Environment.ExitCode = 9;                  return;              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try              {                  t.Sleep = ConfigurationManager.AppSettings["Sleep"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Sleep"]) : 10;                  t.TimeOut = ConfigurationManager.AppSettings["Timeout"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Timeout"]) : -1;                  t.Wait = ConfigurationManager.AppSettings["Wait"] != null ? Int32.Parse(ConfigurationManager.AppSettings["Wait"]) : 0;                    var p = new OptionSet()                              {                                  {"t|task="' "{TaskNameOrID} of task to trigger (case-sensitive)"' v => t.TaskNameOrId = v}'                                  {"p|password:"' "{Password} for the task (if required)"' v => t.Password = v}'                                  {"variable:"' "{Name} of variable to change"' v => t.VariableName = v}'                                  {"values:"' "{Value(s)} to assign the variable above (semicolon or comma separated)"' v =>t.VariableValues = new List<string>(v.Split(new[] {';'' '''}' StringSplitOptions.RemoveEmptyEntries))}'                                  {"s|service:"' "Location of QlikView Management Service' defaults to {address} in configuration file"' v => t.ServiceAddress = v }'                                  {"sleep:"' "Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"' v => t.Sleep = Int32.Parse(v)}'                                  {"timeout:"' "Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString(t.TimeOut / 1000 / 60)) + ")"'v => t.TimeOut = Int32.Parse(v)}'                                  {"wait:"' "Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'v => t.Wait = Int32.Parse(v)}'                                  {"v|verbose"' "Increases the verbosity level"' v => { if (v != null) ++t.Verbosity; }}'                                  {"V|version"' "Show version information"' v => version = v != null}'                                  {"?|h|help"' "Show usage information"' v => help = v != null}'                              };                    p.Parse(args);                    if (help || args.Length == 0)                  {                      ShowHelp(p);                      return;                  }                }              catch (Exception ex)              {                  LogHelper.Log(LogLevel.Error' ex.Message.Replace(Environment.NewLine' " ")' new LogProperties { TaskNameOrId = t.TaskNameOrId' ExecId = "-1" });                  Environment.ExitCode = 9;                  return;              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: if (t.Wait > 0)              {                  Console.WriteLine("Waiting for " + t.Wait / 1000 + " seconds...");                  Thread.Sleep(t.Wait);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
Magic Number,qv_edx_trigger,Program,C:\repos\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try              {                  // Create a QMS API client                  IQMS apiClient = String.IsNullOrEmpty(t.ServiceAddress) ? new QMSClient() : new QMSClient("BasicHttpBinding_IQMS"' t.ServiceAddress);                    // Retrieve a time limited service key                  ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                    TaskInfo taskInfo = new TaskInfo();                    if (!IsGuid(t.TaskNameOrId))                  {                      List<TaskInfo> taskList = apiClient.FindEDX(t.TaskNameOrId);                        // Find correct task with support for multiple qds                      if (taskList.Count > 0)                      {                          int i = 0;                            for (i = 0; i < taskList.Count; i++)                          {                              if (taskList[i].Name == t.TaskNameOrId)                                  break;                          }                            taskInfo = new TaskInfo                                         {                                             Name = taskList[i].Name'                                             ID = taskList[i].ID'                                             QDSID = taskList[i].QDSID'                                             Enabled = taskList[i].Enabled                                         };                      }                  }                  else                  {                      taskInfo = apiClient.GetTask(Guid.Parse(t.TaskNameOrId));                  }                    if (taskInfo.Name != null)                  {                      // Trigger the task                      TriggerEDXTaskResult result = apiClient.TriggerEDXTask(Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);                        if (result.EDXTaskStartResult == EDXTaskStartResult.Success)                      {                          logProperties.ExecId = result.ExecId.ToString();                            if (t.Verbosity > 0)                          {                              LogHelper.Log(LogLevel.Info' String.Format("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);                          }                            LogHelper.Log(LogLevel.Info' "Started"' logProperties);                            EDXStatus executionStatus = null;                            if(t.TimeOut != 0)                          {                              // Wait until the task is completed or TIMEOUT has passed.                              SpinWait.SpinUntil(() =>                              {                                  Thread.Sleep(t.Sleep);                                    // Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)                                  if (t.Sleep > 18 * 60 * 1000)                                  {                                      if (t.Verbosity > 1)                                          LogHelper.Log(LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);                                        ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey();                                  }                                    // Get the current state of the task.                                  try                                  {                                      executionStatus = apiClient.GetEDXTaskStatus(Guid.Empty' result.ExecId);                                  }                                  catch (Exception ex)                                  {                                      LogHelper.Log(LogLevel.Warn' String.Format("{0}"' ex.Message.Replace(Environment.NewLine' " "))' logProperties);                                  }                                    if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)                                      LogHelper.Log(LogLevel.Info' executionStatus.TaskStatus.ToString()' logProperties);                                    // Return true if the task has completed.                                  return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);                              }' t.TimeOut);                                // Write the result                              if (executionStatus != null)                              {                                  if (executionStatus.TaskStatus == TaskStatusValue.Completed)                                  {                                      // datetime parsing needs culture formatting' catch it for now and avoid...                                      try                                      {                                          TimeSpan span = DateTime.Parse(executionStatus.FinishTime).Subtract(DateTime.Parse(executionStatus.StartTime));                                          LogHelper.Log(LogLevel.Info' String.Format("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);                                        }                                      catch (Exception)                                      {                                          LogHelper.Log(LogLevel.Info' String.Format("{0}"' executionStatus.TaskStatus)' logProperties);                                      }                                  }                                  else                                  {                                      // If something went wrong' point to the logfile for the task execution                                      exitCode = (Int32)executionStatus.TaskStatus;                                      LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);                                      LogHelper.Log(LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);                                  }                              }                              else                              {                                  exitCode = 9;                                  LogHelper.Log(LogLevel.Error' String.Format("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);                              }                          }                      }                      else                      {                          exitCode = 9;                          LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);                      }                  }                  else                  {                      exitCode = 9;                      LogHelper.Log(LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);                  }              }              catch (Exception ex)              {                  exitCode = 10;                  LogHelper.Log(LogLevel.Error' String.Format("{0} (Error code: {1})"' ex.Message.Replace(Environment.NewLine' " ")' exitCode)' logProperties);              }
