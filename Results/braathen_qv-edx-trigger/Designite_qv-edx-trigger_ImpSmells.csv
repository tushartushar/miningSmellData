Implementation smell,Namespace,Class,File,Method,Description
Long Method,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The method has 100 lines of code.
Long Method,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The method has 107 lines of code.
Complex Method,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,Cyclomatic complexity of the method is 13
Long Parameter List,qv_edx_trigger.QMSAPI,IQMS,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,TriggerEDXTask,The method has 5 parameters.
Long Parameter List,qv_edx_trigger.QMSAPI,IQMS,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,AddSelections,The method has 5 parameters.
Long Parameter List,qv_edx_trigger.QMSAPI,IQMS,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetFieldContentList,The method has 5 parameters.
Long Parameter List,qv_edx_trigger.QMSAPI,QMSClient,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,TriggerEDXTask,The method has 5 parameters.
Long Parameter List,qv_edx_trigger.QMSAPI,QMSClient,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,AddSelections,The method has 5 parameters.
Long Parameter List,qv_edx_trigger.QMSAPI,QMSClient,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetFieldContentList,The method has 5 parameters.
Long Identifier,qv_edx_trigger.QMSAPI,GetTimeLimitedRequestKeyResponse,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetTimeLimitedRequestKeyResponse,The length of the parameter GetTimeLimitedRequestKeyResult is 30.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "		t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10; " is 125.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "		t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1; " is 131.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "		t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0; " is 121.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The length of the statement  "				"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"' " is 130.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "		IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress); " is 136.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "			TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues); " is 129.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "					LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties); " is 275.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "						return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting); " is 147.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "							LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties); " is 125.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "						LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties); " is 124.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties); " is 124.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The length of the statement  "		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties); " is 144.
Long Statement,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,IsGuid,The length of the statement  "		Regex guidRegEx = new Regex (@"^(\{{0'1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0'1})$"); " is 137.
Long Statement,qv_edx_trigger.QMSAPI,QTServiceClient,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetTimeLimitedRequestKey,The length of the statement  "	qv_edx_trigger.QMSAPI.GetTimeLimitedRequestKeyRequest inValue = new qv_edx_trigger.QMSAPI.GetTimeLimitedRequestKeyRequest (); " is 125.
Long Statement,qv_edx_trigger.QMSAPI,QTServiceClient,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetTimeLimitedRequestKey,The length of the statement  "	qv_edx_trigger.QMSAPI.GetTimeLimitedRequestKeyResponse retVal = ((qv_edx_trigger.QMSAPI.IQTService)(this)).GetTimeLimitedRequestKey (inValue); " is 142.
Long Statement,qv_edx_trigger.QMSAPI,QTServiceClient,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Service References\QMSAPI\Reference.cs,GetSystemInformation,The length of the statement  "	qv_edx_trigger.QMSAPI.GetSystemInformationResponse retVal = ((qv_edx_trigger.QMSAPI.IQTService)(this)).GetSystemInformation (inValue); " is 134.
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try {  	t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  	t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1;  	t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0;  	var p = new OptionSet () {  		{  			"t|task="'  			"{TaskNameOrID} of task to trigger (case-sensitive)"'  			v => t.TaskNameOrId = v  		}'  		{  			"p|password:"'  			"{Password} for the task (if required)"'  			v => t.Password = v  		}'  		{  			"variable:"'  			"{Name} of variable to change"'  			v => t.VariableName = v  		}'  		{  			"values:"'  			"{Value(s)} to assign the variable above (semicolon or comma separated)"'  			v => t.VariableValues = new List<string> (v.Split (new[] {  				';''  				'''  			}' StringSplitOptions.RemoveEmptyEntries))  		}'  		{  			"s|service:"'  			"Location of QlikView Management Service' defaults to {address} in configuration file"'  			v => t.ServiceAddress = v  		}'  		{  			"sleep:"'  			"Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"'  			v => t.Sleep = Int32.Parse (v)  		}'  		{  			"timeout:"'  			"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"'  			v => t.TimeOut = Int32.Parse (v)  		}'  		{  			"wait:"'  			"Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'  			v => t.Wait = Int32.Parse (v)  		}'  		{  			"v|verbose"'  			"Increases the verbosity level"'  			v => {  				if (v != null)  					++t.Verbosity;  			}  		}'  		{  			"V|version"'  			"Show version information"'  			v => version = v != null  		}'  		{  			"?|h|help"'  			"Show usage information"'  			v => help = v != null  		}'  	};  	p.Parse (args);  	if (help || args.Length == 0) {  		ShowHelp (p);  		return;  	}  } catch (Exception ex) {  	LogHelper.Log (LogLevel.Error' ex.Message.Replace (Environment.NewLine' " ")' new LogProperties {  		TaskNameOrId = t.TaskNameOrId'  		ExecId = "-1"  	});  	Environment.ExitCode = 9;  	return;  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try {  	t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  	t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1;  	t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0;  	var p = new OptionSet () {  		{  			"t|task="'  			"{TaskNameOrID} of task to trigger (case-sensitive)"'  			v => t.TaskNameOrId = v  		}'  		{  			"p|password:"'  			"{Password} for the task (if required)"'  			v => t.Password = v  		}'  		{  			"variable:"'  			"{Name} of variable to change"'  			v => t.VariableName = v  		}'  		{  			"values:"'  			"{Value(s)} to assign the variable above (semicolon or comma separated)"'  			v => t.VariableValues = new List<string> (v.Split (new[] {  				';''  				'''  			}' StringSplitOptions.RemoveEmptyEntries))  		}'  		{  			"s|service:"'  			"Location of QlikView Management Service' defaults to {address} in configuration file"'  			v => t.ServiceAddress = v  		}'  		{  			"sleep:"'  			"Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"'  			v => t.Sleep = Int32.Parse (v)  		}'  		{  			"timeout:"'  			"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"'  			v => t.TimeOut = Int32.Parse (v)  		}'  		{  			"wait:"'  			"Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'  			v => t.Wait = Int32.Parse (v)  		}'  		{  			"v|verbose"'  			"Increases the verbosity level"'  			v => {  				if (v != null)  					++t.Verbosity;  			}  		}'  		{  			"V|version"'  			"Show version information"'  			v => version = v != null  		}'  		{  			"?|h|help"'  			"Show usage information"'  			v => help = v != null  		}'  	};  	p.Parse (args);  	if (help || args.Length == 0) {  		ShowHelp (p);  		return;  	}  } catch (Exception ex) {  	LogHelper.Log (LogLevel.Error' ex.Message.Replace (Environment.NewLine' " ")' new LogProperties {  		TaskNameOrId = t.TaskNameOrId'  		ExecId = "-1"  	});  	Environment.ExitCode = 9;  	return;  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try {  	t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  	t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1;  	t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0;  	var p = new OptionSet () {  		{  			"t|task="'  			"{TaskNameOrID} of task to trigger (case-sensitive)"'  			v => t.TaskNameOrId = v  		}'  		{  			"p|password:"'  			"{Password} for the task (if required)"'  			v => t.Password = v  		}'  		{  			"variable:"'  			"{Name} of variable to change"'  			v => t.VariableName = v  		}'  		{  			"values:"'  			"{Value(s)} to assign the variable above (semicolon or comma separated)"'  			v => t.VariableValues = new List<string> (v.Split (new[] {  				';''  				'''  			}' StringSplitOptions.RemoveEmptyEntries))  		}'  		{  			"s|service:"'  			"Location of QlikView Management Service' defaults to {address} in configuration file"'  			v => t.ServiceAddress = v  		}'  		{  			"sleep:"'  			"Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"'  			v => t.Sleep = Int32.Parse (v)  		}'  		{  			"timeout:"'  			"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"'  			v => t.TimeOut = Int32.Parse (v)  		}'  		{  			"wait:"'  			"Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'  			v => t.Wait = Int32.Parse (v)  		}'  		{  			"v|verbose"'  			"Increases the verbosity level"'  			v => {  				if (v != null)  					++t.Verbosity;  			}  		}'  		{  			"V|version"'  			"Show version information"'  			v => version = v != null  		}'  		{  			"?|h|help"'  			"Show usage information"'  			v => help = v != null  		}'  	};  	p.Parse (args);  	if (help || args.Length == 0) {  		ShowHelp (p);  		return;  	}  } catch (Exception ex) {  	LogHelper.Log (LogLevel.Error' ex.Message.Replace (Environment.NewLine' " ")' new LogProperties {  		TaskNameOrId = t.TaskNameOrId'  		ExecId = "-1"  	});  	Environment.ExitCode = 9;  	return;  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try {  	t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  	t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1;  	t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0;  	var p = new OptionSet () {  		{  			"t|task="'  			"{TaskNameOrID} of task to trigger (case-sensitive)"'  			v => t.TaskNameOrId = v  		}'  		{  			"p|password:"'  			"{Password} for the task (if required)"'  			v => t.Password = v  		}'  		{  			"variable:"'  			"{Name} of variable to change"'  			v => t.VariableName = v  		}'  		{  			"values:"'  			"{Value(s)} to assign the variable above (semicolon or comma separated)"'  			v => t.VariableValues = new List<string> (v.Split (new[] {  				';''  				'''  			}' StringSplitOptions.RemoveEmptyEntries))  		}'  		{  			"s|service:"'  			"Location of QlikView Management Service' defaults to {address} in configuration file"'  			v => t.ServiceAddress = v  		}'  		{  			"sleep:"'  			"Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"'  			v => t.Sleep = Int32.Parse (v)  		}'  		{  			"timeout:"'  			"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"'  			v => t.TimeOut = Int32.Parse (v)  		}'  		{  			"wait:"'  			"Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'  			v => t.Wait = Int32.Parse (v)  		}'  		{  			"v|verbose"'  			"Increases the verbosity level"'  			v => {  				if (v != null)  					++t.Verbosity;  			}  		}'  		{  			"V|version"'  			"Show version information"'  			v => version = v != null  		}'  		{  			"?|h|help"'  			"Show usage information"'  			v => help = v != null  		}'  	};  	p.Parse (args);  	if (help || args.Length == 0) {  		ShowHelp (p);  		return;  	}  } catch (Exception ex) {  	LogHelper.Log (LogLevel.Error' ex.Message.Replace (Environment.NewLine' " ")' new LogProperties {  		TaskNameOrId = t.TaskNameOrId'  		ExecId = "-1"  	});  	Environment.ExitCode = 9;  	return;  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try {  	t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  	t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1;  	t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0;  	var p = new OptionSet () {  		{  			"t|task="'  			"{TaskNameOrID} of task to trigger (case-sensitive)"'  			v => t.TaskNameOrId = v  		}'  		{  			"p|password:"'  			"{Password} for the task (if required)"'  			v => t.Password = v  		}'  		{  			"variable:"'  			"{Name} of variable to change"'  			v => t.VariableName = v  		}'  		{  			"values:"'  			"{Value(s)} to assign the variable above (semicolon or comma separated)"'  			v => t.VariableValues = new List<string> (v.Split (new[] {  				';''  				'''  			}' StringSplitOptions.RemoveEmptyEntries))  		}'  		{  			"s|service:"'  			"Location of QlikView Management Service' defaults to {address} in configuration file"'  			v => t.ServiceAddress = v  		}'  		{  			"sleep:"'  			"Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"'  			v => t.Sleep = Int32.Parse (v)  		}'  		{  			"timeout:"'  			"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"'  			v => t.TimeOut = Int32.Parse (v)  		}'  		{  			"wait:"'  			"Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'  			v => t.Wait = Int32.Parse (v)  		}'  		{  			"v|verbose"'  			"Increases the verbosity level"'  			v => {  				if (v != null)  					++t.Verbosity;  			}  		}'  		{  			"V|version"'  			"Show version information"'  			v => version = v != null  		}'  		{  			"?|h|help"'  			"Show usage information"'  			v => help = v != null  		}'  	};  	p.Parse (args);  	if (help || args.Length == 0) {  		ShowHelp (p);  		return;  	}  } catch (Exception ex) {  	LogHelper.Log (LogLevel.Error' ex.Message.Replace (Environment.NewLine' " ")' new LogProperties {  		TaskNameOrId = t.TaskNameOrId'  		ExecId = "-1"  	});  	Environment.ExitCode = 9;  	return;  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: try {  	t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  	t.TimeOut = ConfigurationManager.AppSettings ["Timeout"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Timeout"]) : -1;  	t.Wait = ConfigurationManager.AppSettings ["Wait"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Wait"]) : 0;  	var p = new OptionSet () {  		{  			"t|task="'  			"{TaskNameOrID} of task to trigger (case-sensitive)"'  			v => t.TaskNameOrId = v  		}'  		{  			"p|password:"'  			"{Password} for the task (if required)"'  			v => t.Password = v  		}'  		{  			"variable:"'  			"{Name} of variable to change"'  			v => t.VariableName = v  		}'  		{  			"values:"'  			"{Value(s)} to assign the variable above (semicolon or comma separated)"'  			v => t.VariableValues = new List<string> (v.Split (new[] {  				';''  				'''  			}' StringSplitOptions.RemoveEmptyEntries))  		}'  		{  			"s|service:"'  			"Location of QlikView Management Service' defaults to {address} in configuration file"'  			v => t.ServiceAddress = v  		}'  		{  			"sleep:"'  			"Sleep number of {seconds} between status polls (default is " + t.Sleep / 1000 + " seconds)"'  			v => t.Sleep = Int32.Parse (v)  		}'  		{  			"timeout:"'  			"Timeout in number of {minutes} (default is " + (t.TimeOut < 0 ? "indefinitely" : Convert.ToString (t.TimeOut / 1000 / 60)) + ")"'  			v => t.TimeOut = Int32.Parse (v)  		}'  		{  			"wait:"'  			"Wait number of {seconds} (default is " + t.Wait / 1000 + ") before executing task"'  			v => t.Wait = Int32.Parse (v)  		}'  		{  			"v|verbose"'  			"Increases the verbosity level"'  			v => {  				if (v != null)  					++t.Verbosity;  			}  		}'  		{  			"V|version"'  			"Show version information"'  			v => version = v != null  		}'  		{  			"?|h|help"'  			"Show usage information"'  			v => help = v != null  		}'  	};  	p.Parse (args);  	if (help || args.Length == 0) {  		ShowHelp (p);  		return;  	}  } catch (Exception ex) {  	LogHelper.Log (LogLevel.Error' ex.Message.Replace (Environment.NewLine' " ")' new LogProperties {  		TaskNameOrId = t.TaskNameOrId'  		ExecId = "-1"  	});  	Environment.ExitCode = 9;  	return;  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: t.Sleep = ConfigurationManager.AppSettings ["Sleep"] != null ? Int32.Parse (ConfigurationManager.AppSettings ["Sleep"]) : 10;  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: Environment.ExitCode = 9;  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: if (t.Wait > 0) {  	Console.WriteLine ("Waiting for " + t.Wait / 1000 + " seconds...");  	Thread.Sleep (t.Wait);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,Main,The following statement contains a magic number: Console.WriteLine ("Waiting for " + t.Wait / 1000 + " seconds...");  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: try {  	// Create a QMS API client  	IQMS apiClient = String.IsNullOrEmpty (t.ServiceAddress) ? new QMSClient () : new QMSClient ("BasicHttpBinding_IQMS"' t.ServiceAddress);  	// Retrieve a time limited service key  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	TaskInfo taskInfo = new TaskInfo ();  	if (!IsGuid (t.TaskNameOrId)) {  		List<TaskInfo> taskList = apiClient.FindEDX (t.TaskNameOrId);  		// Find correct task with support for multiple qds  		if (taskList.Count > 0) {  			int i = 0;  			for (i = 0; i < taskList.Count; i++) {  				if (taskList [i].Name == t.TaskNameOrId)  					break;  			}  			taskInfo = new TaskInfo {  				Name = taskList [i].Name'  				ID = taskList [i].ID'  				QDSID = taskList [i].QDSID'  				Enabled = taskList [i].Enabled  			};  		}  	} else {  		taskInfo = apiClient.GetTask (Guid.Parse (t.TaskNameOrId));  	}  	if (taskInfo.Name != null) {  		// Trigger the task  		TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  		if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  			logProperties.ExecId = result.ExecId.ToString ();  			if (t.Verbosity > 0) {  				LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  			}  			LogHelper.Log (LogLevel.Info' "Started"' logProperties);  			EDXStatus executionStatus = null;  			if (t.TimeOut != 0) {  				// Wait until the task is completed or TIMEOUT has passed.  				SpinWait.SpinUntil (() => {  					Thread.Sleep (t.Sleep);  					// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  					if (t.Sleep > 18 * 60 * 1000) {  						if (t.Verbosity > 1)  							LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  						ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  					}  					// Get the current state of the task.  					try {  						executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  					} catch (Exception ex) {  						LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  					}  					if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  						LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  					// Return true if the task has completed.  					return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  				}' t.TimeOut);  				// Write the result  				if (executionStatus != null) {  					if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  						// datetime parsing needs culture formatting' catch it for now and avoid...  						try {  							TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  							LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  						} catch (Exception) {  							LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  						}  					} else {  						// If something went wrong' point to the logfile for the task execution  						exitCode = (Int32)executionStatus.TaskStatus;  						LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  						LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  					}  				} else {  					exitCode = 9;  					LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  				}  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  	}  } catch (Exception ex) {  	exitCode = 10;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' ex.Message.Replace (Environment.NewLine' " ")' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (taskInfo.Name != null) {  	// Trigger the task  	TriggerEDXTaskResult result = apiClient.TriggerEDXTask (Guid.Empty' taskInfo.Name' t.Password' t.VariableName' t.VariableValues);  	if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  		logProperties.ExecId = result.ExecId.ToString ();  		if (t.Verbosity > 0) {  			LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  		}  		LogHelper.Log (LogLevel.Info' "Started"' logProperties);  		EDXStatus executionStatus = null;  		if (t.TimeOut != 0) {  			// Wait until the task is completed or TIMEOUT has passed.  			SpinWait.SpinUntil (() => {  				Thread.Sleep (t.Sleep);  				// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  				if (t.Sleep > 18 * 60 * 1000) {  					if (t.Verbosity > 1)  						LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  					ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  				}  				// Get the current state of the task.  				try {  					executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  				} catch (Exception ex) {  					LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  				}  				if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  					LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  				// Return true if the task has completed.  				return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  			}' t.TimeOut);  			// Write the result  			if (executionStatus != null) {  				if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  					// datetime parsing needs culture formatting' catch it for now and avoid...  					try {  						TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  						LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  					} catch (Exception) {  						LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  					}  				} else {  					// If something went wrong' point to the logfile for the task execution  					exitCode = (Int32)executionStatus.TaskStatus;  					LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  					LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  				}  			} else {  				exitCode = 9;  				LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  			}  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' "TaskNotFound (Error code: 9)"' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (result.EDXTaskStartResult == EDXTaskStartResult.Success) {  	logProperties.ExecId = result.ExecId.ToString ();  	if (t.Verbosity > 0) {  		LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  	}  	LogHelper.Log (LogLevel.Info' "Started"' logProperties);  	EDXStatus executionStatus = null;  	if (t.TimeOut != 0) {  		// Wait until the task is completed or TIMEOUT has passed.  		SpinWait.SpinUntil (() => {  			Thread.Sleep (t.Sleep);  			// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  			if (t.Sleep > 18 * 60 * 1000) {  				if (t.Verbosity > 1)  					LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  				ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  			}  			// Get the current state of the task.  			try {  				executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  			} catch (Exception ex) {  				LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  			}  			if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  				LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  			// Return true if the task has completed.  			return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  		}' t.TimeOut);  		// Write the result  		if (executionStatus != null) {  			if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  				// datetime parsing needs culture formatting' catch it for now and avoid...  				try {  					TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  					LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  				} catch (Exception) {  					LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  				}  			} else {  				// If something went wrong' point to the logfile for the task execution  				exitCode = (Int32)executionStatus.TaskStatus;  				LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  				LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  			}  		} else {  			exitCode = 9;  			LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  		}  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' result.EDXTaskStartResult' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.Verbosity > 0) {  	LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.Verbosity > 0) {  	LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: LogHelper.Log (LogLevel.Info' String.Format ("Name: {0}' ID: {1}' Enabled: {2}' Sleep: {3} seconds' Timeout: {4}"' taskInfo.Name' taskInfo.ID' taskInfo.Enabled ? "Yes" : "No"' t.Sleep / 1000' t.TimeOut == -1 ? "Indefinitely" : t.TimeOut / 60000 + " minutes")' logProperties);  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.TimeOut != 0) {  	// Wait until the task is completed or TIMEOUT has passed.  	SpinWait.SpinUntil (() => {  		Thread.Sleep (t.Sleep);  		// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  		if (t.Sleep > 18 * 60 * 1000) {  			if (t.Verbosity > 1)  				LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  			ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  		}  		// Get the current state of the task.  		try {  			executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  		} catch (Exception ex) {  			LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  		}  		if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  			LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  		// Return true if the task has completed.  		return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  	}' t.TimeOut);  	// Write the result  	if (executionStatus != null) {  		if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  			// datetime parsing needs culture formatting' catch it for now and avoid...  			try {  				TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  				LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  			} catch (Exception) {  				LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  			}  		} else {  			// If something went wrong' point to the logfile for the task execution  			exitCode = (Int32)executionStatus.TaskStatus;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  			LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  	}  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.TimeOut != 0) {  	// Wait until the task is completed or TIMEOUT has passed.  	SpinWait.SpinUntil (() => {  		Thread.Sleep (t.Sleep);  		// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  		if (t.Sleep > 18 * 60 * 1000) {  			if (t.Verbosity > 1)  				LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  			ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  		}  		// Get the current state of the task.  		try {  			executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  		} catch (Exception ex) {  			LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  		}  		if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  			LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  		// Return true if the task has completed.  		return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  	}' t.TimeOut);  	// Write the result  	if (executionStatus != null) {  		if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  			// datetime parsing needs culture formatting' catch it for now and avoid...  			try {  				TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  				LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  			} catch (Exception) {  				LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  			}  		} else {  			// If something went wrong' point to the logfile for the task execution  			exitCode = (Int32)executionStatus.TaskStatus;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  			LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  	}  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.TimeOut != 0) {  	// Wait until the task is completed or TIMEOUT has passed.  	SpinWait.SpinUntil (() => {  		Thread.Sleep (t.Sleep);  		// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  		if (t.Sleep > 18 * 60 * 1000) {  			if (t.Verbosity > 1)  				LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  			ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  		}  		// Get the current state of the task.  		try {  			executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  		} catch (Exception ex) {  			LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  		}  		if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  			LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  		// Return true if the task has completed.  		return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  	}' t.TimeOut);  	// Write the result  	if (executionStatus != null) {  		if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  			// datetime parsing needs culture formatting' catch it for now and avoid...  			try {  				TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  				LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  			} catch (Exception) {  				LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  			}  		} else {  			// If something went wrong' point to the logfile for the task execution  			exitCode = (Int32)executionStatus.TaskStatus;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  			LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  	}  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.TimeOut != 0) {  	// Wait until the task is completed or TIMEOUT has passed.  	SpinWait.SpinUntil (() => {  		Thread.Sleep (t.Sleep);  		// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  		if (t.Sleep > 18 * 60 * 1000) {  			if (t.Verbosity > 1)  				LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  			ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  		}  		// Get the current state of the task.  		try {  			executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  		} catch (Exception ex) {  			LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  		}  		if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  			LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  		// Return true if the task has completed.  		return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  	}' t.TimeOut);  	// Write the result  	if (executionStatus != null) {  		if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  			// datetime parsing needs culture formatting' catch it for now and avoid...  			try {  				TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  				LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  			} catch (Exception) {  				LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  			}  		} else {  			// If something went wrong' point to the logfile for the task execution  			exitCode = (Int32)executionStatus.TaskStatus;  			LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  			LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  		}  	} else {  		exitCode = 9;  		LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  	}  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: SpinWait.SpinUntil (() => {  	Thread.Sleep (t.Sleep);  	// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  	if (t.Sleep > 18 * 60 * 1000) {  		if (t.Verbosity > 1)  			LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  		ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	}  	// Get the current state of the task.  	try {  		executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  	} catch (Exception ex) {  		LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  	}  	if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  		LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  	// Return true if the task has completed.  	return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  }' t.TimeOut);  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: SpinWait.SpinUntil (() => {  	Thread.Sleep (t.Sleep);  	// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  	if (t.Sleep > 18 * 60 * 1000) {  		if (t.Verbosity > 1)  			LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  		ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	}  	// Get the current state of the task.  	try {  		executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  	} catch (Exception ex) {  		LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  	}  	if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  		LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  	// Return true if the task has completed.  	return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  }' t.TimeOut);  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: SpinWait.SpinUntil (() => {  	Thread.Sleep (t.Sleep);  	// Retrieve a new service key if sleep time is above 18 minutes to be safe (timeout is 20 minutes in QV11)  	if (t.Sleep > 18 * 60 * 1000) {  		if (t.Verbosity > 1)  			LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  		ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  	}  	// Get the current state of the task.  	try {  		executionStatus = apiClient.GetEDXTaskStatus (Guid.Empty' result.ExecId);  	} catch (Exception ex) {  		LogHelper.Log (LogLevel.Warn' String.Format ("{0}"' ex.Message.Replace (Environment.NewLine' " "))' logProperties);  	}  	if (executionStatus != null && t.Verbosity > 1 && executionStatus.TaskStatus != TaskStatusValue.Running)  		LogHelper.Log (LogLevel.Info' executionStatus.TaskStatus.ToString ()' logProperties);  	// Return true if the task has completed.  	return executionStatus != null && (executionStatus.TaskStatus != TaskStatusValue.Running && executionStatus.TaskStatus != TaskStatusValue.Waiting);  }' t.TimeOut);  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.Sleep > 18 * 60 * 1000) {  	if (t.Verbosity > 1)  		LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.Sleep > 18 * 60 * 1000) {  	if (t.Verbosity > 1)  		LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (t.Sleep > 18 * 60 * 1000) {  	if (t.Verbosity > 1)  		LogHelper.Log (LogLevel.Info' "GetTimeLimitedServiceKey()"' logProperties);  	ServiceKeyClientMessageInspector.ServiceKey = apiClient.GetTimeLimitedServiceKey ();  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: if (executionStatus != null) {  	if (executionStatus.TaskStatus == TaskStatusValue.Completed) {  		// datetime parsing needs culture formatting' catch it for now and avoid...  		try {  			TimeSpan span = DateTime.Parse (executionStatus.FinishTime).Subtract (DateTime.Parse (executionStatus.StartTime));  			LogHelper.Log (LogLevel.Info' String.Format ("{0} (Duration: {1})"' executionStatus.TaskStatus' span)' logProperties);  		} catch (Exception) {  			LogHelper.Log (LogLevel.Info' String.Format ("{0}"' executionStatus.TaskStatus)' logProperties);  		}  	} else {  		// If something went wrong' point to the logfile for the task execution  		exitCode = (Int32)executionStatus.TaskStatus;  		LogHelper.Log (LogLevel.Error' String.Format ("{0} (Error code: {1})"' executionStatus.TaskStatus' exitCode)' logProperties);  		LogHelper.Log (LogLevel.Error' "Logfile: " + executionStatus.LogFileFullPath' logProperties);  	}  } else {  	exitCode = 9;  	LogHelper.Log (LogLevel.Error' String.Format ("Failed to get execution status (Error code: {0})"' exitCode)' logProperties);  }  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: exitCode = 9;  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: exitCode = 9;  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: exitCode = 9;  
Magic Number,qv_edx_trigger,Program,F:\newReposMay17\braathen_qv-edx-trigger\qv-edx-trigger\Program.cs,TriggerTask,The following statement contains a magic number: exitCode = 10;  
