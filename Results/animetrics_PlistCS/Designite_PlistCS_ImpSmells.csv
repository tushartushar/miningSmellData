Implementation smell,Namespace,Class,File,Method,Description
Long Statement,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeXml,The length of the statement  "                    //xmlWriter.WriteComment("DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" " + "\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\""); " is 137.
Long Statement,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeXml,The length of the statement  "                    xmlWriter.WriteDocType("plist"' "-//Apple Computer//DTD PLIST 1.0//EN"' "http://www.apple.com/DTDs/PropertyList-1.0.dtd"' null); " is 128.
Long Statement,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDate,The length of the statement  "            List<byte> buffer =new List<byte>(RegulateNullBytes(BitConverter.GetBytes(PlistDateConverter.ConvertToAppleTimeStamp(obj))' 8)); " is 128.
Long Statement,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinary,The length of the statement  "                        return (objectTable[offsetTable[objRef]] == 0) ? (object)null : ((objectTable[offsetTable[objRef]] == 9) ? true : false); " is 121.
Long Statement,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CheckDictionary,The length of the statement  "            CollectionAssert.AreEquivalent((List<object>)dict["testArray"]' (List<object>)actualDict["testArray"]' "Arrays do not correspond"); " is 131.
Long Statement,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CheckDictionary,The length of the statement  "            CollectionAssert.AreEquivalent((List<object>)dict["testArrayLarge"]' (List<object>)actualDict["testArrayLarge"]' "Large arrays do not correspond."); " is 148.
Long Statement,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CheckDictionary,The length of the statement  "            CollectionAssert.AreEquivalent((Dictionary<string' object>)dict["testDict"]' (Dictionary<string' object>)actualDict["testDict"]' "Dictionaries do not correspond."); " is 164.
Long Statement,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CheckDictionary,The length of the statement  "            CollectionAssert.AreEquivalent((Dictionary<string' object>)dict["testDictLarge"]' (Dictionary<string' object>)actualDict["testDictLarge"]' "Large dictionaries do not correspond."); " is 180.
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,getPlistType,The following statement contains a magic number: byte[] magicHeader = new byte[8];
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,getPlistType,The following statement contains a magic number: stream.Read(magicHeader' 0' 8);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,getPlistType,The following statement contains a magic number: if (BitConverter.ToInt64(magicHeader' 0) == 3472403351741427810)              {                  return plistType.Binary;              }              else              {                  return plistType.Xml;              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinary,The following statement contains a magic number: offsetTable.Add(objectTable.Count - 8);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinary,The following statement contains a magic number: objectTable.AddRange(new byte[6]);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,readBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,readBinary,The following statement contains a magic number: List<byte> trailer = bList.GetRange(bList.Count - 32' 32);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,readBinary,The following statement contains a magic number: offsetTableBytes = bList.GetRange((int)offsetTableOffset' bList.Count - (int)offsetTableOffset - 32);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseDictionary,The following statement contains a magic number: if (children.Count % 2 != 0)              {                  throw new DataMisalignedException("Dictionary elements must have an even number of child nodes");              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseDictionary,The following statement contains a magic number: for (int i = 0; i < children.Count; i += 2)              {                  XmlNode keynode = children[i];                  XmlNode valnode = children[i + 1];                    if (keynode.Name != "key")                  {                      throw new ApplicationException("expected a key node");                  }                    object result = parse(valnode);                    if (result != null)                  {                      dict.Add(keynode.InnerText' result);                  }              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDictionary,The following statement contains a magic number: if (dictionary.Count < 15)              {                  header.Add(Convert.ToByte(0xD0 | Convert.ToByte(dictionary.Count)));              }              else              {                  header.Add(0xD0 | 0xf);                  header.AddRange(writeBinaryInteger(dictionary.Count' false));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,composeBinaryArray,The following statement contains a magic number: if (objects.Count < 15)              {                  header.Add(Convert.ToByte(0xA0 | Convert.ToByte(objects.Count)));              }              else              {                  header.Add(0xA0 | 0xf);                  header.AddRange(writeBinaryInteger(objects.Count' false));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDate,The following statement contains a magic number: List<byte> buffer =new List<byte>(RegulateNullBytes(BitConverter.GetBytes(PlistDateConverter.ConvertToAppleTimeStamp(obj))' 8));
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryBool,The following statement contains a magic number: List<byte> buffer = new List<byte>(new byte[1] { (bool)obj ? (byte)9 : (byte)8 });
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryBool,The following statement contains a magic number: List<byte> buffer = new List<byte>(new byte[1] { (bool)obj ? (byte)9 : (byte)8 });
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryInteger,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))                  buffer.Add(0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryInteger,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))                  buffer.Add(0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryInteger,The following statement contains a magic number: int header = 0x10 | (int)(Math.Log(buffer.Count) / Math.Log(2));
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDouble,The following statement contains a magic number: List<byte> buffer =new List<byte>(RegulateNullBytes(BitConverter.GetBytes(value)' 4));
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDouble,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))                  buffer.Add(0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDouble,The following statement contains a magic number: while (buffer.Count != Math.Pow(2' Math.Log(buffer.Count) / Math.Log(2)))                  buffer.Add(0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryDouble,The following statement contains a magic number: int header = 0x20 | (int)(Math.Log(buffer.Count) / Math.Log(2));
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryByteArray,The following statement contains a magic number: if (value.Length < 15)              {                  header.Add(Convert.ToByte(0x40 | Convert.ToByte(value.Length)));              }              else              {                  header.Add(0x40 | 0xf);                  header.AddRange(writeBinaryInteger(buffer.Count' false));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,writeBinaryString,The following statement contains a magic number: if (head)              {                  if (value.Length < 15)                  {                      header.Add(Convert.ToByte(0x50 | Convert.ToByte(value.Length)));                  }                  else                  {                      header.Add(0x50 | 0xf);                      header.AddRange(writeBinaryInteger(buffer.Count' false));                  }              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: offsetByteSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(6' 1).ToArray()' 4)' 0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: objRefSize = BitConverter.ToInt32(RegulateNullBytes(trailer.GetRange(7' 1).ToArray()' 4)' 0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] refCountBytes = trailer.GetRange(12' 4).ToArray();
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseTrailer,The following statement contains a magic number: byte[] offsetTableOffsetBytes = trailer.GetRange(24' 8).ToArray();
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseOffsetTable,The following statement contains a magic number: for (int i = 0; i < offsetTableBytes.Count; i += offsetByteSize)              {                  byte[] buffer = offsetTableBytes.GetRange(i' offsetByteSize).ToArray();                  Array.Reverse(buffer);                  offsetTable.Add(BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)                  refStartPosition = offsetTable[objRef] + 1;              else                  refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: if (refCount < 15)                  refStartPosition = offsetTable[objRef] + 1;              else                  refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)              {                  byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();                  Array.Reverse(refBuffer);                  refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryDictionary,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * 2 * objRefSize; i += objRefSize)              {                  byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();                  Array.Reverse(refBuffer);                  refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryArray,The following statement contains a magic number: if (refCount < 15)                  refStartPosition = offsetTable[objRef] + 1;              else                  //The following integer has a header aswell so we increase the refStartPosition by two to account for that.                  refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryArray,The following statement contains a magic number: if (refCount < 15)                  refStartPosition = offsetTable[objRef] + 1;              else                  //The following integer has a header aswell so we increase the refStartPosition by two to account for that.                  refStartPosition = offsetTable[objRef] + 2 + RegulateNullBytes(BitConverter.GetBytes(refCount)' 1).Length;
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryArray,The following statement contains a magic number: for (int i = refStartPosition; i < refStartPosition + refCount * objRefSize; i += objRefSize)              {                  byte[] refBuffer = objectTable.GetRange(i' objRefSize).ToArray();                  Array.Reverse(refBuffer);                  refs.Add(BitConverter.ToInt32(RegulateNullBytes(refBuffer' 4)' 0));              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,getCount,The following statement contains a magic number: if (headerByteTrail < 15)              {                  count = headerByteTrail;                  newBytePosition = bytePosition + 1;              }              else                  count = (int)parseBinaryInt(bytePosition + 1' out newBytePosition);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinary,The following statement contains a magic number: switch (header & 0xF0)              {                  case 0:                      {                          //If the byte is                          //0 return null                          //9 return true                          //8 return false                          return (objectTable[offsetTable[objRef]] == 0) ? (object)null : ((objectTable[offsetTable[objRef]] == 9) ? true : false);                      }                  case 0x10:                      {                          return parseBinaryInt(offsetTable[objRef]);                      }                  case 0x20:                      {                          return parseBinaryReal(offsetTable[objRef]);                      }                  case 0x30:                      {                          return parseBinaryDate(offsetTable[objRef]);                      }                  case 0x40:                      {                          return parseBinaryByteArray(offsetTable[objRef]);                      }                  case 0x50://String ASCII                      {                          return parseBinaryAsciiString(offsetTable[objRef]);                      }                  case 0x60://String Unicode                      {                          return parseBinaryUnicodeString(offsetTable[objRef]);                      }                  case 0xD0:                      {                          return parseBinaryDictionary(objRef);                      }                  case 0xA0:                      {                          return parseBinaryArray(objRef);                      }              }
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryDate,The following statement contains a magic number: byte[] buffer = objectTable.GetRange(headerPosition + 1' 8).ToArray();
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryInt,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryInt,The following statement contains a magic number: return BitConverter.ToInt32(RegulateNullBytes(buffer' 4)' 0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryReal,The following statement contains a magic number: int byteCount = (int)Math.Pow(2' header & 0xf);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryReal,The following statement contains a magic number: return BitConverter.ToDouble(RegulateNullBytes(buffer' 8)' 0);
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryUnicodeString,The following statement contains a magic number: charCount = charCount * 2;
Magic Number,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinaryUnicodeString,The following statement contains a magic number: for (int i = 0; i < charCount; i+=2)              {                  one = objectTable.GetRange(charStartPosition+i'1)[0];                  two = objectTable.GetRange(charStartPosition + i+1' 1)[0];                    if (BitConverter.IsLittleEndian)                  {                      buffer[i] = two;                      buffer[i + 1] = one;                  }                  else                  {                      buffer[i] = one;                      buffer[i + 1] = two;                  }              }
Magic Number,PlistCS,PlistDateConverter,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,ConvertFromAppleTimeStamp,The following statement contains a magic number: DateTime origin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,PlistCS,PlistDateConverter,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,ConvertToAppleTimeStamp,The following statement contains a magic number: DateTime begin = new DateTime(2001' 1' 1' 0' 0' 0' 0);
Magic Number,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CreateDictionary,The following statement contains a magic number: const int largeCollectionSize = 18;
Magic Number,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CreateDictionary,The following statement contains a magic number: for (int i = 0; i < largeCollectionSize; i++)              {                  largeArray.Add(i);                  string key = i.ToString();                  if (i < 10)                      key = "0" + i.ToString();                  largeDict.Add(key' i);              }
Magic Number,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CreateDictionary,The following statement contains a magic number: dict.Add("testInt"' -3455);
Magic Number,Testing,plistTests,C:\repos\animetrics_PlistCS\PlistCS\PlistCS\PlistTests.cs,CreateDictionary,The following statement contains a magic number: dict.Add("testArray"' new List<object> { 34' "string item in array" });
Missing Default,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parse,The following switch statement is missing a default case: switch (node.Name)              {                  case "dict":                      return parseDictionary(node);                  case "array":                      return parseArray(node);                  case "string":                      return node.InnerText;                  case "integer":                    //  int result;                      //int.TryParse(node.InnerText' System.Globalization.NumberFormatInfo.InvariantInfo' out result);                      return Convert.ToInt32(node.InnerText' System.Globalization.NumberFormatInfo.InvariantInfo);                  case "real":                      return Convert.ToDouble(node.InnerText'System.Globalization.NumberFormatInfo.InvariantInfo);                  case "false":                      return false;                  case "true":                      return true;                  case "null":                      return null;                  case "date":                      return XmlConvert.ToDateTime(node.InnerText' XmlDateTimeSerializationMode.Utc);                  case "data":                      return Convert.FromBase64String(node.InnerText);              }
Missing Default,PlistCS,Plist,C:\repos\animetrics_PlistCS\PlistCS\Src\Plist.cs,parseBinary,The following switch statement is missing a default case: switch (header & 0xF0)              {                  case 0:                      {                          //If the byte is                          //0 return null                          //9 return true                          //8 return false                          return (objectTable[offsetTable[objRef]] == 0) ? (object)null : ((objectTable[offsetTable[objRef]] == 9) ? true : false);                      }                  case 0x10:                      {                          return parseBinaryInt(offsetTable[objRef]);                      }                  case 0x20:                      {                          return parseBinaryReal(offsetTable[objRef]);                      }                  case 0x30:                      {                          return parseBinaryDate(offsetTable[objRef]);                      }                  case 0x40:                      {                          return parseBinaryByteArray(offsetTable[objRef]);                      }                  case 0x50://String ASCII                      {                          return parseBinaryAsciiString(offsetTable[objRef]);                      }                  case 0x60://String Unicode                      {                          return parseBinaryUnicodeString(offsetTable[objRef]);                      }                  case 0xD0:                      {                          return parseBinaryDictionary(objRef);                      }                  case 0xA0:                      {                          return parseBinaryArray(objRef);                      }              }
