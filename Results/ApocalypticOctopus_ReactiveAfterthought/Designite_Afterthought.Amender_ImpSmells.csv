Implementation smell,Namespace,Class,File,Method,Description
Long Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,The method has 152 lines of code.
Long Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The method has 101 lines of code.
Long Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The method has 238 lines of code.
Long Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The method has 168 lines of code.
Long Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendEvent,The method has 112 lines of code.
Long Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The method has 121 lines of code.
Long Method,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,EmitOperations,The method has 154 lines of code.
Long Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The method has 287 lines of code.
Long Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The method has 657 lines of code.
Long Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The method has 225 lines of code.
Long Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,VisibilityIntersection,The method has 153 lines of code.
Long Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The method has 100 lines of code.
Long Method,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,EscapeKeyword,The method has 157 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,CreateIndicesFor,The method has 105 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The method has 170 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The method has 198 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeTypeReference,The method has 164 lines of code.
Long Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The method has 217 lines of code.
Long Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The method has 119 lines of code.
Long Method,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\CoreTypes.cs,CoreTypes,The method has 170 lines of code.
Long Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The method has 121 lines of code.
Long Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The method has 108 lines of code.
Long Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeReference,The method has 105 lines of code.
Long Method,Microsoft.Cci.MetadataReader,TypeSpecSignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,TypeSpecSignatureConverter,The method has 121 lines of code.
Long Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,The method has 125 lines of code.
Long Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The method has 460 lines of code.
Long Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The method has 104 lines of code.
Long Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The method has 231 lines of code.
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,Cyclomatic complexity of the method is 28
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,Cyclomatic complexity of the method is 10
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,Cyclomatic complexity of the method is 10
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendConstructor,Cyclomatic complexity of the method is 11
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,Cyclomatic complexity of the method is 21
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,Cyclomatic complexity of the method is 19
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendEvent,Cyclomatic complexity of the method is 10
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,Cyclomatic complexity of the method is 22
Complex Method,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,Cyclomatic complexity of the method is 11
Complex Method,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,ILAmender,Cyclomatic complexity of the method is 50
Complex Method,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,GetLabel,Cyclomatic complexity of the method is 19
Complex Method,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,EmitOperations,Cyclomatic complexity of the method is 63
Complex Method,Afterthought.Amender,Program,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Program.cs,Amend,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateBlocksForBranchTargetsAndFallthroughs,Cyclomatic complexity of the method is 46
Complex Method,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,GetInstruction,Cyclomatic complexity of the method is 55
Complex Method,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupDominanceFrontier,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupImmediateDominators,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,Cyclomatic complexity of the method is 272
Complex Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,FillInTypes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,Cyclomatic complexity of the method is 595
Complex Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,Cyclomatic complexity of the method is 53
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,LongVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,ShortVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,SizeOfOffset,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitMethodBody,Cyclomatic complexity of the method is 47
Complex Method,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitDebugInformationFor,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitOperation,Cyclomatic complexity of the method is 58
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,Parse,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FindOptionByReflection,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ProcessOptionWithMatchingField,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintOptions,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyImplementedInterfaceMethods,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetEventSignature,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldSignature,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendPropertyName,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,ClrHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ClrOperandStackTypeFor,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci,ClrHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ConversionPossible,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,EffectiveBaseClass,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsCompileTimeConstantType,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsPrimitiveInteger,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsSignedPrimitive,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,VisibilityIntersection,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetField,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,StackType,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypeAlignment,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AppendArrayDimensions,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,EscapeKeyword,Cyclomatic complexity of the method is 76
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetTypeName,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeInstanceName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,DispatchAsReference,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetNamespaceScopes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,CreateIndicesFor,Cyclomatic complexity of the method is 46
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetDataOffset,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetFieldFlags,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetGenericParamFlags,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMappingFlags,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMethodFlags,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMethodImplementationFlags,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeCodeByteFor,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefFlags,Cyclomatic complexity of the method is 41
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeMemberVisibilityFlags,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetUserStringToken,Cyclomatic complexity of the method is 35
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeLocalVariableSignatureAndReturnToken,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateMethodSemanticsTableRows,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeDefTableRows,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadataConstantValue,Cyclomatic complexity of the method is 40
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,Cyclomatic complexity of the method is 148
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeExceptionInformation,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeCustomAttributeSignature,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadataExpression,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMarshallingDescriptor,Cyclomatic complexity of the method is 32
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetSerializedTypeName,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeSignature,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeTypeReference,Cyclomatic complexity of the method is 67
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,Cyclomatic complexity of the method is 21
Complex Method,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,CopyTo,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetFragmentLocationsFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ToLineColumn,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ToLineColumn,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ToPosition,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.Cci,SourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Immutable,DummyArrayMethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,DummyArrayMethodReference,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Immutable,PlatformType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,GetTypeFor,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,Cyclomatic complexity of the method is 10
Complex Method,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,KindToString,Cyclomatic complexity of the method is 18
Complex Method,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,CountFailure,Cyclomatic complexity of the method is 18
Complex Method,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,CountCheck,Cyclomatic complexity of the method is 18
Complex Method,System.Diagnostics.Contracts.Internal,ContractHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\Contracts.cs,GetDisplayMessage,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,AddDefinition,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,AddDefinition,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MutableCodeModel,FieldDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,MethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MutableCodeModel,MarshallingInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Miscellaneous.cs,Copy,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,NestedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Resolve,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Copy,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,SelfInstance,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,Assembly,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Units.cs,Copy,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MutableCodeModel,Module,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Units.cs,Copy,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,Insert,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Pdb,PdbConstant,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbConstant.cs,PdbConstant,Cyclomatic complexity of the method is 53
Complex Method,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadTokenToSourceInfo,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,ReadSourceFileInfo,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,LoadManagedFunctions,Cyclomatic complexity of the method is 37
Complex Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,CountScopesAndSlots,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,Cyclomatic complexity of the method is 34
Complex Method,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.Pdb,PdbScope,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbScope.cs,PdbScope,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.Cci.Pdb,PdbLocalConstant,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetTypeForConstant,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,NextToken,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ParseFullName,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ParseAssemblyName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetFieldOrPropType,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,Cyclomatic complexity of the method is 43
Complex Method,Microsoft.Cci.MetadataReader,CustomAttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,CustomAttributeDecoder,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSecurityAttribute,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\CoreTypes.cs,CoreTypes,Cyclomatic complexity of the method is 60
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetUninterpretedPESections,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetWin32Resources,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadTypesInNamespace,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeReferenceForToken,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,ResolveModuleTypeRefReference,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetReferenceToAliasedType,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadNestedTypesOfType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadMembersOf_Module_Type,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetFieldMapping,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetFieldSizeIfPossibleToDoSoWithoutResolving,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetDefaultValue,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMethodReferenceForToken,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetReferenceForToken,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeReference,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,MethodDefSignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,MethodDefSignatureConverter,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.MetadataReader,TypeSpecSignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,TypeSpecSignatureConverter,Cyclomatic complexity of the method is 85
Complex Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Rewrite,Cyclomatic complexity of the method is 40
Complex Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,Cyclomatic complexity of the method is 351
Complex Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,Cyclomatic complexity of the method is 94
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadPEFileLevelData,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToTag,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetTypeDefProps,Cyclomatic complexity of the method is 10
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AssemblyAmender,The method has 7 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,The method has 10 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddMethod,The method has 9 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The method has 5 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The method has 6 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,EmitDefaultEvent,The method has 7 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The method has 8 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AreEquivalent,The method has 5 parameters.
Long Parameter List,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The method has 6 parameters.
Long Parameter List,Afterthought.Amender,Program,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Program.cs,Amend,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.Analysis,ControlAndDataFlowGraph,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\Graph.cs,ControlAndDataFlowGraph,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,TypeInferencer,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AddExceptionHandlerInformation,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,ILGeneratorMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\MethodBody.cs,ILGeneratorMethodBody,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FinishArgument,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ProcessOptionWithMatchingField,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,MetadataHostEnvironment,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,MetadataReaderHost,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternId,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternedKey,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,IAssemblyName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,BindToObject,The method has 8 parameters.
Long Parameter List,Microsoft.Cci,MethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,MethodReference,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,MethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,MethodReference,The method has 8 parameters.
Long Parameter List,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetMethod,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParameterListsAreEquivalent,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParameterListsAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParameterListsAreEquivalent,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,ISCopeContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,GetMatchingMembersNamed,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,ISCopeContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,GetMembersNamed,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,IInternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,GetFunctionPointerTypeReferenceInternedKey,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,IInternFactoryContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,GetFunctionPointerTypeReferenceInternedKey,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,DummyInternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\DummyObjects.cs,GetFunctionPointerTypeReferenceInternedKey,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,AssemblyIdentity,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineLocalVariable,The method has 9 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineParameter,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineField,The method has 9 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineGlobalVariable,The method has 8 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,SetMethodSourceRange,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineSequencePoints,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,Initialize2,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineLocalVariable2,The method has 9 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter2,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,DefineGlobalVariable2,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,ISymUnmanagedWriter5,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\ISymbolWriter.cs,MapTokenToSourceSpan,The method has 6 parameters.
Long Parameter List,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PeWriter,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WritePeToStream,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,SourceEditHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,SourceEditHostEnvironment,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,ErrorMessage,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ErrorMessage,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,PrimarySourceDocument,The method has 5 parameters.
Long Parameter List,Microsoft.Cci,EditDescriptor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,EditDescriptor,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Immutable,NamespaceTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,NamespaceTypeReference,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Immutable,PlatformType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,CreateReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Immutable,FunctionPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,FunctionPointerType,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,Matrix,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetMatrix,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializedNestedTypeDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,BinarySearchForSlot,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,BinarySearchReference,The method has 5 parameters.
Long Parameter List,System.Diagnostics.Contracts,ContractException,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\Contracts.cs,ContractException,The method has 5 parameters.
Long Parameter List,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,TriggerFailure,The method has 5 parameters.
Long Parameter List,System.Diagnostics.Contracts.Internal,ContractHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\Contracts.cs,TriggerFailure,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MutableCodeModel,MutableModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetGenericTypeParameterReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MutableCodeModel,MutableModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetNestedTypeReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MutableCodeModel,MutableModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetNamespaceTypeReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MutableCodeModel,MutableModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetSpecializedNestedTypeReference,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.MutableCodeModel,MutableModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetFunctionPointerTypeReference,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.Pdb,DataStream,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\DataStream.cs,Read,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFuncsFromDbiModule,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadTokenToSourceInfo,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,ReadSourceFileInfo,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,CountScopesAndSlots,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbLine,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbLine.cs,PdbLine,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbScope,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbScope.cs,PdbScope,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbTokenLine,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbTokenLine.cs,PdbTokenLine,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbSourceLineLocation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,PdbSourceLineLocation,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FieldOrPropertyNamedArgumentExpression,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,FieldOrPropertyNamedArgumentExpression,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CustomAttribute,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,CustomAttribute,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Module,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,Module,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Assembly,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,Assembly,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FieldDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,FieldDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalFieldDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GlobalFieldDefinition,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,MethodDefinition,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericMethod,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,NonGenericMethod,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalNonGenericMethod,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GlobalNonGenericMethod,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethod,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GenericMethod,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalGenericMethod,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GlobalGenericMethod,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,EventDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,EventDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,PropertyDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,PropertyDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,MethodReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Win32Resource,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,Win32Resource,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ResourceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,ResourceReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Resource,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,Resource,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CoreTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,CoreTypeReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,TypeRefReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NamespaceTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NonGenericNamespaceTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNamespaceTypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericNamespaceTypeRefReference,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReferenceWithoutPrimitiveTypeCode,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NamespaceTypeRefReferenceWithoutPrimitiveTypeCode,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReferenceWithPrimitiveTypeCode,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NamespaceTypeRefReferenceWithPrimitiveTypeCode,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NestedTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNestedTypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NonGenericNestedTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedTypeRefReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericNestedTypeRefReference,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NamespaceType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NonGenericNamespaceType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithoutPrimitiveType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NonGenericNamespaceTypeWithoutPrimitiveType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,_Module_Type,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,_Module_Type,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NonGenericNamespaceTypeWithPrimitiveType,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNamespaceType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericNamespaceType,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNestedType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NonGenericNestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericNestedType,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericParameter,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericTypeParameter,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GenericMethodParameter,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MatrixWithToken,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,MatrixWithToken,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FunctionPointerTypeWithToken,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,FunctionPointerTypeWithToken,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ExportedTypeNamespaceAlias,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ExportedTypeNamespaceAlias,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ExportedTypeNestedAlias,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ExportedTypeNestedAlias,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Parameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,Parameter,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterInfo,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ParameterInfo,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterWithMetadata,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ParameterWithMetadata,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterWithoutMetadata,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ParameterWithoutMetadata,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,CreateCoreTypeReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,PEFileToObjectModel,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,WindowsRuntimeMetadataReaderHost,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.MethodBody,LocalVariableDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,LocalVariableDefinition,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.MethodBody,CilExceptionInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CilExceptionInformation,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeDefTableReader,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MemberRefTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,CustomAttributeTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ImplMapTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ModuleRow,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ModuleRow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,TypeDefRow,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,TypeDefRow,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodRow,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,MethodRow,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,AssemblyRow,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,AssemblyRow,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefRow,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,AssemblyRefRow,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeRow,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ExportedTypeRow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,SEHTableEntry,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,SEHTableEntry,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodIL,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,MethodIL,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineNestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineMethod,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineImportType,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineImportMember,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineEvent,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetEventProps,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineField,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineProperty,The method has 11 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineParam,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetFieldProps,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetPropertyProps,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetParamProps,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataEmit,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,TranslateSigWithScope,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetTypeDefProps,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumMembersWithName,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumMethodsWithName,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumFieldsWithName,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumMethodImpls,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumPermissionSets,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetMethodProps,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetMemberRefProps,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetEventProps,The method has 12 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetClassLayout,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetPinvokeMap,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumCustomAttributes,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetMemberProps,The method has 12 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetFieldProps,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetPropertyProps,The method has 15 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,IMetaDataImport,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetParamProps,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineNestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineMethod,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineImportType,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineImportMember,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineEvent,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetEventProps,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineField,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineProperty,The method has 11 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,DefineParam,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetFieldProps,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetPropertyProps,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,SetParamProps,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,TranslateSigWithScope,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetTypeDefProps,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumMembersWithName,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumMethodsWithName,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumFieldsWithName,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumMethodImpls,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumPermissionSets,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetMethodProps,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetMemberRefProps,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetEventProps,The method has 12 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetClassLayout,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetPinvokeMap,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,EnumCustomAttributes,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetMemberProps,The method has 12 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetFieldProps,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetPropertyProps,The method has 15 parameters.
Long Parameter List,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetParamProps,The method has 9 parameters.
Long Identifier,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the parameter lastInstructionWasUnconditionalTransfer is 39.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNamespaceTypeReferenceInternId,The length of the parameter containingUnitNamespaceInteredId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedTypeReferenceInternId,The length of the parameter containingTypeReferenceInteredId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodParameterReferenceInternId,The length of the parameter definingMethodReferenceInternId is 31.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the parameter requiredParameterTypesInternedId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the parameter returnValueCustomModifiersInternedId is 36.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the parameter containingTypeReferenceInternedId is 33.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the parameter requiredParameterTypesInternedId is 32.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the parameter returnValueCustomModifiersInternedId is 36.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodInstanceReferenceInternedKey,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetFieldReferenceInternedId,The length of the parameter containingTypeReferenceInternedId is 33.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCustomModifierListInternId,The length of the parameter currentCustomModifierInternedId is 31.
Long Identifier,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,Unspecialize,The length of the parameter potentiallySpecializedEventDefinition is 37.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,Unspecialize,The length of the parameter potentiallySpecializedFieldReference is 36.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,Unspecialize,The length of the parameter potentiallySpecializedFieldDefinition is 37.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,UninstantiateAndUnspecialize,The length of the parameter potentiallySpecializedMethodReference is 37.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,UninstantiateAndUnspecialize,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,Unspecialize,The length of the parameter potentiallySpecializedPropertyDefinition is 40.
Long Identifier,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter operationExceptionInformations is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,DispatchAsReference,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,BaseMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,MetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Traverse,The length of the parameter operationExceptionInformations is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,IMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,IMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,IMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,IMetadataVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,IMetadataVisitorContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,IMetadataVisitorContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,IMetadataVisitorContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci,IMetadataVisitorContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetGenericMethodInstanceIndex,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeGenericMethodInstanceSignature,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeTypeReference,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci,DummyPrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\DummyObjects.cs,GetCorrespondingSourceLocation,The length of the parameter sourceLocationInPreviousVersionOfDocument is 41.
Long Identifier,Microsoft.Cci,DummySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\DummyObjects.cs,GetCorrespondingSourceLocation,The length of the parameter sourceLocationInPreviousVersionOfDocument is 41.
Long Identifier,Microsoft.Cci,SourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the parameter sourceLocationInPreviousVersionOfDocument is 41.
Long Identifier,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,SourceDocumentWithInclusion,The length of the parameter startingPositionOfIncludedRegion is 32.
Long Identifier,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the parameter sourceLocationInPreviousVersionOfDocument is 41.
Long Identifier,Microsoft.Cci,ISourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Interfaces.cs,GetCorrespondingSourceLocation,The length of the parameter sourceLocationInPreviousVersionOfDocument is 41.
Long Identifier,Microsoft.Cci.Immutable,SpecializedEventDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedFieldDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedGenericMethodParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the parameter specializedOperationExceptionInformation is 40.
Long Identifier,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the parameter unspecializedOperationException is 31.
Long Identifier,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,CopyAndSpecialize,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the parameter partiallySpecializedTypeReference is 33.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataShallowCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataShallowCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataShallowCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataShallowCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,GetMutableShallowCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,GetMutableShallowCopy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,GetMutableShallowCopy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,GetTypeSpecificMutableShallowCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the parameter specializedNesetedTypeReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,GenericMethodInstanceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,MetadataRewriter,The length of the parameter copyAndRewriteImmutableReferences is 33.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableFunctionPointerTypeReference is 35.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableGenericMethodInstanceReference is 37.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableGenericMethodInstanceReference is 37.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableGenericTypeInstanceReference is 35.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableGenericTypeParameterReference is 36.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableManagedPointerTypeReference is 34.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableNamespaceTypeDefinition is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableNestedUnitNamespaceReference is 35.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableOperationExceptionInformation is 36.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableParameterTypeInformation is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutablePlatformInvokeInformation is 32.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableRootUnitNamespaceReference is 33.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableSpecializedFieldReference is 32.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableSpecializedMethodReference is 33.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter mutableSpecializedNestedTypeReference is 37.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the parameter operationExceptionInformations is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetMutableCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetMutableCopy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetMutableCopy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetTypeSpecificMutableCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetTypeSpecificReferenceCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetReferenceCopy,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.MutableCodeModel,GenericMethodParameterReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Copy,The length of the parameter genericMethodParameterReference is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Copy,The length of the parameter specializedNestedTypeDefinition is 31.
Long Identifier,Microsoft.Cci.MutableCodeModel,SpecializedNestedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Copy,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,NestedNamespaceReference,The length of the parameter parentModuleNamespaceReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SafeArrayMarshallingInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,SafeArrayMarshallingInformation,The length of the parameter safeArrayElementUserDefinedSubType is 34.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameNamespaceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceTypeNameNamespaceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,NestedNamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,RootNamespaceTypeNameNamespaceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,RootNamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the parameter genericParamConstraintRowIdStart is 32.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the parameter genericParamConstraintRowIdEnd is 30.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_01010101010101010101010101010101 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00110011001100110011001100110011 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00001111000011110000111100001111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000111111110000000011111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000000000001111111111111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_11111111111111111111111111111111 is 37.
Long Identifier,Microsoft.Cci.PeWriterInternal,ReferenceIndexer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,TraverseChildren,The length of the parameter genericMethodInstanceReference is 30.
Long Identifier,Microsoft.Cci.PeWriterInternal,ReferenceIndexer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,TraverseChildren,The length of the parameter specializedNestedTypeReference is 30.
Long Statement,Afterthought.Amender,Amender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Amender.cs,Execute,The length of the statement  "		Program.Amend (TargetAssembly.First ().ItemSpec' AmendmentAssemblies.Select (a => a.ItemSpec).ToArray ()' ReferenceAssemblies.Select (a => a.ItemSpec).ToArray ()); " is 163.
Long Statement,Afterthought.Amender,Amender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Amender.cs,Execute,The length of the statement  "	Log.LogMessage (MessageImportance.High' "Amending Complete ({0:0.000} seconds)"' DateTime.Now.Subtract (start).TotalSeconds); " is 125.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,The length of the statement  "			var existingProperty = type.Properties == null ? null : type.Properties.Where (p => AreEquivalent (p' property) && p.Visibility == TypeMemberVisibility.Public).FirstOrDefault (); " is 178.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,The length of the statement  "			var existingMethod = type.Methods == null ? null : type.Methods.Where (m => AreEquivalent (m' method) && m.Visibility == TypeMemberVisibility.Public).FirstOrDefault (); " is 168.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,The length of the statement  "			var existingEvent = type.Events == null ? null : type.Events.Where (e => AreEquivalent (e' eventInfo) && e.Visibility == TypeMemberVisibility.Public).FirstOrDefault (); " is 168.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendType,The length of the statement  "				var args = eventInfo.EventHandlerType.GetMethod ("Invoke").GetParameters ().SkipWhile ((p' i) => (i == 0 && p.ParameterType == typeof(object)) || (i == 1 && p.ParameterType == typeof(EventArgs))).Select (p => p.ParameterType).ToArray (); " is 237.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The length of the statement  "	if (property.Getter != null || (isInterface && property.Implements.GetGetMethod () != null) || (!isInterface && property.Setter == null)) { " is 139.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The length of the statement  "			Name = host.NameTable.GetNameFor ((isInterface ? property.Implements.DeclaringType.FullName + "." : "") + "get_" + (isInterface ? property.Implements.Name : property.Name))' " is 173.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The length of the statement  "			Implement (type' ResolveProperty (ResolveType (property.Implements.DeclaringType)' property.Implements).Getter' getter); " is 120.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The length of the statement  "	if (property.Setter != null || (isInterface && property.Implements.GetSetMethod () != null) || (!isInterface && property.Getter == null)) { " is 139.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The length of the statement  "			Name = host.NameTable.GetNameFor ((isInterface ? property.Implements.DeclaringType.FullName + "." : "") + "set_" + (isInterface ? property.Implements.Name : property.Name))' " is 173.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The length of the statement  "			Implement (type' ResolveProperty (ResolveType (property.Implements.DeclaringType)' property.Implements).Setter' setter); " is 120.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddMethod,The length of the statement  "	var args = method.Implementation != null ? method.Implementation.GetParameters ().Skip (1).Select (p => p.ParameterType).ToArray () : (method.Overrides != null ? method.Overrides.GetParameters ().Select (p => p.ParameterType) : method.Raises.Type.GetMethod ("Invoke").GetParameters ().SkipWhile ((p' i) => (i == 0 && p.ParameterType == typeof(object)) || (i == 1 && p.ParameterType == typeof(EventArgs))).Select (p => p.ParameterType).ToArray ()); " is 447.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddMethod,The length of the statement  "		Type = method.Raises != null ? (ITypeReference)host.PlatformType.SystemVoid : ResolveType ((method.Implementation ?? method.Overrides).ReturnType)' " is 147.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddMethod,The length of the statement  "		Visibility = isInterface ? TypeMemberVisibility.Private : (method.Overrides != null && !method.Overrides.IsPublic ? TypeMemberVisibility.Family : TypeMemberVisibility.Public)' " is 175.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The length of the statement  "	if (@event.Adder != null || (isInterface && @event.Implements.GetAddMethod () != null) || (!isInterface && @event.Remover == null)) { " is 133.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The length of the statement  "			Name = host.NameTable.GetNameFor ((isInterface ? @event.Implements.DeclaringType.FullName + "." : "") + "add_" + (isInterface ? @event.Implements.Name : @event.Name))' " is 167.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The length of the statement  "	if (@event.Remover != null || (isInterface && @event.Implements.GetRemoveMethod () != null) || (!isInterface && @event.Adder == null)) { " is 136.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The length of the statement  "			Name = host.NameTable.GetNameFor ((isInterface ? @event.Implements.DeclaringType.FullName + "." : "") + "remove_" + (isInterface ? @event.Implements.Name : @event.Name))' " is 170.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddAttributes,The length of the statement  "		IMethodReference ctor = TypeHelper.GetMethod (ResolveType (attribute.Type)' host.NameTable.GetNameFor (".ctor")' attribute.Constructor.GetParameters ().Select (p => ResolveType (p.ParameterType)).ToArray ()); " is 208.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddAttributes,The length of the statement  "		IMethodReference ctor = TypeHelper.GetMethod (ResolveType (attribute.Type)' host.NameTable.GetNameFor (".ctor")' attribute.Constructor.GetParameters ().Select (p => ResolveType (p.ParameterType)).ToArray ()); " is 208.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The length of the statement  "	if (TypeHelper.Type1ImplementsType2 (GetCurrentType ()' iTypeAmendment) && methodDef.IsStatic && methodDef.Visibility == TypeMemberVisibility.Private) " is 150.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The length of the statement  "	else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) { " is 138.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The length of the statement  "		IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault (); " is 177.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The length of the statement  "	else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) { " is 141.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The length of the statement  "		IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault (); " is 197.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendConstructor,The length of the statement  "			CallMethodDelegate (methodBody' constructorAmendment.Implementation' false' il' null' MethodDelegateType.Implement' null' null); " is 128.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendConstructor,The length of the statement  "	if (typeDef.BaseClasses != null && typeDef.BaseClasses.Any (b => TypeHelper.TypesAreEquivalent (b' host.PlatformType.SystemObject)) || (methodBody.Operations != null && methodBody.Operations.Any (o => o.OperationCode == OperationCode.Call && ((IMethodReference)o.Value).ResolvedMethod.IsConstructor && ((IMethodReference)o.Value).ResolvedMethod.ContainingType == typeDef))) { " is 375.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendConstructor,The length of the statement  "			il.Emit (initializer.Key.Setter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' initializer.Key.Setter); " is 128.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "	if (methodBody.MethodDefinition.Name.Value.StartsWith ("get_") || methodBody.MethodDefinition.Name.Value.Contains (".get_")) { " is 126.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "			var backingField = GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First (); " is 122.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "					il.Emit (propertyDef.Setter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Setter); " is 120.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "			il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ()); " is 134.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "			var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null; " is 128.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "			var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null; " is 125.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "				il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod); " is 135.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The length of the statement  "					il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod); " is 135.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The length of the statement  "			CallMethodDelegate (methodBody' methodAmendment.Implementation' false' il' null' MethodDelegateType.Implement' null' null); " is 123.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The length of the statement  "			il.Emit (OperationCode.Call' ResolveMethod (ResolveType (methodAmendment.Overrides.DeclaringType)' methodAmendment.Overrides)); " is 127.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The length of the statement  "			var args = invokeMethod.GetParameters ().SkipWhile ((p' i) => (i == 0 && thisFirstParam) || (i == 1 && eventArgsSecondParam)).Select (p => p.ParameterType).ToArray (); " is 167.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The length of the statement  "				il.Emit (OperationCode.Newobj' ResolveConstructor (ResolveType (typeof(EventArgs))' typeof(EventArgs).GetConstructor (Type.EmptyTypes))); " is 137.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The length of the statement  "			ResolveMethodDelegate (methodBody.MethodDefinition.ContainingType' methodAmendment.Catch' methodBody.MethodDefinition' ref delegateType); " is 137.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The length of the statement  "			var exceptionType = ResolveType (methodAmendment.Catch.GetParameters () [(delegateType.HasFlag (MethodDelegateType.ArraySyntax) ? 1 : 0) + (context != null ? 2 : 1)].ParameterType); " is 181.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendEvent,The length of the statement  "	if (methodBody.MethodDefinition.Name.Value.StartsWith ("add_") || methodBody.MethodDefinition.Name.Value.Contains (".add_")) { " is 126.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,EmitDefaultEvent,The length of the statement  "	// Either call System.Delegate.Combine(System.Delegate' System.Delegate) or System.Delegate.Remove(System.Delegate' System.Delegate) " is 132.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,EmitDefaultEvent,The length of the statement  "	il.Emit (OperationCode.Call' ResolveMethod (ResolveType (typeof(System.Delegate))' typeof(System.Delegate).GetMethod (isAdder ? "Combine" : "Remove"' new Type[] { " is 162.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,EmitDefaultEvent,The length of the statement  "	il.Emit (OperationCode.Call' new GenericMethodInstance (ResolveType (typeof(System.Threading.Interlocked)).Methods.Where (m => m.Name.Value == "CompareExchange" && m.IsGeneric && m.GenericParameterCount == 1 && m.ParameterCount == 3).First ()' new ITypeReference[] { " is 266.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The length of the statement  "	var targetMethodDef = ResolveMethodDelegate (methodBody.MethodDefinition.ContainingType' method' methodDef' ref delegateType); " is 126.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The length of the statement  "	// Array syntax (T instance' string methodName[' TContext context][' TException exception]' object[] parameters[' object result]) " is 129.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The length of the statement  "		ITypeDefinition argTypeDef = targetMethodDef.Parameters.Skip (2 + (context != null ? 1 : 0) + (exception != null ? 1 : 0)).First ().Type.ResolvedType; " is 150.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The length of the statement  "		if (delegateType.HasFlag (MethodDelegateType.Function) && (delegateType.HasFlag (MethodDelegateType.After) || delegateType.HasFlag (MethodDelegateType.Catch)) && methodDef.Type.IsValueType) " is 189.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The length of the statement  "		var ldArg = methodDef.ParameterCount > 0 && targetMethodDef.Parameters.Last ().IsByReference ? OperationCode.Ldarga_S : OperationCode.Ldarg_S; " is 142.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveType,The length of the statement  "		typeDef = GenericTypeInstance.GetGenericTypeInstance ((INamedTypeDefinition)genericTypeDef' type.GetGenericArguments ().Select (t => ResolveType (t)).Cast<ITypeReference> ()' host.InternFactory); " is 195.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveType,The length of the statement  "		typeDef = ResolveAssembly (type.Assembly).GetAllTypes ().OfType<INamedTypeDefinition> ().Where (t => GetTypeName (t) == type.FullName).FirstOrDefault (); " is 153.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethod,The length of the statement  "	return TypeHelper.GetMethod (declaringType' host.NameTable.GetNameFor (method.Name)' method.GetParameters ().Select (p => ResolveType (p.ParameterType)).ToArray ()); " is 165.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AreEquivalent,The length of the statement  "	return (resolvedTypeDefs.TryGetValue (typeRef.ResolvedType' out mappedType) && type == mappedType) || TypeHelper.TypesAreEquivalent (typeRef' ResolveType (type)); " is 162.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,GetTypeName,The length of the statement  "		return GetTypeName (((INestedTypeReference)typeRef).ContainingType) + "+" + ((INestedTypeReference)typeRef).Name.Value + (((INestedTypeReference)typeRef).MangleName && ((INestedTypeReference)typeRef).GenericParameterCount > 0 ? "`" + ((INestedTypeReference)typeRef).GenericParameterCount : ""); " is 294.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,GetTypeName,The length of the statement  "		return typeRef.ToString () + (((INamedTypeReference)typeRef).MangleName && ((INamedTypeReference)typeRef).GenericParameterCount > 0 ? "`" + ((INamedTypeReference)typeRef).GenericParameterCount : ""); " is 199.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AreEquivalent,The length of the statement  "	property.GetIndexParameters ().Select (p => ResolveType (p.ParameterType)).Cast<ITypeDefinition> ().SequenceEqual (propertyDef.Parameters.Select (p => p.Type.ResolvedType)); " is 173.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AreEquivalent,The length of the statement  "	method.GetParameters ().All (p => AreEquivalent (methodDef.Parameters.ElementAt (p.Position).Type' p.ParameterType)) && (// Method specific tests " is 145.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AreEquivalent,The length of the statement  "	AreEquivalent (methodDef.Type' ((System.Reflection.MethodInfo)method).ReturnType) && // Ensure generic parameter types match " is 124.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AreEquivalent,The length of the statement  "	method.GetGenericArguments ().Select (t => ResolveType (t)).Cast<ITypeDefinition> ().SequenceEqual (methodDef.GenericParameters.Cast<IGenericParameterReference> ().Select (p => p.ResolvedType)) && // Ensure generic type parameter counts match " is 242.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolvePropertyDelegate,The length of the statement  "	var declaringType = ResolveType (method.DeclaringType.IsGenericType ? method.DeclaringType.GetGenericTypeDefinition () : method.DeclaringType); " is 143.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolvePropertyDelegate,The length of the statement  "	var genericMethod = (declaringType.IsGeneric ? GenericTypeInstance.GetGenericTypeInstance ((INamedTypeDefinition)declaringType' new ITypeReference[] { " is 150.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolvePropertyDelegate,The length of the statement  "	}' host.InternFactory) : declaringType).Methods.Where (m => m.Name.Value == method.Name && m.ParameterCount == method.GetParameters ().Length).FirstOrDefault (); " is 161.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolvePropertyDelegate,The length of the statement  "		Operations = declaringType.Methods.Where (m => m.Name.Value == method.Name && m.ParameterCount == method.GetParameters ().Length).FirstOrDefault ().Body.Operations' " is 164.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolvePropertyDelegate,The length of the statement  "		Instance = genericMethod.GenericParameterCount == 0 ? genericMethod : new GenericMethodInstance (genericMethod' new ITypeReference[] { " is 134.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "	var declaringType = ResolveType (method.DeclaringType.IsGenericType ? method.DeclaringType.GetGenericTypeDefinition () : method.DeclaringType); " is 143.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "	var targetMethodDef = declaringType.Methods.Where (m => m.Name.Value == method.Name && m.ParameterCount == method.GetParameters ().Length).FirstOrDefault (); " is 157.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "	int contextParam = delegateType.HasFlag (MethodDelegateType.WithContext) && !delegateType.HasFlag (MethodDelegateType.Before) ? 1 : 0; " is 134.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "	delegateType = delegateType | (TypeHelper.TypesAreEquivalent (targetMethodDef.Type' host.PlatformType.SystemVoid) ? MethodDelegateType.Action : MethodDelegateType.Function); " is 173.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "	(!delegateType.HasFlag (MethodDelegateType.HasResultParameter) || (parameters.Exists<object> (parameters.Length - 1) && method.ReturnType == typeof(object)))) " is 158.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "	if (delegateType.HasFlag (MethodDelegateType.Catch) && !TypeHelper.Type1DerivesFromOrIsTheSameAsType2 (paramDefs [1 + nameParam + contextParam].Type.ResolvedType' ResolveType (typeof(Exception)))) " is 196.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "		if (!methodDef.Parameters.All (p => TypeHelper.TypesAreEquivalent (p.Type' paramDefs [p.Index + 1 + contextParam + exceptionParam].Type))) " is 138.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "		if (delegateType.HasFlag (MethodDelegateType.HasResultParameter) && !TypeHelper.TypesAreEquivalent (methodDef.Type' paramDefs [parameters.Length - 1].Type)) " is 156.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The length of the statement  "		if (delegateType.HasFlag (MethodDelegateType.Function) && !delegateType.HasFlag (MethodDelegateType.Before) && !TypeHelper.TypesAreEquivalent (methodDef.Type' targetMethodDef.Type)) " is 181.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveEventDelegate,The length of the statement  "	var declaringType = ResolveType (method.DeclaringType.IsGenericType ? method.DeclaringType.GetGenericTypeDefinition () : method.DeclaringType); " is 143.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveEventDelegate,The length of the statement  "	var genericMethod = (declaringType.IsGeneric ? GenericTypeInstance.GetGenericTypeInstance ((INamedTypeDefinition)declaringType' new ITypeReference[] { " is 150.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveEventDelegate,The length of the statement  "	}' host.InternFactory) : declaringType).Methods.Where (m => m.Name.Value == method.Name && m.ParameterCount == method.GetParameters ().Length).FirstOrDefault (); " is 161.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveEventDelegate,The length of the statement  "		Operations = declaringType.Methods.Where (m => m.Name.Value == method.Name && m.ParameterCount == method.GetParameters ().Length).FirstOrDefault ().Body.Operations' " is 164.
Long Statement,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveEventDelegate,The length of the statement  "		Instance = genericMethod.GenericParameterCount == 0 ? genericMethod : new GenericMethodInstance (genericMethod' new ITypeReference[] { " is 134.
Long Statement,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,UpdateMethodBody,The length of the statement  "	methodBody.OperationExceptionInformation = new List<IOperationExceptionInformation> (GetOperationExceptionInformation ()); " is 122.
Long Statement,Afterthought.Amender,Program,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Program.cs,Amend,The length of the statement  "	if (File.Exists (afterthoughtTracker) && File.GetLastWriteTime (targetAssembly) == File.GetLastWriteTime (afterthoughtTracker)) " is 127.
Long Statement,Afterthought.Amender,Program,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Program.cs,Amend,The length of the statement  "	foreach (string path in amendmentAssemblies.Union (referenceAssemblies).Union (Directory.GetFiles (targetDirectory).Where (p => p.EndsWith (".dll"' StringComparison.OrdinalIgnoreCase) && p != targetAssembly))) " is 209.
Long Statement,Afterthought.Amender,Program,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Program.cs,Amend,The length of the statement  "			throw new ArgumentException (backupTargetAssembly + " is not a PE file containing a CLR assembly' or an error occurred when loading it."); " is 138.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateBlocksForBranchTargetsAndFallthroughs,The length of the statement  "			//The code following these instructions will be dead unless its a branch target' but we may as well end the basic block with the transfer. " is 138.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "		//This is formally specified in the Metadata model' but the checker does not yet understand it well enough to prove this. " is 121.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "			currentBlock.Instructions = new Sublist<Instruction> (instructions' startingInstruction' instructions.Count - startingInstruction); " is 131.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "		instructions.Add (this.GetInstruction (ilOperation' currentBlock' successorEdges' out lastInstructionWasUnconditionalTransfer)); " is 128.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "		currentBlock.Instructions = new Sublist<Instruction> (instructions' startingInstruction' instructions.Count - startingInstruction); " is 131.
Long Statement,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowQueries.cs,DominanceFrontierFor,The length of the statement  "	return new Sublist<BasicBlock> (this.dominanceFrontier' basicBlock.firstDominanceFrontierNode' basicBlock.dominanceFrontierCount); " is 130.
Long Statement,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupImmediateDominators,The length of the statement  "			//We iterate in reverse post order so that a block always has its immediateDominator field filled in before we get to any of its successors. " is 140.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The length of the statement  "	if (this.cdfg.AllBlocks.Count == 1 && this.cdfg.AllBlocks [0] != null && this.cdfg.AllBlocks [0].Instructions.Count <= 1) " is 121.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,AddStackSetup,The length of the statement  "	block.OperandStack = new Sublist<Instruction> (this.operandStackSetupInstructions' this.operandStackSetupInstructions.Count - 1' 1); " is 132.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,DequeueBlockAndSetupDataFlow,The length of the statement  "		//The block might already be in the queue' but we can deal with this more efficiently by checking blocksAlreadyVisited when dequeueing. " is 135.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The length of the statement  "		successor.OperandStack = new Sublist<Instruction> (this.operandStackSetupInstructions' startingCount' operandStackSetupInstructions.Count - startingCount); " is 155.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The length of the statement  "		//This is an optimistic assumption. It should be true for any well formed PE file. We are content to crash given bad input. " is 123.
Long Statement,Microsoft.Cci.Analysis,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\Graph.cs,Pop,The length of the statement  "	//This is an optimistic assumption. Clients have to match their Pop and Push calls' but enforcing this convention via contracts is too verbose. " is 143.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,DequeueBlockAndFillInItsTypes,The length of the statement  "	//The block either has no operand stack setup instructions' or we presume that a predecessor block has already assigned types to them. " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,DequeueBlockAndFillInItsTypes,The length of the statement  "		//The block might already be in the queue' but we can deal with this more efficiently by checking blocksAlreadyVisited when dequeueing. " is 135.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		if (instruction.Operand1.Type.TypeCode == PrimitiveTypeCode.Boolean && ((Instruction)instruction.Operand2).Type.TypeCode == PrimitiveTypeCode.Boolean) { " is 152.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "			instruction.Type = ManagedPointerType.GetManagedPointerType (this.cfg.MethodBody.MethodDefinition.ContainingType' this.internFactory); " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory); " is 126.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory); " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory); " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory); " is 126.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory); " is 126.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is a polymorphic constant. " is 144.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the left operand is a polymorphic constant. " is 143.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is a polymorphic constant. " is 144.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the left operand is a polymorphic constant. " is 143.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "				// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes " is 121.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "					//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one. " is 140.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,GetSynchronizationInformation,The length of the statement  "		synchronizationPoints = this.synchronizationPoints == null ? Enumerable<ISynchronizationPoint>.Empty : this.synchronizationPoints.AsReadOnly () " is 143.
Long Statement,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,Rewrite,The length of the statement  "	return new ILGeneratorMethodBody (this.Generator' methodBody.LocalsAreZeroed' this.maxStack' methodBody.MethodDefinition' this.localVariables.ToArray ()' Enumerable<ITypeDefinition>.Empty); " is 189.
Long Statement,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitMethodBody,The length of the statement  "		this.Generator.AddExceptionHandlerInformation (exceptionInfo.HandlerKind' exceptionInfo.ExceptionType' this.GetLabelFor (exceptionInfo.TryStartOffset)' this.GetLabelFor (exceptionInfo.TryEndOffset)' this.GetLabelFor (exceptionInfo.HandlerStartOffset)' this.GetLabelFor (exceptionInfo.HandlerEndOffset)' exceptionInfo.HandlerKind == HandlerKind.Filter ? this.GetLabelFor (exceptionInfo.FilterDecisionStartOffset) : null); " is 420.
Long Statement,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitDebugInformationFor,The length of the statement  "					if (iteratorScope.Offset >= currentScope.Offset && iteratorScope.Offset + iteratorScope.Length <= currentScope.Offset + currentScope.Length) { " is 142.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The length of the statement  "					AddError ("Response file '{0}' line {1}' char {2} contains '\"' not starting or ending an argument"' responseFileName' lineNo' index); " is 134.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,GatherRequiredOptions,The length of the statement  "	foreach (var field in this.GetType ().GetFields (System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public)) { " is 132.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The length of the statement  "			foreach (System.Reflection.FieldInfo enumConstant in type.GetFields (System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public)) { " is 150.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FindOptionByReflection,The length of the statement  "	System.Reflection.FieldInfo fi = this.GetType ().GetField (arg' System.Reflection.BindingFlags.IgnoreCase | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public); " is 189.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,FindOptionByReflection,The length of the statement  "		fi = this.GetType ().GetField (arg' System.Reflection.BindingFlags.IgnoreCase | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public); " is 159.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,TryGetOptions,The length of the statement  "	var fi = this.GetType ().GetField (fieldWithOptions' System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.FlattenHierarchy | System.Reflection.BindingFlags.Public); " is 182.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintOptions,The length of the statement  "	foreach (System.Reflection.FieldInfo f in this.GetType ().GetFields (System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance)) { " is 152.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintOptions,The length of the statement  "			foreach (System.Reflection.FieldInfo enumConstant in opttype.GetFields (System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)) { " is 153.
Long Statement,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,PrintDerivedOptions,The length of the statement  "	foreach (System.Reflection.FieldInfo f in this.GetType ().GetFields (System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public)) { " is 150.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "				if (result == null || result.Version == dummyVersion || (result.Version < coreId.Version && coreId.Version != dummyVersion) || result.Version == coreId.Version && unit.UnitIdentity.Equals (coreId)) { " is 199.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "		//In this case' we have little option but to choose the identity of the core assembly of the platform we are running on. " is 120.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "		//We either found a plausible identity by polling the assemblies in the unit cache' or we used the identity of our own core assembly. " is 133.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "		//(Note that if result.Location.Length > 0' then the core assembly has already been loaded and we thus know the location and don't have to probe.) " is 146.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,LoadAssembly,The length of the statement  "		if (string.IsNullOrEmpty (assemblyIdentity.Location) || string.Equals (assemblyIdentity.Location' "unknown://location"' StringComparison.OrdinalIgnoreCase)) { " is 158.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ReportError,The length of the statement  "		Microsoft.Cci.ErrorEventArgs errorEventArguments = new Microsoft.Cci.ErrorEventArgs (error.ErrorReporter' error.Location' errors.AsReadOnly ()); " is 144.
Long Statement,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,UnifyAssembly,The length of the statement  "	if (assemblyIdentity.Name.UniqueKeyIgnoringCase == this.CoreAssemblySymbolicIdentity.Name.UniqueKeyIgnoringCase && assemblyIdentity.Culture == this.CoreAssemblySymbolicIdentity.Culture && IteratorHelper.EnumerablesAreEqual (assemblyIdentity.PublicKeyToken' this.CoreAssemblySymbolicIdentity.PublicKeyToken)) " is 307.
Long Statement,Microsoft.Cci,IMetadataReaderHostContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The length of the statement  "	Contract.Ensures (Contract.Result<byte> () == 1 || Contract.Result<byte> () == 2 || Contract.Result<byte> () == 4 || Contract.Result<byte> () == 8); " is 148.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "		        IBinaryDocumentMemoryBlock binDocMemoryBlock = MemoryMappedFile.CreateMemoryMappedFile(sourceDocument.Location' sourceDocument);" is 128.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "		IBinaryDocumentMemoryBlock binDocMemoryBlock = UnmanagedBinaryMemoryBlock.CreateUnmanagedBinaryMemoryBlock (sourceDocument.Location' sourceDocument); " is 149.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "		        IBinaryDocumentMemoryBlock binDocMemoryBlock = MemoryMappedFile.CreateMemoryMappedFile(newBinaryDocument.Location' newBinaryDocument);" is 134.
Long Statement,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,OpenBinaryDocument,The length of the statement  "		IBinaryDocumentMemoryBlock binDocMemoryBlock = UnmanagedBinaryMemoryBlock.CreateUnmanagedBinaryMemoryBlock (newBinaryDocument.Location' newBinaryDocument); " is 155.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedNamespaceInternId,The length of the statement  "	uint value = this.NestedNamespaceHashtable.Find (parentNamespaceInternedId' (uint)nestedUnitNamespaceReference.Name.UniqueKey); " is 127.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedNamespaceInternId,The length of the statement  "		this.NestedNamespaceHashtable.Add (parentNamespaceInternedId' (uint)nestedUnitNamespaceReference.Name.UniqueKey' value); " is 120.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetUnitNamespaceInternId,The length of the statement  "	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = unitNamespaceReference as INestedUnitNamespaceReference; " is 122.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNamespaceTypeReferenceInternId,The length of the statement  "		if (nsTypeStore.ContainingNamespaceInternedId == containingUnitNamespaceInteredId && nsTypeStore.GenericParameterCount == genericParameterCount) { " is 146.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNamespaceTypeReferenceInternId,The length of the statement  "	NamespaceTypeStore nsTypeStore1 = new NamespaceTypeStore (containingUnitNamespaceInteredId' genericParameterCount' this.CurrentTypeInternValue++); " is 146.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedTypeReferenceInternId,The length of the statement  "		if (nstTypeStore.ContainingTypeInternedId == containingTypeReferenceInteredId && nstTypeStore.GenericParameterCount == genericParameterCount) { " is 143.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNestedTypeReferenceInternId,The length of the statement  "	NestedTypeStore nstTypeStore1 = new NestedTypeStore (containingTypeReferenceInteredId' genericParameterCount' this.CurrentTypeInternValue++); " is 141.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMatrixTypeReferenceInternId,The length of the statement  "		if (matrixTypeStore.Rank == rank && IteratorHelper.EnumerablesAreEqual<ulong> (matrixTypeStore.Sizes' sizes) && IteratorHelper.EnumerablesAreEqual<int> (matrixTypeStore.LowerBounds' lowerBounds)) " is 195.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMatrixTypeReferenceInternId,The length of the statement  "	MatrixTypeStore matrixTypeStore1 = new MatrixTypeStore (rank' new List<int> (lowerBounds).ToArray ()' new List<ulong> (sizes).ToArray ()' this.CurrentTypeInternValue++); " is 169.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericTypeParameterReferenceInternId,The length of the statement  "	uint definingTypeReferenceInternId = this.GetTypeReferenceInternId (GetUninstantiatedGenericType (definingTypeReference)); " is 122.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetParameterTypeInternId,The length of the statement  "		customModifiersInternId = this.GetCustomModifierListInternId (parameterTypeInformation.CustomModifiers.GetEnumerator ()); " is 121.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetParameterTypeInternId,The length of the statement  "		if (parameterTypeStore.IsByReference == parameterTypeInformation.IsByReference && parameterTypeStore.CustomModifiersInternId == customModifiersInternId) { " is 154.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetParameterTypeInternId,The length of the statement  "	ParameterTypeStore parameterTypeStore1 = new ParameterTypeStore (parameterTypeInformation.IsByReference' customModifiersInternId' this.CurrentParameterTypeInternValue++); " is 170.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the statement  "	uint returnValueCustomModifiersInternedId = this.GetCustomModifierListInternId (returnValueCustomModifiers.GetEnumerator ()); " is 125.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the statement  "		if (signatureStore.CallingConvention == callingConvention && signatureStore.RequiredParameterListInternedId == requiredParameterTypesInternedId && signatureStore.ExtraParameterListInternedId == extraArgumentTypesInteredId && signatureStore.ReturnValueCustomModifiersListInteredId == returnValueCustomModifiersInternedId && signatureStore.ReturnValueIsByRef == returnValueIsByRef && signatureStore.ReturnTypeReferenceInternedId == returnTypeReferenceInternedId) { " is 462.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The length of the statement  "	SignatureStore signatureStore1 = new SignatureStore (callingConvention' requiredParameterTypesInternedId' extraArgumentTypesInteredId' returnValueIsByRef' returnValueCustomModifiersInternedId' returnTypeReferenceInternedId' 0' this.CurrentSignatureInternValue++); " is 263.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "	uint requiredParameterTypesInternedId = this.GetParameterTypeListInternId (methodReference.Parameters.GetEnumerator ()); " is 120.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "		returnValueCustomModifiersInternedId = this.GetCustomModifierListInternId (methodReference.ReturnValueCustomModifiers.GetEnumerator ()); " is 136.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "		if (signatureStore.CallingConvention == methodReference.CallingConvention && signatureStore.RequiredParameterListInternedId == requiredParameterTypesInternedId && signatureStore.ReturnValueCustomModifiersListInteredId == returnValueCustomModifiersInternedId && signatureStore.ReturnValueIsByRef == methodReference.ReturnValueIsByRef && signatureStore.ReturnTypeReferenceInternedId == returnTypeReferenceInternedId && signatureStore.GenericParameterCount == genericParameterCount) { " is 481.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The length of the statement  "	SignatureStore signatureStore1 = new SignatureStore (methodReference.CallingConvention' requiredParameterTypesInternedId' 0' methodReference.ReturnValueIsByRef' returnValueCustomModifiersInternedId' returnTypeReferenceInternedId' genericParameterCount' this.CurrentMethodReferenceInternValue++); " is 295.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodInstanceReferenceInternedKey,The length of the statement  "	uint genericArgumentsInternedId = this.GetTypeReferenceListInternedId (genericMethodInstanceReference.GenericArguments.GetEnumerator ()); " is 137.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternId,The length of the statement  "	uint signatureInternedId = this.GetSignatureInternId (callingConvention' parameters' extraArgumentTypes' returnValueCustomModifiers' returnValueIsByRef' returnType); " is 165.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "		return this.GetNamespaceTypeReferenceInternId (namespaceTypeReference.ContainingUnitNamespace' namespaceTypeReference.Name' namespaceTypeReference.GenericParameterCount); " is 170.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "		return this.GetNestedTypeReferenceInternId (nestedTypeReference.ContainingType' nestedTypeReference.Name' nestedTypeReference.GenericParameterCount); " is 149.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "			return this.GetMatrixTypeReferenceInternId (arrayTypeReference.ElementType' (int)arrayTypeReference.Rank' arrayTypeReference.Sizes' arrayTypeReference.LowerBounds); " is 164.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "		return this.GetGenericTypeInstanceReferenceInternId (genericTypeInstanceReference.GenericType' genericTypeInstanceReference.GenericArguments); " is 142.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "		return this.GetGenericTypeParameterReferenceInternId (genericTypeParameterReference.DefiningType' (int)genericTypeParameterReference.Index); " is 140.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "		return this.GetGenericMethodParameterReferenceInternId (genericMethodParameterReference.DefiningMethod' genericMethodParameterReference.Index); " is 143.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "		return this.GetFunctionPointerTypeReferenceInternId (functionPointerTypeReference.CallingConvention' functionPointerTypeReference.Parameters' functionPointerTypeReference.ExtraArgumentTypes' returnValueCustomModifiers' functionPointerTypeReference.ReturnValueIsByRef' functionPointerTypeReference.Type); " is 303.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInterendIdIgnoringCustomModifiers,The length of the statement  "	//^ assume false; //It is an informal requirement that all classes implementing ITypeReference should produce a non null result for one of the calls above. " is 155.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTypeReferenceInternId,The length of the statement  "		return this.GetModifiedTypeReferenceInternId (modifiedTypeReference.UnmodifiedType' modifiedTypeReference.CustomModifiers); " is 123.
Long Statement,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetFunctionPointerTypeReferenceInternedKey,The length of the statement  "		return this.GetFunctionPointerTypeReferenceInternId (callingConvention' parameters' extraArgumentTypes' returnValueCustomModifiers' returnValueIsByRef' returnType); " is 164.
Long Statement,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The length of the statement  "			//^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant. " is 201.
Long Statement,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The length of the statement  "		//string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference? " is 146.
Long Statement,Microsoft.Cci,GlobalAssemblyCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,Contains,The length of the statement  "		        var gacKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"\Software\Microsoft\.NETCompactFramework\Installer\Assemblies\Global");" is 135.
Long Statement,Microsoft.Cci,GlobalAssemblyCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "		        var gacKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"\Software\Microsoft\.NETCompactFramework\Installer\Assemblies\Global");" is 135.
Long Statement,Microsoft.Cci,GlobalAssemblyCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "			if (assemblyIdentity.Equals (new AssemblyIdentity (metadataHost.NameTable.GetNameFor (cn.Name)' cn.Culture' cn.Version' cn.PublicKeyToken' ""))) { " is 146.
Long Statement,Microsoft.Cci,AssemblyName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "	assemblyCache.QueryAssemblyInfo (ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 124.
Long Statement,Microsoft.Cci,AssemblyName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,GetLocation,The length of the statement  "	assemblyCache.QueryAssemblyInfo (ASSEMBLYINFO_FLAG.VALIDATE | ASSEMBLYINFO_FLAG.GETSIZE' this.StrongName' ref assemblyInfo); " is 124.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The length of the statement  "		List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members)); " is 147.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetExplicitlyOverriddenMethods,The length of the statement  "	foreach (IMethodImplementation methodImplementation in overridingMethod.ContainingTypeDefinition.ExplicitImplementationOverrides) { " is 131.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The length of the statement  "		List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members)); " is 147.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyImplementedInterfaceMethods,The length of the statement  "	foreach (IMethodImplementation methodImplementation in implementingMethod.ContainingTypeDefinition.ExplicitImplementationOverrides) { " is 133.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyImplementedInterfaceMethods,The length of the statement  "		foreach (ITypeDefinitionMember interfaceMember in interfaceReference.ResolvedType.GetMembersNamed (implementingMethod.Name' false)) { " is 133.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyOverriddenBaseClassMethod,The length of the statement  "		IMethodDefinition overriddenMethod = GetImplicitlyOverriddenBaseClassMethod (derivedClassMethod' baseClassReference.ResolvedType); " is 130.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetImplicitlyOverriddenBaseClassMethod,The length of the statement  "		IMethodDefinition overriddenMethod = GetImplicitlyOverriddenBaseClassMethod (derivedClassMethod' baseClassReference.ResolvedType); " is 130.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsVisibleOutsideAssembly,The length of the statement  "		return IsExplicitImplementationVisible (propertyDefinition.Getter' containingTypeDefinition) || IsExplicitImplementationVisible (propertyDefinition.Setter' containingTypeDefinition); " is 182.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsVisibleOutsideAssembly,The length of the statement  "		return IsExplicitImplementationVisible (eventDefinition.Adder' containingTypeDefinition) || IsExplicitImplementationVisible (eventDefinition.Remover' containingTypeDefinition); " is 176.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsExplicitImplementationVisible,The length of the statement  "			//If the method being implemented did not resolve it can only be because it is actually defined in another assembly' which implies that it is visible outside its assembly' " is 171.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,IsExplicitImplementationVisible,The length of the statement  "			//at least in the case where the implemented method is public or internal. Since we can't know that without resolving the method' we'll err on the "safe" side. " is 159.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,SignaturesAreEqual,The length of the statement  "	return IteratorHelper.EnumerablesAreEqual (signature1.Parameters' signature2.Parameters' resolveTypes ? ResolvingParameterInformationComparer : ParameterInformationComparer); " is 174.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GenericMethodSignaturesAreEqual,The length of the statement  "	if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (method1.Type' method2.Type' resolveTypes)) " is 141.
Long Statement,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GenericMethodSignaturesAreEqual,The length of the statement  "	return IteratorHelper.EnumerablesAreEqual (method1.Parameters' method2.Parameters' resolveTypes ? ResolvingGenericMethodParameterEqualityComparer : GenericMethodParameterEqualityComparer); " is 188.
Long Statement,Microsoft.Cci,MethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.TypeParameters | NameFormattingOptions.Signature); " is 153.
Long Statement,Microsoft.Cci,GenericMethodParameterInformationComparer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,Equals,The length of the statement  "	return TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (x.Type' y.Type' this.resolveTypes); " is 136.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetEventSignature,The length of the statement  "		sb.Append (this.typeNameFormatter.GetTypeName (eventDef.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind))); " is 180.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldSignature,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.Signature) != 0 && (formattingOptions & NameFormattingOptions.DocumentationIdMemberKind) == 0) { " is 143.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldSignature,The length of the statement  "		sb.Append (this.typeNameFormatter.GetTypeName (field.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind))); " is 177.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 && method.ResolvedMethod.IsSpecialName && (method.Name.Value.Contains ("op_Explicit") || method.Name.Value.Contains ("op_Implicit"))) { " is 217.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,The length of the statement  "		sb.Append (this.typeNameFormatter.GetTypeName (method.Type' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind))); " is 168.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.Signature) == 0 || ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 && !IteratorHelper.EnumerableIsNotEmpty<IParameterTypeInformation> (parameters))) " is 226.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,The length of the statement  "			if (!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty (parameter.Constraints)) " is 166.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The length of the statement  "		sb.Append (this.typeNameFormatter.GetTypeName (method.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind | NameFormattingOptions.TypeConstraints))); " is 218.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendParameter,The length of the statement  "	sb.Append (this.typeNameFormatter.GetTypeName (param.Type' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind))); " is 167.
Long Statement,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendPropertyName,The length of the statement  "		sb.Append (this.typeNameFormatter.GetTypeName (property.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind))); " is 180.
Long Statement,Microsoft.Cci,ClrHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ClrOperandStackTypeFor,The length of the statement  "	Contract.Ensures (Contract.Result<ClrOperandStackType> () >= ClrOperandStackType.Int32 && Contract.Result<ClrOperandStackType> () <= ClrOperandStackType.Invalid); " is 162.
Long Statement,Microsoft.Cci,ClrHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ClrOperandStackTypeFor,The length of the statement  "	Contract.Ensures (Contract.Result<ClrOperandStackType> () >= ClrOperandStackType.Int32 && Contract.Result<ClrOperandStackType> () < ClrOperandStackType.Invalid); " is 161.
Long Statement,Microsoft.Cci,ClrHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ConversionPossible,The length of the statement  "		return toType == PrimitiveTypeCode.Int64 || toType == PrimitiveTypeCode.UInt64 || toType == PrimitiveTypeCode.IntPtr || toType == PrimitiveTypeCode.UIntPtr; " is 156.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "	if (typeDefinition.IsGeneric && TypeHelper.TypesAreEquivalent (typeDefinition.InstanceType' member.ContainingTypeDefinition)) " is 125.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "		return TypeHelper.GetDefiningUnit (typeDefinition).UnitIdentity.Equals (TypeHelper.GetDefiningUnit (member.ContainingTypeDefinition).UnitIdentity); " is 147.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "		return TypeHelper.GetDefiningUnit (typeDefinition).UnitIdentity.Equals (TypeHelper.GetDefiningUnit (member.ContainingTypeDefinition).UnitIdentity) && TypeHelper.Type1DerivesFromOrIsTheSameAsType2 (typeDefinition' member.ContainingTypeDefinition); " is 246.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,CanAccess,The length of the statement  "		return TypeHelper.GetDefiningUnit (typeDefinition).UnitIdentity.Equals (TypeHelper.GetDefiningUnit (member.ContainingTypeDefinition)) || TypeHelper.Type1DerivesFromOrIsTheSameAsType2 (typeDefinition' member.ContainingTypeDefinition); " is 233.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,EffectiveBaseClass,The length of the statement  "	Contract.Ensures (Contract.Result<ITypeDefinition> () == Dummy.TypeDefinition || Contract.Result<ITypeDefinition> ().IsClass); " is 126.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsCompilerGenerated,The length of the statement  "		if (AttributeHelper.Contains (type.Attributes' type.PlatformType.SystemRuntimeCompilerServicesCompilerGeneratedAttribute)) " is 122.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypeVisibilityAsTypeMemberVisibility,The length of the statement  "	// supposedly the only thing that doesn't meet any of the below tests are type parameters and their "default" is public. " is 120.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypeVisibilityAsTypeMemberVisibility,The length of the statement  "				result = TypeHelper.GenericInstanceVisibilityAsTypeMemberVisibility (TypeVisibilityAsTypeMemberVisibility (genType.GenericType.ResolvedType)' genType.GenericArguments); " is 168.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetDefiningUnitReference,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetMethod,The length of the statement  "	IMethodDefinition result = TypeHelper.GetMethod (declaringType.GetMembersNamed (methodReference.Name' false)' methodReference' resolveTypes); " is 141.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TryGetFullyInstantiatedSpecializedTypeReference,The length of the statement  "		if (TryGetFullyInstantiatedSpecializedTypeReference (nestedType.ContainingTypeDefinition' out containingTypeReference)) { " is 121.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,MostDerivedCommonBaseClass,The length of the statement  "		//If type1 and type2 at method entry were both structs' depth1 == depth2 == 1 and neither type1 nor type2 is a class during the first iteration of the loop " is 155.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParametersAreEquivalent,The length of the statement  "	if (param1.IsByReference != param2.IsByReference || param1.IsModified != param1.IsModified || !TypeHelper.TypesAreEquivalent (param1.Type' param2.Type' resolveTypes)) " is 166.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "	if (param1.IsByReference != param2.IsByReference || param1.IsModified != param1.IsModified || !TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (param1.Type' param2.Type' resolveTypes)) " is 229.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "			if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (customModifier1.Modifier' customModifier2.Modifier' resolveTypes)) " is 165.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ParameterListsAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		if (!TypeHelper.ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (parameter1' parameter2' resolveTypes)) " is 142.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The length of the statement  "			List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members)); " is 147.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,ArrayTypesAreEquivalent,The length of the statement  "	if (!IteratorHelper.EnumerablesAreEqual<ulong> (arrayTypeRef1.Sizes' arrayTypeRef2.Sizes) || !IteratorHelper.EnumerablesAreEqual<int> (arrayTypeRef1.LowerBounds' arrayTypeRef2.LowerBounds)) { " is 191.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,FunctionPointerTypesAreEquivalent,The length of the statement  "	return TypeHelper.ParameterListsAreEquivalent (functionPointer1.ExtraArgumentTypes' functionPointer2.ExtraArgumentTypes' resolveTypes); " is 135.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "	if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (functionPointer1.Type' functionPointer2.Type' resolveTypes)) " is 159.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "	return TypeHelper.ParameterListsAreEquivalent (functionPointer1.ExtraArgumentTypes' functionPointer2.ExtraArgumentTypes' resolveTypes); " is 135.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		if (!TypeHelper.TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (inst1.GenericType' inst2.GenericType' resolveTypes)) " is 151.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		return IteratorHelper.EnumerablesAreEqual<ITypeReference> (inst1.GenericArguments' inst2.GenericArguments' resolveTypes ? RelaxedTypeEquivalenceComparer.resolvingInstance : RelaxedTypeEquivalenceComparer.instance); " is 214.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		return TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (array1.ElementType' array2.ElementType' resolveTypes); " is 144.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		return TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (pointer1.TargetType' pointer2.TargetType' resolveTypes); " is 146.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		return TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (mpointer1.TargetType' mpointer2.TargetType' resolveTypes); " is 148.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch,The length of the statement  "		return TypeHelper.FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch (fpointer1' fpointer2' resolveTypes); " is 152.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,Type1IsCovariantWithType2,The length of the statement  "	return TypeHelper.TypesAreAssignmentCompatible (arrType1.ElementType.ResolvedType' arrType2.ElementType.ResolvedType' resolveTypes); " is 132.
Long Statement,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,TypesAreAssignmentCompatible,The length of the statement  "	if (sourceType.IsInterface && TypeHelper.TypesAreEquivalent (targetType' targetType.PlatformType.SystemObject' resolveTypes)) " is 125.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.TypeParameters) != 0 && (formattingOptions & NameFormattingOptions.FormattingForDocumentationId) == 0 && genericParameterCount > 0 && !(type.ResolvedType is Dummy)) { " is 213.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The length of the statement  "				if (!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty (parameter.Constraints)) " is 166.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AppendAliasName,The length of the statement  "			sb.Append (this.GetNamespaceName ((IUnitNamespaceReference)namespaceAlias.ContainingNamespace' NameFormattingOptions.None)); " is 124.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceTypeName,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.SupressAttributeSuffix) != 0 && AttributeHelper.IsAttributeType (nsType.ResolvedType) & tname.EndsWith ("Attribute"' StringComparison.Ordinal)) " is 190.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceTypeName,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.OmitContainingNamespace) == 0 && !(nsType.ContainingUnitNamespace is IRootUnitNamespaceReference)) " is 145.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "		if (nestedUnitSetNamespace.ContainingNamespace.Name.Value.Length == 0 || (formattingOptions & NameFormattingOptions.OmitContainingNamespace) != 0) { " is 148.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "			return this.GetNamespaceName (nestedUnitSetNamespace.ContainingUnitSetNamespace' formattingOptions) + "." + nestedUnitSetNamespace.Name.Value; " is 142.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "		if (nestedUnitNamespace.ContainingUnitNamespace is IRootUnitNamespaceReference || (formattingOptions & NameFormattingOptions.OmitContainingNamespace) != 0) { " is 157.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceName,The length of the statement  "			return this.GetNamespaceName (nestedUnitNamespace.ContainingUnitNamespace' formattingOptions) + "." + nestedUnitNamespace.Name.Value; " is 133.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNestedTypeName,The length of the statement  "	if ((formattingOptions & NameFormattingOptions.SupressAttributeSuffix) != 0 && AttributeHelper.IsAttributeType (nestedType.ResolvedType) & tname.EndsWith ("Attribute"' StringComparison.Ordinal)) " is 194.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNestedTypeName,The length of the statement  "		tname = this.GetTypeName (nestedType.ContainingType' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.Visibility | NameFormattingOptions.TypeConstraints)) + delim + tname; " is 201.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeInstanceName,The length of the statement  "		StringBuilder sb = new StringBuilder (this.GetTypeName (genericType' formattingOptions & ~(NameFormattingOptions.TypeParameters | ((formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 ? NameFormattingOptions.UseGenericTypeNameSuffix : NameFormattingOptions.None)))); " is 291.
Long Statement,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetGenericTypeInstanceName,The length of the statement  "			sb.Append (this.GetTypeName (argument' formattingOptions & ~(NameFormattingOptions.MemberKind | NameFormattingOptions.DocumentationIdMemberKind))); " is 147.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,AssemblyOneAllowsAssemblyTwoToAccessItsInternals,The length of the statement  "		if (!TypeHelper.TypesAreEquivalent (attribute.Type' assembly1.PlatformType.SystemRuntimeCompilerServicesInternalsVisibleToAttribute)) " is 133.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAssemblyIdentity,The length of the statement  "	string culture = assemblyName.CultureInfo == null || assemblyName.CultureInfo == System.Globalization.CultureInfo.InvariantCulture ? "neutral" : assemblyName.CultureInfo.ToString (); " is 182.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAssemblyIdentity,The length of the statement  "		return new AssemblyIdentity (assembly.Name' assembly.Culture' assembly.Version' UnitHelper.ComputePublicKeyToken (pKey)' assembly.Location); " is 140.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,StrongName,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "' Version={0}.{1}.{2}.{3}"' assemblyReference.Version.Major' assemblyReference.Version.Minor' assemblyReference.Version.Build' assemblyReference.Version.Revision); " is 211.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,FindType,The length of the statement  "	INamedTypeDefinition /*?*/result = GetType (nameTable' unit.UnitNamespaceRoot' typeName' genericParameterCount' ref offset); " is 124.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetType,The length of the statement  "			var nt = GetNestedType (nameTable' namespaceType' typeName' genericParameterCount - namespaceType.GenericParameterCount' ref offset); " is 133.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetNestedType,The length of the statement  "		var nt = GetNestedType (nameTable' nestedType' typeName' genericParameterCount - nestedType.GenericParameterCount' ref offset); " is 127.
Long Statement,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,UnitNamespacesAreEquivalent,The length of the statement  "		return nstUnitNamespace1.Name.UniqueKey == nstUnitNamespace2.Name.UniqueKey && UnitHelper.UnitNamespacesAreEquivalent (nstUnitNamespace1.ContainingUnitNamespace' nstUnitNamespace2.ContainingUnitNamespace); " is 205.
Long Statement,Microsoft.Cci,ILLocation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnmanagedFileIO.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "ILLocation({0}'0x{1})"' this.methodDefinition.ToString ()' this.offset.ToString ("X8"' CultureInfo.InvariantCulture)); " is 166.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 136.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 136.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	if (marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)) " is 410.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count.      this.path.Pop(); " is 160.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not to decrease this.path.Count. " is 138.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	IGenericMethodInstanceReference /*?*/genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "		//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,DispatchAsReference,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The length of the statement  "	//^ assume this.path.Count == oldCount+1; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 135.
Long Statement,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,VisitMethodReturnAttributes,The length of the statement  "	//^ assume this.path.Count == oldCount; //True because all of the virtual methods of this class promise not decrease this.path.Count. " is 133.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "	//field reference attributes are distinct from field definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 161.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "	if (marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)) " is 410.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "	//method reference attributes are distinct from method definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 163.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "	if (operationExceptionInformation.HandlerKind == HandlerKind.Catch || operationExceptionInformation.HandlerKind == HandlerKind.Filter) " is 134.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "	//type reference attributes are distinct from type definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 159.
Long Statement,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The length of the statement  "	//unit reference attributes are distinct from unit definition attributes. When a definition serves as a reference' the reference is assumed to be unattributed. " is 159.
Long Statement,Microsoft.Cci,ISCopeContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,GetMatchingMembersNamed,The length of the statement  "	Contract.Ensures (Contract.ForAll (Contract.Result<IEnumerable<MemberType>> ()' x => ignoreCase ? x.Name.UniqueKeyIgnoringCase == x.Name.UniqueKeyIgnoringCase : x.Name == name)); " is 178.
Long Statement,Microsoft.Cci,ISCopeContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Core.cs,GetMembersNamed,The length of the statement  "	Contract.Ensures (Contract.ForAll (Contract.Result<IEnumerable<MemberType>> ()' x => ignoreCase ? x.Name.UniqueKeyIgnoringCase == x.Name.UniqueKeyIgnoringCase : x.Name == name)); " is 178.
Long Statement,Microsoft.Cci,IPlatformTypeContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Types.cs,GetTypeFor,The length of the statement  "	Contract.Requires (typeCode != PrimitiveTypeCode.Pointer && typeCode != PrimitiveTypeCode.Reference && typeCode != PrimitiveTypeCode.NotPrimitive); " is 147.
Long Statement,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The length of the statement  "	hash = (hash << 8) ^ (this.version.Major << 6) ^ (this.version.Minor << 4) ^ (this.version.MajorRevision << 2) ^ this.version.MinorRevision; " is 140.
Long Statement,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "' Version={0}.{1}.{2}.{3}"' this.Version.Major' this.Version.Minor' this.Version.Build' this.Version.Revision); " is 159.
Long Statement,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetPrimarySourceLocationsFor,The length of the statement  "				yield return new PdbSourceLineLocation (psDoc' (int)lineInfo.line' (int)lineInfo.column' (int)lineInfo.endLine' (int)lineInfo.endColumn); " is 137.
Long Statement,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetPrimarySourceLocationsFor,The length of the statement  "					yield return new PdbSourceLineLocation (psDoc' (int)lineInfo.line' (int)lineInfo.column' (int)lineInfo.endLine' (int)lineInfo.endColumn); " is 137.
Long Statement,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetPrimarySourceLocationsForToken,The length of the statement  "	yield return new PdbSourceLineLocation (psDoc' (int)lineInfo.line' (int)lineInfo.column' (int)lineInfo.endLine' (int)lineInfo.endColumn); " is 137.
Long Statement,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetSynchronizationInformation,The length of the statement  "		info.asyncMethod = (decoder.GetObjectForToken (info.kickoffMethodToken) as IMethodDefinition) ?? Dummy.MethodDefinition; " is 120.
Long Statement,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetSynchronizationInformation,The length of the statement  "				synchPoint.continuationMethod = (decoder.GetObjectForToken (synchPoint.continuationMethodToken) as IMethodDefinition) ?? Dummy.MethodDefinition; " is 144.
Long Statement,Microsoft.Cci,PdbWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\Writer.cs,DefineTokenSourceLocation,The length of the statement  "	this.symWriter5.MapTokenToSourceSpan (token' document' (uint)ploc.StartLine' (uint)ploc.StartColumn' (uint)ploc.EndLine' (uint)ploc.EndColumn); " is 143.
Long Statement,Microsoft.Cci,PdbWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbWriter\Writer.cs,DefineSequencePoint,The length of the statement  "	if (ploc.Document != this.currentDocument && this.currentDocument != null && ploc.Document != SourceDummy.PrimarySourceDocument) " is 128.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenMemberModules,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument' fileRef.FileName.Value); " is 144.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenMemberModules,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' moduleIdentity' assembly' this.metadataReaderHost.PointerSize); " is 150.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenAssembly,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenAssembly,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' assemblyIdentity' null' this.metadataReaderHost.PointerSize); " is 148.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenModule,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenModule,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' moduleIdentity' null' this.metadataReaderHost.PointerSize); " is 146.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "	IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "	Version version = new Version (assemblyRow.MajorVersion' assemblyRow.MinorVersion' assemblyRow.BuildNumber' assemblyRow.RevisionNumber); " is 136.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "	return new AssemblyIdentity (assemblyName' cultureName' version' publicKeyTokenArray' peFileReader.BinaryDocumentMemoryBlock.BinaryDocument.Location); " is 150.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,GetModuleIdentifier,The length of the statement  "	return new ModuleIdentity (moduleName' peFileReader.BinaryDocumentMemoryBlock.BinaryDocument.Location' containingAssemblyIdentity); " is 131.
Long Statement,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,ResolveSerializedTypeName,The length of the statement  "	ITypeReference /*?*/moduleTypeRef = internalAssembly.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeName); " is 121.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FoldStrings,The length of the statement  "			this.stringIndexMap.Add (cur.Value' this.stringWriter.BaseStream.Position - (uint)(Encoding.UTF8.GetBytes (cur.Key).Length + 1)); " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WritePeToStream,The length of the statement  "	PeWriter writer = new PeWriter (module' host' stream' sourceLocationProvider' localScopeProvider' pdbWriter' customSectionProviders); " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The length of the statement  "		if (TypeHelper.TypesAreEquivalent (attribute.Type' this.host.PlatformType.SystemReflectionAssemblySignatureKeyAttribute)) { " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [1] * (0u + this.resolutionScopeCodedIndexSize + this.stringIndexSize + this.stringIndexSize); " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [2] * (4u + this.stringIndexSize + this.stringIndexSize + this.typeDefOrRefCodedIndexSize + this.fieldDefIndexSize + this.methodDefIndexSize); " is 168.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [12] * (0u + this.hasCustomAttributeCodedIndexSize + this.customAttributeTypeCodedIndexSize + this.blobIndexSize); " is 140.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [25] * (0u + this.typeDefIndexSize + this.methodDefOrRefCodedIndexSize + this.methodDefOrRefCodedIndexSize); " is 134.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [28] * (2u + this.memberForwardedCodedIndexSize + this.stringIndexSize + this.moduleRefIndexSize); " is 124.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [35] * (12u + this.blobIndexSize + this.stringIndexSize + this.stringIndexSize + this.blobIndexSize); " is 127.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The length of the statement  "	result += this.tableSizes [39] * (8u + this.stringIndexSize + this.stringIndexSize + this.implementationCodedIndexSize); " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,CreateIndicesFor,The length of the statement  "	if (methodDef.ReturnValueIsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty (methodDef.ReturnValueAttributes) || !(methodDef.ReturnValueName is Dummy)) " is 162.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,CreateIndicesFor,The length of the statement  "		if (parDef.HasDefaultValue || parDef.IsOptional || parDef.IsOut || parDef.IsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty (parDef.Attributes) || parDef.Name != this.host.NameTable.EmptyName) " is 204.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInClrHeader,The length of the statement  "	clrHeader.strongNameSignature.RelativeVirtualAddress = clrHeader.resources.RelativeVirtualAddress + clrHeader.resources.Size; " is 125.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.AddressOfEntryPoint = this.emitRuntimeStartupStub ? this.textDataSection.RelativeVirtualAddress - (use32bitAddresses ? 6u : 10u) : 0; " is 142.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.SizeOfInitializedData = this.rdataSection.SizeOfRawData + this.coverSection.SizeOfRawData + this.extendedDataSection.SizeOfRawData + this.sdataSection.SizeOfRawData + this.tlsSection.SizeOfRawData + this.resourceSection.SizeOfRawData + this.relocSection.SizeOfRawData; " is 277.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.CliHeaderTable.RelativeVirtualAddress = ntHeader.ImportAddressTable.RelativeVirtualAddress + ntHeader.ImportAddressTable.Size; " is 135.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.ImportTable.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress + this.ComputeOffsetToImportTable (); " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.DebugTable.RelativeVirtualAddress = this.pdbWriter == null ? 0u : this.textSection.RelativeVirtualAddress + this.ComputeOffsetToDebugTable (); " is 151.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.ResourceTable.RelativeVirtualAddress = this.resourceSection.VirtualSize == 0 ? 0u : this.resourceSection.RelativeVirtualAddress; " is 137.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The length of the statement  "	ntHeader.ThreadLocalStorageTable.RelativeVirtualAddress = this.tlsSection.SizeOfRawData == 0 ? 0u : this.tlsSection.RelativeVirtualAddress; " is 139.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "		if (customSections != null && customSections.Find (uiSection => uiSection.SectionName == peSection.SectionName) != null) " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.textDataSection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress + this.textSection.VirtualSize - Aligned (this.textDataWriter.BaseStream.Length' 4); " is 170.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.textMethodBodySection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress + this.sizeOfImportAddressTable + 72; " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.rdataSection.RelativeVirtualAddress = Aligned (this.textSection.RelativeVirtualAddress + this.textSection.VirtualSize' 0x2000); " is 132.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.sdataSection.RelativeVirtualAddress = Aligned (this.rdataSection.RelativeVirtualAddress + this.rdataSection.VirtualSize' 0x2000); " is 134.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.extendedDataSection.RelativeVirtualAddress = Aligned (this.sdataSection.RelativeVirtualAddress + this.sdataSection.VirtualSize' 0x2000); " is 141.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.extendedDataSection.SizeOfRawData = Aligned (this.extendedDataWriter.BaseStream.Length' this.module.FileAlignment); " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.coverSection.PointerToRawData = this.extendedDataSection.PointerToRawData + this.extendedDataSection.SizeOfRawData; " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.coverSection.RelativeVirtualAddress = Aligned (this.extendedDataSection.RelativeVirtualAddress + this.extendedDataSection.VirtualSize' 0x2000); " is 148.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.tlsSection.RelativeVirtualAddress = Aligned (this.coverSection.RelativeVirtualAddress + this.coverSection.VirtualSize' 0x2000); " is 132.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.resourceSection.RelativeVirtualAddress = Aligned (this.tlsSection.RelativeVirtualAddress + this.tlsSection.VirtualSize' 0x2000); " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The length of the statement  "	this.relocSection.RelativeVirtualAddress = Aligned (this.resourceSection.RelativeVirtualAddress + this.resourceSection.VirtualSize' 0x2000); " is 140.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMethodRefTokenFor,The length of the statement  "	return 0x0A000000 | this.GetMemberRefIndex (new Microsoft.Cci.Immutable.DummyArrayMethodReference (arrayTypeReference' operationCode' this.host)); " is 146.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMethodSignatureIndex,The length of the statement  "	this.SerializeSignature (methodReference' methodReference.GenericParameterCount' methodReference.ExtraParameters' writer); " is 122.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCorrespondingMethodToken,The length of the statement  "	var sigString = MemberHelper.GetMethodSignature (methodDefinition' NameFormattingOptions.Signature | NameFormattingOptions.ReturnType | NameFormattingOptions.TypeParameters); " is 174.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCorrespondingMethodToken,The length of the statement  "		var csigString = MemberHelper.GetMethodSignature (correspondingMethod' NameFormattingOptions.Signature | NameFormattingOptions.ReturnType | NameFormattingOptions.TypeParameters); " is 178.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMethodToken,The length of the statement  "	if (definingUnit != null && definingUnit.UnitIdentity.Equals (this.module.ModuleIdentity) && !methodReference.AcceptsExtraArguments) " is 132.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "	if (this.IndexDoesNotFit (16 - 5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl' TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig' TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource)) " is 483.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "	if (this.IndexDoesNotFit (16 - 3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec)) " is 146.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The length of the statement  "	if (this.IndexDoesNotFit (16 - 2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef)) " is 127.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTableRows,The length of the statement  "	//This table is populated after the others because it depends on the order of the entries of the generic parameter table. " is 121.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The length of the statement  "			INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference; " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The length of the statement  "				r.TypeNamespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None)); " is 127.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeDefTableRows,The length of the statement  "			nsName = this.GetStringIndex (TypeHelper.GetNamespaceName (nsType.ContainingUnitNamespace' NameFormattingOptions.None)); " is 120.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The length of the statement  "			if (nsTypeRef.KeepDistinctFromDefinition && nsTypeRef.ContainingUnitNamespace.Unit.UnitIdentity == this.module.ModuleIdentity) " is 126.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The length of the statement  "			INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsTypeRef.ContainingUnitNamespace as INestedUnitNamespaceReference; " is 133.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The length of the statement  "				r.Namespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None)); " is 123.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,The length of the statement  "				if (nensRef != null && nensRef.Name.UniqueKey == this.host.NameTable.System.UniqueKey && nensRef.ContainingUnitNamespace is IRootUnitNamespaceReference) { " is 154.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,The length of the statement  "					return IteratorHelper.EnumerableIsEmpty (this.sourceLocationProvider.GetPrimarySourceLocationsFor (firstOperation.Location)); " is 125.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,DebuggerShouldHideMethod,The length of the statement  "	return IteratorHelper.EnumerableIsEmpty (this.sourceLocationProvider.GetPrimarySourceLocationsFor (firstOperation.Location)); " is 125.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopes,The length of the statement  "	if (this.tokenOfLastMethodWithUsingInfo != 0 && (this.lastUsingInfo == scopes || IteratorHelper.EnumerableIsEmpty (scopes))) " is 124.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The length of the statement  "	if (this.tokenOfLastMethodWithUsingInfo != 0 && (scopes == this.lastUsingInfo || IteratorHelper.EnumerableIsEmpty (scopes))) { " is 126.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The length of the statement  "	bool useSmallExceptionHeaders = MayUseSmallExceptionHeaders (numberOfExceptionHandlers' methodBody.OperationExceptionInformation); " is 130.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMarshallingDescriptor,The length of the statement  "			if (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD) " is 310.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,AppendAssemblyQualifierIfNecessary,The length of the statement  "	if (referencedAssembly != null && (this.module.ContainingAssembly == null || !referencedAssembly.AssemblyIdentity.Equals (this.module.ContainingAssembly.AssemblyIdentity))) { " is 174.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The length of the statement  "	this.WriteDirectory (TypeDirectory' this.win32ResourceWriter' 0' 0' sizeOfDirectoryTree' this.resourceSection.RelativeVirtualAddress' dataWriter); " is 146.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The length of the statement  "		// Machine property not explicitly set (or set to Unknown.) Fallback to CCI behavior prior to adding IModule.Machine property " is 125.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The length of the statement  "	//ushort characteristics = 0x0002|0x0004|0x0008; //executable | no COFF line nums | no COFF symbols (as required by the standard) " is 129.
Long Statement,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRelocSection,The length of the statement  "		//No need to write out a reloc section' but there is still a need to pad out the peStream so that it is an even multiple of module.FileAlignment " is 144.
Long Statement,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,CopyTo,The length of the statement  "	while (this.enumeratorIsValid && charsCopied < length)//^ invariant this.currentFragmentOffset+this.fragmentEnumerator.Current.Length > position; " is 145.
Long Statement,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,CopyTo,The length of the statement  "		int fragCharsCopied = this.fragmentEnumerator.Current.CopyTo (fragmentStart' destination' destinationOffset' fragmentCharsToCopy); " is 130.
Long Statement,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,CopyTo,The length of the statement  "	//^ assume false; //unsatisfied postcondition: ensures 0 <= result && result <= length && position+result <= this.Length; " is 121.
Long Statement,Microsoft.Cci,CompositeSourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ToLineColumn,The length of the statement  "		this.ToLineColumn (position - this.currentFragmentOffset' ref line' ref column' this.fragmentEnumerator.Current.Source); " is 120.
Long Statement,Microsoft.Cci,SourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "		sourceLocationInPreviousVersionOfDocument = prev.GetCorrespondingSourceLocation (sourceLocationInPreviousVersionOfDocument); " is 124.
Long Statement,Microsoft.Cci,SourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "		//The location does not overlap the edit' but may have to move to the left or right' depending on whether the edit deleted or inserted characters " is 145.
Long Statement,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "	//^ assume previousSourceDocument is SourceDocumentWithInclusion; //otherwise this could not be an updated version of previousSourceDocument " is 140.
Long Statement,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "	//^ assert position >= 0 && (position < sourceLocationInPreviousVersionOfDocument.SourceDocument.Length || position == 0); //follows from post condition " is 152.
Long Statement,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "	//^ assume position >= 0 && (position < previousWrappedDocument.Length || position == 0); //assume that things stay the same when unwrapping " is 140.
Long Statement,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "	//^ assert prevLength >= 0 && sourceLocationInPreviousVersionOfDocument.StartIndex+prevLength <= sourceLocationInPreviousVersionOfDocument.SourceDocument.Length; " is 161.
Long Statement,Microsoft.Cci,SourceDocumentWithInclusion,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetCorrespondingSourceLocation,The length of the statement  "	//^ assume prevLength <= previousWrappedDocument.Length && position+prevLength <= previousWrappedDocument.Length; //assume that things stay the same when unwrapping " is 164.
Long Statement,Microsoft.Cci.Immutable,GenericMethodInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.ParameterModifiers | NameFormattingOptions.ParameterName); " is 195.
Long Statement,Microsoft.Cci.Immutable,GenericMethodInstanceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.ParameterModifiers | NameFormattingOptions.ParameterName); " is 195.
Long Statement,Microsoft.Cci.Immutable,SpecializedEventDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the statement  "		partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference (partiallySpecializedTypeReference' specializedParent' this.ContainingGenericTypeInstance.InternFactory); " is 178.
Long Statement,Microsoft.Cci.Immutable,SpecializedEventDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 195.
Long Statement,Microsoft.Cci.Immutable,SpecializedFieldDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference (partiallySpecializedTypeReference' specializedParent' this.ContainingGenericTypeInstance.InternFactory); " is 178.
Long Statement,Microsoft.Cci.Immutable,SpecializedFieldDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 195.
Long Statement,Microsoft.Cci.Immutable,SpecializedGenericMethodParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (partiallySpecializedTypeReference' this.DefiningMethod' this.DefiningMethod.ContainingGenericTypeInstance.InternFactory); " is 215.
Long Statement,Microsoft.Cci.Immutable,SpecializedGenericMethodParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedTypeReference' this.DefiningMethod.ContainingGenericTypeInstance' this.DefiningMethod.ContainingGenericTypeInstance.InternFactory); " is 225.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the statement  "		var specializedOperationExceptionInformation = new List<IOperationExceptionInformation> (this.unspecializedBody.OperationExceptionInformation); " is 143.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,MapBody,The length of the statement  "				var specializedOperationException = new SpecializedOperationExceptionInformation (unspecializedOperationException' specializedType); " is 132.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "	ITypeReference specializedType = TypeHelper.SpecializeTypeReference (unspecializedType' this.containingMethod' this.internFactory); " is 131.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "			var specializedContainingType = TypeHelper.SpecializeTypeReference (fieldReference.ContainingType' this.containingMethod' this.internFactory); " is 142.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "				var specializedContainingType = TypeHelper.SpecializeTypeReference (methodReference.ContainingType' this.containingMethod' this.internFactory); " is 143.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,Specialize,The length of the statement  "	var specialized = new GenericMethodInstanceReference (specializedMethod' IteratorHelper.GetReadonly (args.ToArray ())' this.internFactory); " is 139.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.TypeParameters); " is 153.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (partiallySpecializedTypeReference' this' this.ContainingGenericTypeInstance.InternFactory); " is 185.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 195.
Long Statement,Microsoft.Cci.Immutable,SpecializedMethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.TypeParameters | NameFormattingOptions.TypeConstraints); " is 193.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		//Note that partiallySpecializedType is obtained from genericMethodInstance.GenericMethod which will have been specialized with respect " is 135.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		//to everything but the generic method parameters. Hence only the following call is necessary to specialize partiallySpecializedType. " is 133.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedType' genericMethodInstance' this.InternFactory); " is 143.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	//Since the containing signature is not a generic method instance' it must be a member of a type that has been specialized. " is 123.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	//The things that need to be specialized in partiallySpecializedType are defined by this containing type and/or its containing types. " is 133.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		partiallySpecializedType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (partiallySpecializedType' specializedMethodDefinition' this.internFactory); " is 160.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedType' specializedMethodDefinition.ContainingGenericTypeInstance' this.InternFactory); " is 179.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	SpecializedNestedTypeDefinition snt = specializedPropertyDefinition.ContainingTypeDefinition as SpecializedNestedTypeDefinition; " is 128.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedType' specializedPropertyDefinition.ContainingGenericTypeInstance' this.InternFactory); " is 181.
Long Statement,Microsoft.Cci.Immutable,SpecializedParameterTypeInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,SpecializeIfConstructed,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedType' this.containingSignature' this.InternFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	SpecializedNestedTypeDefinition specializedNestedParent = this.ContainingTypeDefinition as SpecializedNestedTypeDefinition; " is 123.
Long Statement,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "		partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference (partiallySpecializedTypeReference' specializedNestedParent' this.ContainingGenericTypeInstance.InternFactory); " is 184.
Long Statement,Microsoft.Cci.Immutable,SpecializedPropertyDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,CopyAndSpecialize,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.ContainingGenericTypeInstance.InternFactory); " is 195.
Long Statement,Microsoft.Cci.Immutable,NamespaceTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,GetResolvedType,The length of the statement  "	foreach (INamespaceMember member in this.ContainingUnitNamespace.ResolvedUnitNamespace.GetMembersNamed (this.name' false)) { " is 124.
Long Statement,Microsoft.Cci.Immutable,PlatformType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\PlatformTypes.cs,CreateReference,The length of the statement  "	return new NamespaceTypeReference (this.host' ns' this.host.NameTable.GetNameFor (names [names.Length - 1])' genericParameterCount' false' isValueType' typeCode); " is 162.
Long Statement,Microsoft.Cci.Immutable,ArrayType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetMatchingMembersNamed,The length of the statement  "		if (name.UniqueKey != member.Name.UniqueKey || (ignoreCase && name.UniqueKeyIgnoringCase == member.Name.UniqueKeyIgnoringCase)) { " is 129.
Long Statement,Microsoft.Cci.Immutable,ArrayType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetMembersNamed,The length of the statement  "		if (name.UniqueKey != member.Name.UniqueKey || (ignoreCase && name.UniqueKeyIgnoringCase == member.Name.UniqueKeyIgnoringCase)) { " is 129.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,CopyModifierToNewContainer,The length of the statement  "	ITypeReference copiedModifier = TypeDefinition.DeepCopyTypeReference (customModifier.Modifier' targetContainer' internFactory); " is 127.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,Specialize,The length of the statement  "	ITypeReference copiedModifier = TypeHelper.SpecializeTypeReference (customModifier.Modifier' targetContainer' internFactory); " is 125.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,Specialize,The length of the statement  "	ITypeReference copiedModifier = TypeHelper.SpecializeTypeReference (customModifier.Modifier' targetContainer' internFactory); " is 125.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference copiedModifier = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (customModifier.Modifier' containingMethodInstance' internFactory); " is 165.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference copiedModifier = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (customModifier.Modifier' containingTypeInstance' internFactory); " is 163.
Long Statement,Microsoft.Cci.Immutable,CustomModifier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableMethodTypeParameter,The length of the statement  "	ITypeReference copiedModifier = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (customModifier.Modifier' specializedMethodReference' internFactory); " is 158.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "			//^ assume unspecializedMember is IEventDefinition || unspecializedMember is IFieldDefinition || unspecializedMember is IMethodDefinition || " is 140.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "			//^   unspecializedMember is IPropertyDefinition || unspecializedMember is INestedTypeDefinition; //follows from informal post condition on Members property. " is 157.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	var copiedGenericType = (INamedTypeReference)TypeDefinition.DeepCopyTypeReference (genericTypeInstance.GenericType' targetContainer' internFactory); " is 148.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	var copiedGenericType = (INamedTypeReference)TypeHelper.SpecializeTypeReference (genericTypeInstance.GenericType' targetContainer' internFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	var copiedGenericType = (INamedTypeReference)TypeHelper.SpecializeTypeReference (genericTypeInstance.GenericType' targetContainer' internFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	var specializedGenericType = (INamedTypeReference)TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (genericTypeInstance.GenericType' containingMethodInstance' internFactory); " is 191.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		ITypeReference specializedArgType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (argType' containingMethodInstance' internFactory); " is 153.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	var specializedGenericType = (INamedTypeReference)TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (genericTypeInstance.GenericType' containingTypeInstance' internFactory); " is 189.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		ITypeReference specializedArgType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (argType' containingTypeInstance' internFactory); " is 151.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	var specializedGenericType = (INamedTypeReference)TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (genericTypeInstance.GenericType' specializedMethodReference' internFactory); " is 184.
Long Statement,Microsoft.Cci.Immutable,GenericTypeInstance,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		ITypeReference specializedArgType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (argType' specializedMethodReference' internFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,GenericParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	if (specializedMethodDefinition != null && genericMethodParameter.DefiningMethod.InternedKey == specializedMethodDefinition.PartiallySpecializedVersion.InternedKey) { " is 166.
Long Statement,Microsoft.Cci.Immutable,GenericParameter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		IEnumerator<IGenericMethodParameter> genericParameters = specializedMethodDefinition.GenericParameters.GetEnumerator (); " is 120.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReference (targetType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (targetType' containingMethodInstance' internFactory); " is 159.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (targetType' containingTypeInstance' internFactory); " is 157.
Long Statement,Microsoft.Cci.Immutable,ManagedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (targetType' specializedMethodReference' internFactory); " is 152.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReference (elementType' targetContainer' internFactory); " is 123.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference (elementType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference (elementType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (elementType' containingMethodInstance' internFactory); " is 161.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (elementType' containingTypeInstance' internFactory); " is 159.
Long Statement,Microsoft.Cci.Immutable,Matrix,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (elementType' specializedMethodReference' internFactory); " is 154.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReference (targetType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (targetType' containingMethodInstance' internFactory); " is 159.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (targetType' containingTypeInstance' internFactory); " is 157.
Long Statement,Microsoft.Cci.Immutable,PointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceReplacingGenericMethodParameter,The length of the statement  "	ITypeReference specializedtargetType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (targetType' specializedMethodReference' internFactory); " is 152.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	var copiedTargetType = TypeDefinition.DeepCopyTypeReference (modifiedPointer.TargetType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	var copiedTargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (modifiedPointer.TargetType' containingMethodInstance' internFactory); " is 159.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter (modifier' containingMethodInstance' internFactory); " is 139.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	var copiedTargetType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (modifiedPointer.TargetType' containingTypeInstance' internFactory); " is 157.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter (modifier' containingTypeInstance' internFactory); " is 137.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	var copiedTargetType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (modifiedPointer.TargetType' specializedMethodReference' internFactory); " is 152.
Long Statement,Microsoft.Cci.Immutable,ModifiedPointerType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableMethodTypeParameter (modifier' specializedMethodReference' internFactory); " is 147.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	ITypeReference copiedUnmodifiedType = TypeDefinition.DeepCopyTypeReference (modifiedTypeReference.UnmodifiedType' targetContainer' internFactory); " is 146.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	ITypeReference copiedUnmodifiedType = TypeHelper.SpecializeTypeReference (modifiedTypeReference.UnmodifiedType' targetContainer' internFactory); " is 144.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	ITypeReference copiedUnmodifiedType = TypeHelper.SpecializeTypeReference (modifiedTypeReference.UnmodifiedType' targetContainer' internFactory); " is 144.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference copiedUnmodifiedType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (modifiedTypeReference.UnmodifiedType' containingMethodInstance' internFactory); " is 184.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter (modifier' containingMethodInstance' internFactory); " is 139.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference copiedUnmodifiedType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (modifiedTypeReference.UnmodifiedType' containingTypeInstance' internFactory); " is 182.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableTypeParameter (modifier' containingTypeInstance' internFactory); " is 137.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	ITypeReference copiedUnmodifiedType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (modifiedTypeReference.UnmodifiedType' specializedMethodReference' internFactory); " is 177.
Long Statement,Microsoft.Cci.Immutable,ModifiedTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		var copiedModifier = CustomModifier.SpecializeIfConstructedFromApplicableMethodTypeParameter (modifier' specializedMethodReference' internFactory); " is 147.
Long Statement,Microsoft.Cci.Immutable,Scope,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetMembersNamed,The length of the statement  "	Dictionary<int' List<MemberType>> nameToMemberListMap = ignoreCase ? this.caseInsensitiveMemberNameToMemberListMap : this.caseSensitiveMemberNameToMemberListMap; " is 161.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	var specializedParent = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (nestedType.ContainingType' specializedMethodReference' internFactory); " is 152.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	var specializedParent = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (nestedType.ContainingType' genericMethodInstance' internFactory); " is 156.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	var specializedParent = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (nestedType.ContainingType' containingTypeInstance' internFactory); " is 157.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "			//^ assume unspecializedMember is IEventDefinition || unspecializedMember is IFieldDefinition || unspecializedMember is IMethodDefinition || " is 140.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,InitializeIfNecessary,The length of the statement  "			//^   unspecializedMember is IPropertyDefinition || unspecializedMember is INestedTypeDefinition; //follows from informal post condition on Members property. " is 157.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,CopyAndSpecialize,The length of the statement  "	partiallySpecializedTypeReference = TypeDefinition.DeepCopyTypeReference (partiallySpecializedTypeReference' this' this.InternFactory); " is 135.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,CopyAndSpecialize,The length of the statement  "	return TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (partiallySpecializedTypeReference' this.ContainingGenericTypeInstance' this.InternFactory); " is 165.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,The length of the statement  "		return new SpecializedPropertyDefinition (unspecializedPropertyDef' propertyDef' this' this.ContainingGenericTypeInstance); " is 123.
Long Statement,Microsoft.Cci.Immutable,SpecializedNestedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeMember,The length of the statement  "	return new SpecializedNestedTypeDefinition (unspecializedTypeDef' nestedTypeDef' this' this.ContainingGenericTypeInstance' internFactory); " is 138.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return GenericParameter.SpecializeIfConstructedFromApplicableTypeParameter (genericMethodParameter' containingMethodInstance); " is 126.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return GenericTypeInstance.SpecializeIfConstructedFromApplicableTypeParameter (genericTypeInstance' containingMethodInstance' internFactory); " is 141.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return ManagedPointerType.SpecializeIfConstructedFromApplicableTypeParameter (managedPointerType' containingMethodInstance' internFactory); " is 139.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return ModifiedPointerType.SpecializeIfConstructedFromApplicableTypeParameter (modifiedPointer' containingMethodInstance' internFactory); " is 137.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return ModifiedTypeReference.SpecializeIfConstructedFromApplicableTypeParameter (modifiedType' containingMethodInstance' internFactory); " is 136.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return SpecializedNestedTypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (nestedType' containingMethodInstance' internFactory); " is 144.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return PointerType.SpecializeIfConstructedFromApplicableTypeParameter (pointerType' containingMethodInstance' internFactory); " is 125.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return GenericParameter.SpecializeIfConstructedFromApplicableTypeParameter (genericTypeParameter' containingTypeInstance); " is 122.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return GenericTypeInstance.SpecializeIfConstructedFromApplicableTypeParameter (genericTypeInstance' containingTypeInstance' internFactory); " is 139.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return ManagedPointerType.SpecializeIfConstructedFromApplicableTypeParameter (managedPointerType' containingTypeInstance' internFactory); " is 137.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return ModifiedPointerType.SpecializeIfConstructedFromApplicableTypeParameter (modifiedPointer' containingTypeInstance' internFactory); " is 135.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return ModifiedTypeReference.SpecializeIfConstructedFromApplicableTypeParameter (modifiedType' containingTypeInstance' internFactory); " is 134.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return SpecializedNestedTypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (nestedType' containingTypeInstance' internFactory); " is 142.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "		return PointerType.SpecializeIfConstructedFromApplicableTypeParameter (pointerType' containingTypeInstance' internFactory); " is 123.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		return GenericTypeInstance.DeepCopyTypeReferenceWRTSpecializedMethod (genericTypeInstance' specializedMethodReference' internFactory); " is 134.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		return ManagedPointerType.DeepCopyTypeReferenceWRTSpecializedMethod (managedPointerType' specializedMethodReference' internFactory); " is 132.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		return ModifiedPointerType.DeepCopyTypeReferenceWRTSpecializedMethod (modifiedPointer' specializedMethodReference' internFactory); " is 130.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		return ModifiedTypeReference.DeepCopyTypeReferenceWRTSpecializedMethod (modifiedType' specializedMethodReference' internFactory); " is 129.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		return PointerType.DeepCopyTypeReferenceReplacingGenericMethodParameter (pointerType' specializedMethodReference' internFactory); " is 129.
Long Statement,Microsoft.Cci.Immutable,TypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "		return SpecializedNestedTypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (nestedType' specializedMethodReference' internFactory); " is 137.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The length of the statement  "		interfaces.Add (new GenericTypeInstanceReference (this.PlatformType.SystemCollectionsGenericIList' argTypes' this.InternFactory)); " is 130.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The length of the statement  "		interfaces.Add (new GenericTypeInstanceReference (this.PlatformType.SystemCollectionsGenericICollection' argTypes' this.InternFactory)); " is 136.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The length of the statement  "		interfaces.Add (new GenericTypeInstanceReference (this.PlatformType.SystemCollectionsGenericIEnumerable' argTypes' this.InternFactory)); " is 136.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReference,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReference (elementType' targetContainer' internFactory); " is 123.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference (elementType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeTypeReference,The length of the statement  "	ITypeReference specializedElementType = TypeHelper.SpecializeTypeReference (elementType' targetContainer' internFactory); " is 121.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (elementType' method' internFactory); " is 143.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,SpecializeIfConstructedFromApplicableTypeParameter,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.SpecializeIfConstructedFromApplicableTypeParameter (elementType' type' internFactory); " is 141.
Long Statement,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,DeepCopyTypeReferenceWRTSpecializedMethod,The length of the statement  "	ITypeReference specializedElementType = TypeDefinition.DeepCopyTypeReferenceWRTSpecializedMethod (elementType' specializedMethodReference' internFactory); " is 154.
Long Statement,Microsoft.Cci.Immutable,UnitSet,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,Contains,The length of the statement  "	//^ assume result == exists{IUnit u in this.Units; u == unit}; //TODO: Boogie: need a working postcodition on EnumerableContains " is 128.
Long Statement,Microsoft.Cci.Immutable,UnitSetNamespace,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,GetAggregatedMember,The length of the statement  "	if (!this.nestedUnitNamespaceToNestedUnitSetNamespaceMap.TryGetValue (nestedUnitNamespace.Name.UniqueKey' out result)) { " is 120.
Long Statement,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF16WithShortSize,The length of the statement  "	#      string result = new string((sbyte*)(this.CurrentPointer + offset + sizeof(UInt16))' 0' length * sizeof(Char)' Encoding.Unicode);" is 135.
Long Statement,System.Diagnostics.Contracts,Contract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\Contracts.cs,AssertMustUseRewriter,The length of the statement  "	Internal.ContractHelper.TriggerFailure (kind' "Must use the rewriter when using Contract." + contractKind' null' null' null); " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,CopyMethodBody,The length of the statement  "	return this.SubstituteCopiesForOriginals.Substitute (this.SubstituteCopiesForOriginals.shallowCopier.Copy (methodBody)); " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the statement  "	return (GenericMethodParameterReference)this.SubstituteCopiesForOriginals.Substitute (genericMethodParameterReference' keepAsDefinition: false); " is 144.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the statement  "	return (GenericTypeParameterReference)this.SubstituteCopiesForOriginals.Substitute (genericTypeParameterReference' keepAsDefinition: false); " is 140.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the statement  "	return (NamespaceTypeReference)this.SubstituteCopiesForOriginals.Substitute (namespaceTypeReference' keepAsDefinition: false); " is 126.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,CopyUnspecialized,The length of the statement  "	return (NestedTypeReference)this.SubstituteCopiesForOriginals.Substitute (nestedTypeReference' keepAsDefinition: false); " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the statement  "	return (NestedUnitNamespaceReference)this.SubstituteCopiesForOriginals.Substitute (nestedUnitNamespaceReference' keepAsDefinition: false); " is 138.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the statement  "	return (ParameterTypeInformation)this.SubstituteCopiesForOriginals.Substitute (parameterTypeInformation' keepAsDefinition: false); " is 130.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataDeepCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Copy,The length of the statement  "	return (RootUnitNamespaceReference)this.SubstituteCopiesForOriginals.Substitute (rootUnitNamespaceReference' keepAsDefinition: false); " is 134.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,GetTypeSpecificMutableShallowCopy,The length of the statement  "	IGenericMethodInstanceReference /*?*/genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "		fieldDefinition.MarshallingInformation = this.DeepCopy (this.GetMutableShallowCopy (fieldDefinition.MarshallingInformation)); " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "		functionPointerTypeReference.ReturnValueCustomModifiers = this.DeepCopy (functionPointerTypeReference.ReturnValueCustomModifiers); " is 130.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	globalMethodDefinition.ContainingNamespace = this.GetMutableCopyIfItExists (globalMethodDefinition.ContainingNamespace); " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	genericTypeInstanceReference.GenericType = (INamedTypeReference)this.DeepCopy (genericTypeInstanceReference.GenericType); " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	IGenericMethodInstanceReference /*?*/genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	ISpecializedNestedTypeReference /*?*/specializedNestedTypeReference = nestedTypeReference as ISpecializedNestedTypeReference; " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	if (marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)) " is 286.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "		marshallingInformation.SafeArrayElementUserDefinedSubtype = this.DeepCopy (marshallingInformation.SafeArrayElementUserDefinedSubtype); " is 134.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	methodDefinition.ReturnValueAttributes = this.DeepCopyMethodReturnValueAttributes (methodDefinition.ReturnValueAttributes); " is 123.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "		methodDefinition.ReturnValueCustomModifiers = this.DeepCopyMethodReturnValueCustomModifiers (methodDefinition.ReturnValueCustomModifiers); " is 138.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "		methodDefinition.ReturnValueMarshallingInformation = this.DeepCopyMethodReturnValueMarshallingInformation (this.GetMutableShallowCopy (methodDefinition.ReturnValueMarshallingInformation)); " is 188.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	namespaceTypeDefinition.ContainingUnitNamespace = this.GetMutableCopyIfItExists (namespaceTypeDefinition.ContainingUnitNamespace); " is 130.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	nestedTypeDefinition.ContainingTypeDefinition = this.GetMutableCopyIfItExists (nestedTypeDefinition.ContainingTypeDefinition); " is 126.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	specializedNestedTypeReference.UnspecializedVersion = (INestedTypeReference)this.DeepCopy (specializedNestedTypeReference.UnspecializedVersion); " is 144.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = unitNamespaceReference as INestedUnitNamespaceReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	nestedUnitNamespace.ContainingUnitNamespace = this.GetMutableCopyIfItExists (nestedUnitNamespace.ContainingUnitNamespace); " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	nestedUnitNamespaceReference.ContainingUnitNamespace = this.DeepCopy (nestedUnitNamespaceReference.ContainingUnitNamespace); " is 124.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "		parameterDefinition.MarshallingInformation = this.DeepCopy (this.GetMutableShallowCopy (parameterDefinition.MarshallingInformation)); " is 133.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	platformInvokeInformation.ImportModule = this.DeepCopy (this.GetMutableShallowCopy (platformInvokeInformation.ImportModule)); " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The length of the statement  "	typeDefinitionMember.ContainingTypeDefinition = this.GetMutableCopyIfItExists (typeDefinitionMember.ContainingTypeDefinition); " is 126.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the statement  "	ISpecializedNestedTypeReference specializedNesetedTypeReference = nestedTypeReference as ISpecializedNestedTypeReference; " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,Substitute,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,GenericMethodInstanceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Resolve,The length of the statement  "	return new Immutable.GenericMethodInstance (this.GenericMethod.ResolvedMethod' ((IGenericMethodInstanceReference)this).GenericArguments' this.InternFactory); " is 157.
Long Statement,Microsoft.Cci.MutableCodeModel,LocalDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,The length of the statement  "	if (localVariableDefinition.IsModified && IteratorHelper.EnumerableIsNotEmpty (localVariableDefinition.CustomModifiers)) " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,MethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,The length of the statement  "	if (!methodBody.MethodDefinition.IsAbstract && !methodBody.MethodDefinition.IsExternal && methodBody.MethodDefinition.IsCil) " is 124.
Long Statement,Microsoft.Cci.MutableCodeModel,MethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,The length of the statement  "		this.operationExceptionInformation = new List<IOperationExceptionInformation> (methodBody.OperationExceptionInformation); " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MethodBody,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,The length of the statement  "	if (!methodBody.MethodDefinition.IsAbstract && !methodBody.MethodDefinition.IsExternal && methodBody.MethodDefinition.IsCil) " is 124.
Long Statement,Microsoft.Cci.MutableCodeModel,MethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,Copy,The length of the statement  "	if (methodDefinition.HasDeclarativeSecurity && IteratorHelper.EnumerableIsNotEmpty (methodDefinition.SecurityAttributes)) " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.ParameterModifiers | NameFormattingOptions.ParameterName); " is 195.
Long Statement,Microsoft.Cci.MutableCodeModel,TypeDefinitionMember,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Members.cs,ToString,The length of the statement  "	return MemberHelper.GetMemberSignature (this' NameFormattingOptions.ParameterModifiers | NameFormattingOptions.TypeParameters | NameFormattingOptions.ParameterName | NameFormattingOptions.ReturnType | NameFormattingOptions.Signature); " is 234.
Long Statement,Microsoft.Cci.MutableCodeModel,MarshallingInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Miscellaneous.cs,Copy,The length of the statement  "	if (marshallingInformation.UnmanagedType == UnmanagedType.ByValArray || marshallingInformation.UnmanagedType == UnmanagedType.LPArray) " is 134.
Long Statement,Microsoft.Cci.MutableCodeModel,MarshallingInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Miscellaneous.cs,Copy,The length of the statement  "	if (marshallingInformation.UnmanagedType == UnmanagedType.ByValArray || marshallingInformation.UnmanagedType == UnmanagedType.ByValTStr || marshallingInformation.UnmanagedType == UnmanagedType.LPArray) " is 201.
Long Statement,Microsoft.Cci.MutableCodeModel,MarshallingInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Miscellaneous.cs,Copy,The length of the statement  "	if (marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)) " is 286.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Rewrite,The length of the statement  "	Contract.Requires (!(typeDefinition is IGenericTypeInstance)' "Generic type instances should be reconstructed' not rewritten."); " is 128.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the statement  "		functionPointerTypeReference.ReturnValueCustomModifiers = this.Rewrite (functionPointerTypeReference.ReturnValueCustomModifiers); " is 129.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the statement  "	if (marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)) " is 410.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the statement  "		marshallingInformation.SafeArrayElementUserDefinedSubtype = this.Rewrite (marshallingInformation.SafeArrayElementUserDefinedSubtype); " is 133.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the statement  "	nestedUnitNamespaceReference.ContainingUnitNamespace = this.Rewrite (nestedUnitNamespaceReference.ContainingUnitNamespace); " is 123.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the statement  "	if (operationExceptionInformation.HandlerKind == HandlerKind.Catch || operationExceptionInformation.HandlerKind == HandlerKind.Filter) " is 134.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The length of the statement  "	specializedNestedTypeReference.UnspecializedVersion = this.Rewrite (specializedNestedTypeReference.UnspecializedVersion); " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetTypeSpecificMutableCopy,The length of the statement  "	IGenericMethodInstanceReference /*?*/genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "		functionPointerTypeReference.ReturnValueCustomModifiers = this.Visit (functionPointerTypeReference.ReturnValueCustomModifiers); " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,VisitReferenceTo,The length of the statement  "	//The referrer must refer to the same copy of the local definition that was (or will be) produced by a visit to the actual definition. " is 134.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	if (marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)) " is 286.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "		marshallingInformation.SafeArrayElementUserDefinedSubtype = this.Visit (marshallingInformation.SafeArrayElementUserDefinedSubtype); " is 131.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	methodDefinition.ReturnValueAttributes = this.VisitMethodReturnValueAttributes (methodDefinition.ReturnValueAttributes); " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "		methodDefinition.ReturnValueCustomModifiers = this.VisitMethodReturnValueCustomModifiers (methodDefinition.ReturnValueCustomModifiers); " is 135.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "		methodDefinition.ReturnValueMarshallingInformation = this.VisitMethodReturnValueMarshallingInformation (this.GetMutableCopy (methodDefinition.ReturnValueMarshallingInformation)); " is 178.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	IGenericMethodInstanceReference /*?*/genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	specializedNestedTypeReference.UnspecializedVersion = (INestedTypeReference)this.Visit (specializedNestedTypeReference.UnspecializedVersion); " is 141.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	ISpecializedNestedTypeReference /*?*/specializedNestedTypeReference = nestedTypeReference as ISpecializedNestedTypeReference; " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,VisitReferenceTo,The length of the statement  "	//The referrer must refer to the same copy of the parameter definition that was (or will be) produced by a visit to the actual definition. " is 138.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = unitNamespaceReference as INestedUnitNamespaceReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	nestedUnitNamespaceReference.ContainingUnitNamespace = this.Visit (nestedUnitNamespaceReference.ContainingUnitNamespace); " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "		parameterDefinition.MarshallingInformation = this.Visit (this.GetMutableCopy (parameterDefinition.MarshallingInformation)); " is 123.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "		if (marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)) " is 286.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "	if (marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)) " is 286.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		marshallingInformation.SafeArrayElementUserDefinedSubtype = this.Visit (marshallingInformation.SafeArrayElementUserDefinedSubtype); " is 131.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "	methodDefinition.ReturnValueAttributes = this.VisitMethodReturnValueAttributes (methodDefinition.ReturnValueAttributes); " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		methodDefinition.ReturnValueCustomModifiers = this.VisitMethodReturnValueCustomModifiers (methodDefinition.ReturnValueCustomModifiers); " is 135.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	IGenericMethodInstanceReference /*?*/genericMethodInstanceReference = methodReference as IGenericMethodInstanceReference; " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "	if (nestedTypeReference != specializedNestedTypeReference || unspecialized != specializedNestedTypeReference.UnspecializedVersion) { " is 132.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		var copy = MutableModelHelper.GetSpecializedNestedTypeReference (nestedTypeReference.ContainingType' nestedTypeReference.GenericParameterCount' nestedTypeReference.MangleName' nestedTypeReference.Name' unspecialized' this.host.InternFactory' nestedTypeReference); " is 263.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	specializedNestedTypeReference.UnspecializedVersion = (INestedTypeReference)this.Visit (specializedNestedTypeReference.UnspecializedVersion); " is 141.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		var copy = MutableModelHelper.GetNamespaceTypeReference (containingUnit' namespaceTypeReference.GenericParameterCount' namespaceTypeReference.MangleName' namespaceTypeReference.Name' this.host.InternFactory' namespaceTypeReference); " is 232.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	ISpecializedNestedTypeReference /*?*/specializedNestedTypeReference = nestedTypeReference as ISpecializedNestedTypeReference; " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		return MutableModelHelper.GetNestedTypeReference (containingType' nestedTypeReference.GenericParameterCount' nestedTypeReference.MangleName' nestedTypeReference.Name' this.host.InternFactory' nestedTypeReference); " is 213.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		return MutableModelHelper.GetGenericTypeParameterReference (defType' genericTypeParameterReference.Name' genericTypeParameterReference.Index' this.host.InternFactory' genericTypeParameterReference); " is 198.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		return MutableModelHelper.GetGenericTypeInstanceReference (new List<ITypeReference> (args)' typ' this.host.InternFactory' genericTypeInstanceReference); " is 152.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "	if (pars != functionPointerTypeReference.Parameters || typ != functionPointerTypeReference.Type || extraArgumentTypes != functionPointerTypeReference.ExtraArgumentTypes || (customModifiers != functionPointerTypeReference.ReturnValueCustomModifiers && functionPointerTypeReference.ReturnValueIsModified)) { " is 305.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		var copy = MutableModelHelper.GetFunctionPointerTypeReference (functionPointerTypeReference.CallingConvention' pars' extraArgumentTypes' functionPointerTypeReference.ReturnValueIsModified' customModifiers' functionPointerTypeReference.ReturnValueIsByRef' typ' this.host.InternFactory' functionPointerTypeReference); " is 315.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The length of the statement  "		return MutableModelHelper.GetModifiedTypeReference (umt' customModifiers' this.host.InternFactory' modifiedTypeReference); " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	IGenericMethodParameterReference /*?*/genericMethodParameterReference = typeReference as IGenericMethodParameterReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The length of the statement  "	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = unitNamespaceReference as INestedUnitNamespaceReference; " is 122.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetReferenceCopy,The length of the statement  "	//^ requires fieldReference is FieldReference || fieldReference is FieldDefinition || fieldReference is GlobalFieldDefinition; " is 126.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetReferenceCopy,The length of the statement  "	//^ requires methodReference is MethodReference || methodReference is MethodDefinition || methodReference is GlobalMethodDefinition " is 131.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetReferenceCopy,The length of the statement  "	//^ assert specializedFieldReference is SpecializedFieldDefinition || specializedFieldReference is SpecializedFieldReference; " is 125.
Long Statement,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,GetReferenceCopy,The length of the statement  "	//^ assert specialziedMethodReference is SpecializedMethodReference || specializedMethodReference is SpecializedMethodDefinition; " is 129.
Long Statement,Microsoft.Cci.MutableCodeModel,NestedUnitNamespaceReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Namespaces.cs,Resolve,The length of the statement  "	foreach (INamespaceMember member in this.containingUnitNamespace.ResolvedUnitNamespace.GetMembersNamed (this.Name' false)) { " is 124.
Long Statement,Microsoft.Cci.MutableCodeModel,UnitNamespace,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Namespaces.cs,GetMatchingMembersNamed,The length of the statement  "		if (nsmem.Name.UniqueKey == name.UniqueKey || ignoreCase && (name.UniqueKeyIgnoringCase == nsmem.Name.UniqueKeyIgnoringCase)) { " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,UnitNamespace,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Namespaces.cs,GetMembersNamed,The length of the statement  "		if (nsmem.Name.UniqueKey == name.UniqueKey || ignoreCase && (name.UniqueKeyIgnoringCase == nsmem.Name.UniqueKeyIgnoringCase)) { " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,AliasForType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,GetMatchingMembersNamed,The length of the statement  "		if (tdmem.Name.UniqueKey == name.UniqueKey || ignoreCase && (name.UniqueKeyIgnoringCase == tdmem.Name.UniqueKeyIgnoringCase)) { " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,AliasForType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,GetMembersNamed,The length of the statement  "		if (tdmem.Name.UniqueKey == name.UniqueKey || ignoreCase && (name.UniqueKeyIgnoringCase == tdmem.Name.UniqueKeyIgnoringCase)) { " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,FunctionPointerTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,ObjectInvariant,The length of the statement  "	//Contract.Invariant(this.resolvedFunctionPointer == null || this.resolvedFunctionPointer.InternedKey == this.InternedKey); " is 123.
Long Statement,Microsoft.Cci.MutableCodeModel,NamespaceTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Resolve,The length of the statement  "	foreach (INamespaceMember member in this.ContainingUnitNamespace.ResolvedUnitNamespace.GetMembersNamed (this.name' false)) { " is 124.
Long Statement,Microsoft.Cci.MutableCodeModel,NamespaceTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Resolve,The length of the statement  "		if (resolvedType != null && !(resolvedType is Dummy) && resolvedType.GenericParameterCount == this.GenericParameterCount) " is 121.
Long Statement,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,Copy,The length of the statement  "		this.explicitImplementationOverrides = new List<IMethodImplementation> (typeDefinition.ExplicitImplementationOverrides); " is 120.
Long Statement,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,SelfInstance,The length of the statement  "		var containingTypeDefinition = SelfInstance ((INamedTypeDefinition)nestedTypeDefinition.ContainingTypeDefinition' internFactory); " is 129.
Long Statement,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,SelfInstance,The length of the statement  "			result = new Immutable.SpecializedNestedTypeDefinition (nestedTypeDefinition' nestedTypeDefinition' containingTypeDefinition' genericTypeInstance' internFactory); " is 162.
Long Statement,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,GetMatchingMembersNamed,The length of the statement  "		if (tdmem.Name.UniqueKey == name.UniqueKey || ignoreCase && (name.UniqueKeyIgnoringCase == tdmem.Name.UniqueKeyIgnoringCase)) { " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,NamedTypeDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Types.cs,GetMembersNamed,The length of the statement  "		if (tdmem.Name.UniqueKey == name.UniqueKey || ignoreCase && (name.UniqueKeyIgnoringCase == tdmem.Name.UniqueKeyIgnoringCase)) { " is 127.
Long Statement,Microsoft.Cci.MutableCodeModel,AssemblyReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Units.cs,ResolveAssembly,The length of the statement  "	if (this.ReferringUnit != null && (String.IsNullOrEmpty (unifiedIdentity.Location) || unifiedIdentity.Location.Equals ("unknown://location"))) " is 142.
Long Statement,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The length of the statement  "	value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24)); " is 133.
Long Statement,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The length of the statement  "	value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56)); " is 310.
Long Statement,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The length of the statement  "	value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24)); " is 134.
Long Statement,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The length of the statement  "	value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56)); " is 311.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "	var redirectedTypeRef = peFileToObjectModel.ModuleReader.metadataReaderHost.Redirect (peFileToObjectModel.Module' typeRef) as INamespaceTypeReference; " is 150.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "		var namespaceName = this.GetNamespaceName (peFileToObjectModel.NameTable' redirectedTypeRef.ContainingUnitNamespace as INestedUnitNamespaceReference); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "			mangledName = peFileToObjectModel.NameTable.GetNameFor (redirectedTypeRef.Name.Value + "`" + redirectedTypeRef.GenericParameterCount); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "		var redirectedNamespaceTypeName = new NamespaceTypeName (peFileToObjectModel.NameTable' namespaceName' mangledName' redirectedTypeRef.Name); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetNamespaceName,The length of the statement  "	var parentNamespaceName = this.GetNamespaceName (nameTable' nestedUnitNamespaceReference.ContainingUnitNamespace as INestedUnitNamespaceReference); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetSpecializedTypeReference,The length of the statement  "		var parentTemplate = this.GetSpecializedTypeReference (peFileToObjectModel' (INamedTypeReference)nestedType.ContainingType' out argumentUsed' mostNested: false); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetSpecializedTypeReference,The length of the statement  "		genericArgumentsReferences [i] = this.GenericArguments [i + argumentUsed].GetAsTypeReference (peFileToObjectModel' peFileToObjectModel.Module) ?? Dummy.TypeReference; " is 166.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetSpecializedTypeReference,The length of the statement  "	return new GenericTypeInstanceReference (nominalType' IteratorHelper.GetReadonly (genericArgumentsReferences)' peFileToObjectModel.InternFactory); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AssemblyQualifiedTypeName,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetAsTypeReference,The length of the statement  "	return this.TypeName.GetAsTypeReference (peFileToObjectModel' new AssemblyReference (peFileToObjectModel' 0' this.AssemblyIdentity' flags)); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The length of the statement  "	if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) { " is 121.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The length of the statement  "	if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "	if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) { " is 122.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "		result = ulong.Parse (val' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ParseAssemblyName,The length of the statement  "			while (this.CurrentTypeNameTokenKind != TypeNameTokenKind.Comma && this.CurrentTypeNameTokenKind != TypeNameTokenKind.CloseBracket && this.CurrentTypeNameTokenKind != TypeNameTokenKind.EOS) { " is 191.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MetadataObject,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GetAttributes,The length of the statement  "		attributes [i] = this.PEFileToObjectModel.GetCustomAttributeAtRow (this' this.TokenValue' customAttributeRowIdStart + i); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GetMatchingMembersNamed,The length of the statement  "	MultiHashtable<InternalMemberType> hashTable = ignoreCase ? this.caseInsensitiveMemberHashTable : this.caseSensitiveMemberHashTable; " is 132.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,GetMembersNamed,The length of the statement  "	MultiHashtable<InternalMemberType> hashTable = ignoreCase ? this.caseInsensitiveMemberHashTable : this.caseSensitiveMemberHashTable; " is 132.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodDefinition,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.TypeParameters); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.TypeParameters | NameFormattingOptions.Signature); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameTypeReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,Resolve,The length of the statement  "		var retModuleType = assemblyPEFileToObjectModel.ResolveNamespaceTypeDefinition (this.NamespaceFullName' this.MangledTypeName); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GetSpecializedTypeReference,The length of the statement  "		var parentTemplate = this.GetSpecializedTypeReference ((INamedTypeReference)nestedType.ContainingType' out argumentsUsed' outer: false); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GetSpecializedTypeReference,The length of the statement  "		genericArgumentsReferences [i] = this.GetGenericTypeParameterFromOrdinal ((ushort)(i + argumentsUsed)) ?? Dummy.TypeReference; " is 126.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,GetSpecializedTypeReference,The length of the statement  "	return new GenericTypeInstanceReference (nominalType' IteratorHelper.GetReadonly (genericArgumentsReferences)' this.PEFileToObjectModel.InternFactory); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,CreateCoreTypeReference,The length of the statement  "	return new CoreTypeReference (this.PEFileToObjectModel' coreAssemblyReference' namespaceReference' typeName' 0' signatureTypeCode); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,CreateCoreTypeReference,The length of the statement  "	return new CoreTypeReference (this.PEFileToObjectModel' coreAssemblyReference' namespaceReference' typeName' genericParameterCount' signatureTypeCode); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,SplitMangledTypeName,The length of the statement  "          genericParamCount = ushort.Parse(mangledTypeName.Substring(index + 1' mangledTypeName.Length - index - 1)' System.Globalization.NumberStyles.Integer'" is 149.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,SplitMangledTypeName,The length of the statement  "	ushort.TryParse (mangledTypeName.Substring (index + 1' mangledTypeName.Length - index - 1)' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out genericParamCount); " is 209.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr)); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression)); " is 139.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value " is 125.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) { " is 127.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "		foreach (ITypeDefinitionMember member in attributeType.GetMembersNamed (this.PEFileToObjectModel.NameTable.Ctor' false)) { " is 122.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "		ctorReference = new MethodReference (this.PEFileToObjectModel.ModuleReader.metadataReaderHost' moduleTypeReference' CallingConvention.Default | CallingConvention.HasThis' this.PEFileToObjectModel.PlatformType.SystemVoid' this.PEFileToObjectModel.NameTable.Ctor' 0' this.PEFileToObjectModel.PlatformType.SystemSecurityPermissionsSecurityAction); " is 344.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "			namedArgumentArray [i] = new FieldOrPropertyNamedArgumentExpression (memberName' moduleTypeReference' isField' memberType' value); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,MethodBodyDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,GetTypeFromToken,The length of the statement  "	ITypeReference /*?*/result = this.method.PEFileToObjectModel.GetTypeReferenceFromStandaloneSignatureToken (this.method' standAloneSignatureToken); " is 146.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "			//Look for a lot of different mscorlib types' since an assembly need not reference System.Object or any particular type. " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "			if (tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey && tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey && tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey && tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey) " is 919.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "			//Just because this reference looks like a mscorlib type' does not mean that it actually is one. Badly behaved assemblies might reuse mscorlib names. " is 149.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The length of the statement  "		Version version = new Version (assemblyRefRow.MajorVersion' assemblyRefRow.MinorVersion' assemblyRefRow.BuildNumber' assemblyRefRow.RevisionNumber); " is 148.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The length of the statement  "		AssemblyIdentity assemblyIdentity = new AssemblyIdentity (assemblyRefName' cultureName.Value' version' publicKeyTokenArray' string.Empty); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadModuleReferences,The length of the statement  "		ModuleIdentity probedModuleIdentity = this.ModuleReader.metadataReaderHost.ProbeModuleReference (this.Module' moduleIdentity); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadModuleReferences,The length of the statement  "		uint internedModuleId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetModuleInternedKey (probedModuleIdentity); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetAssemblyReferences,The length of the statement  "		this.AssemblyReferences = this.ModuleReader.metadataReaderHost.Redirect (this.Module' IteratorHelper.GetReadonly (arefArray)); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,FindAssemblyReference,The length of the statement  "	uint assemblyInternedId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetAssemblyInternedKey (assemblyIdentity); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,FindAssemblyReference,The length of the statement  "		uint refInternedId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetAssemblyInternedKey (assemblyRef.AssemblyIdentity); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetWin32Resources,The length of the statement  "				yield return new Win32Resource (this' typeIdOrName' idOrName' langIdOrName' resourceData.RVAToData' (uint)resourceData.Size' (uint)resourceData.CodePage); " is 154.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,ResolveResource,The length of the statement  "		return new Resource (this' resourceReference.ResourceRowId' resourceReference.Name' resRow.Flags' (resRow.Implementation & TokenTypeIds.RIDMask) != 0); " is 151.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetResourceData,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument (this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value); " is 215.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetResourceData,The length of the statement  "		return new EnumerableMemoryBlockWrapper (this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt (resOffset + sizeof(Int32)' len)); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetEntryPointMethod,The length of the statement  "		FileReference /*?*/file = this.GetFileReferenceAt (this.PEFileReader.COR20Header.EntryPointTokenOrRVA & TokenTypeIds.RIDMask); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetNamespaceForString,The length of the statement  "		NestedNamespace nestedNamespace = new NestedNamespace (this' iNamespaceFullName' iNamespaceFullName' this.RootModuleNamespace); " is 127.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "	NamespaceReference /*?*/retNamespaceReference = this.NamespaceReferenceINameHashtable.Find (moduleReference.InternedModuleId' (uint)iNamespaceFullName.UniqueKey); " is 162.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "		retNamespaceReference = new NestedNamespaceReference (this' iNamespaceName' iNamespaceFullName' parentNamespaceReference); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "	this.NamespaceReferenceINameHashtable.Add (moduleReference.InternedModuleId' (uint)iNamespaceFullName.UniqueKey' retNamespaceReference); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,PreLoadTypeDefTableLookup,The length of the statement  "		this.NestedTypeTokenTable.Add (TokenTypeIds.TypeDef | nestedClassRow.EnclosingClass' (uint)typeName.UniqueKey' TokenTypeIds.TypeDef | nestedClassRow.NestedClass); " is 162.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,PreLoadTypeDefTableLookup,The length of the statement  "			this.NamespaceTypeTokenTable.Add ((uint)namespaceName.UniqueKey' (uint)typeName.UniqueKey' TokenTypeIds.ExportedType | i); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "			type = new NonGenericNamespaceTypeWithoutPrimitiveType (this' typeName' typeDefRowId' typeDefRow.Flags' moduleNamespace); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "			type = new NonGenericNamespaceTypeWithPrimitiveType (this' typeName' typeDefRowId' typeDefRow.Flags' moduleNamespace' signatureTypeCode); " is 137.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "		type = new GenericNamespaceType (this' unmangledTypeName' typeDefRowId' typeDefRow.Flags' moduleNamespace' typeName' genericParamRowIdStart' genericParamRowIdEnd); " is 163.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateModuleNestedType,The length of the statement  "		type = new GenericNestedType (this' unmangledTypeName' typeDefRowId' typeDefRow.Flags' parentModuleType' typeName' genericParamRowIdStart' genericParamRowIdEnd); " is 161.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateExportedNamespaceType,The length of the statement  "	ExportedTypeNamespaceAlias exportedType = new ExportedTypeNamespaceAlias (this' typeName' exportedTypeRowId' exportedTypeRow.Flags' moduleNamespace); " is 149.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateExportedNestedType,The length of the statement  "	ExportedTypeNestedAlias exportedType = new ExportedTypeNestedAlias (this' typeName' exportedTypeRowId' exportedTypeRow.Flags' parentExportedType); " is 146.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadTypesInNamespace,The length of the statement  "			type = this.CreateModuleNamespaceType (i' typeDefRow' moduleNamespace' MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeDefinitionAtRowWorker,The length of the statement  "				this.PEFileReader.ErrorContainer.AddMetadataError (TableIndices.NestedClass' typeDefRowId' MetadataReaderErrorKind.NestedClassParentError); " is 139.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeDefinitionAtRowWorker,The length of the statement  "			var type = this.CreateModuleNamespaceType (typeDefRowId' typeDefRow' parentNamespace' MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetExportedTypeAtRowWorker,The length of the statement  "					this.PEFileReader.ErrorContainer.AddMetadataError (TableIndices.ExportedType' exportedTypeRowId' MetadataReaderErrorKind.NestedClassParentError); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,ResolveNestedTypeDefinition,The length of the statement  "		uint typeToken = this.NestedTypeTokenTable.Find (TokenTypeIds.TypeDef | mdParentType.TypeDefRowId' (uint)typeName.UniqueKey); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,TryToResolveAsNamespaceTypeAlias,The length of the statement  "	uint exportedTypeToken = this.NamespaceTypeTokenTable.Find ((uint)namespaceName.UniqueKey' (uint)mangledTypeName.UniqueKey); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,ResolveExportedNestedType,The length of the statement  "	uint exportedTypeToken = this.NestedTypeTokenTable.Find (TokenTypeIds.ExportedType | parentType.ExportedTypeRowId' (uint)typeName.UniqueKey); " is 141.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetGenericParamInfoForType,The length of the statement  "	genericParamRowIdStart = this.PEFileReader.GenericParamTable.FindGenericParametersForType (typeDefRowId' out genericParamCount); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetInterfaceInfoForType,The length of the statement  "	interfaceRowIdStart = this.PEFileReader.InterfaceImplTable.FindInterfaceImplForType (moduleType.TypeDefRowId' out interfaceCount); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMethodImplInfoForType,The length of the statement  "	methodImplRowIdStart = this.PEFileReader.MethodImplTable.FindMethodsImplForClass (moduleType.TypeDefRowId' out methodImplCount); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the statement  "	genericParamConstraintRowIdStart = this.PEFileReader.GenericParamConstraintTable.FindConstraintForGenericParam (genericParam.GenericParameterRowId' out constraintCount); " is 169.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetGenericTypeParamAtRow,The length of the statement  "				this.ModuleGenericParamArray [genericParamRowId] = new GenericTypeParameter (this' genericParamRow.Number' genericParamRow.Flags' genericParamName' genericParamRowId' moduleTypeOwner); " is 184.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetGenericMethodParamAtRow,The length of the statement  "				this.ModuleGenericParamArray [genericParamRowId] = new GenericMethodParameter (this' genericParamRow.Number' genericParamRow.Flags' genericParamName' genericParamRowId' moduleMethodOwner); " is 188.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "				moduleTypeRefReference = new NamespaceTypeRefReferenceWithoutPrimitiveTypeCode (this' mangledTypeName' typeRefRowId' moduleReference' namespaceReference' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 218.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "				moduleTypeRefReference = new NamespaceTypeRefReferenceWithPrimitiveTypeCode (this' mangledTypeName' typeRefRowId' moduleReference' namespaceReference' signatureTypeCode); " is 170.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "			moduleTypeRefReference = new GenericNamespaceTypeRefReference (this' iTypeName' typeRefRowId' moduleReference' namespaceReference' mangledTypeName' genericParamCount' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 231.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "			moduleTypeRefReference = new NonGenericNestedTypeRefReference (this' mangledTypeName' typeRefRowId' moduleReference' parentModuleTypeReference' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 208.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "			moduleTypeRefReference = new GenericNestedTypeRefReference (this' iTypeName' typeRefRowId' moduleReference' parentModuleTypeReference' mangledTypeName' genericParamCount' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 235.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPredefinedTypeRefReferenceAtRowWorker,The length of the statement  "	Debug.Assert (this.ModuleTypeRefReferenceLoadState [typeRefRowId] == LoadState.Uninitialized && this.ModuleTypeRefReferenceArray [typeRefRowId] == null); " is 153.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPredefinedTypeRefReferenceAtRowWorker,The length of the statement  "	var result = this.CreateTypeRefReference (typeRefRowId' typeRefRow' null' this.AssemblyReferenceArray [resolutionScopeRowId]' signatureTypeCode); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "				this.PEFileReader.ErrorContainer.AddMetadataError (TableIndices.TypeRef' typeRefRowId' MetadataReaderErrorKind.NestedClassParentError); " is 135.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "			typeRefReference = this.CreateTypeRefReference (typeRefRowId' typeRefRow' parentModuleTypeReference' parentModuleTypeReference.ModuleReference' mustBeStruct ? MetadataReaderSignatureTypeCode.ValueType : MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 255.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "			typeRefReference = this.CreateTypeRefReference (typeRefRowId' typeRefRow' null' moduleReference' mustBeStruct ? MetadataReaderSignatureTypeCode.ValueType : MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 208.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "		var redirectedTypeReference = this.ModuleReader.metadataReaderHost.Redirect (this.Module' typeRefReference) as INamedTypeReference; " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,TryToResolveNamespaceTypeReferenceAsExportedType,The length of the statement  "		//Since we are not able to resolve the assembly reference' we cannot know if the referenced assembly has an alias' so we just give up and return null. " is 150.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetReferenceToAliasedType,The length of the statement  "			ExportedTypeAliasBase /*?*/aliasType = assemblyPEFileToObjectModel.TryToResolveAsNamespaceTypeAlias (namespaceName' mangledTypeName); " is 133.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,UnderlyingModuleTypeSpecReference,The length of the statement  "	TypeSpecSignatureConverter typeSpecSignatureConverter = new TypeSpecSignatureConverter (this' moduleTypeSpecReference' memoryReader); " is 133.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,FindCoreTypeReference,The length of the statement  "	var retModuleType = this.ResolveNamespaceTypeDefinition (coreTypeReference.NamespaceFullName' coreTypeReference.mangledTypeName) as TypeBase; " is 141.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateMethod,The length of the statement  "		moduleMethod = new NonGenericMethod (this' methodName' parentModuleType' methodDefRowId' methodRow.Flags' methodRow.ImplFlags); " is 127.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateMethod,The length of the statement  "		moduleMethod = new GenericMethod (this' methodName' parentModuleType' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' genericParamRowIdStart' genericParamRowIdEnd); " is 170.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateProperty,The length of the statement  "	PropertyDefinition moduleProperty = new PropertyDefinition (this' propertyName' parentModuleType' propertyDefRowId' propertyRow.Flags); " is 135.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadNestedTypesOfType,The length of the statement  "			currType = this.CreateModuleNestedType (nestedClassRow.NestedClass' this.PEFileReader.TypeDefTable [nestedClassRow.NestedClass]' moduleType); " is 141.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyPtrRows; ++propertyIter) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyRows; ++propertyIter) { " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyPtrRows; ++propertyIter) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyRows; ++propertyIter) { " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateGlobalField,The length of the statement  "	GlobalFieldDefinition globalField = new GlobalFieldDefinition (this' fieldTypeMembName' this._Module_' fieldDefRowId' fieldRow.Flags' globalFieldName' containingNamespace); " is 172.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateGlobalMethod,The length of the statement  "		GlobalNonGenericMethod globalNGMethod = new GlobalNonGenericMethod (this' methodTypeMembName' this._Module_' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' globalMethodName' containingNamespace); " is 202.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,CreateGlobalMethod,The length of the statement  "		GlobalGenericMethod globalGMethod = new GlobalGenericMethod (this' methodTypeMembName' this._Module_' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' genericParamRowIdStart' genericParamRowIdEnd' globalMethodName' containingNamespace); " is 241.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetGenericParamInfoForMethod,The length of the statement  "	genericParamRowIdStart = this.PEFileReader.GenericParamTable.FindGenericParametersForMethod (methodDefRowId' out genericParamCount); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetFieldSequenceNumber,The length of the statement  "	uint fieldStart = this.PEFileReader.GetFieldInformation (fieldDefinition.OwningModuleType.TypeDefRowId' out fieldCount); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetSemanticInfoForProperty,The length of the statement  "	methodSemanticRowIdStart = this.PEFileReader.MethodSemanticsTable.FindSemanticMethodsForProperty (propertyRowId' out methodCount); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetSemanticInfoForEvent,The length of the statement  "	methodSemanticRowIdStart = this.PEFileReader.MethodSemanticsTable.FindSemanticMethodsForEvent (eventRowId' out methodCount); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPropertyGetterOrSetterMethod,The length of the statement  "	this.GetSemanticInfoForProperty (propertyDefinition.PropertyRowId' out methodSemanticRowIdStart' out methodSemanticRowIdEnd); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPropertyAccessorMethods,The length of the statement  "	this.GetSemanticInfoForProperty (propertyDefinition.PropertyRowId' out methodSemanticRowIdStart' out methodSemanticRowIdEnd); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,The length of the statement  "	System.Runtime.InteropServices.UnmanagedType unmanagedType = (System.Runtime.InteropServices.UnmanagedType)memoryReader.ReadByte (); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,The length of the statement  "			System.Runtime.InteropServices.UnmanagedType elementType = (System.Runtime.InteropServices.UnmanagedType)memoryReader.ReadByte (); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetPlatformInvokeInformation,The length of the statement  "	return new PlatformInvokeInformation (implMapRow.PInvokeMapFlags' this.GetNameFromOffset (implMapRow.ImportName)' moduleReference); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					unspecializedFieldReference = new FieldReference (this' memberRefRowId' TypeCache.Unspecialize (parentTypeReference)' name); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					specializedField = new SpecializedFieldReference (parentTypeReference' unspecializedFieldReference' this.InternFactory); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "				MethodReference unspecializedMethodReference = this.UnspecializedMemberReferenceArray [memberRefRowId] as MethodReference; " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					unspecializedMethodReference = new MethodReference (this' memberRefRowId' TypeCache.Unspecialize (parentTypeReference)' name' firstByte); " is 137.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					specializedMethod = new SpecializedMethodReference (parentTypeReference' unspecializedMethodReference' this.InternFactory); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMethodRefSignature,The length of the statement  "	MethodRefSignatureConverter methodRefSigConv = new MethodRefSignatureConverter (this' moduleMethodReference' memoryReader); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMethodSpecAtRow,The length of the statement  "	IGenericMethodInstanceReference /*?*/methodSpecReference = this.ModuleMethodSpecHashtable.Find (ownerId' methodSpecRowId); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMethodSpecAtRow,The length of the statement  "				methodSpecReference = new GenericMethodInstanceReferenceWithToken (moduleMethod' methodSpecSigConv.GenericTypeArguments' this.InternFactory' methodSpecRowId | TokenTypeIds.MethodSpec); " is 184.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomAttributeInfo,The length of the statement  "	customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken (metadataObject.TokenValue' out customAttributeCount); " is 150.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "						this.CustomAttributeArray [customAttributeRowId] = this.ModuleReader.metadataReaderHost.Rewrite (this.Module' new CustomAttribute (this' customAttributeRowId' moduleMethodReference' null' null)); " is 195.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "						CustomAttributeDecoder customAttrDecoder = new CustomAttributeDecoder (this' memoryReader' customAttributeRowId' moduleMethodReference); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleCustomAttributes,The length of the statement  "	uint customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken (TokenTypeIds.Module | (uint)0x00000001' out customAttributeCount); " is 168.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleCustomAttributes,The length of the statement  "	for (uint customAttributeIter = customAttributeRowIdStart; customAttributeIter < customAttributeRowIdEnd; ++customAttributeIter) { " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetAssemblyCustomAttributes,The length of the statement  "	uint customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken (TokenTypeIds.Assembly | (uint)0x00000001' out customAttributeCount); " is 170.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetAssemblyCustomAttributes,The length of the statement  "	for (uint customAttributeIter = customAttributeRowIdStart; customAttributeIter < customAttributeRowIdEnd; ++customAttributeIter) { " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeInfo,The length of the statement  "	securityAttributeRowIdStart = this.PEFileReader.DeclSecurityTable.FindSecurityAttributesForToken (metadataObject.TokenValue' out securityAttributeCount); " is 153.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeAtRow,The length of the statement  "					this.DeclSecurityArray [securityAttributeRowId] = new SecurityAttribute (this' securityAttributeRowId' (SecurityAction)declSecurity.ActionFlags); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeData,The length of the statement  "	SecurityAttributeDecoder20 securityAttrDecoder = new SecurityAttributeDecoder20 (this' memoryReader' securityAttribute); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The length of the statement  "			typeRef = this.PEFileToObjectModel.GetTypeSpecReferenceAtRow (this.MetadataOwnerObject' typeRID).UnderlyingModuleTypeReference; " is 127.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleGenericTypeInstanceReference,The length of the statement  "		templateTypeReference = this.PEFileToObjectModel.GetTypeRefReferenceAtRow (templateTypeRowId' headByte == ElementType.ValueType); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,Specialize,The length of the statement  "		var containingType = this.Specialize (0' (INamedTypeReference)nestedTypeReference.ContainingType' ref genericArgumentCount' outer: false); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,Specialize,The length of the statement  "			namedTypeReference = new SpecializedNestedTypeReference (nestedTypeReference' containingType' this.PEFileToObjectModel.InternFactory); " is 134.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,Specialize,The length of the statement  "	//We cannot compute the intern key of a generic method type parameter before we are able to compute the intern key of the generic method. " is 137.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,Specialize,The length of the statement  "		return new GenericTypeInstanceReferenceWithToken (typeSpecToken' namedTypeReference' IteratorHelper.GetReadonly (genericArgumentArray)' this.PEFileToObjectModel.InternFactory); " is 176.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,Specialize,The length of the statement  "		return new GenericTypeInstanceReference (namedTypeReference' IteratorHelper.GetReadonly (genericArgumentArray)' this.PEFileToObjectModel.InternFactory); " is 152.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleMatrixType,The length of the statement  "	return new MatrixWithToken (typeSpecToken' elementType' rank' IteratorHelper.GetReadonly (lowerBounds)' IteratorHelper.GetReadonly (sizes)' this.PEFileToObjectModel.InternFactory); " is 180.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "		IParameterTypeInformation[] moduleParameterArr = this.GetModuleParameterTypeInformations (Dummy.Signature' paramCount - methodParamCount); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "		return new FunctionPointerTypeWithToken (typeSpecToken' (CallingConvention)firstByte' isReturnByReference' returnTypeReference' returnCustomModifiers' moduleParameters' moduleVarargsParameters' this.PEFileToObjectModel.InternFactory); " is 234.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "		return new FunctionPointerType ((CallingConvention)firstByte' isReturnByReference' returnTypeReference' returnCustomModifiers' moduleParameters' moduleVarargsParameters' this.PEFileToObjectModel.InternFactory); " is 210.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeReference,The length of the statement  "		return PointerType.GetPointerType (this.GetTypeReference () ?? Dummy.TypeReference' this.PEFileToObjectModel.InternFactory); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeReference,The length of the statement  "		return this.PEFileToObjectModel.GetTypeReferenceForToken (this.MetadataOwnerObject' typeToken' headByte == ElementType.ValueType); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleParameters,The length of the statement  "			moduleParameter = new ParameterWithMetadata (this.PEFileToObjectModel' paramIndex' customModifiers' typeReference' moduleMethod' isByReference' (paramIndex == paramCount - 1) && paramArrayType != null && paramArrayType.IsVector' paramInfo.Value.ParamRowId' paramInfo.Value.ParamName' paramInfo.Value.ParamFlags); " is 312.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleParameters,The length of the statement  "			moduleParameter = new ParameterWithoutMetadata (this.PEFileToObjectModel' paramIndex' customModifiers' typeReference' signatureDefinition' isByReference); " is 154.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetModuleParameterTypeInformations,The length of the statement  "		var parameterType = new ParameterInfo (this.PEFileToObjectModel' index' customModifiers' typeReference' signature' isByReference); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "	if (referringModule == null || referringModule.ContainingAssembly == null || !(referringModule.ContainingAssembly.ContainsForeignTypes)) " is 136.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "	if (string.Equals (this.CoreAssemblySymbolicIdentity.Name.Value' "System.Runtime"' StringComparison.OrdinalIgnoreCase)) { " is 121.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "	if (referringModule == null || referringModule.ContainingAssembly == null || !(referringModule.ContainingAssembly.ContainsForeignTypes)) " is 136.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "		if (namespaceTypeReference.Name == platformType.SystemEventHandler1.Name && namespaceTypeReference.GenericParameterCount == 1) " is 126.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "	if (referringModule == null || referringModule.ContainingAssembly == null || !(referringModule.ContainingAssembly.ContainsForeignTypes)) " is 136.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "	//The custom attribute constructor has been redirected from Windows.Foundation.AttributeUsageAttribute' which has a different " is 125.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "	//set of flags from System.AttributeUsageAttribute for its first and only constructor parameter and also does not have an AllowMultiple property.  " is 145.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "		namedArgArray [0] = new FieldOrPropertyNamedArgumentExpression (this.AllowMultiple' Dummy.Type' false' this.PlatformType.SystemBoolean' trueVal); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,FellowCustomAttributeIncludeAllowMultiple,The length of the statement  "		if (caType != null && caType.Name == this.AllowMultipleAttribute && this.IsWindowsFoundation (caType.ContainingUnitNamespace as INestedUnitNamespaceReference)) " is 159.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The length of the statement  "	if (assemblyIdentity.Name.UniqueKeyIgnoringCase == this.CoreAssemblySymbolicIdentity.Name.UniqueKeyIgnoringCase && assemblyIdentity.Culture == this.CoreAssemblySymbolicIdentity.Culture && IteratorHelper.EnumerablesAreEqual (assemblyIdentity.PublicKeyToken' this.CoreAssemblySymbolicIdentity.PublicKeyToken)) " is 307.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The length of the statement  "	if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255)) " is 160.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimePlatform,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,GetSystemRuntimeInteropServicesWindowsRuntimeSymbolicIdentity,The length of the statement  "		location = Path.Combine (Path.GetDirectoryName (core.Location) ?? ""' "System.Runtime.InteropServices.WindowsRuntime.dll"); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.Errors,DirectoryLocation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "DirectoryLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.directory.ToString ()' this.offset); " is 152.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataStreamLocation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "MetadataStreamLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.streamName' this.offset); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataLocation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "MetadataLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.tableIndex.ToString ()' this.rowId); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,AddBinaryError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new BinaryLocation (this.BinaryDocument' offset)' errorKind)); " is 166.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,AddDirectoryError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new DirectoryLocation (this.BinaryDocument' directory' offset)' errorKind)); " is 180.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,AddMetadataStreamError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new MetadataStreamLocation (this.BinaryDocument' streamName' offset)' errorKind)); " is 186.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,AddMetadataError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new MetadataLocation (this.BinaryDocument' tableIndex' rowId)' errorKind)); " is 179.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Errors.cs,AddILError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new ILLocation (this.BinaryDocument' methodDefinition' offset)' errorKind)); " is 180.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,LocalVariableSignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,GetLocalVariable,The length of the statement  "	return new LocalVariableDefinition (this.OwningMethodBody' customModifiers' isPinned' isByReferenece' index' typeReference); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,LoadLocalSignature,The length of the statement  "		MemoryBlock signatureMemoryBlock = this.PEFileToObjectModel.PEFileReader.BlobStream.GetMemoryBlockAt (sigRow.Signature); " is 120.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,LoadLocalSignature,The length of the statement  "		LocalVariableSignatureConverter locVarSigConv = new LocalVariableSignatureConverter (this.PEFileToObjectModel' this.MethodBody' memoryReader); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	StandAloneSigRow sigRow = this.PEFileToObjectModel.PEFileReader.StandAloneSigTable [standAloneMethodToken & TokenTypeIds.RIDMask]; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	MemoryBlock signatureMemoryBlock = this.PEFileToObjectModel.PEFileReader.BlobStream.GetMemoryBlockAt (signatureBlobOffset); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	StandAloneMethodSignatureConverter standAloneSigConv = new StandAloneMethodSignatureConverter (this.PEFileToObjectModel' this.MethodDefinition' memoryReader); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	return new FunctionPointerType ((CallingConvention)standAloneSigConv.FirstByte' standAloneSigConv.IsReturnByReference' standAloneSigConv.ReturnTypeReference' standAloneSigConv.ReturnCustomModifiers' standAloneSigConv.RequiredParameters' standAloneSigConv.VarArgParameters' this.PEFileToObjectModel.InternFactory); " is 313.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The length of the statement  "			this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "				ITypeReference /*?*/typeRef = this.PEFileToObjectModel.GetTypeReferenceForToken (this.MethodDefinition' sehTableEntry.ClassTokenOrFilterOffset); " is 144.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "			exceptions [i] = new CilExceptionInformation (handlerKind' exceptionType' tryStart' tryEnd' filterDecisionStart' handlerStart' handlerEnd); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetExtends,The length of the statement  "	uint extends = this.TypeDefTableMemoryReader.PeekReference (rowOffset + this.ExtendsOffset' this.IsTypeDefOrRefRefSizeSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetFieldStart,The length of the statement  "	uint fieldListStart = this.TypeDefTableMemoryReader.PeekReference (rowOffset + this.FieldListOffset' this.IsFieldRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodStart,The length of the statement  "	uint methodListStart = this.TypeDefTableMemoryReader.PeekReference (rowOffset + this.MethodListOffset' this.IsMethodRefSizeSmall); " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindTypeContainingMethod,The length of the statement  "	int slot = this.TypeDefTableMemoryReader.BinarySearchForSlot (numOfRows' this.RowSize' this.MethodListOffset' methodDefOrPtrRowId' this.IsMethodRefSizeSmall); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindTypeContainingField,The length of the statement  "	int slot = this.TypeDefTableMemoryReader.BinarySearchForSlot (numOfRows' this.RowSize' this.FieldListOffset' fieldDefOrPtrRowId' this.IsFieldRefSizeSmall); " is 155.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetFieldFor,The length of the statement  "	uint field = this.FieldPtrTableMemoryReader.PeekReference (rowOffset + this.FieldOffset' this.IsFieldTableRowRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetRowIdForFieldDefRow,The length of the statement  "	return (uint)(this.FieldPtrTableMemoryReader.LinearSearchReference (this.RowSize' this.FieldOffset' fieldDefRowId' this.IsFieldTableRowRefSizeSmall) + 1); " is 154.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.FieldTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodFor,The length of the statement  "	uint method = this.MethodPtrTableMemoryReader.PeekReference (rowOffset + this.MethodOffset' this.IsMethodTableRowRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetRowIdForMethodDefRow,The length of the statement  "	return (uint)(this.MethodPtrTableMemoryReader.LinearSearchReference (this.RowSize' this.MethodOffset' methodDefRowId' this.IsMethodTableRowRefSizeSmall) + 1); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetParamStart,The length of the statement  "	uint paramListStart = this.MethodTableMemoryReader.PeekReference (rowOffset + this.ParamListOffset' this.IsParamRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.MethodTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ParamPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetParamFor,The length of the statement  "	uint param = this.ParamPtrTableMemoryReader.PeekReference (rowOffset + this.ParamOffset' this.IsParamTableRowRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "	int foundRowNumber = this.InterfaceImplTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ClassOffset' typeDefRowId' this.IsTypeDefOrRefRefSizeSmall); " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "	while (startRowNumber > 0 && this.InterfaceImplTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ClassOffset' this.IsTypeDefOrRefRefSizeSmall) == typeDefRowId) { " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.InterfaceImplTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ClassOffset' this.IsTypeDefOrRefRefSizeSmall) == typeDefRowId) { " is 203.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetInterface,The length of the statement  "	uint @interface = this.InterfaceImplTableMemoryReader.PeekReference (rowOffset + this.InterfaceOffset' this.IsTypeDefOrRefRefSizeSmall); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.MemberRefTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetConstantRowId,The length of the statement  "	int foundRowNumber = this.ConstantTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' HasConstantTag.ConvertToTag (parentToken)' this.IsHasConstantRefSizeSmall); " is 202.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.CustomAttributeTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' searchCodedTag' this.IsHasCustomAttributeRefSizeSmall); " is 189.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.CustomAttributeTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ParentOffset' this.IsHasCustomAttributeRefSizeSmall) == searchCodedTag) { " is 198.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.CustomAttributeTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ParentOffset' this.IsHasCustomAttributeRefSizeSmall) == searchCodedTag) { " is 214.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetFieldMarshalRowId,The length of the statement  "	int foundRowNumber = this.FieldMarshalTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' HasFieldMarshalTag.ConvertToTag (token)' this.IsHasFieldMarshalRefSizeSmall); " is 208.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.DeclSecurityTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' searchCodedTag' this.IsHasDeclSecurityRefSizeSmall); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.DeclSecurityTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ParentOffset' this.IsHasDeclSecurityRefSizeSmall) == searchCodedTag) { " is 192.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.DeclSecurityTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ParentOffset' this.IsHasDeclSecurityRefSizeSmall) == searchCodedTag) { " is 208.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetPackingSize,The length of the statement  "	int foundRowNumber = this.ClassLayoutTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' typeRowId' this.IsTypeDefTableRowRefSizeSmall); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetClassSize,The length of the statement  "	int foundRowNumber = this.ClassLayoutTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' typeRowId' this.IsTypeDefTableRowRefSizeSmall); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldLayoutTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetOffset,The length of the statement  "	int foundRowNumber = this.FieldLayoutTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.FieldOffset' rowId' this.IsFieldTableRowRefSizeSmall); " is 170.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindEventMapRowIdFor,The length of the statement  "	int rowNumber = this.EventMapTableMemoryReader.LinearSearchReference (this.RowSize' this.ParentOffset' typeDefRowId' this.IsTypeDefTableRowRefSizeSmall); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetEventListStartFor,The length of the statement  "	uint eventList = this.EventMapTableMemoryReader.PeekReference (rowOffset + this.EventListOffset' this.IsEventRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetEventFor,The length of the statement  "	uint @event = this.EventPtrTableMemoryReader.PeekReference (rowOffset + this.EventOffset' this.IsEventTableRowRefSizeSmall); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetEventType,The length of the statement  "	uint eventType = this.EventTableMemoryReader.PeekReference (rowOffset + this.EventTypeOffset' this.IsTypeDefOrRefRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindPropertyMapRowIdFor,The length of the statement  "	int rowNumber = this.PropertyMapTableMemoryReader.LinearSearchReference (this.RowSize' this.ParentOffset' typeDefRowId' this.IsTypeDefTableRowRefSizeSmall); " is 156.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetPropertyListStartFor,The length of the statement  "	uint propertyList = this.PropertyMapTableMemoryReader.PeekReference (rowOffset + this.PropertyListOffset' this.IsPropertyRefSizeSmall); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetPropertyFor,The length of the statement  "	uint property = this.PropertyPtrTableMemoryReader.PeekReference (rowOffset + this.PropertyOffset' this.IsPropertyTableRowRefSizeSmall); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.PropertyTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.MethodSemanticsTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.AssociationOffset' searchCodedTag' this.IsHasSemanticRefSizeSmall); " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.MethodSemanticsTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.AssociationOffset' this.IsHasSemanticRefSizeSmall) == searchCodedTag) { " is 196.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.MethodSemanticsTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.AssociationOffset' this.IsHasSemanticRefSizeSmall) == searchCodedTag) { " is 212.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "	int foundRowNumber = this.MethodImplTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ClassOffset' typeDefRowId' this.IsTypeDefTableRowRefSizeSmall); " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "	while (startRowNumber > 0 && this.MethodImplTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ClassOffset' this.IsTypeDefTableRowRefSizeSmall) == typeDefRowId) { " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.MethodImplTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ClassOffset' this.IsTypeDefTableRowRefSizeSmall) == typeDefRowId) { " is 203.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeSpecTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.TypeSpecTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.ImplMapTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.MemberForwardedOffset' searchCodedTag' this.IsMemberForwardRowRefSizeSmall); " is 188.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldRVATableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetFieldRVA,The length of the statement  "	int foundRowNumber = this.FieldRVATableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.FieldOffset' fieldDefRowId' this.IsFieldTableRowRefSizeSmall); " is 175.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetHashValue,The length of the statement  "	uint hashValue = this.FileTableMemoryReader.PeekReference (rowOffset + this.HashValueOffset' this.IsBlobHeapRefSizeSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetNamespace,The length of the statement  "	uint typeNamespace = this.ExportedTypeTableMemoryReader.PeekReference (rowOffset + this.TypeNamespaceOffset' this.IsStringHeapRefSizeSmall); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetImplementation,The length of the statement  "	uint implementation = this.ManifestResourceTableMemoryReader.PeekReference (rowOffset + this.ImplementationOffset' this.IsImplementationRefSizeSmall); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindParentTypeDefRowId,The length of the statement  "	int rowNumber = this.NestedClassTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.NestedClassOffset' nestedTypeRowId' this.IsTypeDefTableRowRefSizeSmall); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindParentTypeDefRowId,The length of the statement  "	return this.NestedClassTableMemoryReader.PeekReference (rowNumber * this.RowSize + this.EnclosingClassOffset' this.IsTypeDefTableRowRefSizeSmall); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.GenericParamTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.OwnerOffset' searchCodedTag' this.IsTypeOrMethodDefRefSizeSmall); " is 182.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.GenericParamTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.OwnerOffset' this.IsTypeOrMethodDefRefSizeSmall) == searchCodedTag) { " is 191.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.GenericParamTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.OwnerOffset' this.IsTypeOrMethodDefRefSizeSmall) == searchCodedTag) { " is 207.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "	int foundRowNumber = this.GenericParamConstraintTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.OwnerOffset' genericParamRowId' this.IsGenericParamTableRowRefSizeSmall); " is 200.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "	while (startRowNumber > 0 && this.GenericParamConstraintTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.OwnerOffset' this.IsGenericParamTableRowRefSizeSmall) == genericParamRowId) { " is 209.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.GenericParamConstraintTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.OwnerOffset' this.IsGenericParamTableRowRefSizeSmall) == genericParamRowId) { " is 225.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetConstraint,The length of the statement  "	uint constraint = this.GenericParamConstraintTableMemoryReader.PeekReference (rowOffset + this.ConstraintOffset' this.IsTypeDefOrRefRefSizeSmall); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The length of the statement  "	var debugDirectoryReader = new MemoryReader (this.DirectoryToMemoryBlock (this.OptionalHeaderDirectoryEntries.DebugTableDirectory)); " is 132.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The length of the statement  "	var dataBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + debugDir.PointerToRawData' debugDir.SizeOfData); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadOptionalHeaderNTAdditionalFields32,The length of the statement  "		this.ErrorContainer.AddBinaryError (memReader.Offset' MetadataReaderErrorKind.OptionalHeaderNTAdditionalFields32TooSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadOptionalHeaderNTAdditionalFields64,The length of the statement  "		this.ErrorContainer.AddBinaryError (memReader.Offset' MetadataReaderErrorKind.OptionalHeaderNTAdditionalFields64TooSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "	MemoryReader memReader = new MemoryReader (this.BinaryDocumentMemoryBlock.Pointer' this.BinaryDocumentMemoryBlock.Length); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "		if (!this.ReadOptionalHeaderStandardFields32 (ref memReader) || !this.ReadOptionalHeaderNTAdditionalFields32 (ref memReader)) { " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "		if (!this.ReadOptionalHeaderStandardFields64 (ref memReader) || !this.ReadOptionalHeaderNTAdditionalFields64 (ref memReader)) { " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "	this.Win32ResourceMemoryReader = new MemoryReader (this.DirectoryToMemoryBlock (this.OptionalHeaderDirectoryEntries.ResourceTableDirectory)); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,DirectoryToMemoryBlock,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= directory.RelativeVirtualAddress && directory.RelativeVirtualAddress < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,DirectoryToMemoryBlock,The length of the statement  "			MemoryBlock retMemBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' directory.Size); " is 152.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToMemoryBlockWithSize,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToMemoryBlockWithSize,The length of the statement  "			MemoryBlock retMemBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' (int)size); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToMemoryBlock,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToMemoryBlock,The length of the statement  "			MemoryBlock retMemBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' sectionHeaderIter.VirtualSize - relativeOffset); " is 184.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAsInSameSection,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA1 && RVA1 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize && sectionHeaderIter.VirtualAddress <= RVA2 && RVA2 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 241.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToSubSection,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA + size <= sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToSubSection,The length of the statement  "			MemoryBlock memBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' size); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAToSubSectionName,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSizeOfRemainderOfSectionContaining,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadCOR20Header,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.COR20Header' 0' MetadataReaderErrorKind.NotEnoughSpaceForCOR20HeaderTableDirectory); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.MetadataHeaderTooSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset - sizeof(uint)' MetadataReaderErrorKind.MetadataSignature); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForVersionString); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadStorageHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StorageHeaderTooSmall); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "			this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StreamHeaderTooSmall); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "		//  Review: Oh well there is no way i can test if we will read correctly. However we can check it after reading and aligning... " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "			this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStreamHeaderName); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStringStream); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForBlobStream); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForGUIDStream); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForBlobStream); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForMetadataStream); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForMetadataStream); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "			this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.UnknownMetadataStream); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.NotEnoughSpaceForMetadataDirectory); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The length of the statement  "	if (!this.ReadMetadataHeader (ref memReader) || !this.ReadStorageHeader (ref memReader) || !this.ReadStreamHeaders (ref memReader) || !this.ProcessAndCacheStreams (ref metadataRoot)) { " is 184.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 0' MetadataReaderErrorKind.MetadataTableHeaderTooSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "	if (this.MetadataStreamKind == MetadataStreamKind.Compressed && (presentTables & (ulong)TableMask.CompressedStreamNotAllowedMask) != 0) { " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		//Carry on regardless. There are/were compiler out there that sort the required tables' but fail to set the bit in SortedTables. " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' memReader.Offset' MetadataReaderErrorKind.TableRowCountSpaceTooSmall); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int propertyRefSize = rowRefSizeArray [(int)TableIndices.PropertyPtr] > 2 ? 4 : rowRefSizeArray [(int)TableIndices.Property]; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int typeDefOrRefRefSize = PEFileReader.ComputeCodedTokenSize (TypeDefOrRefTag.LargeRowSize' rowCountArray' TypeDefOrRefTag.TablesReferenced); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasConstantRefSize = PEFileReader.ComputeCodedTokenSize (HasConstantTag.LargeRowSize' rowCountArray' HasConstantTag.TablesReferenced); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasCustomAttributeRefSize = PEFileReader.ComputeCodedTokenSize (HasCustomAttributeTag.LargeRowSize' rowCountArray' HasCustomAttributeTag.TablesReferenced); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasFieldMarshalRefSize = PEFileReader.ComputeCodedTokenSize (HasFieldMarshalTag.LargeRowSize' rowCountArray' HasFieldMarshalTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasDeclSecurityRefSize = PEFileReader.ComputeCodedTokenSize (HasDeclSecurityTag.LargeRowSize' rowCountArray' HasDeclSecurityTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int memberRefParentRefSize = PEFileReader.ComputeCodedTokenSize (MemberRefParentTag.LargeRowSize' rowCountArray' MemberRefParentTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasSemanticsRefSize = PEFileReader.ComputeCodedTokenSize (HasSemanticsTag.LargeRowSize' rowCountArray' HasSemanticsTag.TablesReferenced); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int methodDefOrRefRefSize = PEFileReader.ComputeCodedTokenSize (MethodDefOrRefTag.LargeRowSize' rowCountArray' MethodDefOrRefTag.TablesReferenced); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int memberForwardedRefSize = PEFileReader.ComputeCodedTokenSize (MemberForwardedTag.LargeRowSize' rowCountArray' MemberForwardedTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int implementationRefSize = PEFileReader.ComputeCodedTokenSize (ImplementationTag.LargeRowSize' rowCountArray' ImplementationTag.TablesReferenced); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int customAttributeTypeRefSize = PEFileReader.ComputeCodedTokenSize (CustomAttributeTypeTag.LargeRowSize' rowCountArray' CustomAttributeTypeTag.TablesReferenced); " is 162.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int resolutionScopeRefSize = PEFileReader.ComputeCodedTokenSize (ResolutionScopeTag.LargeRowSize' rowCountArray' ResolutionScopeTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int typeOrMethodDefRefSize = PEFileReader.ComputeCodedTokenSize (TypeOrMethodDefTag.LargeRowSize' rowCountArray' TypeOrMethodDefTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int stringHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.StringHeapLarge) == HeapSizeFlag.StringHeapLarge ? 4 : 2; " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int guidHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.GUIDHeapLarge) == HeapSizeFlag.GUIDHeapLarge ? 4 : 2; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int blobHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.BlobHeapLarge) == HeapSizeFlag.BlobHeapLarge ? 4 : 2; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ModuleTable = new ModuleTableReader (rowCountArray [(int)TableIndices.Module]' stringHeapRefSize' guidHeapRefSize' currentPointer); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.TypeRefTable = new TypeRefTableReader (rowCountArray [(int)TableIndices.TypeRef]' resolutionScopeRefSize' stringHeapRefSize' currentPointer); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.TypeDefTable = new TypeDefTableReader (rowCountArray [(int)TableIndices.TypeDef]' fieldRefSize' methodRefSize' typeDefOrRefRefSize' stringHeapRefSize' currentPointer); " is 172.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldPtrTable = new FieldPtrTableReader (rowCountArray [(int)TableIndices.FieldPtr]' rowRefSizeArray [(int)TableIndices.Field]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldTable = new FieldTableReader (rowCountArray [(int)TableIndices.Field]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 133.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodPtrTable = new MethodPtrTableReader (rowCountArray [(int)TableIndices.MethodPtr]' rowRefSizeArray [(int)TableIndices.Method]' currentPointer); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodTable = new MethodTableReader (rowCountArray [(int)TableIndices.Method]' paramRefSize' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ParamPtrTable = new ParamPtrTableReader (rowCountArray [(int)TableIndices.ParamPtr]' rowRefSizeArray [(int)TableIndices.Param]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.InterfaceImplTable = new InterfaceImplTableReader (rowCountArray [(int)TableIndices.InterfaceImpl]' rowRefSizeArray [(int)TableIndices.TypeDef]' typeDefOrRefRefSize' currentPointer); " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MemberRefTable = new MemberRefTableReader (rowCountArray [(int)TableIndices.MemberRef]' memberRefParentRefSize' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 169.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ConstantTable = new ConstantTableReader (rowCountArray [(int)TableIndices.Constant]' hasConstantRefSize' blobHeapRefSize' currentPointer); " is 143.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.CustomAttributeTable = new CustomAttributeTableReader (rowCountArray [(int)TableIndices.CustomAttribute]' hasCustomAttributeRefSize' customAttributeTypeRefSize' blobHeapRefSize' currentPointer); " is 199.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldMarshalTable = new FieldMarshalTableReader (rowCountArray [(int)TableIndices.FieldMarshal]' hasFieldMarshalRefSize' blobHeapRefSize' currentPointer); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.DeclSecurityTable = new DeclSecurityTableReader (rowCountArray [(int)TableIndices.DeclSecurity]' hasDeclSecurityRefSize' blobHeapRefSize' currentPointer); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ClassLayoutTable = new ClassLayoutTableReader (rowCountArray [(int)TableIndices.ClassLayout]' rowRefSizeArray [(int)TableIndices.TypeDef]' currentPointer); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldLayoutTable = new FieldLayoutTableReader (rowCountArray [(int)TableIndices.FieldLayout]' rowRefSizeArray [(int)TableIndices.Field]' currentPointer); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.StandAloneSigTable = new StandAloneSigTableReader (rowCountArray [(int)TableIndices.StandAloneSig]' blobHeapRefSize' currentPointer); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.EventMapTable = new EventMapTableReader (rowCountArray [(int)TableIndices.EventMap]' rowRefSizeArray [(int)TableIndices.TypeDef]' eventRefSize' currentPointer); " is 165.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.EventPtrTable = new EventPtrTableReader (rowCountArray [(int)TableIndices.EventPtr]' rowRefSizeArray [(int)TableIndices.Event]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.EventTable = new EventTableReader (rowCountArray [(int)TableIndices.Event]' typeDefOrRefRefSize' stringHeapRefSize' currentPointer); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.PropertyMapTable = new PropertyMapTableReader (rowCountArray [(int)TableIndices.PropertyMap]' rowRefSizeArray [(int)TableIndices.TypeDef]' propertyRefSize' currentPointer); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.PropertyPtrTable = new PropertyPtrTableReader (rowCountArray [(int)TableIndices.PropertyPtr]' rowRefSizeArray [(int)TableIndices.Property]' currentPointer); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.PropertyTable = new PropertyTableReader (rowCountArray [(int)TableIndices.Property]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodSemanticsTable = new MethodSemanticsTableReader (rowCountArray [(int)TableIndices.MethodSemantics]' rowRefSizeArray [(int)TableIndices.Method]' hasSemanticsRefSize' currentPointer); " is 192.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodImplTable = new MethodImplTableReader (rowCountArray [(int)TableIndices.MethodImpl]' rowRefSizeArray [(int)TableIndices.TypeDef]' methodDefOrRefRefSize' currentPointer); " is 180.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ModuleRefTable = new ModuleRefTableReader (rowCountArray [(int)TableIndices.ModuleRef]' stringHeapRefSize' currentPointer); " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.TypeSpecTable = new TypeSpecTableReader (rowCountArray [(int)TableIndices.TypeSpec]' blobHeapRefSize' currentPointer); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ImplMapTable = new ImplMapTableReader (rowCountArray [(int)TableIndices.ImplMap]' rowRefSizeArray [(int)TableIndices.ModuleRef]' memberForwardedRefSize' stringHeapRefSize' currentPointer); " is 193.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldRVATable = new FieldRVATableReader (rowCountArray [(int)TableIndices.FieldRva]' rowRefSizeArray [(int)TableIndices.Field]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyTable = new AssemblyTableReader (rowCountArray [(int)TableIndices.Assembly]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyProcessorTable = new AssemblyProcessorTableReader (rowCountArray [(int)TableIndices.AssemblyProcessor]' currentPointer); " is 133.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyRefTable = new AssemblyRefTableReader (rowCountArray [(int)TableIndices.AssemblyRef]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyRefProcessorTable = new AssemblyRefProcessorTableReader (rowCountArray [(int)TableIndices.AssemblyRefProcessor]' rowRefSizeArray [(int)TableIndices.AssemblyRef]' currentPointer); " is 191.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyRefOSTable = new AssemblyRefOSTableReader (rowCountArray [(int)TableIndices.AssemblyRefOS]' rowRefSizeArray [(int)TableIndices.AssemblyRef]' currentPointer); " is 170.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FileTable = new FileTableReader (rowCountArray [(int)TableIndices.File]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ExportedTypeTable = new ExportedTypeTableReader (rowCountArray [(int)TableIndices.ExportedType]' implementationRefSize' stringHeapRefSize' currentPointer); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ManifestResourceTable = new ManifestResourceTableReader (rowCountArray [(int)TableIndices.ManifestResource]' implementationRefSize' stringHeapRefSize' currentPointer); " is 172.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.NestedClassTable = new NestedClassTableReader (rowCountArray [(int)TableIndices.NestedClass]' rowRefSizeArray [(int)TableIndices.TypeDef]' currentPointer); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.GenericParamTable = new GenericParamTableReader (rowCountArray [(int)TableIndices.GenericParam]' typeOrMethodDefRefSize' stringHeapRefSize' currentPointer); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodSpecTable = new MethodSpecTableReader (rowCountArray [(int)TableIndices.MethodSpec]' methodDefOrRefRefSize' blobHeapRefSize' currentPointer); " is 152.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.GenericParamConstraintTable = new GenericParamConstraintTableReader (rowCountArray [(int)TableIndices.GenericParamConstraint]' rowRefSizeArray [(int)TableIndices.GenericParam]' typeDefOrRefRefSize' currentPointer); " is 219.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.MetadataTablesTooSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataLevelData,The length of the statement  "	if (!this.ReadMetadataTableInformation (ref memReader) || !this.ProcessAndCacheMetadataTableBlocks (memReader.RemainingMemoryBlock)) { " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetFieldInformation,The length of the statement  "		fieldCount = (this.UseFieldPtrTable ? this.FieldPtrTable.NumberOfRows : this.FieldTable.NumberOfRows) - fieldStartRow + 1; " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodInformation,The length of the statement  "		methodCount = (this.UseMethodPtrTable ? this.MethodPtrTable.NumberOfRows : this.MethodTable.NumberOfRows) - methodStartRow + 1; " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetEventInformation,The length of the statement  "		eventCount = (this.UseEventPtrTable ? this.EventPtrTable.NumberOfRows : this.EventTable.NumberOfRows) - eventStartRow + 1; " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetPropertyInformation,The length of the statement  "		propertyCount = (this.UsePropertyPtrTable ? this.PropertyPtrTable.NumberOfRows : this.PropertyTable.NumberOfRows) - propertyStartRow + 1; " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetParamInformation,The length of the statement  "		paramRowCount = (this.UseParamPtrTable ? this.ParamPtrTable.NumberOfRows : this.ParamTable.NumberOfRows) - paramStartRow + 1; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetSmallSEHEntries,The length of the statement  "		retSEHEntries [i] = new SEHTableEntry (sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetFatSEHEntries,The length of the statement  "		retSEHEntries [i] = new SEHTableEntry (sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefOrRefTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return TypeDefOrRefTag.TagToTokenTypeArray [typeDefOrRefTag & TypeDefOrRefTag.TagMask] | typeDefOrRefTag >> TypeDefOrRefTag.NumberOfBits; " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasConstantTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasConstantTag.TagToTokenTypeArray [hasConstant & HasConstantTag.TagMask] | hasConstant >> HasConstantTag.NumberOfBits; " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasCustomAttributeTag.TagToTokenTypeArray [hasCustomAttribute & HasCustomAttributeTag.TagMask] | hasCustomAttribute >> HasCustomAttributeTag.NumberOfBits; " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasFieldMarshalTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasFieldMarshalTag.TagToTokenTypeArray [hasFieldMarshal & HasFieldMarshalTag.TagMask] | hasFieldMarshal >> HasFieldMarshalTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasDeclSecurityTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasDeclSecurityTag.TagToTokenTypeArray [hasDeclSecurity & HasDeclSecurityTag.TagMask] | hasDeclSecurity >> HasDeclSecurityTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberRefParentTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return MemberRefParentTag.TagToTokenTypeArray [memberRef & MemberRefParentTag.TagMask] | memberRef >> MemberRefParentTag.NumberOfBits; " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasSemanticsTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasSemanticsTag.TagToTokenTypeArray [hasSemantic & HasSemanticsTag.TagMask] | hasSemantic >> HasSemanticsTag.NumberOfBits; " is 129.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodDefOrRefTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return MethodDefOrRefTag.TagToTokenTypeArray [methodDefOrRef & MethodDefOrRefTag.TagMask] | methodDefOrRef >> MethodDefOrRefTag.NumberOfBits; " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberForwardedTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return MemberForwardedTag.TagToTokenTypeArray [memberForwarded & MethodDefOrRefTag.TagMask] | memberForwarded >> MethodDefOrRefTag.NumberOfBits; " is 144.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ImplementationTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return ImplementationTag.TagToTokenTypeArray [implementation & ImplementationTag.TagMask] | implementation >> ImplementationTag.NumberOfBits; " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTypeTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return CustomAttributeTypeTag.TagToTokenTypeArray [customAttributeType & CustomAttributeTypeTag.TagMask] | customAttributeType >> CustomAttributeTypeTag.NumberOfBits; " is 166.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ResolutionScopeTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return ResolutionScopeTag.TagToTokenTypeArray [resolutionScope & ResolutionScopeTag.TagMask] | resolutionScope >> ResolutionScopeTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeOrMethodDefTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return TypeOrMethodDefTag.TagToTokenTypeArray [typeOrMethodDef & TypeOrMethodDefTag.TagMask] | typeOrMethodDef >> TypeOrMethodDefTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.PeWriterInternal,MetadataWrapper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\IMetadata.cs,GetTypeDefProps,The length of the statement  "		tName = TypeHelper.GetTypeName (t' NameFormattingOptions.UseGenericTypeNameSuffix | NameFormattingOptions.OmitContainingType); " is 126.
Long Statement,Microsoft.Cci.PeWriterInternal,MethodSpecComparer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,Equals,The length of the statement  "	return x == y || this.peWriter.GetMethodDefOrRefCodedIndex (x.GenericMethod) == this.peWriter.GetMethodDefOrRefCodedIndex (y.GenericMethod) && this.peWriter.GetMethodInstanceSignatureIndex (x) == this.peWriter.GetMethodInstanceSignatureIndex (y); " is 246.
Long Statement,Microsoft.Cci.PeWriterInternal,MethodSpecComparer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetHashCode,The length of the statement  "	return (int)((this.peWriter.GetMethodDefOrRefCodedIndex (methodInstanceReference.GenericMethod) << 2) ^ this.peWriter.GetMethodInstanceSignatureIndex (methodInstanceReference)); " is 177.
Long Statement,Microsoft.Cci.PeWriterInternal,ReferenceIndexer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,TraverseChildren,The length of the statement  "	//do not traverse the reference to aliased type' it does not get into the type ref table based only on its membership of the exported types collection. " is 151.
Long Statement,Microsoft.Cci.PeWriterInternal,ReferenceIndexer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,TraverseChildren,The length of the statement  "	//but DO traverse the reference to assembly (if any) that defines the aliased type. That assembly might not already be in the assembly reference list. " is 150.
Long Statement,Microsoft.Cci.PeWriterInternal,ReferenceIndexer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,TraverseChildren,The length of the statement  "	if (operationExceptionInformation.HandlerKind == HandlerKind.Catch || operationExceptionInformation.HandlerKind == HandlerKind.Filter) { " is 136.
Long Statement,Microsoft.Cci.PeWriterInternal,ReferenceIndexer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,TraverseChildren,The length of the statement  "	//However' the C# compiler (or possibly the CLR metadata writer) creates (but does not emit) tokens for the constructors. " is 121.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The conditional expression  "property.Getter != null || (isInterface && property.Implements.GetGetMethod () != null) || (!isInterface && property.Setter == null)"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddProperty,The conditional expression  "property.Setter != null || (isInterface && property.Implements.GetSetMethod () != null) || (!isInterface && property.Getter == null)"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The conditional expression  "@event.Adder != null || (isInterface && @event.Implements.GetAddMethod () != null) || (!isInterface && @event.Remover == null)"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AddEvent,The conditional expression  "@event.Remover != null || (isInterface && @event.Implements.GetRemoveMethod () != null) || (!isInterface && @event.Adder == null)"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The conditional expression  "methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The conditional expression  "methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendConstructor,The conditional expression  "typeDef.BaseClasses != null && typeDef.BaseClasses.Any (b => TypeHelper.TypesAreEquivalent (b' host.PlatformType.SystemObject)) || (methodBody.Operations != null && methodBody.Operations.Any (o => o.OperationCode == OperationCode.Call && ((IMethodReference)o.Value).ResolvedMethod.IsConstructor && ((IMethodReference)o.Value).ResolvedMethod.ContainingType == typeDef))"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The conditional expression  "delegateType.HasFlag (MethodDelegateType.Function) && (delegateType.HasFlag (MethodDelegateType.After) || delegateType.HasFlag (MethodDelegateType.Catch)) && methodDef.Type.IsValueType"  is complex.
Complex Conditional,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The conditional expression  "parameters.Exists<string> (1) && // Method Name  parameters.Exists<object[]> (2 + contextParam + exceptionParam) && // Method Parameters  (!delegateType.HasFlag (MethodDelegateType.HasResultParameter) || (parameters.Exists<object> (parameters.Length - 1) && method.ReturnType == typeof(object)))"  is complex.
Complex Conditional,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The conditional expression  "result == null || result.Version == dummyVersion || (result.Version < coreId.Version && coreId.Version != dummyVersion) || result.Version == coreId.Version && unit.UnitIdentity.Equals (coreId)"  is complex.
Complex Conditional,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetSignatureInternId,The conditional expression  "signatureStore.CallingConvention == callingConvention && signatureStore.RequiredParameterListInternedId == requiredParameterTypesInternedId && signatureStore.ExtraParameterListInternedId == extraArgumentTypesInteredId && signatureStore.ReturnValueCustomModifiersListInteredId == returnValueCustomModifiersInternedId && signatureStore.ReturnValueIsByRef == returnValueIsByRef && signatureStore.ReturnTypeReferenceInternedId == returnTypeReferenceInternedId"  is complex.
Complex Conditional,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetMethodReferenceInternedId,The conditional expression  "signatureStore.CallingConvention == methodReference.CallingConvention && signatureStore.RequiredParameterListInternedId == requiredParameterTypesInternedId && signatureStore.ReturnValueCustomModifiersListInteredId == returnValueCustomModifiersInternedId && signatureStore.ReturnValueIsByRef == methodReference.ReturnValueIsByRef && signatureStore.ReturnTypeReferenceInternedId == returnTypeReferenceInternedId && signatureStore.GenericParameterCount == genericParameterCount"  is complex.
Complex Conditional,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetMethodSignature,The conditional expression  "(formattingOptions & NameFormattingOptions.FormattingForDocumentationId) != 0 && method.ResolvedMethod.IsSpecialName && (method.Name.Value.Contains ("op_Explicit") || method.Name.Value.Contains ("op_Implicit"))"  is complex.
Complex Conditional,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodParameters,The conditional expression  "!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty (parameter.Constraints)"  is complex.
Complex Conditional,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The conditional expression  "(formattingOptions & NameFormattingOptions.TypeParameters) != 0 && (formattingOptions & NameFormattingOptions.FormattingForDocumentationId) == 0 && genericParameterCount > 0 && !(type.ResolvedType is Dummy)"  is complex.
Complex Conditional,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,AddGenericParametersIfNeeded,The conditional expression  "!parameter.MustBeReferenceType && !parameter.MustBeValueType && !parameter.MustHaveDefaultConstructor && IteratorHelper.EnumerableIsEmpty (parameter.Constraints)"  is complex.
Complex Conditional,Microsoft.Cci,BaseMetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,Visit,The conditional expression  "marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci,MetadataTraverser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Visitors.cs,TraverseChildren,The conditional expression  "marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,CreateIndicesFor,The conditional expression  "methodDef.IsForwardReference && !(methodDef.IsAbstract || methodDef.IsExternal) && (methodDef.Body is Dummy)"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,CreateIndicesFor,The conditional expression  "parDef.HasDefaultValue || parDef.IsOptional || parDef.IsOut || parDef.IsMarshalledExplicitly || IteratorHelper.EnumerableIsNotEmpty (parDef.Attributes) || parDef.Name != this.host.NameTable.EmptyName"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The conditional expression  "il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0"  is complex.
Complex Conditional,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The conditional expression  "typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The conditional expression  "marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MarshallingInformation,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Miscellaneous.cs,Copy,The conditional expression  "marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MetadataRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,RewriteChildren,The conditional expression  "marshallingInformation.UnmanagedType == System.Runtime.InteropServices.UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == System.Runtime.InteropServices.VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MetadataMutator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The conditional expression  "marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Visit,The conditional expression  "marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The conditional expression  "marshallingInformation.UnmanagedType == UnmanagedType.SafeArray && (marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_DISPATCH || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_UNKNOWN || marshallingInformation.SafeArrayElementSubtype == VarEnum.VT_RECORD)"  is complex.
Complex Conditional,Microsoft.Cci.MutableCodeModel,MutatingVisitor,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Mutator.cs,Mutate,The conditional expression  "pars != functionPointerTypeReference.Parameters || typ != functionPointerTypeReference.Type || extraArgumentTypes != functionPointerTypeReference.ExtraArgumentTypes || (customModifiers != functionPointerTypeReference.ReturnValueCustomModifiers && functionPointerTypeReference.ReturnValueIsModified)"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,IsEndofIdentifier,The conditional expression  "c == '[' || c == ']' || c == '*' || c == '+' || c == ''' || c == '&' || c == ' ' || char.IsWhiteSpace (c)"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The conditional expression  "tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey && tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey && tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey && tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,RVAsInSameSection,The conditional expression  "sectionHeaderIter.VirtualAddress <= RVA1 && RVA1 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize && sectionHeaderIter.VirtualAddress <= RVA2 && RVA2 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The conditional expression  "!this.ReadMetadataHeader (ref memReader) || !this.ReadStorageHeader (ref memReader) || !this.ReadStreamHeaders (ref memReader) || !this.ProcessAndCacheStreams (ref metadataRoot)"  is complex.
Empty Catch Block,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,ParseValue,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,GlobalAssemblyCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,Contains,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,GlobalAssemblyCache,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\GlobalAssemblyCache.cs,Contains,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,PeReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ModuleReadWriteFactory.cs,OpenModule,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,ErrorMessage,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetMessage,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,ErrorMessage,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetMessage,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,ErrorMessage,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,GetMessage,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsConstructor) {  	// Get the constructor amendment  	IConstructorAmendment constructorAmendment;  	// Exit immediately if the constructor is not being amended  	if (!Constructors.TryGetValue (methodDef' out constructorAmendment) && PropertyInitializers.Count == 0)  		return methodBody;  	// Amends the constructor  	AmendConstructor (constructorAmendment' methodBody);  }  // Properties  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) {  	// Determine which property is being mutated  	IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault ();  	// Ignore methods that are generated to implement properties defined on base types  	if (propertyDef == null && interfaceName != "")  		return methodBody;  	// Get the property Amendment  	IPropertyAmendment propertyAmendment;  	// Exit immediately if the property is not being amended  	if (!Properties.TryGetValue (propertyDef' out propertyAmendment))  		return methodBody;  	// Amend the property  	AmendProperty (propertyDef' propertyAmendment' methodBody);  }  // Events  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsConstructor) {  	// Get the constructor amendment  	IConstructorAmendment constructorAmendment;  	// Exit immediately if the constructor is not being amended  	if (!Constructors.TryGetValue (methodDef' out constructorAmendment) && PropertyInitializers.Count == 0)  		return methodBody;  	// Amends the constructor  	AmendConstructor (constructorAmendment' methodBody);  }  // Properties  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) {  	// Determine which property is being mutated  	IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault ();  	// Ignore methods that are generated to implement properties defined on base types  	if (propertyDef == null && interfaceName != "")  		return methodBody;  	// Get the property Amendment  	IPropertyAmendment propertyAmendment;  	// Exit immediately if the property is not being amended  	if (!Properties.TryGetValue (propertyDef' out propertyAmendment))  		return methodBody;  	// Amend the property  	AmendProperty (propertyDef' propertyAmendment' methodBody);  }  // Events  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsConstructor) {  	// Get the constructor amendment  	IConstructorAmendment constructorAmendment;  	// Exit immediately if the constructor is not being amended  	if (!Constructors.TryGetValue (methodDef' out constructorAmendment) && PropertyInitializers.Count == 0)  		return methodBody;  	// Amends the constructor  	AmendConstructor (constructorAmendment' methodBody);  }  // Properties  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) {  	// Determine which property is being mutated  	IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault ();  	// Ignore methods that are generated to implement properties defined on base types  	if (propertyDef == null && interfaceName != "")  		return methodBody;  	// Get the property Amendment  	IPropertyAmendment propertyAmendment;  	// Exit immediately if the property is not being amended  	if (!Properties.TryGetValue (propertyDef' out propertyAmendment))  		return methodBody;  	// Amend the property  	AmendProperty (propertyDef' propertyAmendment' methodBody);  }  // Events  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) {  	// Determine which property is being mutated  	IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault ();  	// Ignore methods that are generated to implement properties defined on base types  	if (propertyDef == null && interfaceName != "")  		return methodBody;  	// Get the property Amendment  	IPropertyAmendment propertyAmendment;  	// Exit immediately if the property is not being amended  	if (!Properties.TryGetValue (propertyDef' out propertyAmendment))  		return methodBody;  	// Amend the property  	AmendProperty (propertyDef' propertyAmendment' methodBody);  }  // Events  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) {  	// Determine which property is being mutated  	IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault ();  	// Ignore methods that are generated to implement properties defined on base types  	if (propertyDef == null && interfaceName != "")  		return methodBody;  	// Get the property Amendment  	IPropertyAmendment propertyAmendment;  	// Exit immediately if the property is not being amended  	if (!Properties.TryGetValue (propertyDef' out propertyAmendment))  		return methodBody;  	// Amend the property  	AmendProperty (propertyDef' propertyAmendment' methodBody);  }  // Events  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("get_") || methodName.StartsWith ("set_"))) {  	// Determine which property is being mutated  	IPropertyDefinition propertyDef = typeDef.Properties == null ? null : typeDef.Properties.Where (p => p.Name.Value == interfaceName + methodName.Substring (4)).FirstOrDefault ();  	// Ignore methods that are generated to implement properties defined on base types  	if (propertyDef == null && interfaceName != "")  		return methodBody;  	// Get the property Amendment  	IPropertyAmendment propertyAmendment;  	// Exit immediately if the property is not being amended  	if (!Properties.TryGetValue (propertyDef' out propertyAmendment))  		return methodBody;  	// Amend the property  	AmendProperty (propertyDef' propertyAmendment' methodBody);  }  // Events  else if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,Mutate,The following statement contains a magic number: if (methodDef.IsHiddenBySignature && methodDef.IsSpecialName && (methodName.StartsWith ("add_") || methodName.StartsWith ("remove_"))) {  	// Determine which event is being mutated  	IEventDefinition eventDef = typeDef.Events == null ? null : typeDef.Events.Where (e => e.Name.Value == interfaceName + methodName.Substring (methodName.StartsWith ("a") ? 4 : 7)).FirstOrDefault ();  	// Ignore methods that are generated to implement events defined on base types  	if (eventDef == null && interfaceName != "")  		return methodBody;  	// Get the event amendment  	IEventAmendment eventAmendment;  	// Exit immediately if the event is not being amended  	if (!Events.TryGetValue (eventDef' out eventAmendment))  		return methodBody;  	// Amend the event  	AmendEvent (eventDef' eventAmendment' methodBody);  }  // Methods  else {  	// Get the method Amendment  	IMethodAmendment methodAmendment;  	// Exit immediately if the method is not being amended  	if (!Methods.TryGetValue (methodDef' out methodAmendment))  		return base.Mutate (methodBody);  	// Amends the method  	AmendMethod (methodAmendment' methodBody);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendConstructor,The following statement contains a magic number: il.UpdateMethodBody (6);  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (methodBody.MethodDefinition.Name.Value.StartsWith ("get_") || methodBody.MethodDefinition.Name.Value.Contains (".get_")) {  	// Getter for new or existing property  	if (propertyAmendment.Getter != null) {  		// Clear the original method body  		il.Operations.Clear ();  		// Get the delegate to call   		var getter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Getter);  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Call Getter delegate  		il.Emit (OperationCode.Call' getter.Instance);  		// Return  		il.Emit (OperationCode.Ret);  	}  	// New property without defined getter  	else if (propertyAmendment.PropertyInfo == null) {  		// Get the previously created backing field for this property  		var backingField = GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ();  		// Default getter  		if (propertyAmendment.LazyInitializer == null) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Return  			il.Emit (OperationCode.Ret);  		}  		// Lazy initialized getter  		else {  			// Get the delegate to call before the property getter  			var lazyInitializer = ResolvePropertyDelegate (propertyDef' propertyAmendment.LazyInitializer);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Skip initialization if the backing field is already initialized  			var skipIfNotNull = new ILGeneratorLabel ();  			il.Emit (OperationCode.Brtrue_S' skipIfNotNull);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load this pointer onto stack again  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Call LazyInitializer delegate  			il.Emit (OperationCode.Call' lazyInitializer.Instance);  			// Update the backing field  			il.Emit (OperationCode.Stfld' backingField);  			// End the skipping branch  			il.MarkLabel (skipIfNotNull);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Return  			il.Emit (OperationCode.Ret);  		}  	}  	// Amend the existing property  	else {  		// Before Get  		if (propertyAmendment.BeforeGet != null) {  			// Get the delegate to call before the property getter  			var beforeGet = ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeGet);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Call BeforeGet delegate  			il.Emit (OperationCode.Call' beforeGet.Instance);  		}  		// Lazy Initializer and/or After Get  		if (propertyAmendment.LazyInitializer != null || propertyAmendment.AfterGet != null) {  			// After Get  			if (propertyAmendment.AfterGet != null) {  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Load property name onto stack  				il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			}  			// Emit the original property getter instructions  			il.EmitUntilReturn ();  			// Lazy Initializer  			if (propertyAmendment.LazyInitializer != null) {  				// Add local variable to store the current value of the property  				var currentValue = new LocalDefinition () {  					Name = host.NameTable.GetNameFor ("_cv_")'  					Type = propertyDef.Type  				};  				if (methodBody.LocalVariables == null)  					methodBody.LocalVariables = new List<ILocalDefinition> ();  				methodBody.LocalVariables.Add (currentValue);  				// Store the current value in a local variable  				il.Emit (OperationCode.Stloc' currentValue);  				// Load the current value  				il.Emit (OperationCode.Ldloc' currentValue);  				// Skip initialization if the backing field is already initialized  				var skipIfNotNull = new ILGeneratorLabel ();  				il.Emit (OperationCode.Brtrue_S' skipIfNotNull);  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Load this pointer onto stack again  				il.Emit (OperationCode.Ldarg_0);  				// Load property name onto stack  				il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  				// Call LazyInitializer delegate  				il.Emit (OperationCode.Call' ResolvePropertyDelegate (propertyDef' propertyAmendment.LazyInitializer).Instance);  				// Store the initialized value  				il.Emit (OperationCode.Stloc' currentValue);  				// Load the initialized value  				il.Emit (OperationCode.Ldloc' currentValue);  				// Call the property setter  				il.Emit (propertyDef.Setter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Setter);  				// End the skipping branch  				il.MarkLabel (skipIfNotNull);  				// Load the current value  				il.Emit (OperationCode.Ldloc' currentValue);  			}  			// Call AfterGet delegate  			if (propertyAmendment.AfterGet != null)  				il.Emit (OperationCode.Call' ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterGet).Instance);  		}  		// Emit the rest of the original method if not amending after get  		else  			il.EmitUntilReturn ();  	}  }  // Property Set  else {  	// Setter for new or existing property  	if (propertyAmendment.Setter != null) {  		// Clear the original method body  		il.Operations.Clear ();  		// Get the delegate to call   		var setter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Setter);  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Call Setter delegate  		il.Emit (OperationCode.Call' setter.Instance);  		// Return  		il.Emit (OperationCode.Ret);  	}  	// New property without setter  	else if (propertyAmendment.PropertyInfo == null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Save to backing field  		il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  		// Return  		il.Emit (OperationCode.Ret);  	}  	// Amend the existing property setter  	else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  		// Get the before and after set delegate implementations  		var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  		var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  		// Determine if the old value is used by the amended delegates  		bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  		// Emit a local variable and store the initial property value by calling the property getter  		if (useOriginalValue) {  			// Add local variable to store the old value of the property  			if (methodBody.LocalVariables == null)  				methodBody.LocalVariables = new List<ILocalDefinition> ();  			methodBody.LocalVariables.Add (new LocalDefinition () {  				Name = host.NameTable.GetNameFor ("_ov_")'  				Type = propertyDef.Type  			});  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call the property getter to get the old value  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  			// Store the old value in a local variable  			il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  		}  		// Before Set  		if (beforeSet != null) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Optionally load the old value onto stack  			if (useOriginalValue)  				il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  			else  				il.Emit (OperationCode.Ldarg_1);  			// Load value argument pointer  			il.Emit (OperationCode.Ldarg_1);  			// Call BeforeSet delegate  			il.Emit (OperationCode.Call' beforeSet.Instance);  			// Store the result as the new value for the setter  			il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  		}  		// Emit the old property setter instructions  		il.EmitUntilReturn ();  		// After Set  		if (afterSet != null) {  			il.GoToEndOfOperations ();  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Optionally load the old value onto stack  			if (useOriginalValue)  				il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  			else  				il.Emit (OperationCode.Ldarg_1);  			// Load value argument onto stack  			il.Emit (OperationCode.Ldarg_1);  			// Optionally get the new property value if used  			if (afterSet.ReferencesArgument (4)) {  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Call property getter  				il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  			}  			else  				il.Emit (OperationCode.Ldarg_1);  			// Call AfterSet delegate  			il.Emit (OperationCode.Call' afterSet.Instance);  			il.Emit (OperationCode.Ret);  		}  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (methodBody.MethodDefinition.Name.Value.StartsWith ("get_") || methodBody.MethodDefinition.Name.Value.Contains (".get_")) {  	// Getter for new or existing property  	if (propertyAmendment.Getter != null) {  		// Clear the original method body  		il.Operations.Clear ();  		// Get the delegate to call   		var getter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Getter);  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Call Getter delegate  		il.Emit (OperationCode.Call' getter.Instance);  		// Return  		il.Emit (OperationCode.Ret);  	}  	// New property without defined getter  	else if (propertyAmendment.PropertyInfo == null) {  		// Get the previously created backing field for this property  		var backingField = GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ();  		// Default getter  		if (propertyAmendment.LazyInitializer == null) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Return  			il.Emit (OperationCode.Ret);  		}  		// Lazy initialized getter  		else {  			// Get the delegate to call before the property getter  			var lazyInitializer = ResolvePropertyDelegate (propertyDef' propertyAmendment.LazyInitializer);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Skip initialization if the backing field is already initialized  			var skipIfNotNull = new ILGeneratorLabel ();  			il.Emit (OperationCode.Brtrue_S' skipIfNotNull);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load this pointer onto stack again  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Call LazyInitializer delegate  			il.Emit (OperationCode.Call' lazyInitializer.Instance);  			// Update the backing field  			il.Emit (OperationCode.Stfld' backingField);  			// End the skipping branch  			il.MarkLabel (skipIfNotNull);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Return  			il.Emit (OperationCode.Ret);  		}  	}  	// Amend the existing property  	else {  		// Before Get  		if (propertyAmendment.BeforeGet != null) {  			// Get the delegate to call before the property getter  			var beforeGet = ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeGet);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Call BeforeGet delegate  			il.Emit (OperationCode.Call' beforeGet.Instance);  		}  		// Lazy Initializer and/or After Get  		if (propertyAmendment.LazyInitializer != null || propertyAmendment.AfterGet != null) {  			// After Get  			if (propertyAmendment.AfterGet != null) {  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Load property name onto stack  				il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			}  			// Emit the original property getter instructions  			il.EmitUntilReturn ();  			// Lazy Initializer  			if (propertyAmendment.LazyInitializer != null) {  				// Add local variable to store the current value of the property  				var currentValue = new LocalDefinition () {  					Name = host.NameTable.GetNameFor ("_cv_")'  					Type = propertyDef.Type  				};  				if (methodBody.LocalVariables == null)  					methodBody.LocalVariables = new List<ILocalDefinition> ();  				methodBody.LocalVariables.Add (currentValue);  				// Store the current value in a local variable  				il.Emit (OperationCode.Stloc' currentValue);  				// Load the current value  				il.Emit (OperationCode.Ldloc' currentValue);  				// Skip initialization if the backing field is already initialized  				var skipIfNotNull = new ILGeneratorLabel ();  				il.Emit (OperationCode.Brtrue_S' skipIfNotNull);  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Load this pointer onto stack again  				il.Emit (OperationCode.Ldarg_0);  				// Load property name onto stack  				il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  				// Call LazyInitializer delegate  				il.Emit (OperationCode.Call' ResolvePropertyDelegate (propertyDef' propertyAmendment.LazyInitializer).Instance);  				// Store the initialized value  				il.Emit (OperationCode.Stloc' currentValue);  				// Load the initialized value  				il.Emit (OperationCode.Ldloc' currentValue);  				// Call the property setter  				il.Emit (propertyDef.Setter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Setter);  				// End the skipping branch  				il.MarkLabel (skipIfNotNull);  				// Load the current value  				il.Emit (OperationCode.Ldloc' currentValue);  			}  			// Call AfterGet delegate  			if (propertyAmendment.AfterGet != null)  				il.Emit (OperationCode.Call' ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterGet).Instance);  		}  		// Emit the rest of the original method if not amending after get  		else  			il.EmitUntilReturn ();  	}  }  // Property Set  else {  	// Setter for new or existing property  	if (propertyAmendment.Setter != null) {  		// Clear the original method body  		il.Operations.Clear ();  		// Get the delegate to call   		var setter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Setter);  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Call Setter delegate  		il.Emit (OperationCode.Call' setter.Instance);  		// Return  		il.Emit (OperationCode.Ret);  	}  	// New property without setter  	else if (propertyAmendment.PropertyInfo == null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Save to backing field  		il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  		// Return  		il.Emit (OperationCode.Ret);  	}  	// Amend the existing property setter  	else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  		// Get the before and after set delegate implementations  		var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  		var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  		// Determine if the old value is used by the amended delegates  		bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  		// Emit a local variable and store the initial property value by calling the property getter  		if (useOriginalValue) {  			// Add local variable to store the old value of the property  			if (methodBody.LocalVariables == null)  				methodBody.LocalVariables = new List<ILocalDefinition> ();  			methodBody.LocalVariables.Add (new LocalDefinition () {  				Name = host.NameTable.GetNameFor ("_ov_")'  				Type = propertyDef.Type  			});  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call the property getter to get the old value  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  			// Store the old value in a local variable  			il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  		}  		// Before Set  		if (beforeSet != null) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Optionally load the old value onto stack  			if (useOriginalValue)  				il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  			else  				il.Emit (OperationCode.Ldarg_1);  			// Load value argument pointer  			il.Emit (OperationCode.Ldarg_1);  			// Call BeforeSet delegate  			il.Emit (OperationCode.Call' beforeSet.Instance);  			// Store the result as the new value for the setter  			il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  		}  		// Emit the old property setter instructions  		il.EmitUntilReturn ();  		// After Set  		if (afterSet != null) {  			il.GoToEndOfOperations ();  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Optionally load the old value onto stack  			if (useOriginalValue)  				il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  			else  				il.Emit (OperationCode.Ldarg_1);  			// Load value argument onto stack  			il.Emit (OperationCode.Ldarg_1);  			// Optionally get the new property value if used  			if (afterSet.ReferencesArgument (4)) {  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Call property getter  				il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  			}  			else  				il.Emit (OperationCode.Ldarg_1);  			// Call AfterSet delegate  			il.Emit (OperationCode.Call' afterSet.Instance);  			il.Emit (OperationCode.Ret);  		}  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (methodBody.MethodDefinition.Name.Value.StartsWith ("get_") || methodBody.MethodDefinition.Name.Value.Contains (".get_")) {  	// Getter for new or existing property  	if (propertyAmendment.Getter != null) {  		// Clear the original method body  		il.Operations.Clear ();  		// Get the delegate to call   		var getter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Getter);  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Call Getter delegate  		il.Emit (OperationCode.Call' getter.Instance);  		// Return  		il.Emit (OperationCode.Ret);  	}  	// New property without defined getter  	else if (propertyAmendment.PropertyInfo == null) {  		// Get the previously created backing field for this property  		var backingField = GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ();  		// Default getter  		if (propertyAmendment.LazyInitializer == null) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Return  			il.Emit (OperationCode.Ret);  		}  		// Lazy initialized getter  		else {  			// Get the delegate to call before the property getter  			var lazyInitializer = ResolvePropertyDelegate (propertyDef' propertyAmendment.LazyInitializer);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Skip initialization if the backing field is already initialized  			var skipIfNotNull = new ILGeneratorLabel ();  			il.Emit (OperationCode.Brtrue_S' skipIfNotNull);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load this pointer onto stack again  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Call LazyInitializer delegate  			il.Emit (OperationCode.Call' lazyInitializer.Instance);  			// Update the backing field  			il.Emit (OperationCode.Stfld' backingField);  			// End the skipping branch  			il.MarkLabel (skipIfNotNull);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load the backing field  			il.Emit (OperationCode.Ldfld' backingField);  			// Return  			il.Emit (OperationCode.Ret);  		}  	}  	// Amend the existing property  	else {  		// Before Get  		if (propertyAmendment.BeforeGet != null) {  			// Get the delegate to call before the property getter  			var beforeGet = ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeGet);  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Call BeforeGet delegate  			il.Emit (OperationCode.Call' beforeGet.Instance);  		}  		// Lazy Initializer and/or After Get  		if (propertyAmendment.LazyInitializer != null || propertyAmendment.AfterGet != null) {  			// After Get  			if (propertyAmendment.AfterGet != null) {  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Load property name onto stack  				il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			}  			// Emit the original property getter instructions  			il.EmitUntilReturn ();  			// Lazy Initializer  			if (propertyAmendment.LazyInitializer != null) {  				// Add local variable to store the current value of the property  				var currentValue = new LocalDefinition () {  					Name = host.NameTable.GetNameFor ("_cv_")'  					Type = propertyDef.Type  				};  				if (methodBody.LocalVariables == null)  					methodBody.LocalVariables = new List<ILocalDefinition> ();  				methodBody.LocalVariables.Add (currentValue);  				// Store the current value in a local variable  				il.Emit (OperationCode.Stloc' currentValue);  				// Load the current value  				il.Emit (OperationCode.Ldloc' currentValue);  				// Skip initialization if the backing field is already initialized  				var skipIfNotNull = new ILGeneratorLabel ();  				il.Emit (OperationCode.Brtrue_S' skipIfNotNull);  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Load this pointer onto stack again  				il.Emit (OperationCode.Ldarg_0);  				// Load property name onto stack  				il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  				// Call LazyInitializer delegate  				il.Emit (OperationCode.Call' ResolvePropertyDelegate (propertyDef' propertyAmendment.LazyInitializer).Instance);  				// Store the initialized value  				il.Emit (OperationCode.Stloc' currentValue);  				// Load the initialized value  				il.Emit (OperationCode.Ldloc' currentValue);  				// Call the property setter  				il.Emit (propertyDef.Setter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Setter);  				// End the skipping branch  				il.MarkLabel (skipIfNotNull);  				// Load the current value  				il.Emit (OperationCode.Ldloc' currentValue);  			}  			// Call AfterGet delegate  			if (propertyAmendment.AfterGet != null)  				il.Emit (OperationCode.Call' ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterGet).Instance);  		}  		// Emit the rest of the original method if not amending after get  		else  			il.EmitUntilReturn ();  	}  }  // Property Set  else {  	// Setter for new or existing property  	if (propertyAmendment.Setter != null) {  		// Clear the original method body  		il.Operations.Clear ();  		// Get the delegate to call   		var setter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Setter);  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Call Setter delegate  		il.Emit (OperationCode.Call' setter.Instance);  		// Return  		il.Emit (OperationCode.Ret);  	}  	// New property without setter  	else if (propertyAmendment.PropertyInfo == null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Save to backing field  		il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  		// Return  		il.Emit (OperationCode.Ret);  	}  	// Amend the existing property setter  	else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  		// Get the before and after set delegate implementations  		var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  		var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  		// Determine if the old value is used by the amended delegates  		bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  		// Emit a local variable and store the initial property value by calling the property getter  		if (useOriginalValue) {  			// Add local variable to store the old value of the property  			if (methodBody.LocalVariables == null)  				methodBody.LocalVariables = new List<ILocalDefinition> ();  			methodBody.LocalVariables.Add (new LocalDefinition () {  				Name = host.NameTable.GetNameFor ("_ov_")'  				Type = propertyDef.Type  			});  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call the property getter to get the old value  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  			// Store the old value in a local variable  			il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  		}  		// Before Set  		if (beforeSet != null) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Optionally load the old value onto stack  			if (useOriginalValue)  				il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  			else  				il.Emit (OperationCode.Ldarg_1);  			// Load value argument pointer  			il.Emit (OperationCode.Ldarg_1);  			// Call BeforeSet delegate  			il.Emit (OperationCode.Call' beforeSet.Instance);  			// Store the result as the new value for the setter  			il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  		}  		// Emit the old property setter instructions  		il.EmitUntilReturn ();  		// After Set  		if (afterSet != null) {  			il.GoToEndOfOperations ();  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Load property name onto stack  			il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  			// Optionally load the old value onto stack  			if (useOriginalValue)  				il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  			else  				il.Emit (OperationCode.Ldarg_1);  			// Load value argument onto stack  			il.Emit (OperationCode.Ldarg_1);  			// Optionally get the new property value if used  			if (afterSet.ReferencesArgument (4)) {  				// Load this pointer onto stack  				il.Emit (OperationCode.Ldarg_0);  				// Call property getter  				il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  			}  			else  				il.Emit (OperationCode.Ldarg_1);  			// Call AfterSet delegate  			il.Emit (OperationCode.Call' afterSet.Instance);  			il.Emit (OperationCode.Ret);  		}  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.Setter != null) {  	// Clear the original method body  	il.Operations.Clear ();  	// Get the delegate to call   	var setter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Setter);  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load property name onto stack  	il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Call Setter delegate  	il.Emit (OperationCode.Call' setter.Instance);  	// Return  	il.Emit (OperationCode.Ret);  }  // New property without setter  else if (propertyAmendment.PropertyInfo == null) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Save to backing field  	il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  	// Return  	il.Emit (OperationCode.Ret);  }  // Amend the existing property setter  else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.Setter != null) {  	// Clear the original method body  	il.Operations.Clear ();  	// Get the delegate to call   	var setter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Setter);  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load property name onto stack  	il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Call Setter delegate  	il.Emit (OperationCode.Call' setter.Instance);  	// Return  	il.Emit (OperationCode.Ret);  }  // New property without setter  else if (propertyAmendment.PropertyInfo == null) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Save to backing field  	il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  	// Return  	il.Emit (OperationCode.Ret);  }  // Amend the existing property setter  else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.Setter != null) {  	// Clear the original method body  	il.Operations.Clear ();  	// Get the delegate to call   	var setter = ResolvePropertyDelegate (propertyDef' propertyAmendment.Setter);  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load property name onto stack  	il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Call Setter delegate  	il.Emit (OperationCode.Call' setter.Instance);  	// Return  	il.Emit (OperationCode.Ret);  }  // New property without setter  else if (propertyAmendment.PropertyInfo == null) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Save to backing field  	il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  	// Return  	il.Emit (OperationCode.Ret);  }  // Amend the existing property setter  else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.PropertyInfo == null) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Save to backing field  	il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  	// Return  	il.Emit (OperationCode.Ret);  }  // Amend the existing property setter  else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.PropertyInfo == null) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Save to backing field  	il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  	// Return  	il.Emit (OperationCode.Ret);  }  // Amend the existing property setter  else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.PropertyInfo == null) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Save to backing field  	il.Emit (OperationCode.Stfld' GetCurrentType ().Fields.Where (f => f.Name.Value == GetBackingFieldName (propertyAmendment)).First ());  	// Return  	il.Emit (OperationCode.Ret);  }  // Amend the existing property setter  else if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (propertyAmendment.BeforeSet != null || propertyAmendment.AfterSet != null) {  	// Get the before and after set delegate implementations  	var beforeSet = propertyAmendment.BeforeSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.BeforeSet) : null;  	var afterSet = propertyAmendment.AfterSet != null ? ResolvePropertyDelegate (propertyDef' propertyAmendment.AfterSet) : null;  	// Determine if the old value is used by the amended delegates  	bool useOriginalValue = beforeSet.ReferencesArgument (2) || afterSet.ReferencesArgument (2);  	// Emit a local variable and store the initial property value by calling the property getter  	if (useOriginalValue) {  		// Add local variable to store the old value of the property  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_ov_")'  			Type = propertyDef.Type  		});  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call the property getter to get the old value  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		// Store the old value in a local variable  		il.Emit (OperationCode.Stloc' methodBody.LocalVariables.Last ());  	}  	// Before Set  	if (beforeSet != null) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument pointer  		il.Emit (OperationCode.Ldarg_1);  		// Call BeforeSet delegate  		il.Emit (OperationCode.Call' beforeSet.Instance);  		// Store the result as the new value for the setter  		il.Emit (OperationCode.Starg' methodBody.MethodDefinition.Parameters.First ());  	}  	// Emit the old property setter instructions  	il.EmitUntilReturn ();  	// After Set  	if (afterSet != null) {  		il.GoToEndOfOperations ();  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Load property name onto stack  		il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  		// Optionally load the old value onto stack  		if (useOriginalValue)  			il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  		else  			il.Emit (OperationCode.Ldarg_1);  		// Load value argument onto stack  		il.Emit (OperationCode.Ldarg_1);  		// Optionally get the new property value if used  		if (afterSet.ReferencesArgument (4)) {  			// Load this pointer onto stack  			il.Emit (OperationCode.Ldarg_0);  			// Call property getter  			il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  		}  		else  			il.Emit (OperationCode.Ldarg_1);  		// Call AfterSet delegate  		il.Emit (OperationCode.Call' afterSet.Instance);  		il.Emit (OperationCode.Ret);  	}  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (afterSet != null) {  	il.GoToEndOfOperations ();  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load property name onto stack  	il.Emit (OperationCode.Ldstr' propertyDef.Name.Value);  	// Optionally load the old value onto stack  	if (useOriginalValue)  		il.Emit (OperationCode.Ldloc' methodBody.LocalVariables.Last ());  	else  		il.Emit (OperationCode.Ldarg_1);  	// Load value argument onto stack  	il.Emit (OperationCode.Ldarg_1);  	// Optionally get the new property value if used  	if (afterSet.ReferencesArgument (4)) {  		// Load this pointer onto stack  		il.Emit (OperationCode.Ldarg_0);  		// Call property getter  		il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  	}  	else  		il.Emit (OperationCode.Ldarg_1);  	// Call AfterSet delegate  	il.Emit (OperationCode.Call' afterSet.Instance);  	il.Emit (OperationCode.Ret);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: if (afterSet.ReferencesArgument (4)) {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Call property getter  	il.Emit (propertyDef.Getter.ResolvedMethod.IsVirtual ? OperationCode.Callvirt : OperationCode.Call' propertyDef.Getter.ResolvedMethod);  }  else  	il.Emit (OperationCode.Ldarg_1);  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendProperty,The following statement contains a magic number: il.UpdateMethodBody (6);  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The following statement contains a magic number: if (methodAmendment.Catch != null || methodAmendment.Finally != null) {  	bool hasReturnValue = !TypeHelper.TypesAreEquivalent (methodBody.MethodDefinition.Type' host.PlatformType.SystemVoid);  	ILocalDefinition result = null;  	// Store the result before starting the catch/finally blocks  	if (hasReturnValue) {  		result = new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_result_")'  			Type = methodBody.MethodDefinition.Type  		};  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (result);  		il.Emit (OperationCode.Stloc' result);  	}  	// Skip to the return statement  	var exit = new ILGeneratorLabel ();  	il.Emit (OperationCode.Leave_S' exit);  	// Catch  	if (methodAmendment.Catch != null) {  		// Determine the type of delegate  		var delegateType = MethodDelegateType.Catch;  		if (context != null)  			delegateType |= MethodDelegateType.WithContext;  		ResolveMethodDelegate (methodBody.MethodDefinition.ContainingType' methodAmendment.Catch' methodBody.MethodDefinition' ref delegateType);  		// Determine the type of exception being caught  		var exceptionType = ResolveType (methodAmendment.Catch.GetParameters () [(delegateType.HasFlag (MethodDelegateType.ArraySyntax) ? 1 : 0) + (context != null ? 2 : 1)].ParameterType);  		// Start the catch block  		il.BeginCatchBlock (exceptionType);  		// Store exception in local variable  		var exception = new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_exception_")'  			Type = exceptionType  		};  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (exception);  		il.Emit (OperationCode.Stloc' exception);  		// Call the catch delegate  		CallMethodDelegate (methodBody' methodAmendment.Catch' false' il' null' MethodDelegateType.Catch' context' exception);  		// Store the new result if the method has a return value  		if (hasReturnValue)  			il.Emit (OperationCode.Stloc' result);  		// Exit the catch block  		il.Emit (OperationCode.Leave_S' exit);  		// End nested try block if necessary  		if (methodAmendment.Finally != null)  			il.EndTryBody ();  	}  	// Finally  	if (methodAmendment.Finally != null) {  		// Start the finally block  		il.BeginFinallyBlock ();  		// Call the finally delegate  		CallMethodDelegate (methodBody' methodAmendment.Finally' false' il' null' MethodDelegateType.Finally' context' null);  		// End the finally block  		il.Emit (OperationCode.Endfinally);  	}  	// End the try clause  	il.MarkLabel (exit);  	il.EndTryBody ();  	// Load the result  	if (hasReturnValue)  		il.Emit (OperationCode.Ldloc' result);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The following statement contains a magic number: if (methodAmendment.Catch != null) {  	// Determine the type of delegate  	var delegateType = MethodDelegateType.Catch;  	if (context != null)  		delegateType |= MethodDelegateType.WithContext;  	ResolveMethodDelegate (methodBody.MethodDefinition.ContainingType' methodAmendment.Catch' methodBody.MethodDefinition' ref delegateType);  	// Determine the type of exception being caught  	var exceptionType = ResolveType (methodAmendment.Catch.GetParameters () [(delegateType.HasFlag (MethodDelegateType.ArraySyntax) ? 1 : 0) + (context != null ? 2 : 1)].ParameterType);  	// Start the catch block  	il.BeginCatchBlock (exceptionType);  	// Store exception in local variable  	var exception = new LocalDefinition () {  		Name = host.NameTable.GetNameFor ("_exception_")'  		Type = exceptionType  	};  	if (methodBody.LocalVariables == null)  		methodBody.LocalVariables = new List<ILocalDefinition> ();  	methodBody.LocalVariables.Add (exception);  	il.Emit (OperationCode.Stloc' exception);  	// Call the catch delegate  	CallMethodDelegate (methodBody' methodAmendment.Catch' false' il' null' MethodDelegateType.Catch' context' exception);  	// Store the new result if the method has a return value  	if (hasReturnValue)  		il.Emit (OperationCode.Stloc' result);  	// Exit the catch block  	il.Emit (OperationCode.Leave_S' exit);  	// End nested try block if necessary  	if (methodAmendment.Finally != null)  		il.EndTryBody ();  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendMethod,The following statement contains a magic number: il.UpdateMethodBody (6);  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,AmendEvent,The following statement contains a magic number: il.UpdateMethodBody (6);  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,EmitDefaultEvent,The following statement contains a magic number: il.Emit (OperationCode.Call' new GenericMethodInstance (ResolveType (typeof(System.Threading.Interlocked)).Methods.Where (m => m.Name.Value == "CompareExchange" && m.IsGeneric && m.GenericParameterCount == 1 && m.ParameterCount == 3).First ()' new ITypeReference[] {  	eventDef.Type  }' host.InternFactory));  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,CallMethodDelegate,The following statement contains a magic number: if (delegateType.HasFlag (MethodDelegateType.ArraySyntax)) {  	// Add local variable to store the return value before delegate  	ITypeDefinition argTypeDef = targetMethodDef.Parameters.Skip (2 + (context != null ? 1 : 0) + (exception != null ? 1 : 0)).First ().Type.ResolvedType;  	var args = new LocalDefinition () {  		Name = host.NameTable.GetNameFor ("_args_")'  		Type = argTypeDef  	};  	if (methodBody.LocalVariables == null)  		methodBody.LocalVariables = new List<ILocalDefinition> ();  	methodBody.LocalVariables.Add (args);  	// Load the number of arguments onto the stack  	il.Emit (OperationCode.Ldc_I4' methodDef.Parameters.Count ());  	// Create an object array  	il.Emit (OperationCode.Newarr' argTypeDef);  	// Store the new array  	il.Emit (OperationCode.Stloc' args);  	// Populate the array with method arguments  	foreach (var parameter in methodDef.Parameters) {  		// Load the argument array  		il.Emit (OperationCode.Ldloc' args);  		// Add argument index to the stack  		il.Emit (OperationCode.Ldc_I4' parameter.Index);  		// Load the argument  		il.Emit (OperationCode.Ldarg' parameter);  		// Box value types  		if (parameter.Type.IsValueType)  			il.Emit (OperationCode.Box' parameter.Type);  		// Store the argument in the array  		il.Emit (OperationCode.Stelem_Ref);  	}  	// Emit the method implementation here if specified  	if (implement != null)  		implement ();  	// Add local variable to store the return value before delegate  	LocalDefinition result = null;  	if (delegateType.HasFlag (MethodDelegateType.HasResultParameter)) {  		// Create the result local variable  		result = new LocalDefinition () {  			Name = host.NameTable.GetNameFor ("_result_")'  			Type = methodBody.MethodDefinition.Type  		};  		if (methodBody.LocalVariables == null)  			methodBody.LocalVariables = new List<ILocalDefinition> ();  		methodBody.LocalVariables.Add (result);  		// Store the result  		il.Emit (OperationCode.Stloc' result);  	}  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Load method name onto stack  	il.Emit (OperationCode.Ldstr' methodBody.MethodDefinition.Name.Value);  	// Optionally load the method context  	if (context != null)  		il.Emit (OperationCode.Ldloc' context);  	// Optionally load exception  	if (exception != null)  		il.Emit (OperationCode.Ldloc' exception);  	// Load the argument array  	il.Emit (OperationCode.Ldloc' args);  	// Load the result variable is required for the delegate being invoked  	if (delegateType.HasFlag (MethodDelegateType.HasResultParameter)) {  		// Load the result  		il.Emit (OperationCode.Ldloc' result);  		// Box result values if necessary  		if (delegateType.HasFlag (MethodDelegateType.HasResultParameter) && methodDef.Type.IsValueType)  			il.Emit (OperationCode.Box' methodDef.Type);  	}  	// Call the target method  	il.Emit (OperationCode.Call' targetMethodDef);  	// Unbox result values if necessary  	if (delegateType.HasFlag (MethodDelegateType.Function) && (delegateType.HasFlag (MethodDelegateType.After) || delegateType.HasFlag (MethodDelegateType.Catch)) && methodDef.Type.IsValueType)  		il.Emit (OperationCode.Unbox_Any' methodDef.Type);  	// Handle method delegates that potentially return updated arguments  	if (updateArguments) {  		// Update the method arguments with the result of the invocation  		foreach (var parameter in methodDef.Parameters) {  			// Load the arguments back on the stack  			il.Emit (OperationCode.Ldloc' args);  			// Load the index of the argument value  			il.Emit (OperationCode.Ldc_I4' parameter.Index);  			// Get the argument value from the array  			il.Emit (OperationCode.Ldelem_Ref);  			// Unbox value types  			if (parameter.Type.IsValueType)  				il.Emit (OperationCode.Unbox_Any' parameter.Type);  			// Update the actual argument  			il.Emit (OperationCode.Starg' parameter);  		}  	}  }  // Explicit syntax  else {  	// Load this pointer onto stack  	il.Emit (OperationCode.Ldarg_0);  	// Optionally load the method context  	if (context != null)  		il.Emit (OperationCode.Ldloc' context);  	// Optionally load exception  	if (exception != null)  		il.Emit (OperationCode.Ldloc' exception);  	// Determine whether to load the argument value or argument references  	var ldArg = methodDef.ParameterCount > 0 && targetMethodDef.Parameters.Last ().IsByReference ? OperationCode.Ldarga_S : OperationCode.Ldarg_S;  	// Load the method arguments onto the stack  	foreach (var parameter in methodDef.Parameters)  		il.Emit (ldArg' parameter);  	// Emit the method implementation here if specified  	if (implement != null)  		implement ();  	// Call the target method  	il.Emit (OperationCode.Call' targetMethodDef);  }  
Magic Number,Afterthought.Amender,AssemblyAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ResolveMethodDelegate,The following statement contains a magic number: if (parameters.Exists<string> (1) && // Method Name  parameters.Exists<object[]> (2 + contextParam + exceptionParam) && // Method Parameters  (!delegateType.HasFlag (MethodDelegateType.HasResultParameter) || (parameters.Exists<object> (parameters.Length - 1) && method.ReturnType == typeof(object))))  	// Method Result  	delegateType |= MethodDelegateType.ArraySyntax;  else  	delegateType |= MethodDelegateType.ExplicitSyntax;  
Magic Number,Afterthought.Amender,MethodHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ReferencesArgument,The following statement contains a magic number: return method != null && method.Operations.Where (o =>  {  	switch (o.OperationCode) {  	case OperationCode.Ldarg:  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg:  	case OperationCode.Starg_S:  		return ((IParameterListEntry)o.Value).Index == argument;  	case OperationCode.Ldarg_0:  		return argument == 0;  	case OperationCode.Ldarg_1:  		return argument == 1;  	case OperationCode.Ldarg_2:  		return argument == 2;  	case OperationCode.Ldarg_3:  		return argument == 3;  	default:  		return false;  	}  }).Any ();  
Magic Number,Afterthought.Amender,MethodHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ReferencesArgument,The following statement contains a magic number: return method != null && method.Operations.Where (o =>  {  	switch (o.OperationCode) {  	case OperationCode.Ldarg:  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg:  	case OperationCode.Starg_S:  		return ((IParameterListEntry)o.Value).Index == argument;  	case OperationCode.Ldarg_0:  		return argument == 0;  	case OperationCode.Ldarg_1:  		return argument == 1;  	case OperationCode.Ldarg_2:  		return argument == 2;  	case OperationCode.Ldarg_3:  		return argument == 3;  	default:  		return false;  	}  }).Any ();  
Magic Number,Afterthought.Amender,MethodHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ReferencesArgument,The following statement contains a magic number: switch (o.OperationCode) {  case OperationCode.Ldarg:  case OperationCode.Ldarg_S:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Starg:  case OperationCode.Starg_S:  	return ((IParameterListEntry)o.Value).Index == argument;  case OperationCode.Ldarg_0:  	return argument == 0;  case OperationCode.Ldarg_1:  	return argument == 1;  case OperationCode.Ldarg_2:  	return argument == 2;  case OperationCode.Ldarg_3:  	return argument == 3;  default:  	return false;  }  
Magic Number,Afterthought.Amender,MethodHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ReferencesArgument,The following statement contains a magic number: switch (o.OperationCode) {  case OperationCode.Ldarg:  case OperationCode.Ldarg_S:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Starg:  case OperationCode.Starg_S:  	return ((IParameterListEntry)o.Value).Index == argument;  case OperationCode.Ldarg_0:  	return argument == 0;  case OperationCode.Ldarg_1:  	return argument == 1;  case OperationCode.Ldarg_2:  	return argument == 2;  case OperationCode.Ldarg_3:  	return argument == 3;  default:  	return false;  }  
Magic Number,Afterthought.Amender,MethodHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ReferencesArgument,The following statement contains a magic number: return argument == 2;  
Magic Number,Afterthought.Amender,MethodHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\AssemblyAmender.cs,ReferencesArgument,The following statement contains a magic number: return argument == 3;  
Magic Number,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupDominanceFrontier,The following statement contains a magic number: foreach (var block in this.cfg.AllBlocks) {  	Contract.Assume (block != null);  	var n = block.predeccessorCount;  	if (n < 2)  		continue;  	for (int i = 0; i < n; i++) {  		Contract.Assume (block.firstPredecessorEdge + i >= 0);  		Contract.Assume (block.firstPredecessorEdge + i < predecessorEdges.Count);  		var pred = predecessorEdges [block.firstPredecessorEdge + i];  		Contract.Assume (pred != null);  		var a = pred;  		while (a != block.immediateDominator) {  			frontierFor.Add (a.Offset' block);  			a = (BasicBlock)a.immediateDominator;  			Contract.Assume (a != null);  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupDominanceFrontier,The following statement contains a magic number: if (n < 2)  	continue;  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: if (successor.OperandStack.Count == 0) {  	int n = this.stack.Top;  	if (n < 0)  		return;  	int startingCount = this.operandStackSetupInstructions.Count;  	for (int i = 0; i <= n; i++) {  		var pushInstruction = this.stack.Peek (i);  		this.operandStackSetupInstructions.Add (new Instruction () {  			Operand2 = new List<Instruction> (4) {  				pushInstruction  			}  		});  	}  	successor.OperandStack = new Sublist<Instruction> (this.operandStackSetupInstructions' startingCount' operandStackSetupInstructions.Count - startingCount);  }  else {  	int n = this.stack.Top;  	Contract.Assume (n == successor.OperandStack.Count - 1);  	//This is an optimistic assumption. It should be true for any well formed PE file. We are content to crash given bad input.  	for (int i = 0; i <= n; i++) {  		var pushInstruction = this.stack.Peek (i);  		var setupInstruction = successor.OperandStack [i];  		Contract.Assume (setupInstruction.Operand2 is List<Instruction>);  		//This is set up in the successor.OperandStack.Count == 0' but is hard to write a contract to that effect.  		var list = (List<Instruction>)setupInstruction.Operand2;  		list.Add (pushInstruction);  	}  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: for (int i = 0; i <= n; i++) {  	var pushInstruction = this.stack.Peek (i);  	this.operandStackSetupInstructions.Add (new Instruction () {  		Operand2 = new List<Instruction> (4) {  			pushInstruction  		}  	});  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: this.operandStackSetupInstructions.Add (new Instruction () {  	Operand2 = new List<Instruction> (4) {  		pushInstruction  	}  });  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The following statement contains a magic number: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  case OperationCode.Ldsfld:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldsflda:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldftn:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  case OperationCode.Sizeof:  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArrayIndexerInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  case OperationCode.Newarr:  	InitializeArrayCreateInstruction (instruction' this.stack' instruction.Operation);  	break;  case OperationCode.Array_Set:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArraySetInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Isinst:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldobj:  case OperationCode.Ldflda:  case OperationCode.Ldfld:  case OperationCode.Ldlen:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Mkrefany:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' signature);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' funcPointer);  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	var indexAndValue = new Instruction[2];  	indexAndValue [1] = this.stack.Pop ();  	indexAndValue [0] = this.stack.Pop ();  	instruction.Operand2 = indexAndValue;  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Dup:  	var dupop = this.stack.Pop ();  	instruction.Operand1 = dupop;  	this.stack.Push (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Newobj:  	Contract.Assume (instruction.Operation.Value is ISignature);  	//This is an informally specified property of the Metadata model.  	signature = (ISignature)instruction.Operation.Value;  	var numArguments = (int)IteratorHelper.EnumerableCount (signature.Parameters);  	if (numArguments > 0) {  		if (numArguments > 1) {  			numArguments--;  			var arguments = new Instruction[numArguments];  			instruction.Operand2 = arguments;  			for (var i = numArguments - 1; i >= 0; i--)  				arguments [i] = stack.Pop ();  		}  		instruction.Operand1 = stack.Pop ();  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	break;  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: if (rank > 0) {  	if (currentOperation.OperationCode == OperationCode.Array_Create_WithLowerBound)  		rank *= 2;  	rank--;  	if (rank > 0) {  		var indices = new Instruction[rank];  		instruction.Operand2 = indices;  		for (var i = rank; i > 0; i--)  			indices [i - 1] = stack.Pop ();  	}  	instruction.Operand1 = stack.Pop ();  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: if (currentOperation.OperationCode == OperationCode.Array_Create_WithLowerBound)  	rank *= 2;  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: rank *= 2;  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\Graph.cs,Stack,The following statement contains a magic number: if (maxStack <= 0)  	maxStack = 8;  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\Graph.cs,Stack,The following statement contains a magic number: maxStack = 8;  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\Graph.cs,Push,The following statement contains a magic number: if (this.top >= this.elements.Length - 1) {  	Array.Resize (ref this.elements' this.elements.Length * 2);  	Contract.Assume (Contract.ForAll (0' this.top + 1' i => this.elements [i] != null));  	//this the expected behavior of Array.Resize  }  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\Graph.cs,Push,The following statement contains a magic number: Array.Resize (ref this.elements' this.elements.Length * 2);  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Div:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Rem:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  	Contract.Assume (instruction.Operand1 != null);  	Contract.Assume (instruction.Operand2 is Instruction);  	if (instruction.Operand1.Type.TypeCode == PrimitiveTypeCode.Boolean && ((Instruction)instruction.Operand2).Type.TypeCode == PrimitiveTypeCode.Boolean) {  		this.stack.Pop ();  		this.stack.Pop ();  		instruction.Type = this.platformType.SystemBoolean;  		this.stack.Push (instruction);  		break;  	}  	goto case OperationCode.Add;  case OperationCode.Add_Ovf_Un:  case OperationCode.Div_Un:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Rem_Un:  case OperationCode.Sub_Ovf_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetUnsignedBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  	instruction.Type = this.platformType.SystemRuntimeArgumentHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  	var arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = ManagedPointerType.GetManagedPointerType (arrayType.ElementType' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create_WithLowerBound:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank * 2; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Get:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = arrayType.ElementType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Set:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	this.stack.Pop ();  	//The value to set  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Box:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	var numArguments = IteratorHelper.EnumerableCount (signature.Parameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!signature.IsStatic)  		this.stack.Pop ();  	instruction.Type = signature.Type;  	if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	this.stack.Pop ();  	//The function pointer  	numArguments = IteratorHelper.EnumerableCount (funcPointer.Parameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!funcPointer.IsStatic)  		this.stack.Pop ();  	instruction.Type = funcPointer.Type;  	if (funcPointer.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemBoolean;  	this.stack.Push (instruction);  	break;  case OperationCode.Ckfinite:  case OperationCode.Neg:  case OperationCode.Not:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Ldind_I:  case OperationCode.Localloc:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Ldind_I1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Ldind_I2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Ldind_I4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Ldind_I8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_U:  case OperationCode.Ldlen:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_U1:  case OperationCode.Ldind_U1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_U2:  case OperationCode.Ldind_U2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_U4:  case OperationCode.Ldind_U4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_U8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R_Un:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	if (TypeHelper.SizeOfType (instruction.Operand1.Type) < 4)  		instruction.Type = this.platformType.SystemFloat32;  	else  		instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R4:  case OperationCode.Ldind_R4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R8:  case OperationCode.Ldind_R8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Dup:  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	var parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		instruction.Type = this.cfg.MethodBody.MethodDefinition.ContainingType;  		if (instruction.Type.IsValueType)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	else {  		instruction.Type = parameter.Type;  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		instruction.Type = ManagedPointerType.GetManagedPointerType (this.cfg.MethodBody.MethodDefinition.ContainingType' this.internFactory);  	}  	else {  		instruction.Type = ManagedPointerType.GetManagedPointerType (parameter.Type' this.internFactory);  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I8:  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R4:  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R8:  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldobj:  case OperationCode.Unbox_Any:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	arrayType = instruction.Operand1.Type as IArrayTypeReference;  	if (arrayType != null)  		instruction.Type = arrayType.ElementType;  	else  		//Should only get here if the IL is bad.  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelema:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldfld:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsfld:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldflda:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsflda:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldftn:  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldvirtftn:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldind_Ref:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	var ptr = instruction.Operand1.Type as IPointerTypeReference;  	if (ptr != null)  		instruction.Type = ptr.TargetType;  	else {  		Contract.Assume (instruction.Operand1.Type is IManagedPointerTypeReference);  		//This is an informally specified property of the Metadata model.  		instruction.Type = ((IManagedPointerTypeReference)instruction.Operand1.Type).TargetType;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = local.Type;  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (local.Type' this.internFactory);  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldnull:  	instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldstr:  	instruction.Type = this.platformType.SystemString;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldtoken:  	if (instruction.Operation.Value is IMethodReference)  		instruction.Type = this.platformType.SystemRuntimeMethodHandle;  	else if (instruction.Operation.Value is ITypeReference)  		instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	else if (instruction.Operation.Value is IFieldReference)  		instruction.Type = this.platformType.SystemRuntimeFieldHandle;  	else {  		//this should never happen in well formed IL.  		instruction.Type = this.platformType.SystemVoid;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Mkrefany:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemTypedReference;  	this.stack.Push (instruction);  	break;  case OperationCode.Newarr:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Newobj:  	var constructorReference = instruction.Operation.Value as IMethodReference;  	Contract.Assume (constructorReference != null);  	//This is an informally specified property of the Metadata model.  	for (var i = constructorReference.ParameterCount; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = constructorReference.ContainingType;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanytype:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanyval:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.cfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Sizeof:  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Unbox:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  default:  	instruction.Type = this.platformType.SystemVoid;  	break;  }  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Div:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Rem:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  	Contract.Assume (instruction.Operand1 != null);  	Contract.Assume (instruction.Operand2 is Instruction);  	if (instruction.Operand1.Type.TypeCode == PrimitiveTypeCode.Boolean && ((Instruction)instruction.Operand2).Type.TypeCode == PrimitiveTypeCode.Boolean) {  		this.stack.Pop ();  		this.stack.Pop ();  		instruction.Type = this.platformType.SystemBoolean;  		this.stack.Push (instruction);  		break;  	}  	goto case OperationCode.Add;  case OperationCode.Add_Ovf_Un:  case OperationCode.Div_Un:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Rem_Un:  case OperationCode.Sub_Ovf_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetUnsignedBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  	instruction.Type = this.platformType.SystemRuntimeArgumentHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  	var arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = ManagedPointerType.GetManagedPointerType (arrayType.ElementType' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create_WithLowerBound:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank * 2; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Get:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = arrayType.ElementType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Set:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	this.stack.Pop ();  	//The value to set  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Box:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	var numArguments = IteratorHelper.EnumerableCount (signature.Parameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!signature.IsStatic)  		this.stack.Pop ();  	instruction.Type = signature.Type;  	if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	this.stack.Pop ();  	//The function pointer  	numArguments = IteratorHelper.EnumerableCount (funcPointer.Parameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!funcPointer.IsStatic)  		this.stack.Pop ();  	instruction.Type = funcPointer.Type;  	if (funcPointer.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemBoolean;  	this.stack.Push (instruction);  	break;  case OperationCode.Ckfinite:  case OperationCode.Neg:  case OperationCode.Not:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Ldind_I:  case OperationCode.Localloc:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Ldind_I1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Ldind_I2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Ldind_I4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Ldind_I8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_U:  case OperationCode.Ldlen:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_U1:  case OperationCode.Ldind_U1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_U2:  case OperationCode.Ldind_U2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_U4:  case OperationCode.Ldind_U4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_U8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R_Un:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	if (TypeHelper.SizeOfType (instruction.Operand1.Type) < 4)  		instruction.Type = this.platformType.SystemFloat32;  	else  		instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R4:  case OperationCode.Ldind_R4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R8:  case OperationCode.Ldind_R8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Dup:  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	var parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		instruction.Type = this.cfg.MethodBody.MethodDefinition.ContainingType;  		if (instruction.Type.IsValueType)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	else {  		instruction.Type = parameter.Type;  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		instruction.Type = ManagedPointerType.GetManagedPointerType (this.cfg.MethodBody.MethodDefinition.ContainingType' this.internFactory);  	}  	else {  		instruction.Type = ManagedPointerType.GetManagedPointerType (parameter.Type' this.internFactory);  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I8:  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R4:  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R8:  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldobj:  case OperationCode.Unbox_Any:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	arrayType = instruction.Operand1.Type as IArrayTypeReference;  	if (arrayType != null)  		instruction.Type = arrayType.ElementType;  	else  		//Should only get here if the IL is bad.  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelema:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldfld:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsfld:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldflda:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsflda:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldftn:  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldvirtftn:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldind_Ref:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	var ptr = instruction.Operand1.Type as IPointerTypeReference;  	if (ptr != null)  		instruction.Type = ptr.TargetType;  	else {  		Contract.Assume (instruction.Operand1.Type is IManagedPointerTypeReference);  		//This is an informally specified property of the Metadata model.  		instruction.Type = ((IManagedPointerTypeReference)instruction.Operand1.Type).TargetType;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = local.Type;  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (local.Type' this.internFactory);  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldnull:  	instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldstr:  	instruction.Type = this.platformType.SystemString;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldtoken:  	if (instruction.Operation.Value is IMethodReference)  		instruction.Type = this.platformType.SystemRuntimeMethodHandle;  	else if (instruction.Operation.Value is ITypeReference)  		instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	else if (instruction.Operation.Value is IFieldReference)  		instruction.Type = this.platformType.SystemRuntimeFieldHandle;  	else {  		//this should never happen in well formed IL.  		instruction.Type = this.platformType.SystemVoid;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Mkrefany:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemTypedReference;  	this.stack.Push (instruction);  	break;  case OperationCode.Newarr:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Newobj:  	var constructorReference = instruction.Operation.Value as IMethodReference;  	Contract.Assume (constructorReference != null);  	//This is an informally specified property of the Metadata model.  	for (var i = constructorReference.ParameterCount; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = constructorReference.ContainingType;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanytype:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanyval:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.cfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Sizeof:  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Unbox:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  default:  	instruction.Type = this.platformType.SystemVoid;  	break;  }  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: for (var i = arrayType.Rank * 2; i > 0; i--)  	this.stack.Pop ();  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: if (TypeHelper.SizeOfType (instruction.Operand1.Type) < 4)  	instruction.Type = this.platformType.SystemFloat32;  else  	instruction.Type = this.platformType.SystemFloat64;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (shortOffsetOk) {  	operation.operationCode = ShortVersionOf (operation.OperationCode);  	if (operation.operationCode != oldOpCode) {  		numberOfAdjustments++;  		adjustment -= 3;  	}  }  else {  	if (operation.operationCode != LongVersionOf (operation.operationCode))  		throw new InvalidOperationException ();  	//A short branch was specified for an offset that is long.  	//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (operation.operationCode != oldOpCode) {  	numberOfAdjustments++;  	adjustment -= 3;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= 3;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  	//eliminate branch to the next instruction  	operation.operationCode = OperationCode.Invalid;  	numberOfAdjustments++;  	adjustment -= 2;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  	//eliminate branch to the next instruction  	operation.operationCode = OperationCode.Invalid;  	numberOfAdjustments++;  	adjustment -= 2;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 8;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4 * ((uint)labels.Length + 1);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldloc_S || opcode == OperationCode.Ldloca_S || opcode == OperationCode.Stloc_S)  	this.offset += 1;  else if (opcode == OperationCode.Ldloc || opcode == OperationCode.Ldloca || opcode == OperationCode.Stloc)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldloc || opcode == OperationCode.Ldloca || opcode == OperationCode.Stloc)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 8;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldarg_S || opcode == OperationCode.Ldarga_S || opcode == OperationCode.Starg_S)  	this.offset += 1;  else if (opcode == OperationCode.Ldarg || opcode == OperationCode.Ldarga || opcode == OperationCode.Starg)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldarg || opcode == OperationCode.Ldarga || opcode == OperationCode.Starg)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,SizeOfOffset,The following statement contains a magic number: switch (opcode) {  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	return 1;  default:  	return 4;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,SizeOfOffset,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,SizeOfOperationCode,The following statement contains a magic number: if (((int)opcode) > 0xff && (opcode < OperationCode.Array_Create))  	return 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,SizeOfOperationCode,The following statement contains a magic number: return 2;  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: for (var index = 0; index < line.Length; index++) {  	var current = line [index];  	if (current == '\\') {  		// escape character  		escaping++;  		// swallow the escape character for now  		// grab everything prior to prior escape character  		if (index > start) {  			currentArg.Append (line.Substring (start' index - start));  		}  		start = index + 1;  		continue;  	}  	if (escaping > 0) {  		if (current == '"') {  			var backslashes = escaping / 2;  			for (int i = 0; i < backslashes; i++) {  				currentArg.Append ('\\');  			}  			if (escaping % 2 == 1) {  				// escapes the "  				currentArg.Append ('"');  				escaping = 0;  				start = index + 1;  				continue;  			}  		}  		else {  			var backslashes = escaping;  			for (int i = 0; i < backslashes; i++) {  				currentArg.Append ('\\');  			}  		}  		escaping = 0;  	}  	if (inDoubleQuotes) {  		if (current == '"') {  			// ending argument  			FinishArgument (line' start' args' currentArg' index' true);  			start = index + 1;  			inDoubleQuotes = false;  			continue;  		}  	}  	else// not in quotes  	 {  		if (Char.IsWhiteSpace (current)) {  			// end previous' start new  			FinishArgument (line' start' args' currentArg' index' false);  			start = index + 1;  			continue;  		}  		if (current == '"') {  			// starting double quote  			if (index != start) {  				AddError ("Response file '{0}' line {1}' char {2} contains '\"' not starting or ending an argument"' responseFileName' lineNo' index);  			}  			start = index + 1;  			inDoubleQuotes = true;  			continue;  		}  	}  }  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: for (var index = 0; index < line.Length; index++) {  	var current = line [index];  	if (current == '\\') {  		// escape character  		escaping++;  		// swallow the escape character for now  		// grab everything prior to prior escape character  		if (index > start) {  			currentArg.Append (line.Substring (start' index - start));  		}  		start = index + 1;  		continue;  	}  	if (escaping > 0) {  		if (current == '"') {  			var backslashes = escaping / 2;  			for (int i = 0; i < backslashes; i++) {  				currentArg.Append ('\\');  			}  			if (escaping % 2 == 1) {  				// escapes the "  				currentArg.Append ('"');  				escaping = 0;  				start = index + 1;  				continue;  			}  		}  		else {  			var backslashes = escaping;  			for (int i = 0; i < backslashes; i++) {  				currentArg.Append ('\\');  			}  		}  		escaping = 0;  	}  	if (inDoubleQuotes) {  		if (current == '"') {  			// ending argument  			FinishArgument (line' start' args' currentArg' index' true);  			start = index + 1;  			inDoubleQuotes = false;  			continue;  		}  	}  	else// not in quotes  	 {  		if (Char.IsWhiteSpace (current)) {  			// end previous' start new  			FinishArgument (line' start' args' currentArg' index' false);  			start = index + 1;  			continue;  		}  		if (current == '"') {  			// starting double quote  			if (index != start) {  				AddError ("Response file '{0}' line {1}' char {2} contains '\"' not starting or ending an argument"' responseFileName' lineNo' index);  			}  			start = index + 1;  			inDoubleQuotes = true;  			continue;  		}  	}  }  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: if (escaping > 0) {  	if (current == '"') {  		var backslashes = escaping / 2;  		for (int i = 0; i < backslashes; i++) {  			currentArg.Append ('\\');  		}  		if (escaping % 2 == 1) {  			// escapes the "  			currentArg.Append ('"');  			escaping = 0;  			start = index + 1;  			continue;  		}  	}  	else {  		var backslashes = escaping;  		for (int i = 0; i < backslashes; i++) {  			currentArg.Append ('\\');  		}  	}  	escaping = 0;  }  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: if (escaping > 0) {  	if (current == '"') {  		var backslashes = escaping / 2;  		for (int i = 0; i < backslashes; i++) {  			currentArg.Append ('\\');  		}  		if (escaping % 2 == 1) {  			// escapes the "  			currentArg.Append ('"');  			escaping = 0;  			start = index + 1;  			continue;  		}  	}  	else {  		var backslashes = escaping;  		for (int i = 0; i < backslashes; i++) {  			currentArg.Append ('\\');  		}  	}  	escaping = 0;  }  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: if (current == '"') {  	var backslashes = escaping / 2;  	for (int i = 0; i < backslashes; i++) {  		currentArg.Append ('\\');  	}  	if (escaping % 2 == 1) {  		// escapes the "  		currentArg.Append ('"');  		escaping = 0;  		start = index + 1;  		continue;  	}  }  else {  	var backslashes = escaping;  	for (int i = 0; i < backslashes; i++) {  		currentArg.Append ('\\');  	}  }  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: if (current == '"') {  	var backslashes = escaping / 2;  	for (int i = 0; i < backslashes; i++) {  		currentArg.Append ('\\');  	}  	if (escaping % 2 == 1) {  		// escapes the "  		currentArg.Append ('"');  		escaping = 0;  		start = index + 1;  		continue;  	}  }  else {  	var backslashes = escaping;  	for (int i = 0; i < backslashes; i++) {  		currentArg.Append ('\\');  	}  }  
Magic Number,Microsoft.Cci,OptionParsing,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\CommandLineOptions.cs,SplitLineWithQuotes,The following statement contains a magic number: if (escaping % 2 == 1) {  	// escapes the "  	currentArg.Append ('"');  	escaping = 0;  	start = index + 1;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {  	var dummyVersion = new Version (255' 255' 255' 255);  	lock (GlobalLock.LockingObject) {  		foreach (IUnit unit in this.unitCache.Values) {  			Contract.Assume (unit != null);  			AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;  			if (coreId.Name.Value.Length == 0)  				continue;  			this.coreIdentities.Add (coreId);  			if (result == null || result.Version == dummyVersion || (result.Version < coreId.Version && coreId.Version != dummyVersion) || result.Version == coreId.Version && unit.UnitIdentity.Equals (coreId)) {  				result = coreId;  				referringUnit = unit;  			}  		}  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {  	var dummyVersion = new Version (255' 255' 255' 255);  	lock (GlobalLock.LockingObject) {  		foreach (IUnit unit in this.unitCache.Values) {  			Contract.Assume (unit != null);  			AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;  			if (coreId.Name.Value.Length == 0)  				continue;  			this.coreIdentities.Add (coreId);  			if (result == null || result.Version == dummyVersion || (result.Version < coreId.Version && coreId.Version != dummyVersion) || result.Version == coreId.Version && unit.UnitIdentity.Equals (coreId)) {  				result = coreId;  				referringUnit = unit;  			}  		}  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {  	var dummyVersion = new Version (255' 255' 255' 255);  	lock (GlobalLock.LockingObject) {  		foreach (IUnit unit in this.unitCache.Values) {  			Contract.Assume (unit != null);  			AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;  			if (coreId.Name.Value.Length == 0)  				continue;  			this.coreIdentities.Add (coreId);  			if (result == null || result.Version == dummyVersion || (result.Version < coreId.Version && coreId.Version != dummyVersion) || result.Version == coreId.Version && unit.UnitIdentity.Equals (coreId)) {  				result = coreId;  				referringUnit = unit;  			}  		}  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (this.unitCache.Count > 0) {  	var dummyVersion = new Version (255' 255' 255' 255);  	lock (GlobalLock.LockingObject) {  		foreach (IUnit unit in this.unitCache.Values) {  			Contract.Assume (unit != null);  			AssemblyIdentity coreId = unit.CoreAssemblySymbolicIdentity;  			if (coreId.Name.Value.Length == 0)  				continue;  			this.coreIdentities.Add (coreId);  			if (result == null || result.Version == dummyVersion || (result.Version < coreId.Version && coreId.Version != dummyVersion) || result.Version == coreId.Version && unit.UnitIdentity.Equals (coreId)) {  				result = coreId;  				referringUnit = unit;  			}  		}  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: Contract.Ensures (Contract.Result<byte> () == 4 || Contract.Result<byte> () == 8);  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: Contract.Ensures (Contract.Result<byte> () == 4 || Contract.Result<byte> () == 8);  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: lock (GlobalLock.LockingObject) {  	if (this.unitCache.Count > 0) {  		foreach (IUnit unit in this.unitCache.Values) {  			IModule /*?*/module = unit as IModule;  			if (module == null)  				continue;  			if (module.Requires32bits)  				return 4;  			if (module.Requires64bits)  				return 8;  		}  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: lock (GlobalLock.LockingObject) {  	if (this.unitCache.Count > 0) {  		foreach (IUnit unit in this.unitCache.Values) {  			IModule /*?*/module = unit as IModule;  			if (module == null)  				continue;  			if (module.Requires32bits)  				return 4;  			if (module.Requires64bits)  				return 8;  		}  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: if (this.unitCache.Count > 0) {  	foreach (IUnit unit in this.unitCache.Values) {  		IModule /*?*/module = unit as IModule;  		if (module == null)  			continue;  		if (module.Requires32bits)  			return 4;  		if (module.Requires64bits)  			return 8;  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: if (this.unitCache.Count > 0) {  	foreach (IUnit unit in this.unitCache.Values) {  		IModule /*?*/module = unit as IModule;  		if (module == null)  			continue;  		if (module.Requires32bits)  			return 4;  		if (module.Requires64bits)  			return 8;  	}  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: foreach (IUnit unit in this.unitCache.Values) {  	IModule /*?*/module = unit as IModule;  	if (module == null)  		continue;  	if (module.Requires32bits)  		return 4;  	if (module.Requires64bits)  		return 8;  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: foreach (IUnit unit in this.unitCache.Values) {  	IModule /*?*/module = unit as IModule;  	if (module == null)  		continue;  	if (module.Requires32bits)  		return 4;  	if (module.Requires64bits)  		return 8;  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: if (module.Requires32bits)  	return 4;  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: if (module.Requires64bits)  	return 8;  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: return 8;  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetTargetPlatformPointerSize,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 1) {  	if (coreVersion.Minor == 0)  		platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v1.0.3705");  	else if (coreVersion.Minor == 1)  		platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v1.1.4322");  }  else if (coreVersion.Major == 2) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.5");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.0");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v2.0.50727");  }  else if (coreVersion.Major == 4) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v4.0.30319");  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 1) {  	if (coreVersion.Minor == 0)  		platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v1.0.3705");  	else if (coreVersion.Minor == 1)  		platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v1.1.4322");  }  else if (coreVersion.Major == 2) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.5");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.0");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v2.0.50727");  }  else if (coreVersion.Major == 4) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v4.0.30319");  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 2) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.5");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.0");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v2.0.50727");  }  else if (coreVersion.Major == 4) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v4.0.30319");  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 2) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.5");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v3.0");  	result = this.Probe (platformDir' referencedAssembly);  	if (result != null)  		return result;  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v2.0.50727");  }  else if (coreVersion.Major == 4) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v4.0.30319");  }  
Magic Number,Microsoft.Cci,MetadataHostEnvironment,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,ProbeAssemblyReference,The following statement contains a magic number: if (coreVersion.Major == 4) {  	platformDir = Path.Combine (Path.GetDirectoryName (platformDir) ?? ""' "v4.0.30319");  }  
Magic Number,Microsoft.Cci,IMetadataReaderHostContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: Contract.Ensures (Contract.Result<byte> () == 1 || Contract.Result<byte> () == 2 || Contract.Result<byte> () == 4 || Contract.Result<byte> () == 8);  
Magic Number,Microsoft.Cci,IMetadataReaderHostContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: Contract.Ensures (Contract.Result<byte> () == 1 || Contract.Result<byte> () == 2 || Contract.Result<byte> () == 4 || Contract.Result<byte> () == 8);  
Magic Number,Microsoft.Cci,IMetadataReaderHostContract,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: Contract.Ensures (Contract.Result<byte> () == 1 || Contract.Result<byte> () == 2 || Contract.Result<byte> () == 4 || Contract.Result<byte> () == 8);  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {  	var keys = new List<uint> (this.currentWildGuesses.Keys);  	foreach (var key in keys) {  		var oldValue = this.currentWildGuesses [key];  		if (oldValue == 4)  			this.currentWildGuesses [key] = 1;  		else if (oldValue == 1)  			this.currentWildGuesses [key] = 2;  		else if (oldValue == 2)  			this.currentWildGuesses [key] = 8;  		else {  			this.currentWildGuesses [key] = 4;  			continue;  		}  		allPermutationsHaveBeenTried = false;  		break;  	}  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {  	var keys = new List<uint> (this.currentWildGuesses.Keys);  	foreach (var key in keys) {  		var oldValue = this.currentWildGuesses [key];  		if (oldValue == 4)  			this.currentWildGuesses [key] = 1;  		else if (oldValue == 1)  			this.currentWildGuesses [key] = 2;  		else if (oldValue == 2)  			this.currentWildGuesses [key] = 8;  		else {  			this.currentWildGuesses [key] = 4;  			continue;  		}  		allPermutationsHaveBeenTried = false;  		break;  	}  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {  	var keys = new List<uint> (this.currentWildGuesses.Keys);  	foreach (var key in keys) {  		var oldValue = this.currentWildGuesses [key];  		if (oldValue == 4)  			this.currentWildGuesses [key] = 1;  		else if (oldValue == 1)  			this.currentWildGuesses [key] = 2;  		else if (oldValue == 2)  			this.currentWildGuesses [key] = 8;  		else {  			this.currentWildGuesses [key] = 4;  			continue;  		}  		allPermutationsHaveBeenTried = false;  		break;  	}  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {  	var keys = new List<uint> (this.currentWildGuesses.Keys);  	foreach (var key in keys) {  		var oldValue = this.currentWildGuesses [key];  		if (oldValue == 4)  			this.currentWildGuesses [key] = 1;  		else if (oldValue == 1)  			this.currentWildGuesses [key] = 2;  		else if (oldValue == 2)  			this.currentWildGuesses [key] = 8;  		else {  			this.currentWildGuesses [key] = 4;  			continue;  		}  		allPermutationsHaveBeenTried = false;  		break;  	}  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (this.currentWildGuesses != null) {  	var keys = new List<uint> (this.currentWildGuesses.Keys);  	foreach (var key in keys) {  		var oldValue = this.currentWildGuesses [key];  		if (oldValue == 4)  			this.currentWildGuesses [key] = 1;  		else if (oldValue == 1)  			this.currentWildGuesses [key] = 2;  		else if (oldValue == 2)  			this.currentWildGuesses [key] = 8;  		else {  			this.currentWildGuesses [key] = 4;  			continue;  		}  		allPermutationsHaveBeenTried = false;  		break;  	}  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: foreach (var key in keys) {  	var oldValue = this.currentWildGuesses [key];  	if (oldValue == 4)  		this.currentWildGuesses [key] = 1;  	else if (oldValue == 1)  		this.currentWildGuesses [key] = 2;  	else if (oldValue == 2)  		this.currentWildGuesses [key] = 8;  	else {  		this.currentWildGuesses [key] = 4;  		continue;  	}  	allPermutationsHaveBeenTried = false;  	break;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: foreach (var key in keys) {  	var oldValue = this.currentWildGuesses [key];  	if (oldValue == 4)  		this.currentWildGuesses [key] = 1;  	else if (oldValue == 1)  		this.currentWildGuesses [key] = 2;  	else if (oldValue == 2)  		this.currentWildGuesses [key] = 8;  	else {  		this.currentWildGuesses [key] = 4;  		continue;  	}  	allPermutationsHaveBeenTried = false;  	break;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: foreach (var key in keys) {  	var oldValue = this.currentWildGuesses [key];  	if (oldValue == 4)  		this.currentWildGuesses [key] = 1;  	else if (oldValue == 1)  		this.currentWildGuesses [key] = 2;  	else if (oldValue == 2)  		this.currentWildGuesses [key] = 8;  	else {  		this.currentWildGuesses [key] = 4;  		continue;  	}  	allPermutationsHaveBeenTried = false;  	break;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: foreach (var key in keys) {  	var oldValue = this.currentWildGuesses [key];  	if (oldValue == 4)  		this.currentWildGuesses [key] = 1;  	else if (oldValue == 1)  		this.currentWildGuesses [key] = 2;  	else if (oldValue == 2)  		this.currentWildGuesses [key] = 8;  	else {  		this.currentWildGuesses [key] = 4;  		continue;  	}  	allPermutationsHaveBeenTried = false;  	break;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: foreach (var key in keys) {  	var oldValue = this.currentWildGuesses [key];  	if (oldValue == 4)  		this.currentWildGuesses [key] = 1;  	else if (oldValue == 1)  		this.currentWildGuesses [key] = 2;  	else if (oldValue == 2)  		this.currentWildGuesses [key] = 8;  	else {  		this.currentWildGuesses [key] = 4;  		continue;  	}  	allPermutationsHaveBeenTried = false;  	break;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 4)  	this.currentWildGuesses [key] = 1;  else if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 4)  	this.currentWildGuesses [key] = 1;  else if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 4)  	this.currentWildGuesses [key] = 1;  else if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 4)  	this.currentWildGuesses [key] = 1;  else if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 4)  	this.currentWildGuesses [key] = 1;  else if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 1)  	this.currentWildGuesses [key] = 2;  else if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: this.currentWildGuesses [key] = 2;  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (oldValue == 2)  	this.currentWildGuesses [key] = 8;  else {  	this.currentWildGuesses [key] = 4;  	continue;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: this.currentWildGuesses [key] = 8;  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: this.currentWildGuesses [key] = 4;  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: if (allPermutationsHaveBeenTried && this.currentGoodGuesses != null) {  	if (this.currentWildGuesses == null)  		this.currentWildGuesses = new Dictionary<uint' byte> ();  	foreach (var key in this.currentGoodGuesses.Keys) {  		allPermutationsHaveBeenTried = false;  		this.currentWildGuesses [key] = 4;  	}  	this.currentGoodGuesses = null;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: foreach (var key in this.currentGoodGuesses.Keys) {  	allPermutationsHaveBeenTried = false;  	this.currentWildGuesses [key] = 4;  }  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,TryNextPermutation,The following statement contains a magic number: this.currentWildGuesses [key] = 4;  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: this.currentWildGuesses [rkey] = 4;  
Magic Number,Microsoft.Cci,MetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodParameterReferenceInternId,The following statement contains a magic number: if (!(this.CurrentMethodReference is Dummy)) {  	//this happens when the defining method reference contains a type in its signature which either is' or contains'  	//a reference to this generic method type parameter. In that case we break the cycle by just using the index of   	//the generic parameter. Only method references that refer to their own type parameters will ever  	//get this version of the interned id.  	return index + 1000000;  	//provide a big offset to minimize the chances of a structural type in the   	//signature of the method interning onto some other type that is parameterized by a type whose intern key is index.  }  
Magic Number,Microsoft.Cci,InternFactory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetGenericMethodParameterReferenceInternId,The following statement contains a magic number: return index + 1000000;  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {  	IName /*?*/result;  	if (this.caseSensitiveTable.TryGetValue (name' out result)) {  		//^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.  		//^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.  		return result;  	}  	//string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?  	int caseInsensitiveCounter;  	if (!this.caseInsensitiveTable.TryGetValue (name' out caseInsensitiveCounter)) {  		caseInsensitiveCounter = this.caseInsensitiveCounter;  		caseInsensitiveCounter += 17;  		if (caseInsensitiveCounter <= 0) {  			caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  		}  		this.caseInsensitiveCounter = caseInsensitiveCounter;  		this.caseInsensitiveTable.Add (name' caseInsensitiveCounter);  	}  	//^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.  	int caseSensitiveCounter = this.caseSensitiveCounter;  	caseSensitiveCounter += 17;  	if (caseSensitiveCounter <= 0) {  		caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;  		//^ assume caseSensitiveCounter > 0;  	}  	result = new Name (caseInsensitiveCounter' caseSensitiveCounter' name);  	//^ assume result.Value == name;  	this.caseSensitiveCounter = caseSensitiveCounter;  	this.caseSensitiveTable.Add (name' result);  	return result;  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {  	IName /*?*/result;  	if (this.caseSensitiveTable.TryGetValue (name' out result)) {  		//^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.  		//^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.  		return result;  	}  	//string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?  	int caseInsensitiveCounter;  	if (!this.caseInsensitiveTable.TryGetValue (name' out caseInsensitiveCounter)) {  		caseInsensitiveCounter = this.caseInsensitiveCounter;  		caseInsensitiveCounter += 17;  		if (caseInsensitiveCounter <= 0) {  			caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  		}  		this.caseInsensitiveCounter = caseInsensitiveCounter;  		this.caseInsensitiveTable.Add (name' caseInsensitiveCounter);  	}  	//^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.  	int caseSensitiveCounter = this.caseSensitiveCounter;  	caseSensitiveCounter += 17;  	if (caseSensitiveCounter <= 0) {  		caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;  		//^ assume caseSensitiveCounter > 0;  	}  	result = new Name (caseInsensitiveCounter' caseSensitiveCounter' name);  	//^ assume result.Value == name;  	this.caseSensitiveCounter = caseSensitiveCounter;  	this.caseSensitiveTable.Add (name' result);  	return result;  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {  	IName /*?*/result;  	if (this.caseSensitiveTable.TryGetValue (name' out result)) {  		//^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.  		//^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.  		return result;  	}  	//string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?  	int caseInsensitiveCounter;  	if (!this.caseInsensitiveTable.TryGetValue (name' out caseInsensitiveCounter)) {  		caseInsensitiveCounter = this.caseInsensitiveCounter;  		caseInsensitiveCounter += 17;  		if (caseInsensitiveCounter <= 0) {  			caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  		}  		this.caseInsensitiveCounter = caseInsensitiveCounter;  		this.caseInsensitiveTable.Add (name' caseInsensitiveCounter);  	}  	//^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.  	int caseSensitiveCounter = this.caseSensitiveCounter;  	caseSensitiveCounter += 17;  	if (caseSensitiveCounter <= 0) {  		caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;  		//^ assume caseSensitiveCounter > 0;  	}  	result = new Name (caseInsensitiveCounter' caseSensitiveCounter' name);  	//^ assume result.Value == name;  	this.caseSensitiveCounter = caseSensitiveCounter;  	this.caseSensitiveTable.Add (name' result);  	return result;  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: lock (this.caseInsensitiveTable) {  	IName /*?*/result;  	if (this.caseSensitiveTable.TryGetValue (name' out result)) {  		//^ assume result != null; //Follows from the way Dictionary is instantiated' but the verifier is ignorant of this.  		//^ assume result.Value == name; //Only this routine ever adds entries to the table and it only ever adds entries for which this is true. TODO: it would be nice to be able express this as an invariant.  		return result;  	}  	//string lowerCaseName = name.ToLower(CultureInfo.InvariantCulture); //REVIEW: is it safer to use ToUpperInvariant' or does it make no difference?  	int caseInsensitiveCounter;  	if (!this.caseInsensitiveTable.TryGetValue (name' out caseInsensitiveCounter)) {  		caseInsensitiveCounter = this.caseInsensitiveCounter;  		caseInsensitiveCounter += 17;  		if (caseInsensitiveCounter <= 0) {  			caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  		}  		this.caseInsensitiveCounter = caseInsensitiveCounter;  		this.caseInsensitiveTable.Add (name' caseInsensitiveCounter);  	}  	//^ assume caseInsensitiveCounter > 0; //Follows from the invariant' but this is beyond the verifier right now.  	int caseSensitiveCounter = this.caseSensitiveCounter;  	caseSensitiveCounter += 17;  	if (caseSensitiveCounter <= 0) {  		caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;  		//^ assume caseSensitiveCounter > 0;  	}  	result = new Name (caseInsensitiveCounter' caseSensitiveCounter' name);  	//^ assume result.Value == name;  	this.caseSensitiveCounter = caseSensitiveCounter;  	this.caseSensitiveTable.Add (name' result);  	return result;  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: if (!this.caseInsensitiveTable.TryGetValue (name' out caseInsensitiveCounter)) {  	caseInsensitiveCounter = this.caseInsensitiveCounter;  	caseInsensitiveCounter += 17;  	if (caseInsensitiveCounter <= 0) {  		caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  	}  	this.caseInsensitiveCounter = caseInsensitiveCounter;  	this.caseInsensitiveTable.Add (name' caseInsensitiveCounter);  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: if (!this.caseInsensitiveTable.TryGetValue (name' out caseInsensitiveCounter)) {  	caseInsensitiveCounter = this.caseInsensitiveCounter;  	caseInsensitiveCounter += 17;  	if (caseInsensitiveCounter <= 0) {  		caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  	}  	this.caseInsensitiveCounter = caseInsensitiveCounter;  	this.caseInsensitiveTable.Add (name' caseInsensitiveCounter);  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: caseInsensitiveCounter += 17;  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: if (caseInsensitiveCounter <= 0) {  	caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: caseInsensitiveCounter = (caseInsensitiveCounter - int.MinValue) + 1000000;  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: caseSensitiveCounter += 17;  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: if (caseSensitiveCounter <= 0) {  	caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;  	//^ assume caseSensitiveCounter > 0;  }  
Magic Number,Microsoft.Cci,NameTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Core.cs,GetNameFor,The following statement contains a magic number: caseSensitiveCounter = (caseSensitiveCounter - int.MinValue) + 1000000;  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;  	if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  		ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  		return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  	}  	else {  		IFieldDefinition /*?*/f = member as IFieldDefinition;  		if (f == null || f.IsStatic)  			continue;  		if (f.Type.ResolvedType == item)  			continue;  		// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  		ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  		if (f == item) {  			if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  				return (result - bitOffset) / 8;  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  		}  		uint fieldSize;  		if (f.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = f.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  		}  		result += fieldSize;  	}  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;  	if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  		ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  		return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  	}  	else {  		IFieldDefinition /*?*/f = member as IFieldDefinition;  		if (f == null || f.IsStatic)  			continue;  		if (f.Type.ResolvedType == item)  			continue;  		// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  		ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  		if (f == item) {  			if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  				return (result - bitOffset) / 8;  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  		}  		uint fieldSize;  		if (f.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = f.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  		}  		result += fieldSize;  	}  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;  	if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  		ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  		return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  	}  	else {  		IFieldDefinition /*?*/f = member as IFieldDefinition;  		if (f == null || f.IsStatic)  			continue;  		if (f.Type.ResolvedType == item)  			continue;  		// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  		ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  		if (f == item) {  			if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  				return (result - bitOffset) / 8;  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  		}  		uint fieldSize;  		if (f.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = f.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  		}  		result += fieldSize;  	}  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;  	if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  		ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  		return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  	}  	else {  		IFieldDefinition /*?*/f = member as IFieldDefinition;  		if (f == null || f.IsStatic)  			continue;  		if (f.Type.ResolvedType == item)  			continue;  		// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  		ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  		if (f == item) {  			if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  				return (result - bitOffset) / 8;  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  		}  		uint fieldSize;  		if (f.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = f.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  		}  		result += fieldSize;  	}  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;  	if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  		ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  		return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  	}  	else {  		IFieldDefinition /*?*/f = member as IFieldDefinition;  		if (f == null || f.IsStatic)  			continue;  		if (f.Type.ResolvedType == item)  			continue;  		// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  		ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  		if (f == item) {  			if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  				return (result - bitOffset) / 8;  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  		}  		uint fieldSize;  		if (f.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = f.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  		}  		result += fieldSize;  	}  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	INestedTypeDefinition fieldAsTypeDef = member as INestedTypeDefinition;  	if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  		ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  		return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  	}  	else {  		IFieldDefinition /*?*/f = member as IFieldDefinition;  		if (f == null || f.IsStatic)  			continue;  		if (f.Type.ResolvedType == item)  			continue;  		// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  		ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  		if (f == item) {  			if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  				return (result - bitOffset) / 8;  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  		}  		uint fieldSize;  		if (f.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = f.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  		}  		result += fieldSize;  	}  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  	ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  	return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  }  else {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	if (f.Type.ResolvedType == item)  		continue;  	// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == item) {  		if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  			return (result - bitOffset) / 8;  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  	ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  	return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  }  else {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	if (f.Type.ResolvedType == item)  		continue;  	// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == item) {  		if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  			return (result - bitOffset) / 8;  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  	ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  	return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  }  else {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	if (f.Type.ResolvedType == item)  		continue;  	// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == item) {  		if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  			return (result - bitOffset) / 8;  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  	ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  	return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  }  else {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	if (f.Type.ResolvedType == item)  		continue;  	// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == item) {  		if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  			return (result - bitOffset) / 8;  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  	ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  	return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  }  else {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	if (f.Type.ResolvedType == item)  		continue;  	// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == item) {  		if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  			return (result - bitOffset) / 8;  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (fieldAsTypeDef != null && fieldAsTypeDef == item) {  	ushort typeAlignment = (ushort)(TypeHelper.TypeAlignment (fieldAsTypeDef.ResolvedType) * 8);  	return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  }  else {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	if (f.Type.ResolvedType == item)  		continue;  	// in case we are calculating the offset of an anonymous type' skip the implicit field of that type  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == item) {  		if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  			return (result - bitOffset) / 8;  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: return (((result + typeAlignment - 1) / typeAlignment) * typeAlignment) / 8;  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (f == item) {  	if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  		return (result - bitOffset) / 8;  	if (bitFieldAlignment > fieldAlignment)  		fieldAlignment = bitFieldAlignment;  	return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (f == item) {  	if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  		return (result - bitOffset) / 8;  	if (bitFieldAlignment > fieldAlignment)  		fieldAlignment = bitFieldAlignment;  	return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (f.IsBitField && bitOffset > 0 && bitOffset + f.BitLength <= bitFieldAlignment)  	return (result - bitOffset) / 8;  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: return (result - bitOffset) / 8;  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: return (((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment) / 8;  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: if (f.IsBitField) {  	bitFieldAlignment = fieldAlignment;  	fieldSize = f.BitLength;  	if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  		bitOffset = 0;  	if (bitOffset == 0 || fieldSize == 0) {  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		bitOffset = 0;  	}  	bitOffset += fieldSize;  }  else {  	if (bitFieldAlignment > fieldAlignment)  		fieldAlignment = bitFieldAlignment;  	bitFieldAlignment = 0;  	bitOffset = 0;  	result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  	fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,ComputeFieldOffset,The following statement contains a magic number: fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == field) {  		if (f.IsBitField) {  			if (bitOffset > 0 && bitOffset + f.BitLength > bitFieldAlignment)  				bitOffset = 0;  			return bitOffset;  		}  		return 0;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	IFieldDefinition /*?*/f = member as IFieldDefinition;  	if (f == null || f.IsStatic)  		continue;  	ushort fieldAlignment = (ushort)(TypeHelper.TypeAlignment (f.Type.ResolvedType) * 8);  	if (f == field) {  		if (f.IsBitField) {  			if (bitOffset > 0 && bitOffset + f.BitLength > bitFieldAlignment)  				bitOffset = 0;  			return bitOffset;  		}  		return 0;  	}  	uint fieldSize;  	if (f.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = f.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The following statement contains a magic number: if (f.IsBitField) {  	bitFieldAlignment = fieldAlignment;  	fieldSize = f.BitLength;  	if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  		bitOffset = 0;  	if (bitOffset == 0 || fieldSize == 0) {  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		bitOffset = 0;  	}  	bitOffset += fieldSize;  }  else {  	if (bitFieldAlignment > fieldAlignment)  		fieldAlignment = bitFieldAlignment;  	bitFieldAlignment = 0;  	bitOffset = 0;  	result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  	fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  }  
Magic Number,Microsoft.Cci,MemberHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,GetFieldBitOffset,The following statement contains a magic number: fieldSize = TypeHelper.SizeOfType (f.Type.ResolvedType) * 8;  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (method.ResolvedMethod.IsSpecialName && (formattingOptions & NameFormattingOptions.PreserveSpecialNames) == 0) {  	if (methodName.StartsWith ("get_"' StringComparison.Ordinal)) {  		//^ assume methodName.Length >= 4;  		sb.Append (methodName.Substring (4));  		sb.Append (".get");  	}  	else if (methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  		//^ assume methodName.Length >= 4;  		sb.Append (methodName.Substring (4));  		sb.Append (".set");  	}  	else {  		sb.Append (methodName);  	}  }  else  	sb.Append (methodName);  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (method.ResolvedMethod.IsSpecialName && (formattingOptions & NameFormattingOptions.PreserveSpecialNames) == 0) {  	if (methodName.StartsWith ("get_"' StringComparison.Ordinal)) {  		//^ assume methodName.Length >= 4;  		sb.Append (methodName.Substring (4));  		sb.Append (".get");  	}  	else if (methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  		//^ assume methodName.Length >= 4;  		sb.Append (methodName.Substring (4));  		sb.Append (".set");  	}  	else {  		sb.Append (methodName);  	}  }  else  	sb.Append (methodName);  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (methodName.StartsWith ("get_"' StringComparison.Ordinal)) {  	//^ assume methodName.Length >= 4;  	sb.Append (methodName.Substring (4));  	sb.Append (".get");  }  else if (methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  	//^ assume methodName.Length >= 4;  	sb.Append (methodName.Substring (4));  	sb.Append (".set");  }  else {  	sb.Append (methodName);  }  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (methodName.StartsWith ("get_"' StringComparison.Ordinal)) {  	//^ assume methodName.Length >= 4;  	sb.Append (methodName.Substring (4));  	sb.Append (".get");  }  else if (methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  	//^ assume methodName.Length >= 4;  	sb.Append (methodName.Substring (4));  	sb.Append (".set");  }  else {  	sb.Append (methodName);  }  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: sb.Append (methodName.Substring (4));  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: if (methodName.StartsWith ("set_"' StringComparison.Ordinal)) {  	//^ assume methodName.Length >= 4;  	sb.Append (methodName.Substring (4));  	sb.Append (".set");  }  else {  	sb.Append (methodName);  }  
Magic Number,Microsoft.Cci,SignatureFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\MemberHelper.cs,AppendMethodName,The following statement contains a magic number: sb.Append (methodName.Substring (4));  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return sizeof(Boolean);  case PrimitiveTypeCode.Char:  	return sizeof(Char);  case PrimitiveTypeCode.Int16:  	return sizeof(Int16);  case PrimitiveTypeCode.Int32:  	return sizeof(Int32);  case PrimitiveTypeCode.Int8:  	return sizeof(SByte);  case PrimitiveTypeCode.UInt16:  	return sizeof(UInt16);  case PrimitiveTypeCode.UInt32:  	return sizeof(UInt32);  case PrimitiveTypeCode.UInt8:  	return sizeof(Byte);  case PrimitiveTypeCode.Int64:  	return sizeof(Int64);  case PrimitiveTypeCode.UInt64:  	return sizeof(UInt64);  case PrimitiveTypeCode.IntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.UIntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Float32:  	return sizeof(Single);  case PrimitiveTypeCode.Float64:  	return sizeof(Double);  case PrimitiveTypeCode.Pointer:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Invalid:  	return 1;  default:  	if (type.IsEnum && type.ResolvedType.IsEnum) {  		if (TypeHelper.TypesAreEquivalent (rootType' type.ResolvedType.UnderlyingType' true))  			return 0;  		return TypeHelper.SizeOfType (type.ResolvedType.UnderlyingType);  	}  	uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;  	if (result > 0)  		return result;  	IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;  	if (type.ResolvedType.Layout == LayoutKind.Sequential) {  		List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members));  		fields.Sort (delegate (IFieldDefinition f1' IFieldDefinition f2) {  			return f1.SequenceNumber - f2.SequenceNumber;  		});  		members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember> (fields);  		Contract.Assume (members != null);  	}  	//Sum up the bit sizes  	result = 0;  	uint bitOffset = 0;  	ushort bitFieldAlignment = 0;  	Contract.Assume (members != null);  	foreach (ITypeDefinitionMember member in members) {  		IFieldDefinition /*?*/field = member as IFieldDefinition;  		if (field == null || field.IsStatic)  			continue;  		ITypeDefinition fieldType = field.Type.ResolvedType;  		ushort fieldAlignment;  		if (rootType == fieldType || fieldType.IsReferenceType)  			fieldAlignment = type.PlatformType.PointerSize;  		else  			fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  		uint fieldSize;  		if (field.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = field.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			if (rootType == fieldType || fieldType.IsReferenceType)  				fieldSize = type.PlatformType.PointerSize * 8u;  			else  				fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  		}  		result += fieldSize;  	}  	//Convert bit size to bytes and pad to be a multiple of the type alignment.  	result = (result + 7) / 8;  	uint typeAlignment = TypeHelper.TypeAlignment (type);  	return ((result + typeAlignment - 1) / typeAlignment) * typeAlignment;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return sizeof(Boolean);  case PrimitiveTypeCode.Char:  	return sizeof(Char);  case PrimitiveTypeCode.Int16:  	return sizeof(Int16);  case PrimitiveTypeCode.Int32:  	return sizeof(Int32);  case PrimitiveTypeCode.Int8:  	return sizeof(SByte);  case PrimitiveTypeCode.UInt16:  	return sizeof(UInt16);  case PrimitiveTypeCode.UInt32:  	return sizeof(UInt32);  case PrimitiveTypeCode.UInt8:  	return sizeof(Byte);  case PrimitiveTypeCode.Int64:  	return sizeof(Int64);  case PrimitiveTypeCode.UInt64:  	return sizeof(UInt64);  case PrimitiveTypeCode.IntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.UIntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Float32:  	return sizeof(Single);  case PrimitiveTypeCode.Float64:  	return sizeof(Double);  case PrimitiveTypeCode.Pointer:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Invalid:  	return 1;  default:  	if (type.IsEnum && type.ResolvedType.IsEnum) {  		if (TypeHelper.TypesAreEquivalent (rootType' type.ResolvedType.UnderlyingType' true))  			return 0;  		return TypeHelper.SizeOfType (type.ResolvedType.UnderlyingType);  	}  	uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;  	if (result > 0)  		return result;  	IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;  	if (type.ResolvedType.Layout == LayoutKind.Sequential) {  		List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members));  		fields.Sort (delegate (IFieldDefinition f1' IFieldDefinition f2) {  			return f1.SequenceNumber - f2.SequenceNumber;  		});  		members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember> (fields);  		Contract.Assume (members != null);  	}  	//Sum up the bit sizes  	result = 0;  	uint bitOffset = 0;  	ushort bitFieldAlignment = 0;  	Contract.Assume (members != null);  	foreach (ITypeDefinitionMember member in members) {  		IFieldDefinition /*?*/field = member as IFieldDefinition;  		if (field == null || field.IsStatic)  			continue;  		ITypeDefinition fieldType = field.Type.ResolvedType;  		ushort fieldAlignment;  		if (rootType == fieldType || fieldType.IsReferenceType)  			fieldAlignment = type.PlatformType.PointerSize;  		else  			fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  		uint fieldSize;  		if (field.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = field.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			if (rootType == fieldType || fieldType.IsReferenceType)  				fieldSize = type.PlatformType.PointerSize * 8u;  			else  				fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  		}  		result += fieldSize;  	}  	//Convert bit size to bytes and pad to be a multiple of the type alignment.  	result = (result + 7) / 8;  	uint typeAlignment = TypeHelper.TypeAlignment (type);  	return ((result + typeAlignment - 1) / typeAlignment) * typeAlignment;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return sizeof(Boolean);  case PrimitiveTypeCode.Char:  	return sizeof(Char);  case PrimitiveTypeCode.Int16:  	return sizeof(Int16);  case PrimitiveTypeCode.Int32:  	return sizeof(Int32);  case PrimitiveTypeCode.Int8:  	return sizeof(SByte);  case PrimitiveTypeCode.UInt16:  	return sizeof(UInt16);  case PrimitiveTypeCode.UInt32:  	return sizeof(UInt32);  case PrimitiveTypeCode.UInt8:  	return sizeof(Byte);  case PrimitiveTypeCode.Int64:  	return sizeof(Int64);  case PrimitiveTypeCode.UInt64:  	return sizeof(UInt64);  case PrimitiveTypeCode.IntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.UIntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Float32:  	return sizeof(Single);  case PrimitiveTypeCode.Float64:  	return sizeof(Double);  case PrimitiveTypeCode.Pointer:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Invalid:  	return 1;  default:  	if (type.IsEnum && type.ResolvedType.IsEnum) {  		if (TypeHelper.TypesAreEquivalent (rootType' type.ResolvedType.UnderlyingType' true))  			return 0;  		return TypeHelper.SizeOfType (type.ResolvedType.UnderlyingType);  	}  	uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;  	if (result > 0)  		return result;  	IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;  	if (type.ResolvedType.Layout == LayoutKind.Sequential) {  		List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members));  		fields.Sort (delegate (IFieldDefinition f1' IFieldDefinition f2) {  			return f1.SequenceNumber - f2.SequenceNumber;  		});  		members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember> (fields);  		Contract.Assume (members != null);  	}  	//Sum up the bit sizes  	result = 0;  	uint bitOffset = 0;  	ushort bitFieldAlignment = 0;  	Contract.Assume (members != null);  	foreach (ITypeDefinitionMember member in members) {  		IFieldDefinition /*?*/field = member as IFieldDefinition;  		if (field == null || field.IsStatic)  			continue;  		ITypeDefinition fieldType = field.Type.ResolvedType;  		ushort fieldAlignment;  		if (rootType == fieldType || fieldType.IsReferenceType)  			fieldAlignment = type.PlatformType.PointerSize;  		else  			fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  		uint fieldSize;  		if (field.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = field.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			if (rootType == fieldType || fieldType.IsReferenceType)  				fieldSize = type.PlatformType.PointerSize * 8u;  			else  				fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  		}  		result += fieldSize;  	}  	//Convert bit size to bytes and pad to be a multiple of the type alignment.  	result = (result + 7) / 8;  	uint typeAlignment = TypeHelper.TypeAlignment (type);  	return ((result + typeAlignment - 1) / typeAlignment) * typeAlignment;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return sizeof(Boolean);  case PrimitiveTypeCode.Char:  	return sizeof(Char);  case PrimitiveTypeCode.Int16:  	return sizeof(Int16);  case PrimitiveTypeCode.Int32:  	return sizeof(Int32);  case PrimitiveTypeCode.Int8:  	return sizeof(SByte);  case PrimitiveTypeCode.UInt16:  	return sizeof(UInt16);  case PrimitiveTypeCode.UInt32:  	return sizeof(UInt32);  case PrimitiveTypeCode.UInt8:  	return sizeof(Byte);  case PrimitiveTypeCode.Int64:  	return sizeof(Int64);  case PrimitiveTypeCode.UInt64:  	return sizeof(UInt64);  case PrimitiveTypeCode.IntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.UIntPtr:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Float32:  	return sizeof(Single);  case PrimitiveTypeCode.Float64:  	return sizeof(Double);  case PrimitiveTypeCode.Pointer:  	return type.PlatformType.PointerSize;  case PrimitiveTypeCode.Invalid:  	return 1;  default:  	if (type.IsEnum && type.ResolvedType.IsEnum) {  		if (TypeHelper.TypesAreEquivalent (rootType' type.ResolvedType.UnderlyingType' true))  			return 0;  		return TypeHelper.SizeOfType (type.ResolvedType.UnderlyingType);  	}  	uint result = mayUseSizeOfProperty ? type.ResolvedType.SizeOf : 0;  	if (result > 0)  		return result;  	IEnumerable<ITypeDefinitionMember> members = type.ResolvedType.Members;  	if (type.ResolvedType.Layout == LayoutKind.Sequential) {  		List<IFieldDefinition> fields = new List<IFieldDefinition> (IteratorHelper.GetFilterEnumerable<ITypeDefinitionMember' IFieldDefinition> (members));  		fields.Sort (delegate (IFieldDefinition f1' IFieldDefinition f2) {  			return f1.SequenceNumber - f2.SequenceNumber;  		});  		members = IteratorHelper.GetConversionEnumerable<IFieldDefinition' ITypeDefinitionMember> (fields);  		Contract.Assume (members != null);  	}  	//Sum up the bit sizes  	result = 0;  	uint bitOffset = 0;  	ushort bitFieldAlignment = 0;  	Contract.Assume (members != null);  	foreach (ITypeDefinitionMember member in members) {  		IFieldDefinition /*?*/field = member as IFieldDefinition;  		if (field == null || field.IsStatic)  			continue;  		ITypeDefinition fieldType = field.Type.ResolvedType;  		ushort fieldAlignment;  		if (rootType == fieldType || fieldType.IsReferenceType)  			fieldAlignment = type.PlatformType.PointerSize;  		else  			fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  		uint fieldSize;  		if (field.IsBitField) {  			bitFieldAlignment = fieldAlignment;  			fieldSize = field.BitLength;  			if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  				bitOffset = 0;  			if (bitOffset == 0 || fieldSize == 0) {  				result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  				bitOffset = 0;  			}  			bitOffset += fieldSize;  		}  		else {  			if (bitFieldAlignment > fieldAlignment)  				fieldAlignment = bitFieldAlignment;  			bitFieldAlignment = 0;  			bitOffset = 0;  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			if (rootType == fieldType || fieldType.IsReferenceType)  				fieldSize = type.PlatformType.PointerSize * 8u;  			else  				fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  		}  		result += fieldSize;  	}  	//Convert bit size to bytes and pad to be a multiple of the type alignment.  	result = (result + 7) / 8;  	uint typeAlignment = TypeHelper.TypeAlignment (type);  	return ((result + typeAlignment - 1) / typeAlignment) * typeAlignment;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	IFieldDefinition /*?*/field = member as IFieldDefinition;  	if (field == null || field.IsStatic)  		continue;  	ITypeDefinition fieldType = field.Type.ResolvedType;  	ushort fieldAlignment;  	if (rootType == fieldType || fieldType.IsReferenceType)  		fieldAlignment = type.PlatformType.PointerSize;  	else  		fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  	uint fieldSize;  	if (field.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = field.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		if (rootType == fieldType || fieldType.IsReferenceType)  			fieldSize = type.PlatformType.PointerSize * 8u;  		else  			fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: foreach (ITypeDefinitionMember member in members) {  	IFieldDefinition /*?*/field = member as IFieldDefinition;  	if (field == null || field.IsStatic)  		continue;  	ITypeDefinition fieldType = field.Type.ResolvedType;  	ushort fieldAlignment;  	if (rootType == fieldType || fieldType.IsReferenceType)  		fieldAlignment = type.PlatformType.PointerSize;  	else  		fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  	uint fieldSize;  	if (field.IsBitField) {  		bitFieldAlignment = fieldAlignment;  		fieldSize = field.BitLength;  		if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  			bitOffset = 0;  		if (bitOffset == 0 || fieldSize == 0) {  			result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  			bitOffset = 0;  		}  		bitOffset += fieldSize;  	}  	else {  		if (bitFieldAlignment > fieldAlignment)  			fieldAlignment = bitFieldAlignment;  		bitFieldAlignment = 0;  		bitOffset = 0;  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		if (rootType == fieldType || fieldType.IsReferenceType)  			fieldSize = type.PlatformType.PointerSize * 8u;  		else  			fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  	}  	result += fieldSize;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: if (rootType == fieldType || fieldType.IsReferenceType)  	fieldAlignment = type.PlatformType.PointerSize;  else  	fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: fieldAlignment = (ushort)(TypeHelper.TypeAlignment (fieldType) * 8);  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: if (field.IsBitField) {  	bitFieldAlignment = fieldAlignment;  	fieldSize = field.BitLength;  	if (bitOffset > 0 && bitOffset + fieldSize > fieldAlignment)  		bitOffset = 0;  	if (bitOffset == 0 || fieldSize == 0) {  		result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  		bitOffset = 0;  	}  	bitOffset += fieldSize;  }  else {  	if (bitFieldAlignment > fieldAlignment)  		fieldAlignment = bitFieldAlignment;  	bitFieldAlignment = 0;  	bitOffset = 0;  	result = ((result + fieldAlignment - 1) / fieldAlignment) * fieldAlignment;  	if (rootType == fieldType || fieldType.IsReferenceType)  		fieldSize = type.PlatformType.PointerSize * 8u;  	else  		fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  }  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: if (rootType == fieldType || fieldType.IsReferenceType)  	fieldSize = type.PlatformType.PointerSize * 8u;  else  	fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: fieldSize = TypeHelper.SizeOfType (fieldType' rootType' mayUseSizeOfProperty: true) * 8;  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: result = (result + 7) / 8;  
Magic Number,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,SizeOfType,The following statement contains a magic number: result = (result + 7) / 8;  
Magic Number,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceTypeName,The following statement contains a magic number: if ((formattingOptions & NameFormattingOptions.SupressAttributeSuffix) != 0 && AttributeHelper.IsAttributeType (nsType.ResolvedType) & tname.EndsWith ("Attribute"' StringComparison.Ordinal))  	tname = tname.Substring (0' tname.Length - 9);  
Magic Number,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNamespaceTypeName,The following statement contains a magic number: tname = tname.Substring (0' tname.Length - 9);  
Magic Number,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNestedTypeName,The following statement contains a magic number: if ((formattingOptions & NameFormattingOptions.SupressAttributeSuffix) != 0 && AttributeHelper.IsAttributeType (nestedType.ResolvedType) & tname.EndsWith ("Attribute"' StringComparison.Ordinal))  	tname = tname.Substring (0' tname.Length - 9);  
Magic Number,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetNestedTypeName,The following statement contains a magic number: tname = tname.Substring (0' tname.Length - 9);  
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Contract.Assert (startIndex + 8 <= hash.GetLowerBound (0) + hash.Length);  
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Array.Copy (hash' startIndex' publicKeyToken' 0' 8);  
Magic Number,Microsoft.Cci,UnitHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UnitHelper.cs,ComputePublicKeyToken,The following statement contains a magic number: Array.Reverse (publicKeyToken' 0' 8);  
Magic Number,Microsoft.Cci,ObjectModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Miscellaneous.cs,CaseInsensitiveStringHash,The following statement contains a magic number: for (int i = 0' n = s.Length; i < n; i++) {  	char ch = s [i];  	ch = Char.ToLower (ch' CultureInfo.InvariantCulture);  	hashCode = hashCode * 17 + ch;  }  
Magic Number,Microsoft.Cci,ObjectModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Miscellaneous.cs,CaseInsensitiveStringHash,The following statement contains a magic number: hashCode = hashCode * 17 + ch;  
Magic Number,Microsoft.Cci,ObjectModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Miscellaneous.cs,CaseSensitiveStringHash,The following statement contains a magic number: for (int i = 0' n = s.Length; i < n; i++) {  	char ch = s [i];  	hashCode = hashCode * 17 + ch;  }  
Magic Number,Microsoft.Cci,ObjectModelHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Miscellaneous.cs,CaseSensitiveStringHash,The following statement contains a magic number: hashCode = hashCode * 17 + ch;  
Magic Number,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 8) ^ (this.version.Major << 6) ^ (this.version.Minor << 4) ^ (this.version.MajorRevision << 2) ^ this.version.MinorRevision;  
Magic Number,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 8) ^ (this.version.Major << 6) ^ (this.version.Minor << 4) ^ (this.version.MajorRevision << 2) ^ this.version.MinorRevision;  
Magic Number,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 8) ^ (this.version.Major << 6) ^ (this.version.Minor << 4) ^ (this.version.MajorRevision << 2) ^ this.version.MinorRevision;  
Magic Number,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 8) ^ (this.version.Major << 6) ^ (this.version.Minor << 4) ^ (this.version.MajorRevision << 2) ^ this.version.MinorRevision;  
Magic Number,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: if (this.Culture.Length > 0)  	hash = (hash << 4) ^ ObjectModelHelper.CaseInsensitiveStringHash (this.Culture);  
Magic Number,Microsoft.Cci,AssemblyIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 4) ^ ObjectModelHelper.CaseInsensitiveStringHash (this.Culture);  
Magic Number,Microsoft.Cci,ModuleIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: if (this.ContainingAssembly != null)  	hash = (hash << 4) ^ this.ContainingAssembly.GetHashCode ();  else if (this.Location.Length > 0)  	hash = (hash << 4) ^ ObjectModelHelper.CaseInsensitiveStringHash (this.Location);  
Magic Number,Microsoft.Cci,ModuleIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: if (this.ContainingAssembly != null)  	hash = (hash << 4) ^ this.ContainingAssembly.GetHashCode ();  else if (this.Location.Length > 0)  	hash = (hash << 4) ^ ObjectModelHelper.CaseInsensitiveStringHash (this.Location);  
Magic Number,Microsoft.Cci,ModuleIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 4) ^ this.ContainingAssembly.GetHashCode ();  
Magic Number,Microsoft.Cci,ModuleIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: if (this.Location.Length > 0)  	hash = (hash << 4) ^ ObjectModelHelper.CaseInsensitiveStringHash (this.Location);  
Magic Number,Microsoft.Cci,ModuleIdentity,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataModel\Units.cs,ComputeHashCode,The following statement contains a magic number: hash = (hash << 4) ^ ObjectModelHelper.CaseInsensitiveStringHash (this.Location);  
Magic Number,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetUsedNamespace,The following statement contains a magic number: if (namespaceName.Length > 0 && namespaceName [0] == 'A') {  	string[] parts = namespaceName.Split (' ');  	if (parts.Length == 2) {  		IName alias = this.host.NameTable.GetNameFor (parts [0].Substring (1));  		IName nsName = this.host.NameTable.GetNameFor (parts [1].Substring (1));  		return new UsedNamespace (alias' nsName);  	}  }  else if (namespaceName.Length > 0 && namespaceName [0] == 'U') {  	IName nsName = this.host.NameTable.GetNameFor (namespaceName.Substring (1));  	return new UsedNamespace (this.host.NameTable.EmptyName' nsName);  }  
Magic Number,Microsoft.Cci,PdbReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\SourceLocationProvider.cs,GetUsedNamespace,The following statement contains a magic number: if (parts.Length == 2) {  	IName alias = this.host.NameTable.GetNameFor (parts [0].Substring (1));  	IName nsName = this.host.NameTable.GetNameFor (parts [1].Substring (1));  	return new UsedNamespace (alias' nsName);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: foreach (var attribute in assembly.AssemblyAttributes) {  	if (TypeHelper.TypesAreEquivalent (attribute.Type' this.host.PlatformType.SystemReflectionAssemblySignatureKeyAttribute)) {  		foreach (var arg in attribute.Arguments) {  			var mconst = arg as IMetadataConstant;  			if (mconst != null) {  				var str = mconst.Value as string;  				if (str != null)  					keySize = (uint)str.Length / 2;  			}  			break;  		}  		break;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: if (TypeHelper.TypesAreEquivalent (attribute.Type' this.host.PlatformType.SystemReflectionAssemblySignatureKeyAttribute)) {  	foreach (var arg in attribute.Arguments) {  		var mconst = arg as IMetadataConstant;  		if (mconst != null) {  			var str = mconst.Value as string;  			if (str != null)  				keySize = (uint)str.Length / 2;  		}  		break;  	}  	break;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: foreach (var arg in attribute.Arguments) {  	var mconst = arg as IMetadataConstant;  	if (mconst != null) {  		var str = mconst.Value as string;  		if (str != null)  			keySize = (uint)str.Length / 2;  	}  	break;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: if (mconst != null) {  	var str = mconst.Value as string;  	if (str != null)  		keySize = (uint)str.Length / 2;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: if (str != null)  	keySize = (uint)str.Length / 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: keySize = (uint)str.Length / 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: return keySize < 128 + 32 ? 128u : keySize - 32;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: return keySize < 128 + 32 ? 128u : keySize - 32;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeStrongNameSignatureSize,The following statement contains a magic number: return keySize < 128 + 32 ? 128u : keySize - 32;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeOffsetToDebugTable,The following statement contains a magic number: result += Aligned (this.resourceWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeOffsetToMetadata,The following statement contains a magic number: result += 72;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeOffsetToMetadata,The following statement contains a magic number: result += Aligned (this.methodStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned (this.ComputeSizeOfMetadataTablesStream ()' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned (this.stringWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned (this.userStringWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += Aligned (this.blobWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadata,The following statement contains a magic number: result += 16;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: if (versionStringData.Length < 12)  	return 12;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: if (versionStringData.Length < 12)  	return 12;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: return 12;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: if (versionStringSize >= 256)  	return 256;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: if (versionStringSize >= 256)  	return 256;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: return 256;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfVersionString,The following statement contains a magic number: return Aligned (versionStringSize' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [2] * (4u + this.stringIndexSize + this.stringIndexSize + this.typeDefOrRefCodedIndexSize + this.fieldDefIndexSize + this.methodDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [4] * (2u + this.stringIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [6] * (8u + this.stringIndexSize + this.blobIndexSize + this.parameterIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [8] * (4u + this.stringIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [9] * (0u + this.typeDefIndexSize + this.typeDefOrRefCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [10] * (0u + this.memberRefParentCodedIndexSize + this.stringIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [11] * (2u + this.hasConstantCodedIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [12] * (0u + this.hasCustomAttributeCodedIndexSize + this.customAttributeTypeCodedIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [13] * (0u + this.hasFieldMarshallCodedIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [14] * (2u + this.declSecurityCodedIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [15] * (6u + this.typeDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [16] * (4u + this.fieldDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [17] * (0u + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [18] * (0u + this.typeDefIndexSize + this.eventDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [20] * (2u + this.stringIndexSize + this.typeDefOrRefCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [21] * (0u + this.typeDefIndexSize + this.propertyDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [23] * (2u + this.stringIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [24] * (2u + this.methodDefIndexSize + this.hasSemanticsCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [25] * (0u + this.typeDefIndexSize + this.methodDefOrRefCodedIndexSize + this.methodDefOrRefCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [26] * (0u + this.stringIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [27] * (0u + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [28] * (2u + this.memberForwardedCodedIndexSize + this.stringIndexSize + this.moduleRefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [29] * (4u + this.fieldDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [32] * (16u + this.blobIndexSize + this.stringIndexSize + this.stringIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [35] * (12u + this.blobIndexSize + this.stringIndexSize + this.stringIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [38] * (4u + this.stringIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [39] * (8u + this.stringIndexSize + this.stringIndexSize + this.implementationCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [40] * (8u + this.stringIndexSize + this.implementationCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [41] * (0u + this.typeDefIndexSize + this.typeDefIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [42] * (4u + this.typeOrMethodDefCodedIndexSize + this.stringIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [43] * (0u + this.methodDefOrRefCodedIndexSize + this.blobIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfMetadataTablesStream,The following statement contains a magic number: result += this.tableSizes [44] * (0u + this.genericParamIndexSize + this.typeDefOrRefCodedIndexSize);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: if (this.module.Requires64bits)  	sizeOfPeHeaders += 16;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfPeHeaders,The following statement contains a magic number: sizeOfPeHeaders += 16;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfTextSection,The following statement contains a magic number: if (this.emitRuntimeStartupStub) {  	textSectionLength += !this.module.Requires64bits ? 66u : 70u;  	//size of import table  	textSectionLength += 14;  	//size of name table  	textSectionLength = Aligned (textSectionLength' !this.module.Requires64bits ? 4u : 8u);  	//optional padding to make startup stub's target address align on word or double word boundary  	textSectionLength += !this.module.Requires64bits ? 8u : 16u;  	//fixed size of runtime startup stub  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfTextSection,The following statement contains a magic number: textSectionLength += 14;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfTextSection,The following statement contains a magic number: textSectionLength += Aligned (this.textDataWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfWin32Resources,The following statement contains a magic number: if (this.win32ResourceWriter.BaseStream.Length > 0)  	result += Aligned (this.win32ResourceWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfWin32Resources,The following statement contains a magic number: result += Aligned (this.win32ResourceWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInClrHeader,The following statement contains a magic number: clrHeader.majorRuntimeVersion = 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInClrHeader,The following statement contains a magic number: clrHeader.minorRuntimeVersion = 5;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInClrHeader,The following statement contains a magic number: clrHeader.resources.Size = Aligned (this.resourceWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The following statement contains a magic number: ntHeader.CliHeaderTable.Size = 72;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The following statement contains a magic number: if (!this.emitRuntimeStartupStub)  	ntHeader.ImportTable.Size = 0;  else {  	ntHeader.ImportTable.Size = use32bitAddresses ? 66u : 70u;  	ntHeader.ImportTable.Size += 13;  	//size of nametable  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInNtHeader,The following statement contains a magic number: ntHeader.ImportTable.Size += 13;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The following statement contains a magic number: this.textDataSection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress + this.textSection.VirtualSize - Aligned (this.textDataWriter.BaseStream.Length' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,FillInSectionHeaders,The following statement contains a magic number: this.textMethodBodySection.RelativeVirtualAddress = this.textSection.RelativeVirtualAddress + this.sizeOfImportAddressTable + 72;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetBlobIndex,The following statement contains a magic number: foreach (char ch in str) {  	byteArray [i++] = (byte)(ch & 0xFF);  	byteArray [i++] = (byte)(ch >> 8);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetBlobIndex,The following statement contains a magic number: byteArray [i++] = (byte)(ch >> 8);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetClrHeaderFlags,The following statement contains a magic number: if (this.module.Requires32bits)  	result |= 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetClrHeaderFlags,The following statement contains a magic number: result |= 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetClrHeaderFlags,The following statement contains a magic number: if (this.module.StrongNameSigned)  	result |= 8;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetClrHeaderFlags,The following statement contains a magic number: result |= 8;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (definingUnit != null && definingUnit.UnitIdentity.Equals (this.module.ModuleIdentity))  	return (this.GetMethodDefIndex (methodReference) << 3) | 2;  else  	return (this.GetMemberRefIndex (methodReference) << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (definingUnit != null && definingUnit.UnitIdentity.Equals (this.module.ModuleIdentity))  	return (this.GetMethodDefIndex (methodReference) << 3) | 2;  else  	return (this.GetMemberRefIndex (methodReference) << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (definingUnit != null && definingUnit.UnitIdentity.Equals (this.module.ModuleIdentity))  	return (this.GetMethodDefIndex (methodReference) << 3) | 2;  else  	return (this.GetMemberRefIndex (methodReference) << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: if (definingUnit != null && definingUnit.UnitIdentity.Equals (this.module.ModuleIdentity))  	return (this.GetMethodDefIndex (methodReference) << 3) | 2;  else  	return (this.GetMemberRefIndex (methodReference) << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: return (this.GetMethodDefIndex (methodReference) << 3) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: return (this.GetMethodDefIndex (methodReference) << 3) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: return (this.GetMemberRefIndex (methodReference) << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetCustomAttributeTypeCodedIndex,The following statement contains a magic number: return (this.GetMemberRefIndex (methodReference) << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetDataOffset,The following statement contains a magic number: if (sectionWriter.BaseStream.Position == sectionWriter.BaseStream.Length)  	sectionWriter.Align (8);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetDataOffset,The following statement contains a magic number: sectionWriter.Align (8);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetImplementationCodedIndex,The following statement contains a magic number: if (aref != null)  	return (this.GetAssemblyRefIndex (aref) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetImplementationCodedIndex,The following statement contains a magic number: return (this.GetAssemblyRefIndex (aref) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetImplementationCodedIndex,The following statement contains a magic number: if (mref != null)  	return (this.GetFileRefIndex (mref) << 2) | 0;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetImplementationCodedIndex,The following statement contains a magic number: return (this.GetFileRefIndex (mref) << 2) | 0;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetManagedResourceOffset,The following statement contains a magic number: this.resourceWriter.Align (8);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (nsTr == null || !nsTr.KeepDistinctFromDefinition) {  	uint parentTypeDefIndex = 0;  	this.typeDefIndex.TryGetValue (memberRef.ContainingType.InternedKey' out parentTypeDefIndex);  	if (parentTypeDefIndex > 0) {  		IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  		if (fieldRef != null)  			return parentTypeDefIndex << 3;  		IMethodReference /*?*/methodRef = memberRef as IMethodReference;  		if (methodRef != null) {  			if (methodRef.AcceptsExtraArguments) {  				uint methodIndex = 0;  				if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  					return (methodIndex << 3) | 3;  			}  			return parentTypeDefIndex << 3;  		}  		//TODO: error  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (nsTr == null || !nsTr.KeepDistinctFromDefinition) {  	uint parentTypeDefIndex = 0;  	this.typeDefIndex.TryGetValue (memberRef.ContainingType.InternedKey' out parentTypeDefIndex);  	if (parentTypeDefIndex > 0) {  		IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  		if (fieldRef != null)  			return parentTypeDefIndex << 3;  		IMethodReference /*?*/methodRef = memberRef as IMethodReference;  		if (methodRef != null) {  			if (methodRef.AcceptsExtraArguments) {  				uint methodIndex = 0;  				if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  					return (methodIndex << 3) | 3;  			}  			return parentTypeDefIndex << 3;  		}  		//TODO: error  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (nsTr == null || !nsTr.KeepDistinctFromDefinition) {  	uint parentTypeDefIndex = 0;  	this.typeDefIndex.TryGetValue (memberRef.ContainingType.InternedKey' out parentTypeDefIndex);  	if (parentTypeDefIndex > 0) {  		IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  		if (fieldRef != null)  			return parentTypeDefIndex << 3;  		IMethodReference /*?*/methodRef = memberRef as IMethodReference;  		if (methodRef != null) {  			if (methodRef.AcceptsExtraArguments) {  				uint methodIndex = 0;  				if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  					return (methodIndex << 3) | 3;  			}  			return parentTypeDefIndex << 3;  		}  		//TODO: error  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (nsTr == null || !nsTr.KeepDistinctFromDefinition) {  	uint parentTypeDefIndex = 0;  	this.typeDefIndex.TryGetValue (memberRef.ContainingType.InternedKey' out parentTypeDefIndex);  	if (parentTypeDefIndex > 0) {  		IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  		if (fieldRef != null)  			return parentTypeDefIndex << 3;  		IMethodReference /*?*/methodRef = memberRef as IMethodReference;  		if (methodRef != null) {  			if (methodRef.AcceptsExtraArguments) {  				uint methodIndex = 0;  				if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  					return (methodIndex << 3) | 3;  			}  			return parentTypeDefIndex << 3;  		}  		//TODO: error  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {  	IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  	if (fieldRef != null)  		return parentTypeDefIndex << 3;  	IMethodReference /*?*/methodRef = memberRef as IMethodReference;  	if (methodRef != null) {  		if (methodRef.AcceptsExtraArguments) {  			uint methodIndex = 0;  			if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  				return (methodIndex << 3) | 3;  		}  		return parentTypeDefIndex << 3;  	}  	//TODO: error  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {  	IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  	if (fieldRef != null)  		return parentTypeDefIndex << 3;  	IMethodReference /*?*/methodRef = memberRef as IMethodReference;  	if (methodRef != null) {  		if (methodRef.AcceptsExtraArguments) {  			uint methodIndex = 0;  			if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  				return (methodIndex << 3) | 3;  		}  		return parentTypeDefIndex << 3;  	}  	//TODO: error  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {  	IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  	if (fieldRef != null)  		return parentTypeDefIndex << 3;  	IMethodReference /*?*/methodRef = memberRef as IMethodReference;  	if (methodRef != null) {  		if (methodRef.AcceptsExtraArguments) {  			uint methodIndex = 0;  			if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  				return (methodIndex << 3) | 3;  		}  		return parentTypeDefIndex << 3;  	}  	//TODO: error  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (parentTypeDefIndex > 0) {  	IFieldReference /*?*/fieldRef = memberRef as IFieldReference;  	if (fieldRef != null)  		return parentTypeDefIndex << 3;  	IMethodReference /*?*/methodRef = memberRef as IMethodReference;  	if (methodRef != null) {  		if (methodRef.AcceptsExtraArguments) {  			uint methodIndex = 0;  			if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  				return (methodIndex << 3) | 3;  		}  		return parentTypeDefIndex << 3;  	}  	//TODO: error  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (fieldRef != null)  	return parentTypeDefIndex << 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return parentTypeDefIndex << 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (methodRef != null) {  	if (methodRef.AcceptsExtraArguments) {  		uint methodIndex = 0;  		if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  			return (methodIndex << 3) | 3;  	}  	return parentTypeDefIndex << 3;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (methodRef != null) {  	if (methodRef.AcceptsExtraArguments) {  		uint methodIndex = 0;  		if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  			return (methodIndex << 3) | 3;  	}  	return parentTypeDefIndex << 3;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (methodRef != null) {  	if (methodRef.AcceptsExtraArguments) {  		uint methodIndex = 0;  		if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  			return (methodIndex << 3) | 3;  	}  	return parentTypeDefIndex << 3;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (methodRef.AcceptsExtraArguments) {  	uint methodIndex = 0;  	if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  		return (methodIndex << 3) | 3;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (methodRef.AcceptsExtraArguments) {  	uint methodIndex = 0;  	if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  		return (methodIndex << 3) | 3;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  	return (methodIndex << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (this.methodDefIndex.TryGetValue (methodRef.InternedKey' out methodIndex))  	return (methodIndex << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return (methodIndex << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return (methodIndex << 3) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return parentTypeDefIndex << 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification (memberRef.ContainingType))  	return (this.GetTypeRefIndex (memberRef.ContainingType) << 3) | 1;  else  	return (this.GetTypeSpecIndex (memberRef.ContainingType) << 3) | 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification (memberRef.ContainingType))  	return (this.GetTypeRefIndex (memberRef.ContainingType) << 3) | 1;  else  	return (this.GetTypeSpecIndex (memberRef.ContainingType) << 3) | 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification (memberRef.ContainingType))  	return (this.GetTypeRefIndex (memberRef.ContainingType) << 3) | 1;  else  	return (this.GetTypeSpecIndex (memberRef.ContainingType) << 3) | 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return (this.GetTypeRefIndex (memberRef.ContainingType) << 3) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return (this.GetTypeSpecIndex (memberRef.ContainingType) << 3) | 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMemberRefParentCodedIndex,The following statement contains a magic number: return (this.GetTypeSpecIndex (memberRef.ContainingType) << 3) | 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetTypeRefIndex (typeReference) << 2) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetTypeRefIndex (typeReference) << 2) | 3;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: if (aref != null)  	return (this.GetAssemblyRefIndex (aref) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: if (aref != null)  	return (this.GetAssemblyRefIndex (aref) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetAssemblyRefIndex (aref) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetAssemblyRefIndex (aref) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: if (mref != null)  	return (this.GetModuleRefIndex (mref) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetResolutionScopeCodedIndex,The following statement contains a magic number: return (this.GetModuleRefIndex (mref) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (nsTr == null || !nsTr.KeepDistinctFromDefinition) {  	uint typeDefIndex = 0;  	if (this.typeDefIndex.TryGetValue (typeReference.InternedKey' out typeDefIndex))  		return (typeDefIndex << 2) | 0;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (this.typeDefIndex.TryGetValue (typeReference.InternedKey' out typeDefIndex))  	return (typeDefIndex << 2) | 0;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: return (typeDefIndex << 2) | 0;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification (typeReference))  	return (this.GetTypeRefIndex (typeReference) << 2) | 1;  else  	return (this.GetTypeSpecIndex (typeReference) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification (typeReference))  	return (this.GetTypeRefIndex (typeReference) << 2) | 1;  else  	return (this.GetTypeSpecIndex (typeReference) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: if (!IsTypeSpecification (typeReference))  	return (this.GetTypeRefIndex (typeReference) << 2) | 1;  else  	return (this.GetTypeSpecIndex (typeReference) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: return (this.GetTypeRefIndex (typeReference) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: return (this.GetTypeSpecIndex (typeReference) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefOrRefCodedIndex,The following statement contains a magic number: return (this.GetTypeSpecIndex (typeReference) << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetUserStringToken,The following statement contains a magic number: if (!this.userStringIndex.TryGetValue (str' out index)) {  	Debug.Assert (!this.streamsAreComplete);  	index = this.userStringWriter.BaseStream.Position;  	this.userStringIndex.Add (str' index);  	this.userStringWriter.WriteCompressedUInt ((uint)str.Length * 2 + 1);  	this.userStringWriter.WriteChars (str.ToCharArray ());  	//Write out a trailing byte indicating if the string is really quite simple  	byte stringKind = 0;  	foreach (char ch in str) {  		if (ch >= 0x7F) {  			stringKind = 1;  		}  		else {  			switch ((int)ch) {  			case 0x1:  			case 0x2:  			case 0x3:  			case 0x4:  			case 0x5:  			case 0x6:  			case 0x7:  			case 0x8:  			case 0xE:  			case 0xF:  			case 0x10:  			case 0x11:  			case 0x12:  			case 0x13:  			case 0x14:  			case 0x15:  			case 0x16:  			case 0x17:  			case 0x18:  			case 0x19:  			case 0x1A:  			case 0x1B:  			case 0x1C:  			case 0x1D:  			case 0x1E:  			case 0x1F:  			case 0x27:  			case 0x2D:  				stringKind = 1;  				break;  			default:  				continue;  			}  		}  		break;  	}  	this.userStringWriter.WriteByte (stringKind);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetUserStringToken,The following statement contains a magic number: this.userStringWriter.WriteCompressedUInt ((uint)str.Length * 2 + 1);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: writer.WriteUshort (5);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeGeneralMetadataHeader,The following statement contains a magic number: SerializeStreamHeader (ref offsetFromStartOfMetadata' 16' "#GUID"' writer);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeStreamHeader,The following statement contains a magic number: writer.WriteUint (Aligned (sizeOfStreamHeap' 4));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeStreamHeader,The following statement contains a magic number: for (uint i = 8 + (uint)streamName.Length; i < sizeOfStreamHeader; i++)  	writer.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadata,The following statement contains a magic number: this.stringWriter.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadata,The following statement contains a magic number: this.userStringWriter.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadata,The following statement contains a magic number: this.blobWriter.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadataTables,The following statement contains a magic number: writer.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.blobWriter.BaseStream.Length > ushort.MaxValue)  	this.blobIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.blobIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 3' TableIndices.Method' TableIndices.MemberRef))  	this.customAttributeTypeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 3' TableIndices.Method' TableIndices.MemberRef))  	this.customAttributeTypeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 3' TableIndices.Method' TableIndices.MemberRef))  	this.customAttributeTypeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.customAttributeTypeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Method' TableIndices.TypeDef))  	this.declSecurityCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Method' TableIndices.TypeDef))  	this.declSecurityCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Method' TableIndices.TypeDef))  	this.declSecurityCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.declSecurityCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Event))  	this.eventDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Event))  	this.eventDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.eventDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Field))  	this.fieldDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Field))  	this.fieldDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.fieldDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.GenericParam))  	this.genericParamIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.GenericParam))  	this.genericParamIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.genericParamIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Field' TableIndices.Param' TableIndices.Property))  	this.hasConstantCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Field' TableIndices.Param' TableIndices.Property))  	this.hasConstantCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Field' TableIndices.Param' TableIndices.Property))  	this.hasConstantCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.hasConstantCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl' TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig' TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource))  	this.hasCustomAttributeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl' TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig' TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource))  	this.hasCustomAttributeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 5' TableIndices.Method' TableIndices.Field' TableIndices.TypeRef' TableIndices.TypeDef' TableIndices.Param' TableIndices.InterfaceImpl' TableIndices.MemberRef' TableIndices.Module' TableIndices.DeclSecurity' TableIndices.Property' TableIndices.Event' TableIndices.StandAloneSig' TableIndices.ModuleRef' TableIndices.TypeSpec' TableIndices.Assembly' TableIndices.AssemblyRef' TableIndices.File' TableIndices.ExportedType' TableIndices.ManifestResource))  	this.hasCustomAttributeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.hasCustomAttributeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Field' TableIndices.Param))  	this.hasFieldMarshallCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Field' TableIndices.Param))  	this.hasFieldMarshallCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.hasFieldMarshallCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Event' TableIndices.Property))  	this.hasSemanticsCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Event' TableIndices.Property))  	this.hasSemanticsCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.hasSemanticsCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.File' TableIndices.AssemblyRef' TableIndices.ExportedType))  	this.implementationCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.File' TableIndices.AssemblyRef' TableIndices.ExportedType))  	this.implementationCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.File' TableIndices.AssemblyRef' TableIndices.ExportedType))  	this.implementationCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.implementationCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Field' TableIndices.Method))  	this.memberForwardedCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Field' TableIndices.Method))  	this.memberForwardedCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.memberForwardedCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec))  	this.memberRefParentCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec))  	this.memberRefParentCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 3' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.ModuleRef' TableIndices.Method' TableIndices.TypeSpec))  	this.memberRefParentCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.memberRefParentCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Method))  	this.methodDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Method))  	this.methodDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.methodDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Method' TableIndices.MemberRef))  	this.methodDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.Method' TableIndices.MemberRef))  	this.methodDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.methodDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.ModuleRef))  	this.moduleRefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.ModuleRef))  	this.moduleRefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.moduleRefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Param))  	this.parameterIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Param))  	this.parameterIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.parameterIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Property))  	this.propertyDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.Property))  	this.propertyDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.propertyDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef))  	this.resolutionScopeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef))  	this.resolutionScopeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.Module' TableIndices.ModuleRef' TableIndices.AssemblyRef' TableIndices.TypeRef))  	this.resolutionScopeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.resolutionScopeCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.stringWriter.BaseStream.Length >= ushort.MaxValue)  	this.stringIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.stringIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.TypeDef))  	this.typeDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16' TableIndices.TypeDef))  	this.typeDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.typeDefIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.TypeSpec))  	this.typeDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.TypeSpec))  	this.typeDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 2' TableIndices.TypeDef' TableIndices.TypeRef' TableIndices.TypeSpec))  	this.typeDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.typeDefOrRefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.TypeDef' TableIndices.Method))  	this.typeOrMethodDefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: if (this.IndexDoesNotFit (16 - 1' TableIndices.TypeDef' TableIndices.Method))  	this.typeOrMethodDefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeColumnSizes,The following statement contains a magic number: this.typeOrMethodDefCodedIndexSize = 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IFieldDefinition fieldDef in this.fieldDefList) {  	fieldDefIndex++;  	if (fieldDef.CompileTimeValue is Dummy)  		continue;  	ConstantRow r = new ConstantRow ();  	r.Type = GetTypeCodeByteFor (fieldDef.CompileTimeValue.Value);  	r.Parent = fieldDefIndex << 2;  	r.Value = this.GetBlobIndex (fieldDef.CompileTimeValue.Value);  	this.constantTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: r.Parent = fieldDefIndex << 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IParameterDefinition parDef in this.parameterDefList) {  	parameterDefIndex++;  	if (!parDef.HasDefaultValue)  		continue;  	ConstantRow r = new ConstantRow ();  	r.Type = GetTypeCodeByteFor (parDef.DefaultValue.Value);  	r.Parent = (parameterDefIndex << 2) | 1;  	r.Value = this.GetBlobIndex (parDef.DefaultValue.Value);  	this.constantTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: r.Parent = (parameterDefIndex << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IPropertyDefinition propDef in this.propertyDefList) {  	propertyDefIndex++;  	if (!propDef.HasDefaultValue)  		continue;  	ConstantRow r = new ConstantRow ();  	r.Type = GetTypeCodeByteFor (propDef.DefaultValue.Value);  	r.Parent = (propertyDefIndex << 2) | 2;  	r.Value = this.GetBlobIndex (propDef.DefaultValue.Value);  	this.constantTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: foreach (IPropertyDefinition propDef in this.propertyDefList) {  	propertyDefIndex++;  	if (!propDef.HasDefaultValue)  		continue;  	ConstantRow r = new ConstantRow ();  	r.Type = GetTypeCodeByteFor (propDef.DefaultValue.Value);  	r.Parent = (propertyDefIndex << 2) | 2;  	r.Value = this.GetBlobIndex (propDef.DefaultValue.Value);  	this.constantTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: r.Parent = (propertyDefIndex << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateConstantTableRows,The following statement contains a magic number: r.Parent = (propertyDefIndex << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: if (assembly != null)  	this.AddAssemblyAttributesToTable (assembly' 14);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddAssemblyAttributesToTable (assembly' 14);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (this.typeDefList' 3);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (this.parameterDefList' 4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (this.interfaceImplTable' 5);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddModuleAttributesToTable (this.module' 7);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (this.propertyDefList' 9);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (this.eventDefList' 10);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (new List<IModuleReference> (this.module.ModuleReferences)' 12);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateCustomAttributeTableRows,The following statement contains a magic number: this.AddCustomAttributesToTable (sortedGenericParameterList' 19);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,AddAssemblyAttributesToTable,The following statement contains a magic number: r.Parent = (1 << 5) | tag;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,AddModuleAttributesToTable,The following statement contains a magic number: r.Parent = (1 << 5) | tag;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,AddCustomAttributesToTable,The following statement contains a magic number: foreach (ParentType parent in parentList) {  	parentIndex++;  	CustomAttributeRow r = new CustomAttributeRow ();  	r.Parent = (parentIndex << 5) | tag;  	foreach (ICustomAttribute customAttribute in parent.Attributes) {  		if (customAttribute.Constructor is Dummy) {  			//TODO: error  		}  		r.Type = this.GetCustomAttributeTypeCodedIndex (customAttribute.Constructor);  		r.Value = this.GetCustomAttributeSignatureIndex (customAttribute);  		r.OriginalPosition = this.customAttributeTable.Count;  		this.customAttributeTable.Add (r);  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,AddCustomAttributesToTable,The following statement contains a magic number: r.Parent = (parentIndex << 5) | tag;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: if (assembly != null)  	this.PopulateDeclSecurityTableRowsFor ((1 << 2) | 2' assembly.SecurityAttributes);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: if (assembly != null)  	this.PopulateDeclSecurityTableRowsFor ((1 << 2) | 2' assembly.SecurityAttributes);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: this.PopulateDeclSecurityTableRowsFor ((1 << 2) | 2' assembly.SecurityAttributes);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: this.PopulateDeclSecurityTableRowsFor ((1 << 2) | 2' assembly.SecurityAttributes);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: foreach (ITypeDefinition typeDef in this.typeDefList) {  	typeDefIndex++;  	if (!typeDef.HasDeclarativeSecurity)  		continue;  	this.PopulateDeclSecurityTableRowsFor (typeDefIndex << 2' typeDef.SecurityAttributes);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: this.PopulateDeclSecurityTableRowsFor (typeDefIndex << 2' typeDef.SecurityAttributes);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: foreach (IMethodDefinition methodDef in this.methodDefList) {  	methodDefIndex++;  	if (!methodDef.HasDeclarativeSecurity)  		continue;  	this.PopulateDeclSecurityTableRowsFor ((methodDefIndex << 2) | 1' methodDef.SecurityAttributes);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateDeclSecurityTableRows,The following statement contains a magic number: this.PopulateDeclSecurityTableRowsFor ((methodDefIndex << 2) | 1' methodDef.SecurityAttributes);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: foreach (IAliasForType alias in assembly.ExportedTypes) {  	ITypeReference exportedType = alias.AliasedType;  	INestedTypeReference /*?*/neRef = null;  	INamespaceTypeReference /*?*/nsRef = null;  	ExportedTypeRow r = new ExportedTypeRow ();  	r.TypeDefId = this.GetExternalTypeToken (exportedType as ITypeDefinition);  	if ((nsRef = exportedType as INamespaceTypeReference) != null) {  		r.Flags = TypeFlags.PublicAccess;  		r.TypeName = this.GetStringIndex (GetMangledName (nsRef));  		INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference;  		if (nestedUnitNamespaceReference == null)  			r.TypeNamespace = StringIdx.Empty;  		else  			r.TypeNamespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None));  		r.Implementation = this.GetImplementationCodedIndex (nsRef);  		if ((r.Implementation & 1) == 1) {  			r.Flags = TypeFlags.PrivateAccess | TypeFlags.ForwarderImplementation;  			r.TypeDefId = 0;  		}  	}  	else if ((neRef = exportedType as INestedTypeReference) != null) {  		r.Flags = TypeFlags.NestedPublicAccess;  		r.TypeName = this.GetStringIndex (GetMangledName (neRef));  		r.TypeNamespace = StringIdx.Empty;  		uint ci = this.GetExportedTypeIndex (neRef.ContainingType);  		r.Implementation = (ci << 2) | 2;  		var parentFlags = this.exportedTypeTable [((int)ci) - 1].Flags;  		if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)  			r.Flags = TypeFlags.PrivateAccess;  	}  	else {  		//TODO: error  		continue;  	}  	this.exportedTypeTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: foreach (IAliasForType alias in assembly.ExportedTypes) {  	ITypeReference exportedType = alias.AliasedType;  	INestedTypeReference /*?*/neRef = null;  	INamespaceTypeReference /*?*/nsRef = null;  	ExportedTypeRow r = new ExportedTypeRow ();  	r.TypeDefId = this.GetExternalTypeToken (exportedType as ITypeDefinition);  	if ((nsRef = exportedType as INamespaceTypeReference) != null) {  		r.Flags = TypeFlags.PublicAccess;  		r.TypeName = this.GetStringIndex (GetMangledName (nsRef));  		INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference;  		if (nestedUnitNamespaceReference == null)  			r.TypeNamespace = StringIdx.Empty;  		else  			r.TypeNamespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None));  		r.Implementation = this.GetImplementationCodedIndex (nsRef);  		if ((r.Implementation & 1) == 1) {  			r.Flags = TypeFlags.PrivateAccess | TypeFlags.ForwarderImplementation;  			r.TypeDefId = 0;  		}  	}  	else if ((neRef = exportedType as INestedTypeReference) != null) {  		r.Flags = TypeFlags.NestedPublicAccess;  		r.TypeName = this.GetStringIndex (GetMangledName (neRef));  		r.TypeNamespace = StringIdx.Empty;  		uint ci = this.GetExportedTypeIndex (neRef.ContainingType);  		r.Implementation = (ci << 2) | 2;  		var parentFlags = this.exportedTypeTable [((int)ci) - 1].Flags;  		if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)  			r.Flags = TypeFlags.PrivateAccess;  	}  	else {  		//TODO: error  		continue;  	}  	this.exportedTypeTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: if ((nsRef = exportedType as INamespaceTypeReference) != null) {  	r.Flags = TypeFlags.PublicAccess;  	r.TypeName = this.GetStringIndex (GetMangledName (nsRef));  	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference;  	if (nestedUnitNamespaceReference == null)  		r.TypeNamespace = StringIdx.Empty;  	else  		r.TypeNamespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None));  	r.Implementation = this.GetImplementationCodedIndex (nsRef);  	if ((r.Implementation & 1) == 1) {  		r.Flags = TypeFlags.PrivateAccess | TypeFlags.ForwarderImplementation;  		r.TypeDefId = 0;  	}  }  else if ((neRef = exportedType as INestedTypeReference) != null) {  	r.Flags = TypeFlags.NestedPublicAccess;  	r.TypeName = this.GetStringIndex (GetMangledName (neRef));  	r.TypeNamespace = StringIdx.Empty;  	uint ci = this.GetExportedTypeIndex (neRef.ContainingType);  	r.Implementation = (ci << 2) | 2;  	var parentFlags = this.exportedTypeTable [((int)ci) - 1].Flags;  	if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)  		r.Flags = TypeFlags.PrivateAccess;  }  else {  	//TODO: error  	continue;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: if ((nsRef = exportedType as INamespaceTypeReference) != null) {  	r.Flags = TypeFlags.PublicAccess;  	r.TypeName = this.GetStringIndex (GetMangledName (nsRef));  	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsRef.ContainingUnitNamespace as INestedUnitNamespaceReference;  	if (nestedUnitNamespaceReference == null)  		r.TypeNamespace = StringIdx.Empty;  	else  		r.TypeNamespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None));  	r.Implementation = this.GetImplementationCodedIndex (nsRef);  	if ((r.Implementation & 1) == 1) {  		r.Flags = TypeFlags.PrivateAccess | TypeFlags.ForwarderImplementation;  		r.TypeDefId = 0;  	}  }  else if ((neRef = exportedType as INestedTypeReference) != null) {  	r.Flags = TypeFlags.NestedPublicAccess;  	r.TypeName = this.GetStringIndex (GetMangledName (neRef));  	r.TypeNamespace = StringIdx.Empty;  	uint ci = this.GetExportedTypeIndex (neRef.ContainingType);  	r.Implementation = (ci << 2) | 2;  	var parentFlags = this.exportedTypeTable [((int)ci) - 1].Flags;  	if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)  		r.Flags = TypeFlags.PrivateAccess;  }  else {  	//TODO: error  	continue;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: if ((neRef = exportedType as INestedTypeReference) != null) {  	r.Flags = TypeFlags.NestedPublicAccess;  	r.TypeName = this.GetStringIndex (GetMangledName (neRef));  	r.TypeNamespace = StringIdx.Empty;  	uint ci = this.GetExportedTypeIndex (neRef.ContainingType);  	r.Implementation = (ci << 2) | 2;  	var parentFlags = this.exportedTypeTable [((int)ci) - 1].Flags;  	if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)  		r.Flags = TypeFlags.PrivateAccess;  }  else {  	//TODO: error  	continue;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: if ((neRef = exportedType as INestedTypeReference) != null) {  	r.Flags = TypeFlags.NestedPublicAccess;  	r.TypeName = this.GetStringIndex (GetMangledName (neRef));  	r.TypeNamespace = StringIdx.Empty;  	uint ci = this.GetExportedTypeIndex (neRef.ContainingType);  	r.Implementation = (ci << 2) | 2;  	var parentFlags = this.exportedTypeTable [((int)ci) - 1].Flags;  	if (parentFlags == TypeFlags.PrivateAccess || (parentFlags & TypeFlags.ForwarderImplementation) != 0)  		r.Flags = TypeFlags.PrivateAccess;  }  else {  	//TODO: error  	continue;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: r.Implementation = (ci << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateExportedTypeTableRows,The following statement contains a magic number: r.Implementation = (ci << 2) | 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: foreach (IResourceReference resourceReference in assembly.Resources) {  	ManifestResourceRow r = new ManifestResourceRow ();  	r.Offset = this.GetManagedResourceOffset (resourceReference);  	r.Flags = resourceReference.Resource.IsPublic ? 1u : 2u;  	r.Name = this.GetStringIndex (resourceReference.Name.Value);  	if (resourceReference.Resource.IsInExternalFile)  		r.Implementation = this.GetFileRefIndex (resourceReference.Resource.ExternalFile) << 2;  	else if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals (assembly.AssemblyIdentity))  		r.Implementation = 0;  	else  		r.Implementation = (this.GetAssemblyRefIndex (resourceReference.DefiningAssembly) << 2) | 1;  	this.manifestResourceTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: foreach (IResourceReference resourceReference in assembly.Resources) {  	ManifestResourceRow r = new ManifestResourceRow ();  	r.Offset = this.GetManagedResourceOffset (resourceReference);  	r.Flags = resourceReference.Resource.IsPublic ? 1u : 2u;  	r.Name = this.GetStringIndex (resourceReference.Name.Value);  	if (resourceReference.Resource.IsInExternalFile)  		r.Implementation = this.GetFileRefIndex (resourceReference.Resource.ExternalFile) << 2;  	else if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals (assembly.AssemblyIdentity))  		r.Implementation = 0;  	else  		r.Implementation = (this.GetAssemblyRefIndex (resourceReference.DefiningAssembly) << 2) | 1;  	this.manifestResourceTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: if (resourceReference.Resource.IsInExternalFile)  	r.Implementation = this.GetFileRefIndex (resourceReference.Resource.ExternalFile) << 2;  else if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals (assembly.AssemblyIdentity))  	r.Implementation = 0;  else  	r.Implementation = (this.GetAssemblyRefIndex (resourceReference.DefiningAssembly) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: if (resourceReference.Resource.IsInExternalFile)  	r.Implementation = this.GetFileRefIndex (resourceReference.Resource.ExternalFile) << 2;  else if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals (assembly.AssemblyIdentity))  	r.Implementation = 0;  else  	r.Implementation = (this.GetAssemblyRefIndex (resourceReference.DefiningAssembly) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: r.Implementation = this.GetFileRefIndex (resourceReference.Resource.ExternalFile) << 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: if (resourceReference.DefiningAssembly.AssemblyIdentity.Equals (assembly.AssemblyIdentity))  	r.Implementation = 0;  else  	r.Implementation = (this.GetAssemblyRefIndex (resourceReference.DefiningAssembly) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateManifestResourceTableRows,The following statement contains a magic number: r.Implementation = (this.GetAssemblyRefIndex (resourceReference.DefiningAssembly) << 2) | 1;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The following statement contains a magic number: foreach (ITypeReference typeRef in this.typeRefList) {  	TypeRefRow r = new TypeRefRow ();  	INestedTypeReference /*?*/neTypeRef = typeRef as INestedTypeReference;  	if (neTypeRef != null) {  		ISpecializedNestedTypeReference /*?*/sneTypeRef = neTypeRef as ISpecializedNestedTypeReference;  		if (sneTypeRef != null)  			r.ResolutionScope = this.GetResolutionScopeCodedIndex (sneTypeRef.UnspecializedVersion.ContainingType);  		else  			r.ResolutionScope = this.GetResolutionScopeCodedIndex (neTypeRef.ContainingType);  		r.Name = this.GetStringIndex (GetMangledName (neTypeRef));  		r.Namespace = StringIdx.Empty;  	}  	else {  		INamespaceTypeReference /*?*/nsTypeRef = typeRef as INamespaceTypeReference;  		if (nsTypeRef == null) {  			//TODO: error  			continue;  		}  		if (nsTypeRef.KeepDistinctFromDefinition && nsTypeRef.ContainingUnitNamespace.Unit.UnitIdentity == this.module.ModuleIdentity)  			r.ResolutionScope = 1 << 2;  		//A coded module token for the current module.  		else  			r.ResolutionScope = this.GetResolutionScopeCodedIndex (nsTypeRef.ContainingUnitNamespace.Unit);  		r.Name = this.GetStringIndex (GetMangledName (nsTypeRef));  		INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsTypeRef.ContainingUnitNamespace as INestedUnitNamespaceReference;  		if (nestedUnitNamespaceReference == null)  			r.Namespace = StringIdx.Empty;  		else  			r.Namespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None));  	}  	this.typeRefTable.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The following statement contains a magic number: if (neTypeRef != null) {  	ISpecializedNestedTypeReference /*?*/sneTypeRef = neTypeRef as ISpecializedNestedTypeReference;  	if (sneTypeRef != null)  		r.ResolutionScope = this.GetResolutionScopeCodedIndex (sneTypeRef.UnspecializedVersion.ContainingType);  	else  		r.ResolutionScope = this.GetResolutionScopeCodedIndex (neTypeRef.ContainingType);  	r.Name = this.GetStringIndex (GetMangledName (neTypeRef));  	r.Namespace = StringIdx.Empty;  }  else {  	INamespaceTypeReference /*?*/nsTypeRef = typeRef as INamespaceTypeReference;  	if (nsTypeRef == null) {  		//TODO: error  		continue;  	}  	if (nsTypeRef.KeepDistinctFromDefinition && nsTypeRef.ContainingUnitNamespace.Unit.UnitIdentity == this.module.ModuleIdentity)  		r.ResolutionScope = 1 << 2;  	//A coded module token for the current module.  	else  		r.ResolutionScope = this.GetResolutionScopeCodedIndex (nsTypeRef.ContainingUnitNamespace.Unit);  	r.Name = this.GetStringIndex (GetMangledName (nsTypeRef));  	INestedUnitNamespaceReference /*?*/nestedUnitNamespaceReference = nsTypeRef.ContainingUnitNamespace as INestedUnitNamespaceReference;  	if (nestedUnitNamespaceReference == null)  		r.Namespace = StringIdx.Empty;  	else  		r.Namespace = this.GetStringIndex (TypeHelper.GetNamespaceName (nestedUnitNamespaceReference' NameFormattingOptions.None));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The following statement contains a magic number: if (nsTypeRef.KeepDistinctFromDefinition && nsTypeRef.ContainingUnitNamespace.Unit.UnitIdentity == this.module.ModuleIdentity)  	r.ResolutionScope = 1 << 2;  //A coded module token for the current module.  else  	r.ResolutionScope = this.GetResolutionScopeCodedIndex (nsTypeRef.ContainingUnitNamespace.Unit);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,PopulateTypeRefTableRows,The following statement contains a magic number: r.ResolutionScope = 1 << 2;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeTablesHeader,The following statement contains a magic number: if (this.stringIndexSize > 2)  	heapSizes |= 0x01;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeTablesHeader,The following statement contains a magic number: if (this.blobIndexSize > 2)  	heapSizes |= 0x04;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: foreach (uint tableSize in this.tableSizes)  	if (tableSize > 0)  		result += 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: if (tableSize > 0)  	result += 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,ComputeSizeOfTablesHeader,The following statement contains a magic number: result += 4;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeIndex,The following statement contains a magic number: if (indexSize == 2)  	writer.WriteUshort ((ushort)index);  else  	writer.WriteUint (index);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: if (il.Length < 64 && methodBody.MaxStack <= 8 && localVariableSignatureToken == 0 && numberOfExceptionHandlers == 0) {  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	writer.WriteByte ((byte)((il.Length << 2) | 2));  }  else {  	writer.Align (4);  	this.methodBodyIndex [methodBody.MethodDefinition] = this.methodStream.Position;  	ushort flags = (3 << 12) | 0x3;  	if (numberOfExceptionHandlers > 0)  		flags |= 0x08;  	if (methodBody.LocalsAreZeroed)  		flags |= 0x10;  	writer.WriteUshort (flags);  	writer.WriteUshort (methodBody.MaxStack);  	writer.WriteUint ((uint)il.Length);  	writer.WriteUint (localVariableSignatureToken);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: writer.WriteByte ((byte)((il.Length << 2) | 2));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: writer.WriteByte ((byte)((il.Length << 2) | 2));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBody,The following statement contains a magic number: writer.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.WriteByte (2);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToFirstMethod,The following statement contains a magic number: cmw.WriteUint (12);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToLastMethodWithUsingInfo,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToLastMethodWithUsingInfo,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToLastMethodWithUsingInfo,The following statement contains a magic number: cmw.WriteUint (12);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteByte (3);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteUint (12 + numberOfScopes * 8);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeIteratorLocalScopes,The following statement contains a magic number: cmw.WriteUint (12 + numberOfScopes * 8);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeCustomDebugMetadata,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeCustomDebugMetadata,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {  	cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  	cmw.WriteUshort ((ushort)usingCounts.Count);  	foreach (ushort uc in usingCounts)  		cmw.WriteUshort (uc);  }  else {  	cmw.WriteUint (streamLength = 12);  	cmw.WriteUshort (1);  	cmw.WriteUshort (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {  	cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  	cmw.WriteUshort ((ushort)usingCounts.Count);  	foreach (ushort uc in usingCounts)  		cmw.WriteUshort (uc);  }  else {  	cmw.WriteUint (streamLength = 12);  	cmw.WriteUshort (1);  	cmw.WriteUshort (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {  	cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  	cmw.WriteUshort ((ushort)usingCounts.Count);  	foreach (ushort uc in usingCounts)  		cmw.WriteUshort (uc);  }  else {  	cmw.WriteUint (streamLength = 12);  	cmw.WriteUshort (1);  	cmw.WriteUshort (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: if (usingCounts.Count > 0) {  	cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  	cmw.WriteUshort ((ushort)usingCounts.Count);  	foreach (ushort uc in usingCounts)  		cmw.WriteUshort (uc);  }  else {  	cmw.WriteUint (streamLength = 12);  	cmw.WriteUshort (1);  	cmw.WriteUshort (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.WriteUint (streamLength = Aligned ((uint)usingCounts.Count * 2 + 10' 4));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.WriteUint (streamLength = 12);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeNamespaceScopeMetadata,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	if (operation.OperationCode == OperationCode.Newobj) {  		IMethodReference /*?*/consRef = operation.Value as IMethodReference;  		if (consRef != null && consRef.ContainingType is INamedEntity) {  			string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  			MemoryStream customMetadata = new MemoryStream ();  			BinaryWriter cmw = new BinaryWriter (customMetadata' true);  			cmw.WriteByte (4);  			//version  			cmw.WriteByte (4);  			//kind: ForwardIterator  			cmw.Align (4);  			uint length = 10 + (uint)iteratorClassName.Length * 2;  			while (length % 4 > 0)  				length++;  			cmw.WriteUint (length);  			cmw.WriteString (iteratorClassName' true);  			cmw.Align (4);  			this.customDebugMetadataForCurrentMethod.Add (customMetadata);  			return;  		}  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (operation.OperationCode == OperationCode.Newobj) {  	IMethodReference /*?*/consRef = operation.Value as IMethodReference;  	if (consRef != null && consRef.ContainingType is INamedEntity) {  		string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  		MemoryStream customMetadata = new MemoryStream ();  		BinaryWriter cmw = new BinaryWriter (customMetadata' true);  		cmw.WriteByte (4);  		//version  		cmw.WriteByte (4);  		//kind: ForwardIterator  		cmw.Align (4);  		uint length = 10 + (uint)iteratorClassName.Length * 2;  		while (length % 4 > 0)  			length++;  		cmw.WriteUint (length);  		cmw.WriteString (iteratorClassName' true);  		cmw.Align (4);  		this.customDebugMetadataForCurrentMethod.Add (customMetadata);  		return;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: if (consRef != null && consRef.ContainingType is INamedEntity) {  	string iteratorClassName = ((INamedEntity)consRef.ContainingType).Name.Value;  	MemoryStream customMetadata = new MemoryStream ();  	BinaryWriter cmw = new BinaryWriter (customMetadata' true);  	cmw.WriteByte (4);  	//version  	cmw.WriteByte (4);  	//kind: ForwardIterator  	cmw.Align (4);  	uint length = 10 + (uint)iteratorClassName.Length * 2;  	while (length % 4 > 0)  		length++;  	cmw.WriteUint (length);  	cmw.WriteString (iteratorClassName' true);  	cmw.Align (4);  	this.customDebugMetadataForCurrentMethod.Add (customMetadata);  	return;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: cmw.WriteByte (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: while (length % 4 > 0)  	length++;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeReferenceToIteratorClass,The following statement contains a magic number: cmw.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	this.EmitPdbInformationFor (operation);  	switch (operation.OperationCode) {  	case OperationCode.Array_Addr:  	case OperationCode.Array_Get:  	case OperationCode.Array_Set:  		writer.WriteByte ((byte)OperationCode.Call);  		writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  		continue;  	case OperationCode.Array_Create:  	case OperationCode.Array_Create_WithLowerBound:  		writer.WriteByte ((byte)OperationCode.Newobj);  		writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  		continue;  	}  	if (operation.OperationCode < OperationCode.Arglist)  		writer.WriteByte ((byte)operation.OperationCode);  	else {  		writer.WriteByte ((byte)((ushort)operation.OperationCode >> 8));  		writer.WriteByte ((byte)((ushort)operation.OperationCode & 0xff));  	}  	switch (operation.OperationCode) {  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble:  	case OperationCode.Ble_Un:  	case OperationCode.Blt:  	case OperationCode.Blt_Un:  	case OperationCode.Bne_Un:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Leave:  		//^ assume operation.Value is uint;  		writer.WriteInt ((int)((uint)operation.Value - mbody.Position - 4));  		break;  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Leave_S:  		//^ assume operation.Value is uint;  		writer.WriteSbyte ((sbyte)((uint)operation.Value - mbody.Position - 1));  		break;  	case OperationCode.Box:  	case OperationCode.Castclass:  	case OperationCode.Constrained_:  	case OperationCode.Cpobj:  	case OperationCode.Initobj:  	case OperationCode.Isinst:  	case OperationCode.Ldelem:  	case OperationCode.Ldelema:  	case OperationCode.Ldobj:  	case OperationCode.Mkrefany:  	case OperationCode.Refanyval:  	case OperationCode.Sizeof:  	case OperationCode.Stelem:  	case OperationCode.Stobj:  	case OperationCode.Unbox:  	case OperationCode.Unbox_Any:  		//^ assume operation.Value is ITypeReference;  		writer.WriteUint (this.GetTypeToken ((ITypeReference)operation.Value));  		break;  	case OperationCode.Call:  	case OperationCode.Callvirt:  	case OperationCode.Jmp:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Newobj:  		//^ assume operation.Value is IMethodReference;  		writer.WriteUint (this.GetMethodToken ((IMethodReference)operation.Value));  		break;  	case OperationCode.Calli:  		//^ assume operation.Value is IFunctionPointerTypeReference;  		writer.WriteUint (this.GetStandaloneSignatureToken ((IFunctionPointerTypeReference)operation.Value));  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		if (operation.Value == null)  			writer.WriteUshort (0);  		else {  			//^ assume operation.Value is IParameterDefinition;  			writer.WriteUshort (GetParameterIndex ((IParameterDefinition)operation.Value));  		}  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		if (operation.Value == null)  			writer.WriteByte (0);  		else {  			//^ assume operation.Value is IParameterDefinition;  			writer.WriteByte ((byte)GetParameterIndex ((IParameterDefinition)operation.Value));  		}  		break;  	case OperationCode.Ldc_I4:  		//^ assume operation.Value is int;  		writer.WriteInt ((int)operation.Value);  		break;  	case OperationCode.Ldc_I4_S:  		//^ assume operation.Value is int;  		writer.WriteSbyte ((sbyte)(int)operation.Value);  		break;  	case OperationCode.Ldc_I8:  		//^ assume operation.Value is long;  		writer.WriteLong ((long)operation.Value);  		break;  	case OperationCode.Ldc_R4:  		//^ assume operation.Value is float;  		writer.WriteFloat ((float)operation.Value);  		break;  	case OperationCode.Ldc_R8:  		//^ assume operation.Value is double;  		writer.WriteDouble ((double)operation.Value);  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stfld:  	case OperationCode.Stsfld:  		//^ assume operation.Value is IFieldReference;  		writer.WriteUint (this.GetFieldToken ((IFieldReference)operation.Value));  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		//^ assume operation.Value is ILocalDefinition;  		writer.WriteUshort ((ushort)this.localDefIndex [(ILocalDefinition)operation.Value]);  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		//^ assume operation.Value is ILocalDefinition;  		writer.WriteByte ((byte)this.localDefIndex [(ILocalDefinition)operation.Value]);  		break;  	case OperationCode.Ldstr:  		//^ assume operation.Value is string;  		writer.WriteUint (this.GetUserStringToken ((string)operation.Value));  		break;  	case OperationCode.Ldtoken:  		uint token = 0;  		IFieldReference /*?*/fieldRef = operation.Value as IFieldReference;  		if (fieldRef != null)  			token = this.GetFieldToken (fieldRef);  		else {  			IMethodReference /*?*/methodRef = operation.Value as IMethodReference;  			if (methodRef != null)  				token = this.GetMethodToken (methodRef);  			else {  				//^ assume operation.Value is ITypeReference;  				token = this.GetTypeToken ((ITypeReference)operation.Value);  			}  		}  		writer.WriteUint (token);  		break;  	case OperationCode.Newarr:  		//^ assume operation.Value is IArrayTypeReference;  		writer.WriteUint (this.GetTypeToken (((IArrayTypeReference)operation.Value).ElementType));  		break;  	case OperationCode.No_:  		//^ assume operation.Value is OperationCheckFlags;  		writer.WriteByte ((byte)(OperationCheckFlags)operation.Value);  		break;  	case OperationCode.Switch:  		//^ assume operation.Value is uint[];  		uint[] targets = (uint[])operation.Value;  		writer.WriteUint ((uint)targets.Length);  		uint offset = writer.BaseStream.Position + (uint)targets.Length * 4;  		foreach (uint target in targets)  			writer.WriteInt ((int)(target - offset));  		break;  	case OperationCode.Unaligned_:  		//^ assume operation.Value is byte;  		writer.WriteByte ((byte)operation.Value);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	this.EmitPdbInformationFor (operation);  	switch (operation.OperationCode) {  	case OperationCode.Array_Addr:  	case OperationCode.Array_Get:  	case OperationCode.Array_Set:  		writer.WriteByte ((byte)OperationCode.Call);  		writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  		continue;  	case OperationCode.Array_Create:  	case OperationCode.Array_Create_WithLowerBound:  		writer.WriteByte ((byte)OperationCode.Newobj);  		writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  		continue;  	}  	if (operation.OperationCode < OperationCode.Arglist)  		writer.WriteByte ((byte)operation.OperationCode);  	else {  		writer.WriteByte ((byte)((ushort)operation.OperationCode >> 8));  		writer.WriteByte ((byte)((ushort)operation.OperationCode & 0xff));  	}  	switch (operation.OperationCode) {  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble:  	case OperationCode.Ble_Un:  	case OperationCode.Blt:  	case OperationCode.Blt_Un:  	case OperationCode.Bne_Un:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Leave:  		//^ assume operation.Value is uint;  		writer.WriteInt ((int)((uint)operation.Value - mbody.Position - 4));  		break;  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Leave_S:  		//^ assume operation.Value is uint;  		writer.WriteSbyte ((sbyte)((uint)operation.Value - mbody.Position - 1));  		break;  	case OperationCode.Box:  	case OperationCode.Castclass:  	case OperationCode.Constrained_:  	case OperationCode.Cpobj:  	case OperationCode.Initobj:  	case OperationCode.Isinst:  	case OperationCode.Ldelem:  	case OperationCode.Ldelema:  	case OperationCode.Ldobj:  	case OperationCode.Mkrefany:  	case OperationCode.Refanyval:  	case OperationCode.Sizeof:  	case OperationCode.Stelem:  	case OperationCode.Stobj:  	case OperationCode.Unbox:  	case OperationCode.Unbox_Any:  		//^ assume operation.Value is ITypeReference;  		writer.WriteUint (this.GetTypeToken ((ITypeReference)operation.Value));  		break;  	case OperationCode.Call:  	case OperationCode.Callvirt:  	case OperationCode.Jmp:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Newobj:  		//^ assume operation.Value is IMethodReference;  		writer.WriteUint (this.GetMethodToken ((IMethodReference)operation.Value));  		break;  	case OperationCode.Calli:  		//^ assume operation.Value is IFunctionPointerTypeReference;  		writer.WriteUint (this.GetStandaloneSignatureToken ((IFunctionPointerTypeReference)operation.Value));  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		if (operation.Value == null)  			writer.WriteUshort (0);  		else {  			//^ assume operation.Value is IParameterDefinition;  			writer.WriteUshort (GetParameterIndex ((IParameterDefinition)operation.Value));  		}  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		if (operation.Value == null)  			writer.WriteByte (0);  		else {  			//^ assume operation.Value is IParameterDefinition;  			writer.WriteByte ((byte)GetParameterIndex ((IParameterDefinition)operation.Value));  		}  		break;  	case OperationCode.Ldc_I4:  		//^ assume operation.Value is int;  		writer.WriteInt ((int)operation.Value);  		break;  	case OperationCode.Ldc_I4_S:  		//^ assume operation.Value is int;  		writer.WriteSbyte ((sbyte)(int)operation.Value);  		break;  	case OperationCode.Ldc_I8:  		//^ assume operation.Value is long;  		writer.WriteLong ((long)operation.Value);  		break;  	case OperationCode.Ldc_R4:  		//^ assume operation.Value is float;  		writer.WriteFloat ((float)operation.Value);  		break;  	case OperationCode.Ldc_R8:  		//^ assume operation.Value is double;  		writer.WriteDouble ((double)operation.Value);  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stfld:  	case OperationCode.Stsfld:  		//^ assume operation.Value is IFieldReference;  		writer.WriteUint (this.GetFieldToken ((IFieldReference)operation.Value));  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		//^ assume operation.Value is ILocalDefinition;  		writer.WriteUshort ((ushort)this.localDefIndex [(ILocalDefinition)operation.Value]);  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		//^ assume operation.Value is ILocalDefinition;  		writer.WriteByte ((byte)this.localDefIndex [(ILocalDefinition)operation.Value]);  		break;  	case OperationCode.Ldstr:  		//^ assume operation.Value is string;  		writer.WriteUint (this.GetUserStringToken ((string)operation.Value));  		break;  	case OperationCode.Ldtoken:  		uint token = 0;  		IFieldReference /*?*/fieldRef = operation.Value as IFieldReference;  		if (fieldRef != null)  			token = this.GetFieldToken (fieldRef);  		else {  			IMethodReference /*?*/methodRef = operation.Value as IMethodReference;  			if (methodRef != null)  				token = this.GetMethodToken (methodRef);  			else {  				//^ assume operation.Value is ITypeReference;  				token = this.GetTypeToken ((ITypeReference)operation.Value);  			}  		}  		writer.WriteUint (token);  		break;  	case OperationCode.Newarr:  		//^ assume operation.Value is IArrayTypeReference;  		writer.WriteUint (this.GetTypeToken (((IArrayTypeReference)operation.Value).ElementType));  		break;  	case OperationCode.No_:  		//^ assume operation.Value is OperationCheckFlags;  		writer.WriteByte ((byte)(OperationCheckFlags)operation.Value);  		break;  	case OperationCode.Switch:  		//^ assume operation.Value is uint[];  		uint[] targets = (uint[])operation.Value;  		writer.WriteUint ((uint)targets.Length);  		uint offset = writer.BaseStream.Position + (uint)targets.Length * 4;  		foreach (uint target in targets)  			writer.WriteInt ((int)(target - offset));  		break;  	case OperationCode.Unaligned_:  		//^ assume operation.Value is byte;  		writer.WriteByte ((byte)operation.Value);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: foreach (IOperation operation in methodBody.Operations) {  	this.EmitPdbInformationFor (operation);  	switch (operation.OperationCode) {  	case OperationCode.Array_Addr:  	case OperationCode.Array_Get:  	case OperationCode.Array_Set:  		writer.WriteByte ((byte)OperationCode.Call);  		writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  		continue;  	case OperationCode.Array_Create:  	case OperationCode.Array_Create_WithLowerBound:  		writer.WriteByte ((byte)OperationCode.Newobj);  		writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  		continue;  	}  	if (operation.OperationCode < OperationCode.Arglist)  		writer.WriteByte ((byte)operation.OperationCode);  	else {  		writer.WriteByte ((byte)((ushort)operation.OperationCode >> 8));  		writer.WriteByte ((byte)((ushort)operation.OperationCode & 0xff));  	}  	switch (operation.OperationCode) {  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble:  	case OperationCode.Ble_Un:  	case OperationCode.Blt:  	case OperationCode.Blt_Un:  	case OperationCode.Bne_Un:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Leave:  		//^ assume operation.Value is uint;  		writer.WriteInt ((int)((uint)operation.Value - mbody.Position - 4));  		break;  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Leave_S:  		//^ assume operation.Value is uint;  		writer.WriteSbyte ((sbyte)((uint)operation.Value - mbody.Position - 1));  		break;  	case OperationCode.Box:  	case OperationCode.Castclass:  	case OperationCode.Constrained_:  	case OperationCode.Cpobj:  	case OperationCode.Initobj:  	case OperationCode.Isinst:  	case OperationCode.Ldelem:  	case OperationCode.Ldelema:  	case OperationCode.Ldobj:  	case OperationCode.Mkrefany:  	case OperationCode.Refanyval:  	case OperationCode.Sizeof:  	case OperationCode.Stelem:  	case OperationCode.Stobj:  	case OperationCode.Unbox:  	case OperationCode.Unbox_Any:  		//^ assume operation.Value is ITypeReference;  		writer.WriteUint (this.GetTypeToken ((ITypeReference)operation.Value));  		break;  	case OperationCode.Call:  	case OperationCode.Callvirt:  	case OperationCode.Jmp:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Newobj:  		//^ assume operation.Value is IMethodReference;  		writer.WriteUint (this.GetMethodToken ((IMethodReference)operation.Value));  		break;  	case OperationCode.Calli:  		//^ assume operation.Value is IFunctionPointerTypeReference;  		writer.WriteUint (this.GetStandaloneSignatureToken ((IFunctionPointerTypeReference)operation.Value));  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		if (operation.Value == null)  			writer.WriteUshort (0);  		else {  			//^ assume operation.Value is IParameterDefinition;  			writer.WriteUshort (GetParameterIndex ((IParameterDefinition)operation.Value));  		}  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		if (operation.Value == null)  			writer.WriteByte (0);  		else {  			//^ assume operation.Value is IParameterDefinition;  			writer.WriteByte ((byte)GetParameterIndex ((IParameterDefinition)operation.Value));  		}  		break;  	case OperationCode.Ldc_I4:  		//^ assume operation.Value is int;  		writer.WriteInt ((int)operation.Value);  		break;  	case OperationCode.Ldc_I4_S:  		//^ assume operation.Value is int;  		writer.WriteSbyte ((sbyte)(int)operation.Value);  		break;  	case OperationCode.Ldc_I8:  		//^ assume operation.Value is long;  		writer.WriteLong ((long)operation.Value);  		break;  	case OperationCode.Ldc_R4:  		//^ assume operation.Value is float;  		writer.WriteFloat ((float)operation.Value);  		break;  	case OperationCode.Ldc_R8:  		//^ assume operation.Value is double;  		writer.WriteDouble ((double)operation.Value);  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stfld:  	case OperationCode.Stsfld:  		//^ assume operation.Value is IFieldReference;  		writer.WriteUint (this.GetFieldToken ((IFieldReference)operation.Value));  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		//^ assume operation.Value is ILocalDefinition;  		writer.WriteUshort ((ushort)this.localDefIndex [(ILocalDefinition)operation.Value]);  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		//^ assume operation.Value is ILocalDefinition;  		writer.WriteByte ((byte)this.localDefIndex [(ILocalDefinition)operation.Value]);  		break;  	case OperationCode.Ldstr:  		//^ assume operation.Value is string;  		writer.WriteUint (this.GetUserStringToken ((string)operation.Value));  		break;  	case OperationCode.Ldtoken:  		uint token = 0;  		IFieldReference /*?*/fieldRef = operation.Value as IFieldReference;  		if (fieldRef != null)  			token = this.GetFieldToken (fieldRef);  		else {  			IMethodReference /*?*/methodRef = operation.Value as IMethodReference;  			if (methodRef != null)  				token = this.GetMethodToken (methodRef);  			else {  				//^ assume operation.Value is ITypeReference;  				token = this.GetTypeToken ((ITypeReference)operation.Value);  			}  		}  		writer.WriteUint (token);  		break;  	case OperationCode.Newarr:  		//^ assume operation.Value is IArrayTypeReference;  		writer.WriteUint (this.GetTypeToken (((IArrayTypeReference)operation.Value).ElementType));  		break;  	case OperationCode.No_:  		//^ assume operation.Value is OperationCheckFlags;  		writer.WriteByte ((byte)(OperationCheckFlags)operation.Value);  		break;  	case OperationCode.Switch:  		//^ assume operation.Value is uint[];  		uint[] targets = (uint[])operation.Value;  		writer.WriteUint ((uint)targets.Length);  		uint offset = writer.BaseStream.Position + (uint)targets.Length * 4;  		foreach (uint target in targets)  			writer.WriteInt ((int)(target - offset));  		break;  	case OperationCode.Unaligned_:  		//^ assume operation.Value is byte;  		writer.WriteByte ((byte)operation.Value);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: if (operation.OperationCode < OperationCode.Arglist)  	writer.WriteByte ((byte)operation.OperationCode);  else {  	writer.WriteByte ((byte)((ushort)operation.OperationCode >> 8));  	writer.WriteByte ((byte)((ushort)operation.OperationCode & 0xff));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: writer.WriteByte ((byte)((ushort)operation.OperationCode >> 8));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Leave:  	//^ assume operation.Value is uint;  	writer.WriteInt ((int)((uint)operation.Value - mbody.Position - 4));  	break;  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	//^ assume operation.Value is uint;  	writer.WriteSbyte ((sbyte)((uint)operation.Value - mbody.Position - 1));  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Constrained_:  case OperationCode.Cpobj:  case OperationCode.Initobj:  case OperationCode.Isinst:  case OperationCode.Ldelem:  case OperationCode.Ldelema:  case OperationCode.Ldobj:  case OperationCode.Mkrefany:  case OperationCode.Refanyval:  case OperationCode.Sizeof:  case OperationCode.Stelem:  case OperationCode.Stobj:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	//^ assume operation.Value is ITypeReference;  	writer.WriteUint (this.GetTypeToken ((ITypeReference)operation.Value));  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  case OperationCode.Jmp:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Newobj:  	//^ assume operation.Value is IMethodReference;  	writer.WriteUint (this.GetMethodToken ((IMethodReference)operation.Value));  	break;  case OperationCode.Calli:  	//^ assume operation.Value is IFunctionPointerTypeReference;  	writer.WriteUint (this.GetStandaloneSignatureToken ((IFunctionPointerTypeReference)operation.Value));  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	if (operation.Value == null)  		writer.WriteUshort (0);  	else {  		//^ assume operation.Value is IParameterDefinition;  		writer.WriteUshort (GetParameterIndex ((IParameterDefinition)operation.Value));  	}  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	if (operation.Value == null)  		writer.WriteByte (0);  	else {  		//^ assume operation.Value is IParameterDefinition;  		writer.WriteByte ((byte)GetParameterIndex ((IParameterDefinition)operation.Value));  	}  	break;  case OperationCode.Ldc_I4:  	//^ assume operation.Value is int;  	writer.WriteInt ((int)operation.Value);  	break;  case OperationCode.Ldc_I4_S:  	//^ assume operation.Value is int;  	writer.WriteSbyte ((sbyte)(int)operation.Value);  	break;  case OperationCode.Ldc_I8:  	//^ assume operation.Value is long;  	writer.WriteLong ((long)operation.Value);  	break;  case OperationCode.Ldc_R4:  	//^ assume operation.Value is float;  	writer.WriteFloat ((float)operation.Value);  	break;  case OperationCode.Ldc_R8:  	//^ assume operation.Value is double;  	writer.WriteDouble ((double)operation.Value);  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stfld:  case OperationCode.Stsfld:  	//^ assume operation.Value is IFieldReference;  	writer.WriteUint (this.GetFieldToken ((IFieldReference)operation.Value));  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	//^ assume operation.Value is ILocalDefinition;  	writer.WriteUshort ((ushort)this.localDefIndex [(ILocalDefinition)operation.Value]);  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	//^ assume operation.Value is ILocalDefinition;  	writer.WriteByte ((byte)this.localDefIndex [(ILocalDefinition)operation.Value]);  	break;  case OperationCode.Ldstr:  	//^ assume operation.Value is string;  	writer.WriteUint (this.GetUserStringToken ((string)operation.Value));  	break;  case OperationCode.Ldtoken:  	uint token = 0;  	IFieldReference /*?*/fieldRef = operation.Value as IFieldReference;  	if (fieldRef != null)  		token = this.GetFieldToken (fieldRef);  	else {  		IMethodReference /*?*/methodRef = operation.Value as IMethodReference;  		if (methodRef != null)  			token = this.GetMethodToken (methodRef);  		else {  			//^ assume operation.Value is ITypeReference;  			token = this.GetTypeToken ((ITypeReference)operation.Value);  		}  	}  	writer.WriteUint (token);  	break;  case OperationCode.Newarr:  	//^ assume operation.Value is IArrayTypeReference;  	writer.WriteUint (this.GetTypeToken (((IArrayTypeReference)operation.Value).ElementType));  	break;  case OperationCode.No_:  	//^ assume operation.Value is OperationCheckFlags;  	writer.WriteByte ((byte)(OperationCheckFlags)operation.Value);  	break;  case OperationCode.Switch:  	//^ assume operation.Value is uint[];  	uint[] targets = (uint[])operation.Value;  	writer.WriteUint ((uint)targets.Length);  	uint offset = writer.BaseStream.Position + (uint)targets.Length * 4;  	foreach (uint target in targets)  		writer.WriteInt ((int)(target - offset));  	break;  case OperationCode.Unaligned_:  	//^ assume operation.Value is byte;  	writer.WriteByte ((byte)operation.Value);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Leave:  	//^ assume operation.Value is uint;  	writer.WriteInt ((int)((uint)operation.Value - mbody.Position - 4));  	break;  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	//^ assume operation.Value is uint;  	writer.WriteSbyte ((sbyte)((uint)operation.Value - mbody.Position - 1));  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Constrained_:  case OperationCode.Cpobj:  case OperationCode.Initobj:  case OperationCode.Isinst:  case OperationCode.Ldelem:  case OperationCode.Ldelema:  case OperationCode.Ldobj:  case OperationCode.Mkrefany:  case OperationCode.Refanyval:  case OperationCode.Sizeof:  case OperationCode.Stelem:  case OperationCode.Stobj:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	//^ assume operation.Value is ITypeReference;  	writer.WriteUint (this.GetTypeToken ((ITypeReference)operation.Value));  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  case OperationCode.Jmp:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Newobj:  	//^ assume operation.Value is IMethodReference;  	writer.WriteUint (this.GetMethodToken ((IMethodReference)operation.Value));  	break;  case OperationCode.Calli:  	//^ assume operation.Value is IFunctionPointerTypeReference;  	writer.WriteUint (this.GetStandaloneSignatureToken ((IFunctionPointerTypeReference)operation.Value));  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	if (operation.Value == null)  		writer.WriteUshort (0);  	else {  		//^ assume operation.Value is IParameterDefinition;  		writer.WriteUshort (GetParameterIndex ((IParameterDefinition)operation.Value));  	}  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	if (operation.Value == null)  		writer.WriteByte (0);  	else {  		//^ assume operation.Value is IParameterDefinition;  		writer.WriteByte ((byte)GetParameterIndex ((IParameterDefinition)operation.Value));  	}  	break;  case OperationCode.Ldc_I4:  	//^ assume operation.Value is int;  	writer.WriteInt ((int)operation.Value);  	break;  case OperationCode.Ldc_I4_S:  	//^ assume operation.Value is int;  	writer.WriteSbyte ((sbyte)(int)operation.Value);  	break;  case OperationCode.Ldc_I8:  	//^ assume operation.Value is long;  	writer.WriteLong ((long)operation.Value);  	break;  case OperationCode.Ldc_R4:  	//^ assume operation.Value is float;  	writer.WriteFloat ((float)operation.Value);  	break;  case OperationCode.Ldc_R8:  	//^ assume operation.Value is double;  	writer.WriteDouble ((double)operation.Value);  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stfld:  case OperationCode.Stsfld:  	//^ assume operation.Value is IFieldReference;  	writer.WriteUint (this.GetFieldToken ((IFieldReference)operation.Value));  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	//^ assume operation.Value is ILocalDefinition;  	writer.WriteUshort ((ushort)this.localDefIndex [(ILocalDefinition)operation.Value]);  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	//^ assume operation.Value is ILocalDefinition;  	writer.WriteByte ((byte)this.localDefIndex [(ILocalDefinition)operation.Value]);  	break;  case OperationCode.Ldstr:  	//^ assume operation.Value is string;  	writer.WriteUint (this.GetUserStringToken ((string)operation.Value));  	break;  case OperationCode.Ldtoken:  	uint token = 0;  	IFieldReference /*?*/fieldRef = operation.Value as IFieldReference;  	if (fieldRef != null)  		token = this.GetFieldToken (fieldRef);  	else {  		IMethodReference /*?*/methodRef = operation.Value as IMethodReference;  		if (methodRef != null)  			token = this.GetMethodToken (methodRef);  		else {  			//^ assume operation.Value is ITypeReference;  			token = this.GetTypeToken ((ITypeReference)operation.Value);  		}  	}  	writer.WriteUint (token);  	break;  case OperationCode.Newarr:  	//^ assume operation.Value is IArrayTypeReference;  	writer.WriteUint (this.GetTypeToken (((IArrayTypeReference)operation.Value).ElementType));  	break;  case OperationCode.No_:  	//^ assume operation.Value is OperationCheckFlags;  	writer.WriteByte ((byte)(OperationCheckFlags)operation.Value);  	break;  case OperationCode.Switch:  	//^ assume operation.Value is uint[];  	uint[] targets = (uint[])operation.Value;  	writer.WriteUint ((uint)targets.Length);  	uint offset = writer.BaseStream.Position + (uint)targets.Length * 4;  	foreach (uint target in targets)  		writer.WriteInt ((int)(target - offset));  	break;  case OperationCode.Unaligned_:  	//^ assume operation.Value is byte;  	writer.WriteByte ((byte)operation.Value);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following statement contains a magic number: writer.WriteInt ((int)((uint)operation.Value - mbody.Position - 4));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: writer.Align (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {  	uint dataSize = numberOfExceptionHandlers * 12 + 4;  	writer.WriteByte (0x01);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort (0);  }  else {  	uint dataSize = numberOfExceptionHandlers * 24 + 4;  	writer.WriteByte (0x41);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort ((ushort)((dataSize >> 8) & 0xffff));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {  	uint dataSize = numberOfExceptionHandlers * 12 + 4;  	writer.WriteByte (0x01);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort (0);  }  else {  	uint dataSize = numberOfExceptionHandlers * 24 + 4;  	writer.WriteByte (0x41);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort ((ushort)((dataSize >> 8) & 0xffff));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {  	uint dataSize = numberOfExceptionHandlers * 12 + 4;  	writer.WriteByte (0x01);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort (0);  }  else {  	uint dataSize = numberOfExceptionHandlers * 24 + 4;  	writer.WriteByte (0x41);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort ((ushort)((dataSize >> 8) & 0xffff));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {  	uint dataSize = numberOfExceptionHandlers * 12 + 4;  	writer.WriteByte (0x01);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort (0);  }  else {  	uint dataSize = numberOfExceptionHandlers * 24 + 4;  	writer.WriteByte (0x41);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort ((ushort)((dataSize >> 8) & 0xffff));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: if (useSmallExceptionHeaders) {  	uint dataSize = numberOfExceptionHandlers * 12 + 4;  	writer.WriteByte (0x01);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort (0);  }  else {  	uint dataSize = numberOfExceptionHandlers * 24 + 4;  	writer.WriteByte (0x41);  	writer.WriteByte ((byte)(dataSize & 0xff));  	writer.WriteUshort ((ushort)((dataSize >> 8) & 0xffff));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyExceptionHandlerTable,The following statement contains a magic number: writer.WriteUshort ((ushort)((dataSize >> 8) & 0xffff));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,MayUseSmallExceptionHeaders,The following statement contains a magic number: if (numberOfExceptionHandlers * 12 + 4 > 0xff)  	return false;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,MayUseSmallExceptionHeaders,The following statement contains a magic number: if (numberOfExceptionHandlers * 12 + 4 > 0xff)  	return false;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: foreach (IWin32Resource r in this.module.Win32Resources) {  	bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;  	if (typeDifferent) {  		lastTypeID = r.TypeId;  		lastTypeName = r.TypeName;  		if (lastTypeID < 0)  			TypeDirectory.NumberOfNamedEntries++;  		else  			TypeDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  	}  	if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  		lastID = r.Id;  		lastName = r.Name;  		if (lastID < 0)  			NameDirectory.NumberOfNamedEntries++;  		else  			NameDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  	}  	LanguageDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 8;  	LanguageDirectory.Entries.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: foreach (IWin32Resource r in this.module.Win32Resources) {  	bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;  	if (typeDifferent) {  		lastTypeID = r.TypeId;  		lastTypeName = r.TypeName;  		if (lastTypeID < 0)  			TypeDirectory.NumberOfNamedEntries++;  		else  			TypeDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  	}  	if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  		lastID = r.Id;  		lastName = r.Name;  		if (lastID < 0)  			NameDirectory.NumberOfNamedEntries++;  		else  			NameDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  	}  	LanguageDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 8;  	LanguageDirectory.Entries.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: foreach (IWin32Resource r in this.module.Win32Resources) {  	bool typeDifferent = (r.TypeId < 0 && r.TypeName != lastTypeName) || r.TypeId > lastTypeID;  	if (typeDifferent) {  		lastTypeID = r.TypeId;  		lastTypeName = r.TypeName;  		if (lastTypeID < 0)  			TypeDirectory.NumberOfNamedEntries++;  		else  			TypeDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  	}  	if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  		lastID = r.Id;  		lastName = r.Name;  		if (lastID < 0)  			NameDirectory.NumberOfNamedEntries++;  		else  			NameDirectory.NumberOfIdEntries++;  		sizeOfDirectoryTree += 24;  		NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  	}  	LanguageDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 8;  	LanguageDirectory.Entries.Add (r);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: if (typeDifferent) {  	lastTypeID = r.TypeId;  	lastTypeName = r.TypeName;  	if (lastTypeID < 0)  		TypeDirectory.NumberOfNamedEntries++;  	else  		TypeDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 24;  	TypeDirectory.Entries.Add (NameDirectory = new Directory (lastTypeName' lastTypeID));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: sizeOfDirectoryTree += 24;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: if (typeDifferent || (r.Id < 0 && r.Name != lastName) || r.Id > lastID) {  	lastID = r.Id;  	lastName = r.Name;  	if (lastID < 0)  		NameDirectory.NumberOfNamedEntries++;  	else  		NameDirectory.NumberOfIdEntries++;  	sizeOfDirectoryTree += 24;  	NameDirectory.Entries.Add (LanguageDirectory = new Directory (lastName' lastID));  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: sizeOfDirectoryTree += 24;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: sizeOfDirectoryTree += 8;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeWin32Resources,The following statement contains a magic number: while ((this.win32ResourceWriter.BaseStream.Length % 4) != 0)  	this.win32ResourceWriter.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	uint nOff = dataWriter.BaseStream.Position + sizeOfDirectoryTree;  	uint dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += SizeOfDirectory (subDir);  		else  			k += 16 + 8 * (uint)subDir.Entries.Count;  	}  	else {  		IWin32Resource r = (IWin32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  		byte[] data = new List<byte> (r.Data).ToArray ();  		dataWriter.WriteUint ((uint)data.Length);  		dataWriter.WriteUint (r.CodePage);  		dataWriter.WriteUint (0);  		dataWriter.WriteBytes (data);  		while ((dataWriter.BaseStream.Length % 4) != 0)  			dataWriter.WriteByte (0);  	}  	if (id >= 0)  		writer.WriteInt (id);  	else {  		if (name == null)  			name = "";  		writer.WriteUint (nOff | 0x80000000);  		dataWriter.WriteUshort ((ushort)name.Length);  		dataWriter.WriteChars (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.WriteUint (dOff | 0x80000000);  	else  		writer.WriteUint (nOff);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	uint nOff = dataWriter.BaseStream.Position + sizeOfDirectoryTree;  	uint dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += SizeOfDirectory (subDir);  		else  			k += 16 + 8 * (uint)subDir.Entries.Count;  	}  	else {  		IWin32Resource r = (IWin32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  		byte[] data = new List<byte> (r.Data).ToArray ();  		dataWriter.WriteUint ((uint)data.Length);  		dataWriter.WriteUint (r.CodePage);  		dataWriter.WriteUint (0);  		dataWriter.WriteBytes (data);  		while ((dataWriter.BaseStream.Length % 4) != 0)  			dataWriter.WriteByte (0);  	}  	if (id >= 0)  		writer.WriteInt (id);  	else {  		if (name == null)  			name = "";  		writer.WriteUint (nOff | 0x80000000);  		dataWriter.WriteUshort ((ushort)name.Length);  		dataWriter.WriteChars (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.WriteUint (dOff | 0x80000000);  	else  		writer.WriteUint (nOff);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	uint nOff = dataWriter.BaseStream.Position + sizeOfDirectoryTree;  	uint dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += SizeOfDirectory (subDir);  		else  			k += 16 + 8 * (uint)subDir.Entries.Count;  	}  	else {  		IWin32Resource r = (IWin32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  		byte[] data = new List<byte> (r.Data).ToArray ();  		dataWriter.WriteUint ((uint)data.Length);  		dataWriter.WriteUint (r.CodePage);  		dataWriter.WriteUint (0);  		dataWriter.WriteBytes (data);  		while ((dataWriter.BaseStream.Length % 4) != 0)  			dataWriter.WriteByte (0);  	}  	if (id >= 0)  		writer.WriteInt (id);  	else {  		if (name == null)  			name = "";  		writer.WriteUint (nOff | 0x80000000);  		dataWriter.WriteUshort ((ushort)name.Length);  		dataWriter.WriteChars (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.WriteUint (dOff | 0x80000000);  	else  		writer.WriteUint (nOff);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int id = int.MinValue;  	string name = null;  	uint nOff = dataWriter.BaseStream.Position + sizeOfDirectoryTree;  	uint dOff = k;  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		id = subDir.ID;  		name = subDir.Name;  		if (level == 0)  			k += SizeOfDirectory (subDir);  		else  			k += 16 + 8 * (uint)subDir.Entries.Count;  	}  	else {  		IWin32Resource r = (IWin32Resource)directory.Entries [i];  		id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  		name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  		dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  		byte[] data = new List<byte> (r.Data).ToArray ();  		dataWriter.WriteUint ((uint)data.Length);  		dataWriter.WriteUint (r.CodePage);  		dataWriter.WriteUint (0);  		dataWriter.WriteBytes (data);  		while ((dataWriter.BaseStream.Length % 4) != 0)  			dataWriter.WriteByte (0);  	}  	if (id >= 0)  		writer.WriteInt (id);  	else {  		if (name == null)  			name = "";  		writer.WriteUint (nOff | 0x80000000);  		dataWriter.WriteUshort ((ushort)name.Length);  		dataWriter.WriteChars (name.ToCharArray ());  		//REVIEW: what happens if the name contains chars that do not fit into a single utf8 code point?  	}  	if (subDir != null)  		writer.WriteUint (dOff | 0x80000000);  	else  		writer.WriteUint (nOff);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += SizeOfDirectory (subDir);  	else  		k += 16 + 8 * (uint)subDir.Entries.Count;  }  else {  	IWin32Resource r = (IWin32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  	byte[] data = new List<byte> (r.Data).ToArray ();  	dataWriter.WriteUint ((uint)data.Length);  	dataWriter.WriteUint (r.CodePage);  	dataWriter.WriteUint (0);  	dataWriter.WriteBytes (data);  	while ((dataWriter.BaseStream.Length % 4) != 0)  		dataWriter.WriteByte (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += SizeOfDirectory (subDir);  	else  		k += 16 + 8 * (uint)subDir.Entries.Count;  }  else {  	IWin32Resource r = (IWin32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  	byte[] data = new List<byte> (r.Data).ToArray ();  	dataWriter.WriteUint ((uint)data.Length);  	dataWriter.WriteUint (r.CodePage);  	dataWriter.WriteUint (0);  	dataWriter.WriteBytes (data);  	while ((dataWriter.BaseStream.Length % 4) != 0)  		dataWriter.WriteByte (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += SizeOfDirectory (subDir);  	else  		k += 16 + 8 * (uint)subDir.Entries.Count;  }  else {  	IWin32Resource r = (IWin32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  	byte[] data = new List<byte> (r.Data).ToArray ();  	dataWriter.WriteUint ((uint)data.Length);  	dataWriter.WriteUint (r.CodePage);  	dataWriter.WriteUint (0);  	dataWriter.WriteBytes (data);  	while ((dataWriter.BaseStream.Length % 4) != 0)  		dataWriter.WriteByte (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	id = subDir.ID;  	name = subDir.Name;  	if (level == 0)  		k += SizeOfDirectory (subDir);  	else  		k += 16 + 8 * (uint)subDir.Entries.Count;  }  else {  	IWin32Resource r = (IWin32Resource)directory.Entries [i];  	id = level == 0 ? r.TypeId : level == 1 ? r.Id : (int)r.LanguageId;  	name = level == 0 ? r.TypeName : level == 1 ? r.Name : null;  	dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  	byte[] data = new List<byte> (r.Data).ToArray ();  	dataWriter.WriteUint ((uint)data.Length);  	dataWriter.WriteUint (r.CodePage);  	dataWriter.WriteUint (0);  	dataWriter.WriteBytes (data);  	while ((dataWriter.BaseStream.Length % 4) != 0)  		dataWriter.WriteByte (0);  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += SizeOfDirectory (subDir);  else  	k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += SizeOfDirectory (subDir);  else  	k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: dataWriter.WriteUint (virtualAddressBase + sizeOfDirectoryTree + 16 + dataWriter.BaseStream.Position);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: while ((dataWriter.BaseStream.Length % 4) != 0)  	dataWriter.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k = offset + 16 + n * 8;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataWriter);  		if (level == 0)  			k += SizeOfDirectory (subDir);  		else  			k += 16 + 8 * (uint)subDir.Entries.Count;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null) {  		this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataWriter);  		if (level == 0)  			k += SizeOfDirectory (subDir);  		else  			k += 16 + 8 * (uint)subDir.Entries.Count;  	}  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataWriter);  	if (level == 0)  		k += SizeOfDirectory (subDir);  	else  		k += 16 + 8 * (uint)subDir.Entries.Count;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (subDir != null) {  	this.WriteDirectory (subDir' writer' k' level + 1' sizeOfDirectoryTree' virtualAddressBase' dataWriter);  	if (level == 0)  		k += SizeOfDirectory (subDir);  	else  		k += 16 + 8 * (uint)subDir.Entries.Count;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += SizeOfDirectory (subDir);  else  	k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: if (level == 0)  	k += SizeOfDirectory (subDir);  else  	k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteDirectory,The following statement contains a magic number: k += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null)  		size += 16 + 8 * (uint)subDir.Entries.Count;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	Directory subDir = directory.Entries [i] as Directory;  	if (subDir != null)  		size += 16 + 8 * (uint)subDir.Entries.Count;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: if (subDir != null)  	size += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: if (subDir != null)  	size += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: size += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SizeOfDirectory,The following statement contains a magic number: size += 16 + 8 * (uint)subDir.Entries.Count;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort ((ushort)(!module.Requires64bits ? 224 : 240));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort ((ushort)(!module.Requires64bits ? 224 : 240));  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort (4);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: switch (module.Kind) {  case ModuleKind.ConsoleApplication:  case ModuleKind.DynamicallyLinkedLibrary:  	writer.WriteUshort (3);  	//70  	break;  case ModuleKind.WindowsApplication:  	writer.WriteUshort (2);  	//70  	break;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: switch (module.Kind) {  case ModuleKind.ConsoleApplication:  case ModuleKind.DynamicallyLinkedLibrary:  	writer.WriteUshort (3);  	//70  	break;  case ModuleKind.WindowsApplication:  	writer.WriteUshort (2);  	//70  	break;  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort (3);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUshort (2);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following statement contains a magic number: writer.WriteUint (16);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteSectionHeader,The following statement contains a magic number: for (int j = 0' m = sectionHeader.Name.Length; j < 8; j++)  	if (j < m)  		writer.WriteByte ((byte)sectionHeader.Name [j]);  	else  		writer.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteImportTable,The following statement contains a magic number: writer.BaseStream.Position += 20;  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteClrHeader,The following statement contains a magic number: writer.WriteUint (72);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteIL,The following statement contains a magic number: while (this.peStream.Position % 4 != 0)  	this.peStream.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteTextData,The following statement contains a magic number: while (this.peStream.Position % 4 != 0)  	this.peStream.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteMetadata,The following statement contains a magic number: while (this.peStream.Position % 4 != 0)  	this.peStream.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteManagedResources,The following statement contains a magic number: while (this.peStream.Position % 4 != 0)  	this.peStream.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRuntimeStartupStub,The following statement contains a magic number: if (!this.module.Requires64bits) {  	//emit 0's (nops) to pad the entry point code so that the target address is aligned on a 4 byte boundary.  	for (uint i = 0' n = (uint)(Aligned ((uint)this.peStream.Position' 4) - this.peStream.Position); i < n; i++)  		writer.WriteByte (0);  	writer.WriteUshort (0);  	writer.WriteByte (0xff);  	writer.WriteByte (0x25);  	//4  	writer.WriteUint (this.ntHeader.ImportAddressTable.RelativeVirtualAddress + (uint)this.module.BaseAddress);  	//8  }  else {  	//emit 0's (nops) to pad the entry point code so that the target address is aligned on a 8 byte boundary.  	for (uint i = 0' n = (uint)(Aligned ((uint)this.peStream.Position' 8) - this.peStream.Position); i < n; i++)  		writer.WriteByte (0);  	writer.WriteUint (0);  	writer.WriteUshort (0);  	writer.WriteByte (0xff);  	writer.WriteByte (0x25);  	//8  	writer.WriteUlong (this.ntHeader.ImportAddressTable.RelativeVirtualAddress + this.module.BaseAddress);  	//16  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRuntimeStartupStub,The following statement contains a magic number: if (!this.module.Requires64bits) {  	//emit 0's (nops) to pad the entry point code so that the target address is aligned on a 4 byte boundary.  	for (uint i = 0' n = (uint)(Aligned ((uint)this.peStream.Position' 4) - this.peStream.Position); i < n; i++)  		writer.WriteByte (0);  	writer.WriteUshort (0);  	writer.WriteByte (0xff);  	writer.WriteByte (0x25);  	//4  	writer.WriteUint (this.ntHeader.ImportAddressTable.RelativeVirtualAddress + (uint)this.module.BaseAddress);  	//8  }  else {  	//emit 0's (nops) to pad the entry point code so that the target address is aligned on a 8 byte boundary.  	for (uint i = 0' n = (uint)(Aligned ((uint)this.peStream.Position' 8) - this.peStream.Position); i < n; i++)  		writer.WriteByte (0);  	writer.WriteUint (0);  	writer.WriteUshort (0);  	writer.WriteByte (0xff);  	writer.WriteByte (0x25);  	//8  	writer.WriteUlong (this.ntHeader.ImportAddressTable.RelativeVirtualAddress + this.module.BaseAddress);  	//16  }  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRuntimeStartupStub,The following statement contains a magic number: for (uint i = 0' n = (uint)(Aligned ((uint)this.peStream.Position' 4) - this.peStream.Position); i < n; i++)  	writer.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRuntimeStartupStub,The following statement contains a magic number: for (uint i = 0' n = (uint)(Aligned ((uint)this.peStream.Position' 8) - this.peStream.Position); i < n; i++)  	writer.WriteByte (0);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: writer.WriteUint (((this.ntHeader.AddressOfEntryPoint + 2) / 0x1000) * 0x1000);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: if (this.module.Requires64bits && !this.module.RequiresAmdInstructionSet)  	writer.WriteUint (relocType << 12);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteRelocSection,The following statement contains a magic number: writer.WriteUint (relocType << 12);  
Magic Number,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteResourceSection,The following statement contains a magic number: while (this.peStream.Position % 8 != 0)  	this.peStream.WriteByte (0);  
Magic Number,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,SetStreamReaderPositionTo,The following statement contains a magic number: if (position < this.streamReaderPosition - this.charsInBuffer) {  	this.streamReader.BaseStream.Position = 0;  	this.streamReader = new StreamReader (this.streamReader.BaseStream' this.streamReader.CurrentEncoding' false' 128);  	this.charsInBuffer = this.streamReader.ReadBlock (this.buffer' 0' this.buffer.Length);  	this.streamReaderPosition = this.charsInBuffer;  	if (this.streamReader.EndOfStream) {  		this.length = this.streamReaderPosition;  		return;  	}  }  
Magic Number,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,SetStreamReaderPositionTo,The following statement contains a magic number: this.streamReader = new StreamReader (this.streamReader.BaseStream' this.streamReader.CurrentEncoding' false' 128);  
Magic Number,Microsoft.Cci.ILGeneratorImplementation,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Push,The following statement contains a magic number: if (this.Count == this.elements.Length)  	Array.Resize (ref this.elements' this.elements.Length * 2);  
Magic Number,Microsoft.Cci.ILGeneratorImplementation,Stack,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILGenerator.cs,Push,The following statement contains a magic number: Array.Resize (ref this.elements' this.elements.Length * 2);  
Magic Number,Microsoft.Cci.Immutable,ArrayType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: if (version.Major >= 2) {  	interfaces.Add (this.PlatformType.SystemCollectionsIStructuralComparable);  	interfaces.Add (this.PlatformType.SystemCollectionsIStructuralEquatable);  }  
Magic Number,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: if (version.Major >= 4) {  	interfaces.Add (this.PlatformType.SystemCollectionsIStructuralComparable);  	interfaces.Add (this.PlatformType.SystemCollectionsIStructuralEquatable);  }  
Magic Number,Microsoft.Cci.Immutable,Vector,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Types.cs,GetInterfaceList,The following statement contains a magic number: if (version.Major >= 2) {  	var argTypes = IteratorHelper.GetSingletonEnumerable<ITypeReference> (this.ElementType);  	interfaces.Add (new GenericTypeInstanceReference (this.PlatformType.SystemCollectionsGenericIList' argTypes' this.InternFactory));  	interfaces.Add (new GenericTypeInstanceReference (this.PlatformType.SystemCollectionsGenericICollection' argTypes' this.InternFactory));  	interfaces.Add (new GenericTypeInstanceReference (this.PlatformType.SystemCollectionsGenericIEnumerable' argTypes' this.InternFactory));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key;  	uint b = 0x9e3779b9;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: a ^= (c >> 13);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: b ^= (a << 8);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: c ^= (b >> 13);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: a ^= (c >> 12);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: b ^= (a << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: c ^= (b >> 5);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: a ^= (c >> 3);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: b ^= (a << 10);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt1,The following statement contains a magic number: c ^= (b >> 15);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: hash += (hash << 3);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: hash ^= (hash >> 11);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashInt2,The following statement contains a magic number: hash += (hash << 15);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: unchecked {  	uint a = 0x9e3779b9 + key1;  	uint b = 0x9e3779b9 + key2;  	uint c = 16777619;  	a -= b;  	a -= c;  	a ^= (c >> 13);  	b -= c;  	b -= a;  	b ^= (a << 8);  	c -= a;  	c -= b;  	c ^= (b >> 13);  	a -= b;  	a -= c;  	a ^= (c >> 12);  	b -= c;  	b -= a;  	b ^= (a << 16);  	c -= a;  	c -= b;  	c ^= (b >> 5);  	a -= b;  	a -= c;  	a ^= (c >> 3);  	b -= c;  	b -= a;  	b ^= (a << 10);  	c -= a;  	c -= b;  	c ^= (b >> 15);  	return c;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: a ^= (c >> 13);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: b ^= (a << 8);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: c ^= (b >> 13);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: a ^= (c >> 12);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: b ^= (a << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: c ^= (b >> 5);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: a ^= (c >> 3);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: b ^= (a << 10);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt1,The following statement contains a magic number: c ^= (b >> 15);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key1;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	hash += key2;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key1;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	hash += key2;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key1;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	hash += key2;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key1;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	hash += key2;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: unchecked {  	uint hash = 0xB1635D64 + key1;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	hash += key2;  	hash += (hash << 3);  	hash ^= (hash >> 11);  	hash += (hash << 15);  	hash |= 0x00000001;  	//  To make sure that this is relatively prime with power of 2  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: hash += (hash << 10);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: hash ^= (hash >> 6);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: hash += (hash << 3);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: hash ^= (hash >> 11);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashDoubleInt2,The following statement contains a magic number: hash += (hash << 15);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,StartHash,The following statement contains a magic number: hash += (hash << 3);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,StartHash,The following statement contains a magic number: hash ^= (hash >> 11);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,StartHash,The following statement contains a magic number: hash += (hash << 15);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,ContinueHash,The following statement contains a magic number: unchecked {  	uint hash = prevHash + key;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,ContinueHash,The following statement contains a magic number: unchecked {  	uint hash = prevHash + key;  	hash += (hash << 10);  	hash ^= (hash >> 6);  	return hash;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,ContinueHash,The following statement contains a magic number: hash += (hash << 10);  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,ContinueHash,The following statement contains a magic number: hash ^= (hash >> 6);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,MultiHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,MultiHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MultiHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Hashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,Hashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashtableForUintValues,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashtableForUintValues,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableForUintValues,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashtableUlong,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,HashtableUlong,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keyValueTable = new KeyValuePair[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,AddInternal,The following statement contains a magic number: unchecked {  	uint mask = this.size - 1;  	var keyValueTable = this.keyValueTable;  	uint key1 = (uint)(key >> 32);  	uint key2 = (uint)key;  	uint hash1 = HashHelper.HashDoubleInt1 (key1' key2);  	uint hash2 = HashHelper.HashDoubleInt2 (key1' key2);  	uint tableIndex = hash1 & mask;  	while (keyValueTable [tableIndex].Value != null) {  		if (keyValueTable [tableIndex].Key == key) {  			keyValueTable [tableIndex].Value = value;  			return;  		}  		tableIndex = (tableIndex + hash2) & mask;  	}  	keyValueTable [tableIndex].Key = key;  	keyValueTable [tableIndex].Value = value;  	this.count++;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,HashtableUlong,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Find,The following statement contains a magic number: unchecked {  	uint mask = this.size - 1;  	var keyValueTable = this.keyValueTable;  	uint key1 = (uint)(key >> 32);  	uint key2 = (uint)key;  	uint hash1 = HashHelper.HashDoubleInt1 (key1' key2);  	uint tableIndex = hash1 & mask;  	if (keyValueTable [tableIndex].Key == key)  		return keyValueTable [tableIndex].Value;  	uint hash2 = HashHelper.HashDoubleInt2 (key1' key2);  	tableIndex = (tableIndex + hash2) & mask;  	InternalT result = null;  	while ((result = keyValueTable [tableIndex].Value) != null) {  		if (keyValueTable [tableIndex].Key == key)  			return result;  		tableIndex = (tableIndex + hash2) & mask;  	}  	return null;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,DoubleHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,DoubleHashtable,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.keysValueTable = new Key1Key2ValueTriple[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,DoubleHashtable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SetOfObjects,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SetOfObjects,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.elements = new object[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfObjects,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfUints,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SetOfUints,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfUints,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,SetOfUints,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfUints,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.elements = new uint[this.size * 2];  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfUints,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,SetOfUints,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\UtilityDataStructures.cs,Expand,The following statement contains a magic number: this.resizeCount = this.size * 6 / 10;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: numberOfBytesRead = 2;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result |= (this.PeekByte (offsetIter) << 8);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: numberOfBytesRead = 4;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: numberOfBytesRead = 2;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result |= (uint)(this.PeekByte (offsetIter) << 8);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: numberOfBytesRead = 4;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if (b2 == 0 || pIter == pEnd) {  	//Dangling lead bytes' do not decompose  	sb.Append ((char)((b << 8) | b1));  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: sb.Append ((char)((b << 8) | b1));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if (b3 == 0 || pIter == pEnd) {  	//Dangling lead bytes' do not decompose  	sb.Append ((char)((b << 8) | b1));  	sb.Append ((char)b2);  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: sb.Append ((char)((b << 8) | b1));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((ch32 & 0xFFFF0000) == 0)  	ch = (char)ch32;  else {  	//break up into UTF16 surrogate pair  	sb.Append ((char)((ch32 >> 10) | 0xD800));  	ch = (char)((ch32 & 0x3FF) | 0xDC00);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: sb.Append ((char)((ch32 >> 10) | 0xD800));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,BinarySearchForSlot,The following statement contains a magic number: while ((endRowNumber - startRowNumber) > 1) {  	if (referenceValue <= startValue)  		return referenceValue == startValue ? startRowNumber : startRowNumber - 1;  	else if (referenceValue >= endValue)  		return referenceValue == endValue ? endRowNumber : endRowNumber + 1;  	int midRowNumber = (startRowNumber + endRowNumber) / 2;  	uint midReferenceValue = this.PeekReference (midRowNumber * rowSize + referenceOffset' isReferenceSmall);  	if (referenceValue > midReferenceValue) {  		startRowNumber = midRowNumber;  		startValue = midReferenceValue;  	}  	else if (referenceValue < midReferenceValue) {  		endRowNumber = midRowNumber;  		endValue = midReferenceValue;  	}  	else  		return midRowNumber;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,BinarySearchReference,The following statement contains a magic number: while (startRowNumber <= endRowNumber) {  	int midRowNumber = (startRowNumber + endRowNumber) / 2;  	uint midReferenceValue = this.PeekReference (midRowNumber * rowSize + referenceOffset' isReferenceSmall);  	if (referenceValue > midReferenceValue)  		startRowNumber = midRowNumber + 1;  	else if (referenceValue < midReferenceValue)  		endRowNumber = midRowNumber - 1;  	else  		return midRowNumber;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadOpcode,The following statement contains a magic number: if (result == 0xFE) {  	result = result << 8 | this.ReadByte ();  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadOpcode,The following statement contains a magic number: result = result << 8 | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if (bytesToRead == 0) {  	//Dangling lead bytes' do not decompose  	buffer [j++] = (char)((b << 8) | b1);  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: buffer [j++] = (char)((b << 8) | b1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if (bytesToRead == 0) {  	//Dangling lead bytes' do not decompose  	buffer [j++] = (char)((b << 8) | b1);  	buffer [j++] = (char)b2;  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: buffer [j++] = (char)((b << 8) | b1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((ch32 & 0xFFFF0000) == 0)  	ch = (char)ch32;  else {  	//break up into UTF16 surrogate pair  	buffer [j++] = (char)((ch32 >> 10) | 0xD800);  	ch = (char)((ch32 & 0x3FF) | 0xDC00);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: buffer [j++] = (char)((ch32 >> 10) | 0xD800);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadASCIINullTerminated,The following statement contains a magic number: if (b != 0) {  	count <<= 2;  	char[] newBuffer = new char[count];  	for (int copy = 0; copy < j; copy++)  		newBuffer [copy] = buffer [copy];  	buffer = newBuffer;  	goto Restart;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\UnmanagedReadWrite.cs,ReadASCIINullTerminated,The following statement contains a magic number: count <<= 2;  
Magic Number,Microsoft.Cci.MutableCodeModel,MetadataCopier,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Copier.cs,DeepCopy,The following statement contains a magic number: Debug.Assert (eventDefinition.Accessors.Count <= 2);  
Magic Number,Microsoft.Cci.MutableCodeModel,Module,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Units.cs,Module,The following statement contains a magic number: this.fileAlignment = 512;  
Magic Number,Microsoft.Cci.MutableCodeModel,Module,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Units.cs,Module,The following statement contains a magic number: this.linkerMajorVersion = 6;  
Magic Number,Microsoft.Cci.MutableCodeModel,Module,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MutableMetadataModel\Units.cs,Module,The following statement contains a magic number: this.subsystemMajorVersion = 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt16,The following statement contains a magic number: value = (short)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt16,The following statement contains a magic number: offset += 2;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt32,The following statement contains a magic number: offset += 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadInt64,The following statement contains a magic number: offset += 8;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt16,The following statement contains a magic number: value = (ushort)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt16,The following statement contains a magic number: offset += 2;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt32,The following statement contains a magic number: offset += 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadUInt64,The following statement contains a magic number: offset += 8;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadFloat,The following statement contains a magic number: offset += 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDouble,The following statement contains a magic number: offset += 8;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal (bits [2]' bits [3]' bits [1]' bits [0] < 0' (byte)((bits [0] & 0x00FF0000) >> 16));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal (bits [2]' bits [3]' bits [1]' bits [0] < 0' (byte)((bits [0] & 0x00FF0000) >> 16));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal (bits [2]' bits [3]' bits [1]' bits [0] < 0' (byte)((bits [0] & 0x00FF0000) >> 16));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadString,The following statement contains a magic number: while (offset + len < buffer.Length && buffer [offset + len] != 0) {  	len += 2;  }  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadString,The following statement contains a magic number: len += 2;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitAccess.cs,ReadString,The following statement contains a magic number: offset += len + 2;  
Magic Number,Microsoft.Cci.Pdb,BitSet,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\BitSet.cs,GetBit,The following statement contains a magic number: return ((uint)1 << (index % 32));  
Magic Number,Microsoft.Cci.Pdb,DbiModuleInfo,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\DbiModuleInfo.cs,DbiModuleInfo,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,IntHashTable,The following statement contains a magic number: loadsize = (int)(this.loadFactorPerc * hashsize) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,InitHash,The following statement contains a magic number: incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,expand,The following statement contains a magic number: rehash (GetPrime (1 + buckets.Length * 2));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,rehash,The following statement contains a magic number: loadsize = (int)(loadFactorPerc * newsize) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,Insert,The following statement contains a magic number: if (count >= loadsize) {  	expand ();  }  else if (occupancy > loadsize && count > 100) {  	rehash ();  }  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\IntHashTable.cs,Insert,The following statement contains a magic number: if (occupancy > loadsize && count > 100) {  	rehash ();  }  
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: for (int i = 0; i < directoryRootPages; i++) {  	int pagesInThisPage = pagesToGo <= pagesPerPage ? pagesToGo : pagesPerPage;  	reader.Seek (head.directoryRoot [i]' 0);  	bits.Append (reader.reader' pagesInThisPage * 4);  	pagesToGo -= pagesInThisPage;  }  
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: bits.Append (reader.reader' pagesInThisPage * 4);  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		}  		else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		}  		else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		}  		else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		}  		else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		}  		else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		}  		else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  	bits.Position += linsiz;  	blocks++;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  	bits.Position += linsiz;  	blocks++;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: for (int i = 0; i < file.count; i++) {  	CV_Line line;  	CV_Column column = new CV_Column ();  	bits.Position = plin + 8 * i;  	bits.ReadUInt32 (out line.offset);  	bits.ReadUInt32 (out line.flags);  	uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  	uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  	//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  	if ((sec.flags & 1) != 0) {  		bits.Position = pcol + 4 * i;  		bits.ReadUInt16 (out column.offColumnStart);  		bits.ReadUInt16 (out column.offColumnEnd);  	}  	lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: for (int i = 0; i < file.count; i++) {  	CV_Line line;  	CV_Column column = new CV_Column ();  	bits.Position = plin + 8 * i;  	bits.ReadUInt32 (out line.offset);  	bits.ReadUInt32 (out line.flags);  	uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  	uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  	//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  	if ((sec.flags & 1) != 0) {  		bits.Position = pcol + 4 * i;  		bits.ReadUInt16 (out column.offColumnStart);  		bits.ReadUInt16 (out column.offColumnEnd);  	}  	lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: for (int i = 0; i < file.count; i++) {  	CV_Line line;  	CV_Column column = new CV_Column ();  	bits.Position = plin + 8 * i;  	bits.ReadUInt32 (out line.offset);  	bits.ReadUInt32 (out line.flags);  	uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  	uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  	//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  	if ((sec.flags & 1) != 0) {  		bits.Position = pcol + 4 * i;  		bits.ReadUInt16 (out column.offColumnStart);  		bits.ReadUInt16 (out column.offColumnEnd);  	}  	lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: bits.Position = plin + 8 * i;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: if ((sec.flags & 1) != 0) {  	bits.Position = pcol + 4 * i;  	bits.ReadUInt16 (out column.offColumnStart);  	bits.ReadUInt16 (out column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: bits.Position = pcol + 4 * i;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: if (sig != 4) {  	throw new PdbDebugException ("Invalid signature. (sig={0})"' sig);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: bits.Position = 4;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,The following statement contains a magic number: dir.streams [3].Read (reader' bits);  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadFunctions,The following statement contains a magic number: if (header.snTokenRidMap != 0 && header.snTokenRidMap != 0xffff) {  	dir.streams [header.snTokenRidMap].Read (reader' bits);  	uint[] ridMap = new uint[dir.streams [header.snTokenRidMap].Length / 4];  	bits.ReadUInt32 (ridMap);  	foreach (PdbFunction func in funcs) {  		func.token = 0x06000000 | ridMap [func.token & 0xffffff];  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadTokenToSourceInfo,The following statement contains a magic number: if (sig != 4) {  	throw new PdbDebugException ("Invalid signature. (sig={0})"' sig);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadTokenToSourceInfo,The following statement contains a magic number: bits.Position = 4;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int place = bits.Position;  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.FILECHKSMS:  		while (bits.Position < endSym) {  			CV_FileCheckSum chk;  			int ni = bits.Position - place;  			bits.ReadUInt32 (out chk.name);  			bits.ReadUInt8 (out chk.len);  			bits.ReadUInt8 (out chk.type);  			string name = (string)names [(int)chk.name];  			int guidStream;  			Guid doctypeGuid = SymDocumentType.Text;  			Guid languageGuid = Guid.Empty;  			Guid vendorGuid = Guid.Empty;  			if (nameIndex.TryGetValue ("/SRC/FILES/" + name.ToUpperInvariant ()' out guidStream)) {  				var guidBits = new BitAccess (0x100);  				dir.streams [guidStream].Read (reader' guidBits);  				LoadGuidStream (guidBits' out doctypeGuid' out languageGuid' out vendorGuid);  			}  			PdbSource src = new PdbSource (/*(uint)ni'*/name' doctypeGuid' languageGuid' vendorGuid);  			checks.Add (ni' src);  			bits.Position += chk.len;  			bits.Align (4);  		}  		bits.Position = endSym;  		break;  	default:  		bits.Position = endSym;  		break;  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.FILECHKSMS:  	while (bits.Position < endSym) {  		CV_FileCheckSum chk;  		int ni = bits.Position - place;  		bits.ReadUInt32 (out chk.name);  		bits.ReadUInt8 (out chk.len);  		bits.ReadUInt8 (out chk.type);  		string name = (string)names [(int)chk.name];  		int guidStream;  		Guid doctypeGuid = SymDocumentType.Text;  		Guid languageGuid = Guid.Empty;  		Guid vendorGuid = Guid.Empty;  		if (nameIndex.TryGetValue ("/SRC/FILES/" + name.ToUpperInvariant ()' out guidStream)) {  			var guidBits = new BitAccess (0x100);  			dir.streams [guidStream].Read (reader' guidBits);  			LoadGuidStream (guidBits' out doctypeGuid' out languageGuid' out vendorGuid);  		}  		PdbSource src = new PdbSource (/*(uint)ni'*/name' doctypeGuid' languageGuid' vendorGuid);  		checks.Add (ni' src);  		bits.Position += chk.len;  		bits.Align (4);  	}  	bits.Position = endSym;  	break;  default:  	bits.Position = endSym;  	break;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_FileCheckSum chk;  	int ni = bits.Position - place;  	bits.ReadUInt32 (out chk.name);  	bits.ReadUInt8 (out chk.len);  	bits.ReadUInt8 (out chk.type);  	string name = (string)names [(int)chk.name];  	int guidStream;  	Guid doctypeGuid = SymDocumentType.Text;  	Guid languageGuid = Guid.Empty;  	Guid vendorGuid = Guid.Empty;  	if (nameIndex.TryGetValue ("/SRC/FILES/" + name.ToUpperInvariant ()' out guidStream)) {  		var guidBits = new BitAccess (0x100);  		dir.streams [guidStream].Read (reader' guidBits);  		LoadGuidStream (guidBits' out doctypeGuid' out languageGuid' out vendorGuid);  	}  	PdbSource src = new PdbSource (/*(uint)ni'*/name' doctypeGuid' languageGuid' vendorGuid);  	checks.Add (ni' src);  	bits.Position += chk.len;  	bits.Align (4);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.MinCapacity (56);  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer (reader' 52);  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: this.magic = new byte[32];  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer (reader' directoryPages * 4);  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: while (bits.Position < proc.end) {  	ushort siz;  	ushort rec;  	bits.ReadUInt16 (out siz);  	int star = bits.Position;  	int stop = bits.Position + siz;  	bits.Position = star;  	bits.ReadUInt16 (out rec);  	switch ((SYM)rec) {  	case SYM.S_OEM: {  		// 0x0404  		OemSymbol oem;  		bits.ReadGuid (out oem.idOem);  		bits.ReadUInt32 (out oem.typind);  		// internal byte[]   rgl;        // user data' force 4-byte alignment  		if (oem.idOem == msilMetaData) {  			string name = bits.ReadString ();  			if (name == "MD2") {  				byte version;  				bits.ReadUInt8 (out version);  				if (version == 4) {  					byte count;  					bits.ReadUInt8 (out count);  					bits.Align (4);  					while (count-- > 0)  						this.ReadCustomMetadata (bits);  				}  			}  			else if (name == "asyncMethodInfo") {  				this.synchronizationInformation = new PdbSynchronizationInformation (bits);  			}  			bits.Position = stop;  			break;  		}  		else {  			throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  			// bits.Position = stop;  		}  	}  	case SYM.S_BLOCK32: {  		BlockSym32 block = new BlockSym32 ();  		bits.ReadUInt32 (out block.parent);  		bits.ReadUInt32 (out block.end);  		bits.ReadUInt32 (out block.len);  		bits.ReadUInt32 (out block.off);  		bits.ReadUInt16 (out block.seg);  		bits.SkipCString (out block.name);  		bits.Position = stop;  		scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  		bits.Position = (int)block.end;  		break;  	}  	case SYM.S_MANSLOT:  		uint typind;  		slots [slot++] = new PdbSlot (bits' out typind);  		bits.Position = stop;  		break;  	case SYM.S_MANCONSTANT:  		constants [constant++] = new PdbConstant (bits);  		bits.Position = stop;  		break;  	case SYM.S_UNAMESPACE:  		bits.ReadCString (out usedNamespaces [usedNs++]);  		bits.Position = stop;  		break;  	case SYM.S_END:  		bits.Position = stop;  		break;  	default: {  		//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  		bits.Position = stop;  		break;  	}  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: while (bits.Position < proc.end) {  	ushort siz;  	ushort rec;  	bits.ReadUInt16 (out siz);  	int star = bits.Position;  	int stop = bits.Position + siz;  	bits.Position = star;  	bits.ReadUInt16 (out rec);  	switch ((SYM)rec) {  	case SYM.S_OEM: {  		// 0x0404  		OemSymbol oem;  		bits.ReadGuid (out oem.idOem);  		bits.ReadUInt32 (out oem.typind);  		// internal byte[]   rgl;        // user data' force 4-byte alignment  		if (oem.idOem == msilMetaData) {  			string name = bits.ReadString ();  			if (name == "MD2") {  				byte version;  				bits.ReadUInt8 (out version);  				if (version == 4) {  					byte count;  					bits.ReadUInt8 (out count);  					bits.Align (4);  					while (count-- > 0)  						this.ReadCustomMetadata (bits);  				}  			}  			else if (name == "asyncMethodInfo") {  				this.synchronizationInformation = new PdbSynchronizationInformation (bits);  			}  			bits.Position = stop;  			break;  		}  		else {  			throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  			// bits.Position = stop;  		}  	}  	case SYM.S_BLOCK32: {  		BlockSym32 block = new BlockSym32 ();  		bits.ReadUInt32 (out block.parent);  		bits.ReadUInt32 (out block.end);  		bits.ReadUInt32 (out block.len);  		bits.ReadUInt32 (out block.off);  		bits.ReadUInt16 (out block.seg);  		bits.SkipCString (out block.name);  		bits.Position = stop;  		scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  		bits.Position = (int)block.end;  		break;  	}  	case SYM.S_MANSLOT:  		uint typind;  		slots [slot++] = new PdbSlot (bits' out typind);  		bits.Position = stop;  		break;  	case SYM.S_MANCONSTANT:  		constants [constant++] = new PdbConstant (bits);  		bits.Position = stop;  		break;  	case SYM.S_UNAMESPACE:  		bits.ReadCString (out usedNamespaces [usedNs++]);  		bits.Position = stop;  		break;  	case SYM.S_END:  		bits.Position = stop;  		break;  	default: {  		//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  		bits.Position = stop;  		break;  	}  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: switch ((SYM)rec) {  case SYM.S_OEM: {  	// 0x0404  	OemSymbol oem;  	bits.ReadGuid (out oem.idOem);  	bits.ReadUInt32 (out oem.typind);  	// internal byte[]   rgl;        // user data' force 4-byte alignment  	if (oem.idOem == msilMetaData) {  		string name = bits.ReadString ();  		if (name == "MD2") {  			byte version;  			bits.ReadUInt8 (out version);  			if (version == 4) {  				byte count;  				bits.ReadUInt8 (out count);  				bits.Align (4);  				while (count-- > 0)  					this.ReadCustomMetadata (bits);  			}  		}  		else if (name == "asyncMethodInfo") {  			this.synchronizationInformation = new PdbSynchronizationInformation (bits);  		}  		bits.Position = stop;  		break;  	}  	else {  		throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  		// bits.Position = stop;  	}  }  case SYM.S_BLOCK32: {  	BlockSym32 block = new BlockSym32 ();  	bits.ReadUInt32 (out block.parent);  	bits.ReadUInt32 (out block.end);  	bits.ReadUInt32 (out block.len);  	bits.ReadUInt32 (out block.off);  	bits.ReadUInt16 (out block.seg);  	bits.SkipCString (out block.name);  	bits.Position = stop;  	scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  	bits.Position = (int)block.end;  	break;  }  case SYM.S_MANSLOT:  	uint typind;  	slots [slot++] = new PdbSlot (bits' out typind);  	bits.Position = stop;  	break;  case SYM.S_MANCONSTANT:  	constants [constant++] = new PdbConstant (bits);  	bits.Position = stop;  	break;  case SYM.S_UNAMESPACE:  	bits.ReadCString (out usedNamespaces [usedNs++]);  	bits.Position = stop;  	break;  case SYM.S_END:  	bits.Position = stop;  	break;  default: {  	//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  	bits.Position = stop;  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: switch ((SYM)rec) {  case SYM.S_OEM: {  	// 0x0404  	OemSymbol oem;  	bits.ReadGuid (out oem.idOem);  	bits.ReadUInt32 (out oem.typind);  	// internal byte[]   rgl;        // user data' force 4-byte alignment  	if (oem.idOem == msilMetaData) {  		string name = bits.ReadString ();  		if (name == "MD2") {  			byte version;  			bits.ReadUInt8 (out version);  			if (version == 4) {  				byte count;  				bits.ReadUInt8 (out count);  				bits.Align (4);  				while (count-- > 0)  					this.ReadCustomMetadata (bits);  			}  		}  		else if (name == "asyncMethodInfo") {  			this.synchronizationInformation = new PdbSynchronizationInformation (bits);  		}  		bits.Position = stop;  		break;  	}  	else {  		throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  		// bits.Position = stop;  	}  }  case SYM.S_BLOCK32: {  	BlockSym32 block = new BlockSym32 ();  	bits.ReadUInt32 (out block.parent);  	bits.ReadUInt32 (out block.end);  	bits.ReadUInt32 (out block.len);  	bits.ReadUInt32 (out block.off);  	bits.ReadUInt16 (out block.seg);  	bits.SkipCString (out block.name);  	bits.Position = stop;  	scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  	bits.Position = (int)block.end;  	break;  }  case SYM.S_MANSLOT:  	uint typind;  	slots [slot++] = new PdbSlot (bits' out typind);  	bits.Position = stop;  	break;  case SYM.S_MANCONSTANT:  	constants [constant++] = new PdbConstant (bits);  	bits.Position = stop;  	break;  case SYM.S_UNAMESPACE:  	bits.ReadCString (out usedNamespaces [usedNs++]);  	bits.Position = stop;  	break;  case SYM.S_END:  	bits.Position = stop;  	break;  default: {  	//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  	bits.Position = stop;  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (oem.idOem == msilMetaData) {  	string name = bits.ReadString ();  	if (name == "MD2") {  		byte version;  		bits.ReadUInt8 (out version);  		if (version == 4) {  			byte count;  			bits.ReadUInt8 (out count);  			bits.Align (4);  			while (count-- > 0)  				this.ReadCustomMetadata (bits);  		}  	}  	else if (name == "asyncMethodInfo") {  		this.synchronizationInformation = new PdbSynchronizationInformation (bits);  	}  	bits.Position = stop;  	break;  }  else {  	throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  	// bits.Position = stop;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (oem.idOem == msilMetaData) {  	string name = bits.ReadString ();  	if (name == "MD2") {  		byte version;  		bits.ReadUInt8 (out version);  		if (version == 4) {  			byte count;  			bits.ReadUInt8 (out count);  			bits.Align (4);  			while (count-- > 0)  				this.ReadCustomMetadata (bits);  		}  	}  	else if (name == "asyncMethodInfo") {  		this.synchronizationInformation = new PdbSynchronizationInformation (bits);  	}  	bits.Position = stop;  	break;  }  else {  	throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  	// bits.Position = stop;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (name == "MD2") {  	byte version;  	bits.ReadUInt8 (out version);  	if (version == 4) {  		byte count;  		bits.ReadUInt8 (out count);  		bits.Align (4);  		while (count-- > 0)  			this.ReadCustomMetadata (bits);  	}  }  else if (name == "asyncMethodInfo") {  	this.synchronizationInformation = new PdbSynchronizationInformation (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (name == "MD2") {  	byte version;  	bits.ReadUInt8 (out version);  	if (version == 4) {  		byte count;  		bits.ReadUInt8 (out count);  		bits.Align (4);  		while (count-- > 0)  			this.ReadCustomMetadata (bits);  	}  }  else if (name == "asyncMethodInfo") {  	this.synchronizationInformation = new PdbSynchronizationInformation (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (version == 4) {  	byte count;  	bits.ReadUInt8 (out count);  	bits.Align (4);  	while (count-- > 0)  		this.ReadCustomMetadata (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (version == 4) {  	byte count;  	bits.ReadUInt8 (out count);  	bits.Align (4);  	while (count-- > 0)  		this.ReadCustomMetadata (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,PdbFunction,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: if (version != 4) {  	throw new PdbDebugException ("Unknown custom metadata item version: {0}"' version);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  default:  	throw new PdbDebugException ("Unknown custom metadata item kind: {0}"' kind);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  default:  	throw new PdbDebugException ("Unknown custom metadata item kind: {0}"' kind);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  default:  	throw new PdbDebugException ("Unknown custom metadata item kind: {0}"' kind);  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 3;  	value = true;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 3;  	value = true;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 3;  	value = true;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: this.CurrentIndex += 3;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 2;  	value = false;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 2;  	value = false;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 2;  	value = false;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: this.CurrentIndex += 2;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 4;  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 4;  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 4;  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: this.CurrentIndex += 4;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 16 > this.Length) {  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: this.CurrentIndex += 16;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {  	pkToken [i] = (byte)result;  	result >>= 8;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {  	pkToken [i] = (byte)result;  	result >>= 8;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: result >>= 8;  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (short)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (int)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (long)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (ushort)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (uint)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (ulong)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (float)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (double)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (char)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  	return new ConstantExpression (type' this.GetPrimitiveValue (type));  case PrimitiveTypeCode.String:  	return new ConstantExpression (type' this.GetSerializedString ());  default:  	var typeDef = type.ResolvedType;  	if (!(typeDef is Dummy)) {  		if (typeDef.IsEnum)  			return new ConstantExpression (type' this.GetPrimitiveValue (typeDef.UnderlyingType));  		type = typeDef;  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemObject)) {  		ITypeReference /*?*/underlyingType = this.GetFieldOrPropType ();  		if (underlyingType == null)  			return null;  		return this.ReadSerializedValue (underlyingType);  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemType)) {  		string /*?*/typeNameStr = this.GetSerializedString ();  		if (typeNameStr == null) {  			return new ConstantExpression (this.PEFileToObjectModel.PlatformType.SystemType' null);  		}  		return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr));  	}  	var vectorType = type as IArrayTypeReference;  	if (vectorType != null) {  		ITypeReference /*?*/elementType = vectorType.ElementType;  		if (elementType == null) {  			this.decodeFailed = true;  			return null;  		}  		int size = this.SignatureMemoryReader.ReadInt32 ();  		if (size == -1) {  			return new ConstantExpression (vectorType' null);  		}  		ExpressionBase[] arrayElements = new ExpressionBase[size];  		for (int i = 0; i < size; ++i) {  			ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  			if (expr == null) {  				this.decodeFailed = true;  				return null;  			}  			arrayElements [i] = expr;  		}  		return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  	}  	else {  		// If the metadata is correct' type must be a reference to an enum type.  		// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  		// We'll let the host deal with this by guessing  		ITypeReference underlyingType;  		switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  		case 1:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  			break;  		case 2:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  			break;  		case 4:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  			break;  		case 8:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  			break;  		default:  			this.decodeFailed = true;  			this.morePermutationsArePossible = false;  			return new ConstantExpression (type' 0);  		}  		return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  	return new ConstantExpression (type' this.GetPrimitiveValue (type));  case PrimitiveTypeCode.String:  	return new ConstantExpression (type' this.GetSerializedString ());  default:  	var typeDef = type.ResolvedType;  	if (!(typeDef is Dummy)) {  		if (typeDef.IsEnum)  			return new ConstantExpression (type' this.GetPrimitiveValue (typeDef.UnderlyingType));  		type = typeDef;  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemObject)) {  		ITypeReference /*?*/underlyingType = this.GetFieldOrPropType ();  		if (underlyingType == null)  			return null;  		return this.ReadSerializedValue (underlyingType);  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemType)) {  		string /*?*/typeNameStr = this.GetSerializedString ();  		if (typeNameStr == null) {  			return new ConstantExpression (this.PEFileToObjectModel.PlatformType.SystemType' null);  		}  		return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr));  	}  	var vectorType = type as IArrayTypeReference;  	if (vectorType != null) {  		ITypeReference /*?*/elementType = vectorType.ElementType;  		if (elementType == null) {  			this.decodeFailed = true;  			return null;  		}  		int size = this.SignatureMemoryReader.ReadInt32 ();  		if (size == -1) {  			return new ConstantExpression (vectorType' null);  		}  		ExpressionBase[] arrayElements = new ExpressionBase[size];  		for (int i = 0; i < size; ++i) {  			ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  			if (expr == null) {  				this.decodeFailed = true;  				return null;  			}  			arrayElements [i] = expr;  		}  		return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  	}  	else {  		// If the metadata is correct' type must be a reference to an enum type.  		// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  		// We'll let the host deal with this by guessing  		ITypeReference underlyingType;  		switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  		case 1:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  			break;  		case 2:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  			break;  		case 4:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  			break;  		case 8:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  			break;  		default:  			this.decodeFailed = true;  			this.morePermutationsArePossible = false;  			return new ConstantExpression (type' 0);  		}  		return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  	return new ConstantExpression (type' this.GetPrimitiveValue (type));  case PrimitiveTypeCode.String:  	return new ConstantExpression (type' this.GetSerializedString ());  default:  	var typeDef = type.ResolvedType;  	if (!(typeDef is Dummy)) {  		if (typeDef.IsEnum)  			return new ConstantExpression (type' this.GetPrimitiveValue (typeDef.UnderlyingType));  		type = typeDef;  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemObject)) {  		ITypeReference /*?*/underlyingType = this.GetFieldOrPropType ();  		if (underlyingType == null)  			return null;  		return this.ReadSerializedValue (underlyingType);  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemType)) {  		string /*?*/typeNameStr = this.GetSerializedString ();  		if (typeNameStr == null) {  			return new ConstantExpression (this.PEFileToObjectModel.PlatformType.SystemType' null);  		}  		return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr));  	}  	var vectorType = type as IArrayTypeReference;  	if (vectorType != null) {  		ITypeReference /*?*/elementType = vectorType.ElementType;  		if (elementType == null) {  			this.decodeFailed = true;  			return null;  		}  		int size = this.SignatureMemoryReader.ReadInt32 ();  		if (size == -1) {  			return new ConstantExpression (vectorType' null);  		}  		ExpressionBase[] arrayElements = new ExpressionBase[size];  		for (int i = 0; i < size; ++i) {  			ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  			if (expr == null) {  				this.decodeFailed = true;  				return null;  			}  			arrayElements [i] = expr;  		}  		return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  	}  	else {  		// If the metadata is correct' type must be a reference to an enum type.  		// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  		// We'll let the host deal with this by guessing  		ITypeReference underlyingType;  		switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  		case 1:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  			break;  		case 2:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  			break;  		case 4:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  			break;  		case 8:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  			break;  		default:  			this.decodeFailed = true;  			this.morePermutationsArePossible = false;  			return new ConstantExpression (type' 0);  		}  		return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: if (vectorType != null) {  	ITypeReference /*?*/elementType = vectorType.ElementType;  	if (elementType == null) {  		this.decodeFailed = true;  		return null;  	}  	int size = this.SignatureMemoryReader.ReadInt32 ();  	if (size == -1) {  		return new ConstantExpression (vectorType' null);  	}  	ExpressionBase[] arrayElements = new ExpressionBase[size];  	for (int i = 0; i < size; ++i) {  		ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  		if (expr == null) {  			this.decodeFailed = true;  			return null;  		}  		arrayElements [i] = expr;  	}  	return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  }  else {  	// If the metadata is correct' type must be a reference to an enum type.  	// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  	// We'll let the host deal with this by guessing  	ITypeReference underlyingType;  	switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  	case 1:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  		break;  	case 2:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  		break;  	case 4:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  		break;  	case 8:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  		break;  	default:  		this.decodeFailed = true;  		this.morePermutationsArePossible = false;  		return new ConstantExpression (type' 0);  	}  	return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: if (vectorType != null) {  	ITypeReference /*?*/elementType = vectorType.ElementType;  	if (elementType == null) {  		this.decodeFailed = true;  		return null;  	}  	int size = this.SignatureMemoryReader.ReadInt32 ();  	if (size == -1) {  		return new ConstantExpression (vectorType' null);  	}  	ExpressionBase[] arrayElements = new ExpressionBase[size];  	for (int i = 0; i < size; ++i) {  		ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  		if (expr == null) {  			this.decodeFailed = true;  			return null;  		}  		arrayElements [i] = expr;  	}  	return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  }  else {  	// If the metadata is correct' type must be a reference to an enum type.  	// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  	// We'll let the host deal with this by guessing  	ITypeReference underlyingType;  	switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  	case 1:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  		break;  	case 2:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  		break;  	case 4:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  		break;  	case 8:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  		break;  	default:  		this.decodeFailed = true;  		this.morePermutationsArePossible = false;  		return new ConstantExpression (type' 0);  	}  	return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: if (vectorType != null) {  	ITypeReference /*?*/elementType = vectorType.ElementType;  	if (elementType == null) {  		this.decodeFailed = true;  		return null;  	}  	int size = this.SignatureMemoryReader.ReadInt32 ();  	if (size == -1) {  		return new ConstantExpression (vectorType' null);  	}  	ExpressionBase[] arrayElements = new ExpressionBase[size];  	for (int i = 0; i < size; ++i) {  		ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  		if (expr == null) {  			this.decodeFailed = true;  			return null;  		}  		arrayElements [i] = expr;  	}  	return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  }  else {  	// If the metadata is correct' type must be a reference to an enum type.  	// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  	// We'll let the host deal with this by guessing  	ITypeReference underlyingType;  	switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  	case 1:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  		break;  	case 2:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  		break;  	case 4:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  		break;  	case 8:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  		break;  	default:  		this.decodeFailed = true;  		this.morePermutationsArePossible = false;  		return new ConstantExpression (type' 0);  	}  	return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  case 1:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  	break;  case 2:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  	break;  case 4:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  	break;  case 8:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  	break;  default:  	this.decodeFailed = true;  	this.morePermutationsArePossible = false;  	return new ConstantExpression (type' 0);  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  case 1:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  	break;  case 2:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  	break;  case 4:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  	break;  case 8:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  	break;  default:  	this.decodeFailed = true;  	this.morePermutationsArePossible = false;  	return new ConstantExpression (type' 0);  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  case 1:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  	break;  case 2:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  	break;  case 4:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  	break;  case 8:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  	break;  default:  	this.decodeFailed = true;  	this.morePermutationsArePossible = false;  	return new ConstantExpression (type' 0);  }  
Magic Number,Microsoft.Cci.MetadataReader,CustomAttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,CustomAttributeDecoder,The following statement contains a magic number: if (2 <= (int)this.SignatureMemoryReader.RemainingBytes) {  	ushort numOfNamedArgs = this.SignatureMemoryReader.ReadUInt16 ();  	if (numOfNamedArgs > 0) {  		namedArgumentArray = new IMetadataNamedArgument[numOfNamedArgs];  		for (i = 0; i < numOfNamedArgs; ++i) {  			if (0 >= (int)this.SignatureMemoryReader.RemainingBytes)  				break;  			bool isField = this.SignatureMemoryReader.ReadByte () == SerializationType.Field;  			ITypeReference /*?*/memberType = this.GetFieldOrPropType ();  			if (memberType == null) {  				//  Error...  				return;  			}  			string /*?*/memberStr = this.GetSerializedString ();  			if (memberStr == null)  				return;  			IName memberName = this.PEFileToObjectModel.NameTable.GetNameFor (memberStr);  			ExpressionBase /*?*/value = this.ReadSerializedValue (memberType);  			if (value == null) {  				//  Error...  				return;  			}  			ITypeReference /*?*/moduleTypeRef = attributeConstructor.ContainingType;  			if (moduleTypeRef == null) {  				//  Error...  				return;  			}  			FieldOrPropertyNamedArgumentExpression namedArg = new FieldOrPropertyNamedArgumentExpression (memberName' moduleTypeRef' isField' memberType' value);  			namedArgumentArray [i] = namedArg;  		}  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: lock (GlobalLock.LockingObject) {  	INameTable nameTable = this.NameTable;  	PeReader peReader = this.ModuleReader;  	int systemKey = nameTable.System.UniqueKey;  	int objectKey = nameTable.Object.UniqueKey;  	int valueTypeKey = nameTable.ValueType.UniqueKey;  	int enumKey = nameTable.Enum.UniqueKey;  	int multicastDelegateKey = nameTable.MulticastDelegate.UniqueKey;  	int arrayKey = nameTable.Array.UniqueKey;  	int attributeKey = nameTable.Attribute.UniqueKey;  	int delegateKey = nameTable.Delegate.UniqueKey;  	int iAsyncResultKey = peReader.IAsyncResult.UniqueKey;  	int iCloneableKey = peReader.ICloneable.UniqueKey;  	int asyncCallbackKey = peReader.AsyncCallback.UniqueKey;  	int attributeUsageAttributeKey = nameTable.AttributeUsageAttribute.UniqueKey;  	int paramArrayAttributeKey = peReader.ParamArrayAttribute.UniqueKey;  	int booleanKey = nameTable.Boolean.UniqueKey;  	int byteKey = nameTable.Byte.UniqueKey;  	int charKey = nameTable.Char.UniqueKey;  	int sByteKey = nameTable.SByte.UniqueKey;  	int int16Key = nameTable.Int16.UniqueKey;  	int uint16Key = nameTable.UInt16.UniqueKey;  	int int32Key = nameTable.Int32.UniqueKey;  	int uint32Key = nameTable.UInt32.UniqueKey;  	int int64Key = nameTable.Int64.UniqueKey;  	int uint64Key = nameTable.UInt64.UniqueKey;  	int stringKey = nameTable.String.UniqueKey;  	int intPtrKey = nameTable.IntPtr.UniqueKey;  	int uintPtrKey = nameTable.UIntPtr.UniqueKey;  	int singleKey = nameTable.Single.UniqueKey;  	int doubleKey = nameTable.Double.UniqueKey;  	int typedReferenceKey = nameTable.TypedReference.UniqueKey;  	int typeKey = nameTable.Type.UniqueKey;  	int dateTimeKey = nameTable.DateTime.UniqueKey;  	int decimalKey = nameTable.Decimal.UniqueKey;  	int dbNullKey = nameTable.DBNull.UniqueKey;  	int runtimeArgumentHandleKey = peReader.RuntimeArgumentHandle.UniqueKey;  	int runtimeFieldHandleKey = peReader.RuntimeFieldHandle.UniqueKey;  	int runtimeMethodHandleKey = peReader.RuntimeMethodHandle.UniqueKey;  	int runtimeTypeHandleKey = peReader.RuntimeTypeHandle.UniqueKey;  	int argIteratorKey = peReader.ArgIterator.UniqueKey;  	int voidKey = nameTable.Void.UniqueKey;  	int mscorlibKey = peReader.Mscorlib.UniqueKey;  	int systemRuntimeKey = peReader.System_Runtime.UniqueKey;  	TypeRefTableReader trTable = this.PEFileReader.TypeRefTable;  	var hitCounts = new uint[trTable.NumberOfRows];  	for (uint i = 1; i <= trTable.NumberOfRows; i++) {  		TypeRefRow tr = trTable [i];  		IName nsName = this.GetNameFromOffset (tr.Namespace);  		if (nsName.UniqueKey != systemKey)  			continue;  		int tKey = this.GetNameFromOffset (tr.Name).UniqueKey;  		//Look for a lot of different mscorlib types' since an assembly need not reference System.Object or any particular type.  		if (tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey && tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey && tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey && tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey)  			continue;  		uint resolutionScopeKind = (tr.ResolutionScope & TokenTypeIds.TokenTypeMask);  		if (resolutionScopeKind != TokenTypeIds.AssemblyRef)  			continue;  		uint resolutionScopeRowId = (tr.ResolutionScope & TokenTypeIds.RIDMask);  		//Just because this reference looks like a mscorlib type' does not mean that it actually is one. Badly behaved assemblies might reuse mscorlib names.  		//We therefore count the number of references and hope that mscorlib has a majority.  		hitCounts [resolutionScopeRowId - 1]++;  		if (tKey == enumKey)  			this.SystemEnumAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == valueTypeKey)  			this.SystemValueTypeAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == multicastDelegateKey)  			this.SystemMulticastDelegateAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == typeKey)  			this.SystemTypeAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == paramArrayAttributeKey)  			this.SystemParamArrayAttributeAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  	}  	uint maxHits = 0;  	uint rowWithMaxHits = 0;  	for (uint i = 0; i < hitCounts.Length; i++) {  		if (hitCounts [i] > maxHits) {  			maxHits = hitCounts [i];  			rowWithMaxHits = i;  		}  	}  	if (maxHits > 0) {  		return this.AssemblyReferenceArray [rowWithMaxHits + 1].AssemblyIdentity;  	}  	TypeDefTableReader tdTable = this.PEFileReader.TypeDefTable;  	for (uint i = 1; i <= tdTable.NumberOfRows; i++) {  		TypeDefRow td = tdTable [i];  		IName nsName = this.GetNameFromOffset (td.Namespace);  		if (nsName.UniqueKey != systemKey)  			continue;  		int tKey = this.GetNameFromOffset (td.Name).UniqueKey;  		//if you're mscorlib' you have to define System.Object  		if (tKey != objectKey)  			continue;  		AssemblyIdentity /*?*/result = this.Module.ModuleIdentity as AssemblyIdentity;  		if (result != null)  			return result;  		//TODO: error  		break;  	}  	AssemblyRefTableReader arTable = this.PEFileReader.AssemblyRefTable;  	for (uint i = 1; i <= arTable.NumberOfRows; i++) {  		AssemblyRefRow ar = arTable [i];  		int key = this.GetNameFromOffset (ar.Name).UniqueKey;  		if (key != systemRuntimeKey)  			continue;  		var identity = this.AssemblyReferenceArray [i].AssemblyIdentity;  		if (identity.Version.Major >= 4)  			return identity;  	}  	for (uint i = 1; i <= arTable.NumberOfRows; i++) {  		AssemblyRefRow ar = arTable [i];  		int key = this.GetNameFromOffset (ar.Name).UniqueKey;  		if (key != mscorlibKey)  			continue;  		return this.AssemblyReferenceArray [i].AssemblyIdentity;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: for (uint i = 1; i <= arTable.NumberOfRows; i++) {  	AssemblyRefRow ar = arTable [i];  	int key = this.GetNameFromOffset (ar.Name).UniqueKey;  	if (key != systemRuntimeKey)  		continue;  	var identity = this.AssemblyReferenceArray [i].AssemblyIdentity;  	if (identity.Version.Major >= 4)  		return identity;  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (identity.Version.Major >= 4)  	return identity;  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: for (uint i = 1; i <= numberOfAssemblyReferences; ++i) {  	AssemblyRefRow assemblyRefRow = this.PEFileReader.AssemblyRefTable [i];  	IName assemblyRefName = this.GetNameFromOffset (assemblyRefRow.Name);  	IName cultureName = this.GetNameFromOffset (assemblyRefRow.Culture);  	Version version = new Version (assemblyRefRow.MajorVersion' assemblyRefRow.MinorVersion' assemblyRefRow.BuildNumber' assemblyRefRow.RevisionNumber);  	byte[] publicKeyTokenArray = TypeCache.EmptyByteArray;  	if (assemblyRefRow.PublicKeyOrToken != 0) {  		var publicKeyOrTokenArray = this.PEFileReader.BlobStream [assemblyRefRow.PublicKeyOrToken];  		if ((assemblyRefRow.Flags & AssemblyFlags.PublicKey) == AssemblyFlags.PublicKey && publicKeyOrTokenArray.Length > 0) {  			publicKeyTokenArray = UnitHelper.ComputePublicKeyToken (publicKeyOrTokenArray);  		}  		else {  			publicKeyTokenArray = publicKeyOrTokenArray;  		}  		if (publicKeyTokenArray.Length != 8) {  			//  Error  		}  	}  	AssemblyIdentity assemblyIdentity = new AssemblyIdentity (assemblyRefName' cultureName.Value' version' publicKeyTokenArray' string.Empty);  	AssemblyReference assemblyReference = new AssemblyReference (this' i' assemblyIdentity' assemblyRefRow.Flags);  	assemblyRefList [i] = assemblyReference;  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: if (assemblyRefRow.PublicKeyOrToken != 0) {  	var publicKeyOrTokenArray = this.PEFileReader.BlobStream [assemblyRefRow.PublicKeyOrToken];  	if ((assemblyRefRow.Flags & AssemblyFlags.PublicKey) == AssemblyFlags.PublicKey && publicKeyOrTokenArray.Length > 0) {  		publicKeyTokenArray = UnitHelper.ComputePublicKeyToken (publicKeyOrTokenArray);  	}  	else {  		publicKeyTokenArray = publicKeyOrTokenArray;  	}  	if (publicKeyTokenArray.Length != 8) {  		//  Error  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: if (publicKeyTokenArray.Length != 8) {  	//  Error  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (resource.IsInExternalFile) {  	IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument (this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value);  	if (binaryDocumentMemoryBlock == null) {  		//  Error. File not present  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableBinaryDocumentMemoryBlockWrapper (binaryDocumentMemoryBlock);  }  else {  	uint resOffset = this.PEFileReader.ManifestResourceTable.GetOffset (resource.ResourceRowId);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	uint len = this.PEFileReader.ResourceMemoryReader.PeekUInt32 ((int)resOffset);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableMemoryBlockWrapper (this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt (resOffset + sizeof(Int32)' len));  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (resource.IsInExternalFile) {  	IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument (this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value);  	if (binaryDocumentMemoryBlock == null) {  		//  Error. File not present  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableBinaryDocumentMemoryBlockWrapper (binaryDocumentMemoryBlock);  }  else {  	uint resOffset = this.PEFileReader.ManifestResourceTable.GetOffset (resource.ResourceRowId);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	uint len = this.PEFileReader.ResourceMemoryReader.PeekUInt32 ((int)resOffset);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableMemoryBlockWrapper (this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt (resOffset + sizeof(Int32)' len));  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {  	//  MDError:  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {  	//  MDError:  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The following statement contains a magic number: while (this.SignatureMemoryReader.NotEndOfBytes) {  	byte header = this.SignatureMemoryReader.PeekByte (0);  	if (header == ElementType.Pinned) {  		this.SignatureMemoryReader.SkipBytes (1);  		isPinned = true;  		continue;  	}  	if (header != ElementType.RequiredModifier && header != ElementType.OptionalModifier)  		break;  	this.SignatureMemoryReader.SkipBytes (1);  	uint typeDefOrRefEncoded = (uint)this.SignatureMemoryReader.ReadCompressedUInt32 ();  	uint typeToken = TypeDefOrRefTag.ConvertToToken (typeDefOrRefEncoded);  	uint tokenType = typeToken & TokenTypeIds.TokenTypeMask;  	uint typeRID = typeToken & TokenTypeIds.RIDMask;  	ITypeReference /*?*/typeRef = null;  	if (tokenType == TokenTypeIds.TypeDef)  		typeRef = this.PEFileToObjectModel.GetTypeDefinitionAtRow (typeRID);  	else if (tokenType == TokenTypeIds.TypeRef)  		typeRef = this.PEFileToObjectModel.GetTypeRefReferenceAtRow (typeRID);  	else  		typeRef = this.PEFileToObjectModel.GetTypeSpecReferenceAtRow (this.MetadataOwnerObject' typeRID).UnderlyingModuleTypeReference;  	if (typeRef == null) {  		//  Error...  		continue;  	}  	if (customModifier != null && customModifierList == null) {  		customModifierList = new List<ICustomModifier> (4);  		customModifierList.Add (customModifier);  	}  	customModifier = new CustomModifier (header == ElementType.OptionalModifier' typeRef);  	if (customModifierList != null)  		customModifierList.Add (customModifier);  }  
Magic Number,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The following statement contains a magic number: if (customModifier != null && customModifierList == null) {  	customModifierList = new List<ICustomModifier> (4);  	customModifierList.Add (customModifier);  }  
Magic Number,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The following statement contains a magic number: customModifierList = new List<ICustomModifier> (4);  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,WindowsRuntimeMetadataReaderHost,The following statement contains a magic number: Contract.Requires (pointerSize == 0 || pointerSize == 4 || pointerSize == 8);  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,WindowsRuntimeMetadataReaderHost,The following statement contains a magic number: Contract.Requires (pointerSize == 0 || pointerSize == 4 || pointerSize == 8);  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  	case OperationCode.Ldc_I4_M1:  	case OperationCode.Ldc_I4_0:  	case OperationCode.Ldc_I4_1:  	case OperationCode.Ldc_I4_2:  	case OperationCode.Ldc_I4_3:  	case OperationCode.Ldc_I4_4:  	case OperationCode.Ldc_I4_5:  	case OperationCode.Ldc_I4_6:  	case OperationCode.Ldc_I4_7:  	case OperationCode.Ldc_I4_8:  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  	case OperationCode.Ldc_I4_M1:  	case OperationCode.Ldc_I4_0:  	case OperationCode.Ldc_I4_1:  	case OperationCode.Ldc_I4_2:  	case OperationCode.Ldc_I4_3:  	case OperationCode.Ldc_I4_4:  	case OperationCode.Ldc_I4_5:  	case OperationCode.Ldc_I4_6:  	case OperationCode.Ldc_I4_7:  	case OperationCode.Ldc_I4_8:  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  	case OperationCode.Ldc_I4_M1:  	case OperationCode.Ldc_I4_0:  	case OperationCode.Ldc_I4_1:  	case OperationCode.Ldc_I4_2:  	case OperationCode.Ldc_I4_3:  	case OperationCode.Ldc_I4_4:  	case OperationCode.Ldc_I4_5:  	case OperationCode.Ldc_I4_6:  	case OperationCode.Ldc_I4_7:  	case OperationCode.Ldc_I4_8:  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instrcutions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (2);  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (4);  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (8);  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (4 * numTargets);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ModuleTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ModuleTableReader,The following statement contains a magic number: this.IsGUIDHeapRefSizeSmall = guidHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeRefTableReader,The following statement contains a magic number: this.IsResolutionScopeRefSizeSmall = resolutionScopeRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsFieldRefSizeSmall = fieldRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsMethodRefSizeSmall = methodRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldPtrTableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodPtrTableReader,The following statement contains a magic number: this.IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsParamRefSizeSmall = paramRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ParamPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ParamPtrTableReader,The following statement contains a magic number: this.IsParamTableRowRefSizeSmall = paramTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ParamTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ParamTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,InterfaceImplTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,InterfaceImplTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsMemberRefParentRefSizeSmall = memberRefParentRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ConstantTableReader,The following statement contains a magic number: this.IsHasConstantRefSizeSmall = hasConstantRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ConstantTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsHasCustomAttributeRefSizeSmall = hasCustomAttributeRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsCustomAttriubuteTypeRefSizeSmall = customAttributeTypeRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldMarshalTableReader,The following statement contains a magic number: this.IsHasFieldMarshalRefSizeSmall = hasFieldMarshalRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldMarshalTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,DeclSecurityTableReader,The following statement contains a magic number: this.IsHasDeclSecurityRefSizeSmall = hasDeclSecurityRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,DeclSecurityTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ClassLayoutTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldLayoutTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldLayoutTableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,StandAloneSigTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,StandAloneSigTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,EventMapTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,EventMapTableReader,The following statement contains a magic number: this.IsEventRefSizeSmall = eventRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,EventPtrTableReader,The following statement contains a magic number: this.IsEventTableRowRefSizeSmall = eventTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,EventTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,EventTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,PropertyMapTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,PropertyMapTableReader,The following statement contains a magic number: this.IsPropertyRefSizeSmall = propertyRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,PropertyPtrTableReader,The following statement contains a magic number: this.IsPropertyTableRowRefSizeSmall = propertyTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,PropertyTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,PropertyTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodSemanticsTableReader,The following statement contains a magic number: this.IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodSemanticsTableReader,The following statement contains a magic number: this.IsHasSemanticRefSizeSmall = hasSemanticRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodImplTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodImplTableReader,The following statement contains a magic number: this.IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ModuleRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeSpecTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,TypeSpecTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsModuleRefTableRowRefSizeSmall = moduleRefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsMemberForwardRowRefSizeSmall = memberForwardedRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldRVATableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FieldRVATableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,AssemblyTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,AssemblyTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,AssemblyRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,AssemblyRefTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefProcessorTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,AssemblyRefProcessorTableReader,The following statement contains a magic number: this.IsAssemblyRefTableRowSizeSmall = assembyRefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefOSTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,AssemblyRefOSTableReader,The following statement contains a magic number: this.IsAssemblyRefTableRowRefSizeSmall = assembyRefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FileTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,FileTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ExportedTypeTableReader,The following statement contains a magic number: this.IsImplementationRefSizeSmall = implementationRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ExportedTypeTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ManifestResourceTableReader,The following statement contains a magic number: this.IsImplementationRefSizeSmall = implementationRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ManifestResourceTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,NestedClassTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GenericParamTableReader,The following statement contains a magic number: this.IsTypeOrMethodDefRefSizeSmall = typeOrMethodDefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GenericParamTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSpecTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodSpecTableReader,The following statement contains a magic number: this.IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSpecTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,MethodSpecTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GenericParamConstraintTableReader,The following statement contains a magic number: this.IsGenericParamTableRowRefSizeSmall = genericParamTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GenericParamConstraintTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The following statement contains a magic number: if (ptrToDebugInfo >= this.BinaryDocumentMemoryBlock.Pointer + this.BinaryDocumentMemoryBlock.Length - 28) {  	//TODO: error  	return new PEFileDebugInformation ();  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The following statement contains a magic number: debugDataReader.SkipBytes (16);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadStreamHeaders,The following statement contains a magic number: for (int i = 0; i < numberOfStreams; ++i) {  	if (memReader.RemainingBytes < COR20Constants.MinimumSizeofStreamHeader) {  		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StreamHeaderTooSmall);  		return false;  	}  	streamHeaders [i].Offset = memReader.ReadUInt32 ();  	streamHeaders [i].Size = memReader.ReadInt32 ();  	//  Review: Oh well there is no way i can test if we will read correctly. However we can check it after reading and aligning...  	streamHeaders [i].Name = memReader.ReadASCIINullTerminated ();  	memReader.Align (4);  	if (memReader.RemainingBytes < 0) {  		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStreamHeaderName);  		return false;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadStreamHeaders,The following statement contains a magic number: memReader.Align (4);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: switch (version) {  case 0x00010000:  	validTablesForVersion = (ulong)TableMask.V1_0_TablesMask;  	break;  case 0x00010001:  	validTablesForVersion = (ulong)TableMask.V1_1_TablesMask;  	break;  case 0x00020000:  	validTablesForVersion = (ulong)TableMask.V2_0_TablesMask;  	break;  default:  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata);  	return false;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if ((presentTables & ~validTablesForVersion) != 0) {  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.UnknownTables);  	return false;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.UnknownTables);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if (this.MetadataStreamKind == MetadataStreamKind.Compressed && (presentTables & (ulong)TableMask.CompressedStreamNotAllowedMask) != 0) {  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream);  	return false;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if ((requiredSortedTables & (ulong)this.MetadataTableHeader.SortedTables) != requiredSortedTables) {  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted);  	//Carry on regardless. There are/were compiler out there that sort the required tables' but fail to set the bit in SortedTables.  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ComputeCodedTokenSize,The following statement contains a magic number: return isAllReferencedTablesSmall ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ComputeCodedTokenSize,The following statement contains a magic number: return isAllReferencedTablesSmall ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {  	if ((validTables & 0x0000000000000001UL) != 0) {  		uint rowCount = rowCountCompressedArray [arrayIndex++];  		rowCountArray [tableIndex] = rowCount;  		rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  	}  	else {  		rowRefSizeArray [tableIndex] = 2;  	}  	validTables >>= 1;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {  	if ((validTables & 0x0000000000000001UL) != 0) {  		uint rowCount = rowCountCompressedArray [arrayIndex++];  		rowCountArray [tableIndex] = rowCount;  		rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  	}  	else {  		rowRefSizeArray [tableIndex] = 2;  	}  	validTables >>= 1;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {  	if ((validTables & 0x0000000000000001UL) != 0) {  		uint rowCount = rowCountCompressedArray [arrayIndex++];  		rowCountArray [tableIndex] = rowCount;  		rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  	}  	else {  		rowRefSizeArray [tableIndex] = 2;  	}  	validTables >>= 1;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: if ((validTables & 0x0000000000000001UL) != 0) {  	uint rowCount = rowCountCompressedArray [arrayIndex++];  	rowCountArray [tableIndex] = rowCount;  	rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  }  else {  	rowRefSizeArray [tableIndex] = 2;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: if ((validTables & 0x0000000000000001UL) != 0) {  	uint rowCount = rowCountCompressedArray [arrayIndex++];  	rowCountArray [tableIndex] = rowCount;  	rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  }  else {  	rowRefSizeArray [tableIndex] = 2;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: if ((validTables & 0x0000000000000001UL) != 0) {  	uint rowCount = rowCountCompressedArray [arrayIndex++];  	rowCountArray [tableIndex] = rowCount;  	rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  }  else {  	rowRefSizeArray [tableIndex] = 2;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: rowRefSizeArray [tableIndex] = 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if ((headByte & CILMethodFlags.ILFormatMask) == CILMethodFlags.ILTinyFormat) {  	int size = headByte >> CILMethodFlags.ILTinyFormatSizeShift;  	return new MethodIL (true' 8' 0x00000000' memReader.GetMemoryBlockAt (0' size)' null);  }  else if ((headByte & CILMethodFlags.ILFormatMask) != CILMethodFlags.ILFatFormat) {  	//  PEFileFormat Error...  	return null;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: return new MethodIL (true' 8' 0x00000000' memReader.GetMemoryBlockAt (0' size)' null);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: memReader.Align (4);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: dataSize += (int)memReader.ReadUInt16 () << 8;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: memReader.SkipBytes (2);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00110011001100110011001100110011) + ((count >> 2) & MASK_00110011001100110011001100110011);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00001111000011110000111100001111) + ((count >> 4) & MASK_00001111000011110000111100001111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000111111110000000011111111) + ((count >> 8) & MASK_00000000111111110000000011111111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000000000001111111111111111) + ((count >> 16) & MASK_00000000000000001111111111111111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_11111111111111111111111111111111) + ((count >> 32) & MASK_11111111111111111111111111111111);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		if ((ch & 0x80) != 0)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (uint j = n - (m.Position - i); j < n; j++) {  		char ch = chars [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i] = (byte)((ch & 0x3F) | 0x80);  		}  	}  }  else {  	m.Position = i + n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = chars [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (uint j = n - (m.Position - i); j < n; j++) {  	char ch = chars [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: ch32 = (ch & 0x3FF) << 10;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: m.Position = i + 3;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: m.Position = i + n * 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	char ch = chars [j];  	buffer [i++] = (byte)ch;  	buffer [i++] = (byte)(ch >> 8);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteChars,The following statement contains a magic number: buffer [i++] = (byte)(ch >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteDouble,The following statement contains a magic number: m.Position = i + 8;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteDouble,The following statement contains a magic number: for (uint j = 0; j < 8; j++)  	buffer [i + j] = *(d + j);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteShort,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteShort,The following statement contains a magic number: buffer [i] = (byte)(value >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUshort,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUshort,The following statement contains a magic number: buffer [i] = (byte)(value >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteInt,The following statement contains a magic number: buffer [i] = (byte)(value >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: buffer [i++] = (byte)(value >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: buffer [i++] = (byte)(value >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUint,The following statement contains a magic number: buffer [i] = (byte)(value >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: m.Position = i + 8;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteLong,The following statement contains a magic number: buffer [i] = (byte)(hi >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: m.Position = i + 8;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer [i++] = (byte)(lo >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer [i++] = (byte)(hi >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteUlong,The following statement contains a magic number: buffer [i] = (byte)(hi >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteFloat,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteFloat,The following statement contains a magic number: for (uint j = 0; j < 4; j++)  	buffer [i + j] = *(f + j);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (!emitNullTerminator) {  	if (this.UTF8)  		this.WriteCompressedUInt (GetUTF8ByteCount (str));  	else  		this.WriteCompressedUInt ((uint)n * 2);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8)  	this.WriteCompressedUInt (GetUTF8ByteCount (str));  else  	this.WriteCompressedUInt ((uint)n * 2);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: this.WriteCompressedUInt ((uint)n * 2);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (this.UTF8) {  	m.Position = i + (uint)n;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		if (ch >= 0x80)  			goto writeUTF8;  		buffer [i++] = (byte)ch;  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  	return;  	writeUTF8:  	int ch32 = 0;  	for (int j = n - (int)(m.Position - i); j < n; j++) {  		char ch = str [j];  		if (ch < 0x80) {  			m.Position = i + 1;  			buffer = m.Buffer;  			buffer [i++] = (byte)ch;  		}  		else if (ch < 0x800) {  			m.Position = i + 2;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  		else if (0xD800 <= ch && ch <= 0xDBFF) {  			ch32 = (ch & 0x3FF) << 10;  		}  		else if (0xDC00 <= ch && ch <= 0xDFFF) {  			ch32 |= ch & 0x3FF;  			m.Position = i + 4;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  			buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  			buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  		}  		else {  			m.Position = i + 3;  			buffer = m.Buffer;  			buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  			buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  			buffer [i++] = (byte)((ch & 0x3F) | 0x80);  		}  	}  	if (emitNullTerminator) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i] = 0;  	}  }  else {  	m.Position = i + (uint)n * 2;  	byte[] buffer = m.Buffer;  	for (int j = 0; j < n; j++) {  		char ch = str [j];  		buffer [i++] = (byte)ch;  		buffer [i++] = (byte)(ch >> 8);  	}  	if (emitNullTerminator) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = 0;  		buffer [i] = 0;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = n - (int)(m.Position - i); j < n; j++) {  	char ch = str [j];  	if (ch < 0x80) {  		m.Position = i + 1;  		buffer = m.Buffer;  		buffer [i++] = (byte)ch;  	}  	else if (ch < 0x800) {  		m.Position = i + 2;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		ch32 = (ch & 0x3FF) << 10;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		ch32 |= ch & 0x3FF;  		m.Position = i + 4;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  		buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  		buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  	}  	else {  		m.Position = i + 3;  		buffer = m.Buffer;  		buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  		buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  		buffer [i++] = (byte)((ch & 0x3F) | 0x80);  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x80) {  	m.Position = i + 1;  	buffer = m.Buffer;  	buffer [i++] = (byte)ch;  }  else if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (ch < 0x800) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x1F) | 0xC0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	ch32 = (ch & 0x3FF) << 10;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: ch32 = (ch & 0x3FF) << 10;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	ch32 |= ch & 0x3FF;  	m.Position = i + 4;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  	buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  	buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch32 & 0x3F) | 0x80);  }  else {  	m.Position = i + 3;  	buffer = m.Buffer;  	buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  	buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  	buffer [i++] = (byte)((ch & 0x3F) | 0x80);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: m.Position = i + 4;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 18) & 0x7) | 0xF0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 12) & 0x3F) | 0x80);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(((ch32 >> 6) & 0x3F) | 0x80);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: m.Position = i + 3;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 12) & 0xF) | 0xE0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(((ch >> 6) & 0x3F) | 0x80);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: m.Position = i + (uint)n * 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: for (int j = 0; j < n; j++) {  	char ch = str [j];  	buffer [i++] = (byte)ch;  	buffer [i++] = (byte)(ch >> 8);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: buffer [i++] = (byte)(ch >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: if (emitNullTerminator) {  	m.Position = i + 2;  	buffer = m.Buffer;  	buffer [i++] = 0;  	buffer [i] = 0;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteString,The following statement contains a magic number: m.Position = i + 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 < 128) {  	buffer [i++] = (byte)(d * 2 + 0);  }  else if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d * 2 + 0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 < 128 * 128) {  	buffer [i++] = (byte)(d * 4 + 1);  	buffer [i++] = (byte)(d >> 6);  }  else if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d * 4 + 1);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 6);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 < 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 8 + 3);  	buffer [i++] = (byte)(d >> 5);  	buffer [i++] = (byte)(d >> 13);  }  else if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d * 8 + 3);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d * 8 + 3);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 5);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 13);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: if (d + 64 * 128 * 128 * 128 < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(d * 16 + 7);  	buffer [i++] = (byte)(d >> 4);  	buffer [i++] = (byte)(d >> 12);  	buffer [i++] = (byte)(d >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)d;  	buffer [i++] = (byte)(d >> 8);  	buffer [i++] = (byte)(d >> 16);  	buffer [i++] = (byte)(d >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d * 16 + 7);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d * 16 + 7);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 4);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 12);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 20);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)15;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullInt,The following statement contains a magic number: buffer [i++] = (byte)(d >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128) {  	buffer [i++] = (byte)(value * 2 + 0);  }  else if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value * 2 + 0);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128) {  	buffer [i++] = (byte)(value * 4 + 1);  	buffer [i++] = (byte)(value >> 6);  }  else if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value * 4 + 1);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 6);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 8 + 3);  	buffer [i++] = (byte)(value >> 5);  	buffer [i++] = (byte)(value >> 13);  }  else if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value * 8 + 3);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value * 8 + 3);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 5);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 13);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: if (value < 128 * 128 * 128 * 128) {  	buffer [i++] = (byte)(value * 16 + 7);  	buffer [i++] = (byte)(value >> 4);  	buffer [i++] = (byte)(value >> 12);  	buffer [i++] = (byte)(value >> 20);  }  else {  	buffer [i++] = (byte)15;  	buffer [i++] = (byte)value;  	buffer [i++] = (byte)(value >> 8);  	buffer [i++] = (byte)(value >> 16);  	buffer [i++] = (byte)(value >> 24);  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value * 16 + 7);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value * 16 + 7);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 4);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 12);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 20);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)15;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 8);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 16);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedFullUInt,The following statement contains a magic number: buffer [i++] = (byte)(value >> 24);  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {  	val = val << 1;  	this.WriteCompressedUInt ((uint)val);  }  else {  	if (val > -0x40) {  		val = 0x40 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)val);  	}  	else if (val >= -0x2000) {  		val = 0x2000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 8) | 0x80));  		this.WriteByte ((byte)(val & 0xff));  	}  	else if (val >= -0x20000000) {  		val = 0x20000000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 24) | 0xc0));  		this.WriteByte ((byte)((val & 0xff0000) >> 16));  		this.WriteByte ((byte)((val & 0xff00) >> 8));  		this.WriteByte ((byte)(val & 0xff));  	}  	else {  		//^ assume false;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {  	val = val << 1;  	this.WriteCompressedUInt ((uint)val);  }  else {  	if (val > -0x40) {  		val = 0x40 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)val);  	}  	else if (val >= -0x2000) {  		val = 0x2000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 8) | 0x80));  		this.WriteByte ((byte)(val & 0xff));  	}  	else if (val >= -0x20000000) {  		val = 0x20000000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 24) | 0xc0));  		this.WriteByte ((byte)((val & 0xff0000) >> 16));  		this.WriteByte ((byte)((val & 0xff00) >> 8));  		this.WriteByte ((byte)(val & 0xff));  	}  	else {  		//^ assume false;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {  	val = val << 1;  	this.WriteCompressedUInt ((uint)val);  }  else {  	if (val > -0x40) {  		val = 0x40 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)val);  	}  	else if (val >= -0x2000) {  		val = 0x2000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 8) | 0x80));  		this.WriteByte ((byte)(val & 0xff));  	}  	else if (val >= -0x20000000) {  		val = 0x20000000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 24) | 0xc0));  		this.WriteByte ((byte)((val & 0xff0000) >> 16));  		this.WriteByte ((byte)((val & 0xff00) >> 8));  		this.WriteByte ((byte)(val & 0xff));  	}  	else {  		//^ assume false;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= 0) {  	val = val << 1;  	this.WriteCompressedUInt ((uint)val);  }  else {  	if (val > -0x40) {  		val = 0x40 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)val);  	}  	else if (val >= -0x2000) {  		val = 0x2000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 8) | 0x80));  		this.WriteByte ((byte)(val & 0xff));  	}  	else if (val >= -0x20000000) {  		val = 0x20000000 + val;  		val = (val << 1) | 1;  		this.WriteByte ((byte)((val >> 24) | 0xc0));  		this.WriteByte ((byte)((val & 0xff0000) >> 16));  		this.WriteByte ((byte)((val & 0xff00) >> 8));  		this.WriteByte ((byte)(val & 0xff));  	}  	else {  		//^ assume false;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val > -0x40) {  	val = 0x40 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)val);  }  else if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val > -0x40) {  	val = 0x40 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)val);  }  else if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val > -0x40) {  	val = 0x40 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)val);  }  else if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val > -0x40) {  	val = 0x40 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)val);  }  else if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x2000) {  	val = 0x2000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: this.WriteByte ((byte)((val >> 8) | 0x80));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: if (val >= -0x20000000) {  	val = 0x20000000 + val;  	val = (val << 1) | 1;  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: this.WriteByte ((byte)((val >> 24) | 0xc0));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: this.WriteByte ((byte)((val & 0xff0000) >> 16));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedInt,The following statement contains a magic number: this.WriteByte ((byte)((val & 0xff00) >> 8));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)  	this.WriteByte ((byte)val);  else if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)  	this.WriteByte ((byte)val);  else if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)  	this.WriteByte ((byte)val);  else if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x7f)  	this.WriteByte ((byte)val);  else if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x3fff) {  	this.WriteByte ((byte)((val >> 8) | 0x80));  	this.WriteByte ((byte)(val & 0xff));  }  else if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: this.WriteByte ((byte)((val >> 8) | 0x80));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: if (val <= 0x1fffffff) {  	this.WriteByte ((byte)((val >> 24) | 0xc0));  	this.WriteByte ((byte)((val & 0xff0000) >> 16));  	this.WriteByte ((byte)((val & 0xff00) >> 8));  	this.WriteByte ((byte)(val & 0xff));  }  else {  	//^ assume false;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: this.WriteByte ((byte)((val >> 24) | 0xc0));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: this.WriteByte ((byte)((val & 0xff0000) >> 16));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,WriteCompressedUInt,The following statement contains a magic number: this.WriteByte ((byte)((val & 0xff00) >> 8));  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	}  	else if (ch < 0x800) {  		count += 2;  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	}  	else {  		count += 3;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	}  	else if (ch < 0x800) {  		count += 2;  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	}  	else {  		count += 3;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	}  	else if (ch < 0x800) {  		count += 2;  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	}  	else {  		count += 3;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: for (int i = 0' n = str.Length; i < n; i++) {  	char ch = str [i];  	if (ch < 0x80) {  		count += 1;  	}  	else if (ch < 0x800) {  		count += 2;  	}  	else if (0xD800 <= ch && ch <= 0xDBFF) {  		count += 2;  	}  	else if (0xDC00 <= ch && ch <= 0xDFFF) {  		count += 2;  	}  	else {  		count += 3;  	}  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  }  else if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  }  else if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  }  else if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x80) {  	count += 1;  }  else if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (ch < 0x800) {  	count += 2;  }  else if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xD800 <= ch && ch <= 0xDBFF) {  	count += 2;  }  else if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: if (0xDC00 <= ch && ch <= 0xDFFF) {  	count += 2;  }  else {  	count += 3;  }  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 2;  
Magic Number,Microsoft.Cci.WriterUtilities,BinaryWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\BinaryWriter.cs,GetUTF8ByteCount,The following statement contains a magic number: count += 3;  
Magic Number,Microsoft.Cci.WriterUtilities,MemoryStream,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\MemoryStream.cs,MemoryStream,The following statement contains a magic number: this.Buffer = new byte[64];  
Magic Number,Microsoft.Cci.WriterUtilities,MemoryStream,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: if (n2 == 0)  	n2 = 16;  
Magic Number,Microsoft.Cci.WriterUtilities,MemoryStream,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: n2 = 16;  
Magic Number,Microsoft.Cci.WriterUtilities,MemoryStream,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: while (m >= n2)  	n2 = n2 * 2;  
Magic Number,Microsoft.Cci.WriterUtilities,MemoryStream,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\MemoryStream.cs,Grow,The following statement contains a magic number: n2 = n2 * 2;  
Magic Number,Microsoft.Cci.PeWriterInternal,ByteArrayComparer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: for (long i = 0' n = x.LongLength; i < n; i++)  	hcode = hcode * 17 + x [i];  
Magic Number,Microsoft.Cci.PeWriterInternal,ByteArrayComparer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: hcode = hcode * 17 + x [i];  
Magic Number,Microsoft.Cci.PeWriterInternal,MethodSpecComparer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetHashCode,The following statement contains a magic number: return (int)((this.peWriter.GetMethodDefOrRefCodedIndex (methodInstanceReference.GenericMethod) << 2) ^ this.peWriter.GetMethodInstanceSignatureIndex (methodInstanceReference));  
Duplicate Code,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\ILReader.cs,PopulateCilInstructions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((85' 106)' (218' 239))
Missing Default,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,GetLabel,The following switch statement is missing a default case: switch (exceptionInfo.HandlerKind) {  case HandlerKind.Catch:  	BeginCatchBlock (exceptionInfo.ExceptionType);  	break;  case HandlerKind.Fault:  	BeginFaultBlock ();  	break;  case HandlerKind.Filter:  	BeginFilterBody ();  	break;  case HandlerKind.Finally:  	BeginFinallyBlock ();  	break;  }  
Missing Default,Afterthought.Amender,ILAmender,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\ILAmender.cs,EmitOperations,The following switch statement is missing a default case: switch (exceptionInfo.HandlerKind) {  case HandlerKind.Catch:  	BeginCatchBlock (exceptionInfo.ExceptionType);  	break;  case HandlerKind.Fault:  	BeginFaultBlock ();  	break;  case HandlerKind.Filter:  	BeginFilterBody ();  	break;  case HandlerKind.Finally:  	BeginFinallyBlock ();  	break;  }  
Missing Default,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\ControlFlowInferencer.cs,GetInstruction,The following switch statement is missing a default case: switch (ilOperation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	Contract.Assume (ilOperation.Value is uint);  	//This is an informally specified property of the Metadata model.  	var targetOffset = (uint)ilOperation.Value;  	this.blocksThatTarget.Add (targetOffset' currentBlock);  	edges.Add (this.cdfg.BlockFor [targetOffset]);  	break;  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (ilOperation.Value is uint);  	//This is an informally specified property of the Metadata model.  	targetOffset = (uint)ilOperation.Value;  	this.blocksThatTarget.Add (targetOffset' currentBlock);  	edges.Add (this.cdfg.BlockFor [targetOffset]);  	isUnconditionalTransfer = true;  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	Contract.Assume (ilOperation.Value is uint);  	//This is an informally specified property of the Metadata model.  	targetOffset = (uint)ilOperation.Value;  	this.blocksThatTarget.Add (targetOffset' currentBlock);  	edges.Add (this.cdfg.BlockFor [targetOffset]);  	break;  case OperationCode.Endfilter:  case OperationCode.Endfinally:  case OperationCode.Jmp:  case OperationCode.Ret:  case OperationCode.Rethrow:  case OperationCode.Throw:  	isUnconditionalTransfer = true;  	break;  case OperationCode.Switch:  	this.AddEdgesForSwitch (ilOperation' currentBlock' edges' instruction);  	break;  }  
Missing Default,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The following switch statement is missing a default case: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  case OperationCode.Ldsfld:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldsflda:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldftn:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  case OperationCode.Sizeof:  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArrayIndexerInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  case OperationCode.Newarr:  	InitializeArrayCreateInstruction (instruction' this.stack' instruction.Operation);  	break;  case OperationCode.Array_Set:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArraySetInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Isinst:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldobj:  case OperationCode.Ldflda:  case OperationCode.Ldfld:  case OperationCode.Ldlen:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Mkrefany:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' signature);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' funcPointer);  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	var indexAndValue = new Instruction[2];  	indexAndValue [1] = this.stack.Pop ();  	indexAndValue [0] = this.stack.Pop ();  	instruction.Operand2 = indexAndValue;  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Dup:  	var dupop = this.stack.Pop ();  	instruction.Operand1 = dupop;  	this.stack.Push (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Newobj:  	Contract.Assume (instruction.Operation.Value is ISignature);  	//This is an informally specified property of the Metadata model.  	signature = (ISignature)instruction.Operation.Value;  	var numArguments = (int)IteratorHelper.EnumerableCount (signature.Parameters);  	if (numArguments > 0) {  		if (numArguments > 1) {  			numArguments--;  			var arguments = new Instruction[numArguments];  			instruction.Operand2 = arguments;  			for (var i = numArguments - 1; i >= 0; i--)  				arguments [i] = stack.Pop ();  		}  		instruction.Operand1 = stack.Pop ();  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	break;  }  
Missing Default,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The following switch statement is missing a default case: switch (rightTypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  	//assume that the left operand has an enum type.  	return leftOperand.Type;  }  
Missing Default,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitMethodBody,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Leave:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	this.GetLabelFor ((uint)operation.Value);  	break;  case OperationCode.Switch:  	uint[] offsets = operation.Value as uint[];  	Contract.Assume (offsets != null);  	foreach (var offset in offsets) {  		this.GetLabelFor (offset);  	}  	break;  }  
Missing Default,Microsoft.Cci,ILRewriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\ILGenerator\ILRewriter.cs,EmitOperation,The following switch statement is missing a default case: switch (operationCode) {  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Leave:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	operationCode = ILGenerator.LongVersionOf (operationCode);  	Contract.Assume (operation.Value is uint);  	value = this.GetLabelFor (+(uint)operation.Value);  	break;  case OperationCode.Switch:  	uint[] offsets = operation.Value as uint[];  	Contract.Assume (offsets != null);  	var n = offsets.Length;  	ILGeneratorLabel[] labels = new ILGeneratorLabel[n];  	for (int i = 0; i < n; i++) {  		var offset = offsets [i];  		labels [i] = this.GetLabelFor (offset);  	}  	value = labels;  	break;  //Avoid the short forms because the locals can get reordered.  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	operationCode = OperationCode.Ldloc;  	break;  case OperationCode.Ldloca_S:  	operationCode = OperationCode.Ldloca;  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	operationCode = OperationCode.Stloc;  	break;  }  
Missing Default,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsVisibleOutsideAssembly,The following switch statement is missing a default case: switch (TypeHelper.TypeVisibilityAsTypeMemberVisibility (typeDefinition)) {  case TypeMemberVisibility.Public:  case TypeMemberVisibility.Family:  case TypeMemberVisibility.FamilyOrAssembly:  	return true;  }  
Missing Default,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,IsVisibleToFriendAssemblies,The following switch statement is missing a default case: switch (TypeHelper.TypeVisibilityAsTypeMemberVisibility (typeDefinition)) {  case TypeMemberVisibility.Public:  case TypeMemberVisibility.Family:  case TypeMemberVisibility.FamilyOrAssembly:  case TypeMemberVisibility.FamilyAndAssembly:  case TypeMemberVisibility.Assembly:  	return true;  }  
Missing Default,Microsoft.Cci,TypeHelper,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,StackType,The following switch statement is missing a default case: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt8:  	return type.PlatformType.SystemInt32;  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt64:  	return type.PlatformType.SystemInt64;  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  	return type.PlatformType.SystemFloat64;  case PrimitiveTypeCode.IntPtr:  case PrimitiveTypeCode.UIntPtr:  	return type.PlatformType.SystemIntPtr;  }  
Missing Default,Microsoft.Cci,TypeNameFormatter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\TypeHelper.cs,GetTypeName,The following switch statement is missing a default case: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return "bool";  case PrimitiveTypeCode.Char:  	return "char";  case PrimitiveTypeCode.Float32:  	return "float";  case PrimitiveTypeCode.Float64:  	return "double";  case PrimitiveTypeCode.Int16:  	return "short";  case PrimitiveTypeCode.Int32:  	return "int";  case PrimitiveTypeCode.Int64:  	return "long";  case PrimitiveTypeCode.Int8:  	return "sbyte";  case PrimitiveTypeCode.String:  	return "string";  case PrimitiveTypeCode.UInt16:  	return "ushort";  case PrimitiveTypeCode.UInt32:  	return "uint";  case PrimitiveTypeCode.UInt64:  	return "ulong";  case PrimitiveTypeCode.UInt8:  	return "byte";  case PrimitiveTypeCode.Void:  	return "void";  case PrimitiveTypeCode.NotPrimitive:  	if (TypeHelper.TypesAreEquivalent (type' type.PlatformType.SystemDecimal))  		return "decimal";  	if (TypeHelper.TypesAreEquivalent (type' type.PlatformType.SystemObject))  		return "object";  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetGenericParamFlags,The following switch statement is missing a default case: switch (genPar.Variance) {  case TypeParameterVariance.Covariant:  	result |= 0x0001;  	break;  case TypeParameterVariance.Contravariant:  	result |= 0x0002;  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMappingFlags,The following switch statement is missing a default case: switch (platformInvokeInformation.StringFormat) {  case StringFormatKind.Ansi:  	result |= 0x0002;  	break;  case StringFormatKind.Unicode:  	result |= 0x0004;  	break;  case StringFormatKind.AutoChar:  	result |= 0x0006;  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetMappingFlags,The following switch statement is missing a default case: switch (platformInvokeInformation.PInvokeCallingConvention) {  case PInvokeCallingConvention.WinApi:  	result |= 0x0100;  	break;  case PInvokeCallingConvention.CDecl:  	result |= 0x0200;  	break;  case PInvokeCallingConvention.StdCall:  	result |= 0x0300;  	break;  case PInvokeCallingConvention.ThisCall:  	result |= 0x0400;  	break;  case PInvokeCallingConvention.FastCall:  	result |= 0x0500;  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeCodeByteFor,The following switch statement is missing a default case: switch (ic.GetTypeCode ()) {  case TypeCode.Boolean:  	return 0x02;  case TypeCode.Char:  	return 0x03;  case TypeCode.SByte:  	return 0x04;  case TypeCode.Byte:  	return 0x05;  case TypeCode.Int16:  	return 0x06;  case TypeCode.UInt16:  	return 0x07;  case TypeCode.Int32:  	return 0x08;  case TypeCode.UInt32:  	return 0x09;  case TypeCode.Int64:  	return 0x0a;  case TypeCode.UInt64:  	return 0x0b;  case TypeCode.Single:  	return 0x0c;  case TypeCode.Double:  	return 0x0d;  case TypeCode.String:  	return 0x0e;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefFlags,The following switch statement is missing a default case: switch (typeDef.Layout) {  case LayoutKind.Sequential:  	result |= 0x00000008;  	break;  case LayoutKind.Explicit:  	result |= 0x00000010;  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefFlags,The following switch statement is missing a default case: switch (typeDef.StringFormat) {  case StringFormatKind.Unicode:  	result |= 0x00010000;  	break;  case StringFormatKind.AutoChar:  	result |= 0x00020000;  	break;  //TODO: need object model support for 0x00030000; custom format class  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeDefFlags,The following switch statement is missing a default case: switch (neTypeDef.Visibility) {  case TypeMemberVisibility.Public:  	result |= 0x00000002;  	break;  case TypeMemberVisibility.Private:  	result |= 0x00000003;  	break;  case TypeMemberVisibility.Family:  	result |= 0x00000004;  	break;  case TypeMemberVisibility.Assembly:  	result |= 0x00000005;  	break;  case TypeMemberVisibility.FamilyAndAssembly:  	result |= 0x00000006;  	break;  case TypeMemberVisibility.FamilyOrAssembly:  	result |= 0x00000007;  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,GetTypeMemberVisibilityFlags,The following switch statement is missing a default case: switch (member.Visibility) {  case TypeMemberVisibility.Private:  	result |= 0x00000001;  	break;  case TypeMemberVisibility.FamilyAndAssembly:  	result |= 0x00000002;  	break;  case TypeMemberVisibility.Assembly:  	result |= 0x00000003;  	break;  case TypeMemberVisibility.Family:  	result |= 0x00000004;  	break;  case TypeMemberVisibility.FamilyOrAssembly:  	result |= 0x00000005;  	break;  case TypeMemberVisibility.Public:  	result |= 0x00000006;  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMetadataConstantValue,The following switch statement is missing a default case: switch (ic.GetTypeCode ()) {  case TypeCode.Boolean:  	writer.WriteBool (ic.ToBoolean (null));  	break;  case TypeCode.Byte:  	writer.WriteByte (ic.ToByte (null));  	break;  case TypeCode.Char:  	writer.WriteUshort ((ushort)ic.ToChar (null));  	break;  case TypeCode.Double:  	writer.WriteDouble (ic.ToDouble (null));  	break;  case TypeCode.Int16:  	writer.WriteShort (ic.ToInt16 (null));  	break;  case TypeCode.Int32:  	writer.WriteInt (ic.ToInt32 (null));  	break;  case TypeCode.Int64:  	writer.WriteLong (ic.ToInt64 (null));  	break;  case TypeCode.SByte:  	writer.WriteSbyte (ic.ToSByte (null));  	break;  case TypeCode.Single:  	writer.WriteFloat (ic.ToSingle (null));  	break;  case TypeCode.String:  	writer.WriteString (ic.ToString (null));  	break;  case TypeCode.UInt16:  	writer.WriteUshort (ic.ToUInt16 (null));  	break;  case TypeCode.UInt32:  	writer.WriteUint (ic.ToUInt32 (null));  	break;  case TypeCode.UInt64:  	writer.WriteUlong (ic.ToUInt64 (null));  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeMethodBodyIL,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  case OperationCode.Array_Set:  	writer.WriteByte ((byte)OperationCode.Call);  	writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  	continue;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  	writer.WriteByte ((byte)OperationCode.Newobj);  	writer.WriteUint (this.GetMethodRefTokenFor ((IArrayTypeReference)operation.Value' operation.OperationCode));  	continue;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeExceptionInformation,The following switch statement is missing a default case: switch (exceptionInfo.HandlerKind) {  case HandlerKind.Catch:  	writer.WriteUshort (0x0000);  	break;  case HandlerKind.Filter:  	writer.WriteUshort (0x0001);  	break;  case HandlerKind.Finally:  	writer.WriteUshort (0x0002);  	break;  case HandlerKind.Fault:  	writer.WriteUshort (0x0004);  	break;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,SerializeTypeReference,The following switch statement is missing a default case: switch (typeReference.TypeCode) {  case PrimitiveTypeCode.Void:  	writer.WriteByte (0x01);  	return;  case PrimitiveTypeCode.Boolean:  	writer.WriteByte (0x02);  	return;  case PrimitiveTypeCode.Char:  	writer.WriteByte (0x03);  	return;  case PrimitiveTypeCode.Int8:  	writer.WriteByte (0x04);  	return;  case PrimitiveTypeCode.UInt8:  	writer.WriteByte (0x05);  	return;  case PrimitiveTypeCode.Int16:  	writer.WriteByte (0x06);  	return;  case PrimitiveTypeCode.UInt16:  	writer.WriteByte (0x07);  	return;  case PrimitiveTypeCode.Int32:  	writer.WriteByte (0x08);  	return;  case PrimitiveTypeCode.UInt32:  	writer.WriteByte (0x09);  	return;  case PrimitiveTypeCode.Int64:  	writer.WriteByte (0x0a);  	return;  case PrimitiveTypeCode.UInt64:  	writer.WriteByte (0x0b);  	return;  case PrimitiveTypeCode.Float32:  	writer.WriteByte (0x0c);  	return;  case PrimitiveTypeCode.Float64:  	writer.WriteByte (0x0d);  	return;  case PrimitiveTypeCode.String:  	writer.WriteByte (0x0e);  	return;  case PrimitiveTypeCode.Pointer:  	IPointerTypeReference /*?*/pointerTypeReference = null;  	if ((pointerTypeReference = typeReference as IPointerTypeReference) != null) {  		if (noTokens)  			this.SerializeTypeName (pointerTypeReference' writer);  		else {  			writer.WriteByte (0x0f);  			this.SerializeTypeReference (pointerTypeReference.TargetType' writer);  		}  		return;  	}  	break;  case PrimitiveTypeCode.Reference:  	IManagedPointerTypeReference /*?*/managedPointerTypeReference = null;  	if ((managedPointerTypeReference = typeReference as IManagedPointerTypeReference) != null) {  		if (noTokens)  			this.SerializeTypeName (managedPointerTypeReference' writer);  		else {  			writer.WriteByte (0x10);  			this.SerializeTypeReference (managedPointerTypeReference.TargetType' writer);  		}  		return;  	}  	break;  case PrimitiveTypeCode.IntPtr:  	writer.WriteByte (0x18);  	return;  case PrimitiveTypeCode.UIntPtr:  	writer.WriteByte (0x19);  	return;  }  
Missing Default,Microsoft.Cci,PeWriter,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeWriter\PeWriter.cs,WriteHeaders,The following switch statement is missing a default case: switch (module.Kind) {  case ModuleKind.ConsoleApplication:  case ModuleKind.DynamicallyLinkedLibrary:  	writer.WriteUshort (3);  	//70  	break;  case ModuleKind.WindowsApplication:  	writer.WriteUshort (2);  	//70  	break;  }  
Missing Default,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ToLineColumn,The following switch statement is missing a default case: switch (text [--i]) {  case '\n':  	if (i > 0 && text [i - 1] == '\r')  		i--;  	goto case '\r';  case '\r':  case (char)0x2028:  case (char)0x2029:  	line--;  	if (i <= position)  		goto forwardSearch;  	break;  }  
Missing Default,Microsoft.Cci,PrimarySourceDocument,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\SourceModel\Implementations.cs,ToPosition,The following switch statement is missing a default case: switch (text [--i]) {  case '\n':  	if (i > 0 && text [i - 1] == '\r')  		i--;  	goto case '\r';  case '\r':  case (char)0x2028:  case (char)0x2029:  	l--;  	if (l < line)  		goto forwardSearch;  	break;  }  
Missing Default,Microsoft.Cci.Immutable,DummyArrayMethodReference,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\MetadataHelper\Members.cs,DummyArrayMethodReference,The following switch statement is missing a default case: switch (this.arrayOperation) {  case OperationCode.Array_Addr:  	name = host.NameTable.Address;  	break;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  	name = host.NameTable.Ctor;  	break;  case OperationCode.Array_Get:  	name = host.NameTable.Get;  	break;  case OperationCode.Array_Set:  	name = host.NameTable.Set;  	break;  }  
Missing Default,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,KindToString,The following switch statement is missing a default case: switch (kind) {  case ContractFailureKind.Assert:  	kindString = "Contract.Assert";  	break;  case ContractFailureKind.Assume:  	kindString = "Contract.Assume";  	break;  case ContractFailureKind.Invariant:  	kindString = "Contract.Invariant";  	break;  case ContractFailureKind.Postcondition:  	kindString = "Contract.Postcondition";  	break;  case ContractFailureKind.PostconditionOnException:  	kindString = "Contract.PostconditionOnException";  	break;  case ContractFailureKind.Precondition:  	kindString = "Contract.Precondition";  	break;  }  
Missing Default,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,CountFailure,The following switch statement is missing a default case: switch (kind) {  case ContractFailureKind.Precondition:  	RequiresCount.IncrementFail ();  	break;  case ContractFailureKind.Assert:  	AssertCount.IncrementFail ();  	break;  case ContractFailureKind.Assume:  	AssumeCount.IncrementFail ();  	break;  case ContractFailureKind.Postcondition:  	EnsuresCount.IncrementFail ();  	break;  case ContractFailureKind.Invariant:  	InvariantCount.IncrementFail ();  	break;  case ContractFailureKind.PostconditionOnException:  	EnsuresOnThrowCount.IncrementFail ();  	break;  }  
Missing Default,System.Diagnostics.Contracts,RuntimeContracts,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\Microsoft.Contracts\RuntimeContracts.cs,CountCheck,The following switch statement is missing a default case: switch (kind) {  case ContractFailureKind.Precondition:  	RequiresCount.IncrementCheck ();  	break;  case ContractFailureKind.Assert:  	AssertCount.IncrementCheck ();  	break;  case ContractFailureKind.Assume:  	AssumeCount.IncrementCheck ();  	break;  case ContractFailureKind.Postcondition:  	EnsuresCount.IncrementCheck ();  	break;  case ContractFailureKind.Invariant:  	InvariantCount.IncrementCheck ();  	break;  case ContractFailureKind.PostconditionOnException:  	EnsuresOnThrowCount.IncrementCheck ();  	break;  }  
Missing Default,Microsoft.Cci.Pdb,PdbFile,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PdbReader\PdbFile.cs,LoadManagedLines,The following switch statement is missing a default case: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	}  	else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Missing Default,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Types.cs,ToString,The following switch statement is missing a default case: switch (this.signatureTypeCode) {  case MetadataReaderSignatureTypeCode.Boolean:  	return "System.Boolean";  case MetadataReaderSignatureTypeCode.Byte:  	return "System.Byte";  case MetadataReaderSignatureTypeCode.Char:  	return "System.Char";  case MetadataReaderSignatureTypeCode.Double:  	return "System.Double";  case MetadataReaderSignatureTypeCode.Int16:  	return "System.Int16";  case MetadataReaderSignatureTypeCode.Int32:  	return "System.Int32";  case MetadataReaderSignatureTypeCode.Int64:  	return "System.Int64";  case MetadataReaderSignatureTypeCode.IntPtr:  	return "System.IntPtr";  case MetadataReaderSignatureTypeCode.Object:  	return "System.Object";  case MetadataReaderSignatureTypeCode.SByte:  	return "System.SByte";  case MetadataReaderSignatureTypeCode.Single:  	return "System.Single";  case MetadataReaderSignatureTypeCode.String:  	return "System.String";  case MetadataReaderSignatureTypeCode.TypedReference:  	return "System.TypedReference";  case MetadataReaderSignatureTypeCode.UInt16:  	return "System.UInt16";  case MetadataReaderSignatureTypeCode.UInt32:  	return "System.UInt32";  case MetadataReaderSignatureTypeCode.UInt64:  	return "System.UInt64";  case MetadataReaderSignatureTypeCode.UIntPtr:  	return "System.UIntPtr";  case MetadataReaderSignatureTypeCode.Void:  	return "System.Void";  }  
Missing Default,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetPrimitiveValue,The following switch statement is missing a default case: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Missing Default,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\Attributes.cs,GetFieldOrPropType,The following switch statement is missing a default case: switch (elementByte) {  case SerializationType.Boolean:  	return this.PEFileToObjectModel.PlatformType.SystemBoolean;  case SerializationType.Char:  	return this.PEFileToObjectModel.PlatformType.SystemChar;  case SerializationType.Int8:  	return this.PEFileToObjectModel.PlatformType.SystemInt8;  case SerializationType.UInt8:  	return this.PEFileToObjectModel.PlatformType.SystemUInt8;  case SerializationType.Int16:  	return this.PEFileToObjectModel.PlatformType.SystemInt16;  case SerializationType.UInt16:  	return this.PEFileToObjectModel.PlatformType.SystemUInt16;  case SerializationType.Int32:  	return this.PEFileToObjectModel.PlatformType.SystemInt32;  case SerializationType.UInt32:  	return this.PEFileToObjectModel.PlatformType.SystemUInt32;  case SerializationType.Int64:  	return this.PEFileToObjectModel.PlatformType.SystemInt64;  case SerializationType.UInt64:  	return this.PEFileToObjectModel.PlatformType.SystemUInt64;  case SerializationType.Single:  	return this.PEFileToObjectModel.PlatformType.SystemFloat32;  case SerializationType.Double:  	return this.PEFileToObjectModel.PlatformType.SystemFloat64;  case SerializationType.String:  	return this.PEFileToObjectModel.PlatformType.SystemString;  case SerializationType.SZArray: {  	ITypeReference /*?*/elementType = this.GetFieldOrPropType ();  	if (elementType == null)  		return null;  	return Vector.GetVector (elementType' this.PEFileToObjectModel.InternFactory);  }  case SerializationType.Type:  	return this.PEFileToObjectModel.PlatformType.SystemType;  case SerializationType.TaggedObject:  	return this.PEFileToObjectModel.PlatformType.SystemObject;  case SerializationType.Enum: {  	string /*?*/typeName = this.GetSerializedString ();  	if (typeName == null)  		return null;  	var result = this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeName);  	var tnr = result as TypeNameTypeReference;  	if (tnr == null) {  		var specializedNestedType = result as ISpecializedNestedTypeReference;  		if (specializedNestedType != null)  			tnr = specializedNestedType.UnspecializedVersion as TypeNameTypeReference;  	}  	if (tnr != null)  		tnr.IsEnum = true;  	return result;  }  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetUninterpretedPESections,The following switch statement is missing a default case: switch (nameStr) {  case ".text":  case ".sdata":  case ".tls":  case ".rdata":  case ".cover":  case ".rsrc":  case ".reloc":  	continue;  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetTypeReferenceForToken,The following switch statement is missing a default case: switch (tokenType) {  case TokenTypeIds.TypeDef: {  	if (rowId == 0 || rowId > this.PEFileReader.TypeDefTable.NumberOfRows) {  		//  handle Error  	}  	return this.GetTypeDefinitionAtRow (rowId);  }  case TokenTypeIds.TypeRef: {  	if (rowId == 0 || rowId > this.PEFileReader.TypeRefTable.NumberOfRows) {  		//  handle Error  	}  	return this.GetTypeRefReferenceAtRow (rowId' mustBeStruct);  }  case TokenTypeIds.TypeSpec: {  	if (rowId == 0 || rowId > this.PEFileReader.TypeSpecTable.NumberOfRows) {  		//  handle Error  	}  	return this.GetTypeSpecReferenceAtRow (owningObject' rowId).UnderlyingModuleTypeReference;  }  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetReferenceToAliasedType,The following switch statement is missing a default case: switch (tokenType) {  case TokenTypeIds.File: {  	FileReference /*?*/fileRef = this.GetFileReferenceAt (rowId);  	if (fileRef == null)  		return null;  	var module = thisAssembly.FindMemberModuleNamed (fileRef.Name) as Module;  	if (module == null)  		return null;  	var foundType = module.PEFileToObjectModel.ResolveNamespaceTypeDefinition (namespaceName' mangledTypeName);  	if (foundType == null)  		return null;  	return foundType;  }  case TokenTypeIds.ExportedType: {  	ExportedTypeAliasBase /*?*/parentExportedType = this.GetExportedTypeAtRowWorker (rowId);  	if (parentExportedType == null)  		return null;  	var parentModuleType = this.GetReferenceToAliasedType (parentExportedType);  	if (parentModuleType == null)  		return null;  	ITypeDefinition parentType = parentModuleType.ResolvedType;  	if (!(parentType is Dummy)) {  		foreach (ITypeDefinitionMember tdm in parentModuleType.ResolvedType.GetMembersNamed (unmangledTypeName' false)) {  			var modTypeRef = tdm as IMetadataReaderNamedTypeReference;  			if (modTypeRef != null)  				return modTypeRef;  		}  	}  	else {  		NamespaceTypeNameTypeReference /*?*/nstr = parentModuleType as NamespaceTypeNameTypeReference;  		if (nstr != null) {  			var nestedTypeName = new NestedTypeName (this.NameTable' nstr.NamespaceTypeName' mangledTypeName);  			return nestedTypeName.GetAsNamedTypeReference (this' nstr.Module);  		}  		NestedTypeNameTypeReference /*?*/netr = parentModuleType as NestedTypeNameTypeReference;  		if (netr != null) {  			var nestedTypeName = new NestedTypeName (this.NameTable' netr.NestedTypeName' mangledTypeName);  			return nestedTypeName.GetAsNamedTypeReference (this' netr.Module);  		}  	}  	return null;  }  case TokenTypeIds.AssemblyRef: {  	AssemblyReference /*?*/assemRef = this.GetAssemblyReferenceAt (rowId);  	if (assemRef == null)  		return null;  	var internalAssembly = assemRef.ResolvedAssembly as Assembly;  	if (internalAssembly != null) {  		//Since we have already loaded the assembly that is supposed to hold this type' we may as well try and resolve it.  		PEFileToObjectModel assemblyPEFileToObjectModel = internalAssembly.PEFileToObjectModel;  		var type = assemblyPEFileToObjectModel.ResolveNamespaceTypeDefinition (namespaceName' mangledTypeName);  		if (type != null)  			return type;  		//The other assembly (internalAssembly) does not have a namespace type def for this reference.  		//Perhaps it has an alias that forwards to somewhere else... Not very likely happen in practice' I would hope.  		ExportedTypeAliasBase /*?*/aliasType = assemblyPEFileToObjectModel.TryToResolveAsNamespaceTypeAlias (namespaceName' mangledTypeName);  		if (aliasType != null && aliasType != alias)  			return assemblyPEFileToObjectModel.GetReferenceToAliasedType (aliasType);  		//Although we can resolve the target assembly' we can neither resolve the aliased type' nor find a secondary alias.  		//This is mighty strange. Probably the host has fluffed assembly resolution and internalAssembly isn't really the  		//assembly we are looking for. We now have to give up and simply return an unresolved reference.  	}  	string fullTypeName = mangledTypeName.Value;  	if (namespaceName.Value.Length > 0)  		fullTypeName = namespaceName.Value + "." + fullTypeName;  	var parser = new TypeNameParser (this.NameTable' fullTypeName);  	return parser.ParseTypeName ().GetAsTypeReference (this' assemRef) as INamedTypeReference;  }  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetFieldMapping,The following switch statement is missing a default case: switch (this.PEFileReader.RVAToSubSectionName (rva)) {  case ".text":  	sectionKind = PESectionKind.Text;  	break;  case ".sdata":  	sectionKind = PESectionKind.StaticData;  	break;  case ".tls":  	sectionKind = PESectionKind.ThreadLocalStorage;  	break;  case ".rdata":  	sectionKind = PESectionKind.ConstantData;  	break;  case ".cover":  	sectionKind = PESectionKind.CoverageData;  	break;  case ".datax":  	sectionKind = PESectionKind.ExtendedData;  	break;  case ".data":  	sectionKind = PESectionKind.ExtendedData;  	break;  //TODO: instead of an enum' use an IName.  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetFieldSizeIfPossibleToDoSoWithoutResolving,The following switch statement is missing a default case: switch (typeReference.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return sizeof(Boolean);  case PrimitiveTypeCode.Char:  	return sizeof(Char);  case PrimitiveTypeCode.Int16:  	return sizeof(Int16);  case PrimitiveTypeCode.Int32:  	return sizeof(Int32);  case PrimitiveTypeCode.Int8:  	return sizeof(SByte);  case PrimitiveTypeCode.UInt16:  	return sizeof(UInt16);  case PrimitiveTypeCode.UInt32:  	return sizeof(UInt32);  case PrimitiveTypeCode.UInt8:  	return sizeof(Byte);  case PrimitiveTypeCode.Int64:  	return sizeof(Int64);  case PrimitiveTypeCode.UInt64:  	return sizeof(UInt64);  case PrimitiveTypeCode.IntPtr:  	return this.pointerSize;  case PrimitiveTypeCode.UIntPtr:  	return this.pointerSize;  case PrimitiveTypeCode.Float32:  	return sizeof(Single);  case PrimitiveTypeCode.Float64:  	return sizeof(Double);  case PrimitiveTypeCode.Pointer:  	return this.pointerSize;  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetDefaultValue,The following switch statement is missing a default case: switch (constRow.Type) {  case ElementType.Boolean: {  	byte val = memoryReader.ReadByte ();  	return new ConstantExpression (this.PlatformType.SystemBoolean' val != 0);  }  case ElementType.Char:  	return new ConstantExpression (this.PlatformType.SystemChar' memoryReader.ReadChar ());  case ElementType.Int8:  	return new ConstantExpression (this.PlatformType.SystemInt8' memoryReader.ReadSByte ());  case ElementType.Int16:  	return new ConstantExpression (this.PlatformType.SystemInt16' memoryReader.ReadInt16 ());  case ElementType.Int32:  	return new ConstantExpression (this.PlatformType.SystemInt32' memoryReader.ReadInt32 ());  case ElementType.Int64:  	return new ConstantExpression (this.PlatformType.SystemInt64' memoryReader.ReadInt64 ());  case ElementType.UInt8:  	return new ConstantExpression (this.PlatformType.SystemUInt8' memoryReader.ReadByte ());  case ElementType.UInt16:  	return new ConstantExpression (this.PlatformType.SystemUInt16' memoryReader.ReadUInt16 ());  case ElementType.UInt32:  	return new ConstantExpression (this.PlatformType.SystemUInt32' memoryReader.ReadUInt32 ());  case ElementType.UInt64:  	return new ConstantExpression (this.PlatformType.SystemUInt64' memoryReader.ReadUInt64 ());  case ElementType.Single:  	return new ConstantExpression (this.PlatformType.SystemFloat32' memoryReader.ReadSingle ());  case ElementType.Double:  	return new ConstantExpression (this.PlatformType.SystemFloat64' memoryReader.ReadDouble ());  case ElementType.String: {  	int byteLen = memoryReader.Length;  	string /*?*/value;  	if (byteLen == -1) {  		value = null;  	}  	else if (byteLen == 0) {  		value = string.Empty;  	}  	else {  		value = memoryReader.ReadUTF16WithSize (byteLen);  	}  	return new ConstantExpression (this.PlatformType.SystemString' value);  }  case ElementType.Class:  	return new ConstantExpression (this.PlatformType.SystemObject' null);  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileToObjectModel.cs,GetMethodReferenceForToken,The following switch statement is missing a default case: switch (tokenKind) {  case TokenTypeIds.MethodDef:  	methRef = this.GetMethodDefAtRow (rowId);  	break;  case TokenTypeIds.MethodSpec:  	methRef = this.GetMethodSpecAtRow (owningObject' rowId);  	break;  case TokenTypeIds.MemberRef:  	methRef = this.GetModuleMemberReferenceAtRow (owningObject' rowId) as IMethodReference;  	break;  }  
Missing Default,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\WindowsRuntimeHost.cs,Rewrite,The following switch statement is missing a default case: switch ((int)argConst.Value) {  case 0x00000001:  	clrEnumValue = 0x00001000;  	break;  case 0x00000002:  	clrEnumValue = 0x00000010;  	break;  case 0x00000004:  	clrEnumValue = 0x00000200;  	break;  case 0x00000008:  	clrEnumValue = 0x00000100;  	break;  case 0x00000010:  	clrEnumValue = 0x00000400;  	break;  case 0x00000020:  	clrEnumValue = 0x00000000;  	break;  case 0x00000040:  	clrEnumValue = 0x00000040;  	break;  case 0x00000080:  	clrEnumValue = 0x00000800;  	break;  case 0x00000100:  	clrEnumValue = 0x00000080;  	break;  case 0x00000200:  	clrEnumValue = 0x00000004;  	break;  case 0x00000400:  	clrEnumValue = 0x00000008;  	break;  case 0x00000800:  	clrEnumValue = 0x00000000;  	break;  case -1:  	clrEnumValue = 0x00007FFF;  	break;  }  
Missing Default,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\ApocalypticOctopus_ReactiveAfterthought\Afterthought.Amender\Microsoft.CCI\PeReader\PEFileStructures.cs,ConvertToTag,The following switch statement is missing a default case: switch (tokenType) {  case TokenTypeIds.MethodDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Method;  case TokenTypeIds.FieldDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Field;  case TokenTypeIds.TypeRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeRef;  case TokenTypeIds.TypeDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeDef;  case TokenTypeIds.ParamDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Param;  case TokenTypeIds.InterfaceImpl:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.InterfaceImpl;  case TokenTypeIds.MemberRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.MemberRef;  case TokenTypeIds.Module:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Module;  case TokenTypeIds.Permission:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.DeclSecurity;  case TokenTypeIds.Property:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Property;  case TokenTypeIds.Event:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Event;  case TokenTypeIds.Signature:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.StandAloneSig;  case TokenTypeIds.ModuleRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ModuleRef;  case TokenTypeIds.TypeSpec:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeSpec;  case TokenTypeIds.Assembly:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Assembly;  case TokenTypeIds.AssemblyRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.AssemblyRef;  case TokenTypeIds.File:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.File;  case TokenTypeIds.ExportedType:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ExportedType;  case TokenTypeIds.ManifestResource:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ManifestResource;  case TokenTypeIds.GenericParam:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.GenericParameter;  }  
