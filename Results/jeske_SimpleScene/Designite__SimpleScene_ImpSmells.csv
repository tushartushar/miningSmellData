Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,ComputeProjections,The method has 118 lines of code.
Long Method,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,The method has 164 lines of code.
Long Method,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,preRenderUpdate,The method has 128 lines of code.
Complex Method,SimpleScene,SSObject,C:\repos\jeske_SimpleScene\SimpleScene\SSObject.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene,SSScene,C:\repos\jeske_SimpleScene\SimpleScene\SSScene.cs,renderPass,Cyclomatic complexity of the method is 9
Complex Method,SimpleScene,SSSimpleShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSSimpleShadowMap.cs,ComputeProjections,Cyclomatic complexity of the method is 9
Complex Method,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,ComputeProjections,Cyclomatic complexity of the method is 12
Complex Method,SimpleScene,SSIndexedMesh<V>,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,preciseIntersect,Cyclomatic complexity of the method is 10
Complex Method,SimpleScene,SSMD5Parser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5Parser.cs,seekRegexEntry,Cyclomatic complexity of the method is 12
Complex Method,SimpleScene,SSInstancedMeshRenderer,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSInstancedMeshRenderer.cs,PreciseIntersect,Cyclomatic complexity of the method is 12
Complex Method,SimpleScene,SSParticleSystemData,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSParticleSystemData.cs,simulateStep,Cyclomatic complexity of the method is 11
Complex Method,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,particleSwap,Cyclomatic complexity of the method is 9
Complex Method,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,expandVolume,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,childExpanded,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readFrameJoints,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene.Demos,SProportionalNavigationPursuitDriver,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\MissileDrivers.cs,updateExecution,Cyclomatic complexity of the method is 8
Complex Method,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,driveCamera,Cyclomatic complexity of the method is 9
Complex Method,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,preRenderUpdate,Cyclomatic complexity of the method is 13
Long Parameter List,SimpleScene,SSRenderConfig,C:\repos\jeske_SimpleScene\SimpleScene\SSScene.cs,SSRenderConfig,The method has 5 parameters. Parameters: main' pssm' instance' instancePssm' other
Long Parameter List,SimpleScene,SSScene,C:\repos\jeske_SimpleScene\SimpleScene\SSScene.cs,SSScene,The method has 5 parameters. Parameters: main' pssm' instance' instancePssm' otherShaders
Long Parameter List,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,neededRotationAxisAngle,The method has 5 parameters. Parameters: dir1' dir2' axis' angle' normalizeInput
Long Parameter List,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,TriangleRayIntersectionTest,The method has 6 parameters. Parameters: V1' V2' V3' rayStart' rayDir' contact
Long Parameter List,SimpleScene,SSSimpleShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSSimpleShadowMap.cs,PrepareForRender,The method has 6 parameters. Parameters: renderConfig' objects' fov' aspect' nearZ' farZ
Long Parameter List,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,PrepareForRender,The method has 6 parameters. Parameters: renderConfig' objects' fov' aspect' cameraNearZ' cameraFarZ
Long Parameter List,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,ComputeProjections,The method has 7 parameters. Parameters: objects' cameraView' cameraProj' fov' aspect' cameraNearZ' cameraFarZ
Long Parameter List,SimpleScene,SSShadowMapBase,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSShadowMapBase.cs,PrepareForRender,The method has 6 parameters. Parameters: renderConfig' objects' fov' aspect' nearZ' farZ
Long Parameter List,SimpleScene,SSShadowMapBase,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSShadowMapBase.cs,viewProjFromLightAlignedBB,The method has 5 parameters. Parameters: bb' lightTransform' lightY' viewMatrix' projMatrix
Long Parameter List,SimpleScene,SSVertex_PosTex,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,SSVertex_PosTex,The method has 5 parameters. Parameters: x' y' z' u' v
Long Parameter List,SimpleScene,ParticlesRingGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesFieldGenerators.cs,ParticlesRingGenerator,The method has 6 parameters. Parameters: planeGenerator' ringCenter' up' ringRadius' sectionStart' sectionEnd
Long Parameter List,SimpleScene,BodiesFieldGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\BodiesFieldGenerators.cs,BodiesFieldGenerator,The method has 6 parameters. Parameters: partFieldGen' bodyScaleMin' bodyScaleMax' bodyRadius' safetyDistance' oriPolicy
Long Parameter List,SimpleScene,BodiesRingGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\BodiesFieldGenerators.cs,BodiesRingGenerator,The method has 11 parameters. Parameters: sliceGenerator' ringCenter' up' ringRadius' sectionStart' sectionEnd' bodyScaleMin' bodyScaleMax' bodyRadius' safetyDistance' oriPolicy
Long Parameter List,SimpleScene,BodiesRingGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\BodiesFieldGenerators.cs,BodiesRingGenerator,The method has 12 parameters. Parameters: ovalHorizontal' ovalVertical' ringCenter' up' ringRadius' sectionStart' sectionEnd' bodyScaleMin' bodyScaleMax' bodyRadius' safetyDistance' oriPolicy
Long Parameter List,SimpleScene,SSColorMaterial,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSColorMaterial.cs,SSColorMaterial,The method has 5 parameters. Parameters: diffuse' ambient' specular' emission' shininess
Long Parameter List,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,jetTxfm,The method has 5 parameters. Parameters: jetIdx' pos' globalOrient' jetPos' jetFwd
Long Parameter List,SimpleScene.Util,LinearADSREnvelope,C:\repos\jeske_SimpleScene\SimpleScene\Util\LinearADSREnvelope.cs,LinearADSREnvelope,The method has 6 parameters. Parameters: attackDuration' decayDuration' sustainDuration' releaseDuration' peakLevel' sustainLevel
Long Parameter List,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,addObject,The method has 5 parameters. Parameters: nAda' curNode' newOb' newObBox' newObSAH
Long Parameter List,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,ssBVHNode,The method has 5 parameters. Parameters: bvh' lparent' gobjectlist' lastSplitAxis' curdepth
Long Parameter List,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawString,The method has 5 parameters. Parameters: text' font' brush' curPoint' fmt
Long Parameter List,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawString,The method has 8 parameters. Parameters: text' font' typeFace' brush' x' y' justification' baseline
Long Parameter List,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawString,The method has 5 parameters. Parameters: text' font' brush' x' y
Long Parameter List,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillRectangle,The method has 5 parameters. Parameters: brush' x' y' width' height
Long Parameter List,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawRectangle,The method has 5 parameters. Parameters: pen' x' y' width' height
Long Parameter List,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawLine,The method has 5 parameters. Parameters: pen' x1' y1' x2' y2
Long Parameter List,SimpleScene.Demos,ISSpriteUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSInstancedSpriteRenderer.cs,updateSprites,The method has 5 parameters. Parameters: instanceData' screenClientRect' cameraPos' camera3dView' camera3dProj
Long Parameter List,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,SLaserBeamMiddleObject,The method has 6 parameters. Parameters: laser' beamId' cameraScene' middleBackgroundTexture' middleOverlayTexture' inteferenceTexture
Long Parameter List,SimpleScene.Demos,SLaserEmissionFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserEmissionFlareUpdater.cs,SLaserEmissionFlareUpdater,The method has 5 parameters. Parameters: laser' beamId' occDisk' backgroundRect' overlayRect
Long Parameter List,SimpleScene.Demos,SLaserEmissionFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserEmissionFlareUpdater.cs,updateSprites,The method has 5 parameters. Parameters: instanceData' screenClientRect' cameraPos' camera3dView' camera3dProj
Long Parameter List,SimpleScene.Demos,SLaserManager,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserManager.cs,SLaserManager,The method has 5 parameters. Parameters: beamScene3d' occDiskScene' flareScene2d' sprite2dCapacity' laserBurnParticlesCapacity
Long Parameter List,SimpleScene.Demos,BeamRuntimeInfo,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserManager.cs,BeamRuntimeInfo,The method has 5 parameters. Parameters: laser' beamId' beamScene' occDiskScene' sprite2dRenderer
Long Parameter List,SimpleScene.Demos,SSpaceMissilesRenderManager,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilesRenderManager.cs,launchCluster,The method has 10 parameters. Parameters: launcherWorldMat' launchVel' numMissiles' target' clusterParams' localPositioningOffsets' localDirections' localPositioningGenerator' missileAtTargetFunc' timeToHit
Long Parameter List,SimpleScene.Demos,SSunFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SSunFlareRenderer.cs,updateSprites,The method has 5 parameters. Parameters: instanceData' clientRect' cameraPos' camera3dView' camera3dProj
Long Parameter List,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,renderShadowmaps,The method has 8 parameters. Parameters: fovy' aspect' nearPlane' farPlane' mainSceneView' mainSceneProj' rotationOnlyView' screenProj
Long Parameter List,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,renderSolid3dScenes,The method has 8 parameters. Parameters: fovy' aspect' nearPlane' farPlane' mainSceneView' mainSceneProj' rotationOnlyView' screenProj
Long Parameter List,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,renderEnvironment3dScenes,The method has 8 parameters. Parameters: fovy' aspect' nearPlane' farPlane' mainSceneView' mainSceneProj' rotationOnlyView' screenProj
Long Parameter List,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,renderAlpha3dScenes,The method has 8 parameters. Parameters: fovy' aspect' nearPlane' farPlane' mainSceneView' mainSceneProj' rotationOnlyView' screenProj
Long Parameter List,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,renderOcclusion3dScenes,The method has 8 parameters. Parameters: fovy' aspect' nearPlane' farPlane' mainSceneView' mainSceneProj' rotationOnlyView' screenProj
Long Parameter List,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,renderScreen2dScenes,The method has 8 parameters. Parameters: fovy' aspect' nearPlane' farPlane' mainSceneView' mainSceneProj' rotationOnlyView' screenProj
Long Parameter List,SimpleScene.Demos,SLaserScreenHitFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserScreenHitFlareUpdater.cs,SLaserScreenHitFlareUpdater,The method has 5 parameters. Parameters: laser' beamId' camera3dScene' rects' scales
Long Parameter List,SimpleScene.Demos,SLaserScreenHitFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserScreenHitFlareUpdater.cs,updateSprites,The method has 5 parameters. Parameters: instanceData' clientRect' cameraPos' camera3dView' camera3dProj
Long Parameter List,SimpleScene.Demos,SSpaceMissileVisualParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissileParameters.cs,createMissile,The method has 5 parameters. Parameters: pos' dir' vel' cluster' clusterId
Long Parameter List,SimpleScene.Demos,SSpaceMissileData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilelData.cs,SSpaceMissileData,The method has 7 parameters. Parameters: missileWorldPos' missileWorldVel' parameters' target' timeToHitTarget' sharableData' atf
Long Parameter List,SimpleScene.Demos,SSpaceMissileVisualData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilelData.cs,SSpaceMissileVisualData,The method has 5 parameters. Parameters: missileWorldPos' missileWorldDir' missileWorldVel' cluster' clusterId
Long Parameter List,SimpleScene.Demos,SSpaceMissileVisualData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilelData.cs,SSpaceMissileVisualData,The method has 7 parameters. Parameters: missileWorldPos' missileWorldVel' parameters' target' atf' ejectionYawVelocity' ejectionPitchVelocity
Long Parameter List,SimpleScene.Demos,SSpaceMissilesVisualSimulation,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilesVisualSimulation.cs,launchCluster,The method has 10 parameters. Parameters: launcherWorldMat' launchVel' numMissiles' target' timeToHit' clusterParams' localPositioningOffsets' localDirectionPresets' meshPositioningGenerator' atTargetFunc
Long Parameter List,SimpleScene.Demos,SSpaceMissileClusterVisualData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilesVisualSimulation.cs,SSpaceMissileClusterVisualData,The method has 10 parameters. Parameters: launcherWorldMat' launcherVel' numMissiles' target' timeToHit' mParams' meshPositioningOffsets' meshPositioningDirections' meshPositioningGenerator' atTargetFunc
Long Parameter List,SimpleScene.Demos,SExplosionManager,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,showExplosion,The method has 5 parameters. Parameters: eParams' intensity' position' velocity' simInterval
Long Parameter List,SimpleScene.Demos,SExplosionManager,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,showExplosionDelayed,The method has 5 parameters. Parameters: eParams' intensity' delay' position' velocity
Long Parameter List,SimpleScene.Demos,SExplosionManager,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,showExplosionAttached,The method has 5 parameters. Parameters: eParams' intensity' attachTo' localPos' simInterval
Long Parameter List,SimpleScene.Demos,SExplosionManager,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,_showExplosionCommon,The method has 6 parameters. Parameters: attachTo' eParams' position' velocity' intensity' simInterval
Long Parameter List,SimpleScene.Demos,DelayedExplosionInfo,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,DelayedExplosionInfo,The method has 6 parameters. Parameters: em' ep' intensity' position' velocity' delay
Long Identifier,SimpleScene,SSRadialEmitter,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticleEmitters.cs,,The length of the parameter velocityFromCenterMagnitudeMin is 30.
Long Identifier,SimpleScene,SSRadialEmitter,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticleEmitters.cs,,The length of the parameter velocityFromCenterMagnitudeMax is 30.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter intensityModulationFunctionStr is 30.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter middleBackgroundTextureFilename is 31.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter middleInterferenceTextureFilename is 33.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter emissionSpritesTextureFilename is 30.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter flameSmokeParticlesPerEmissionMin is 33.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter flameSmokeParticlesPerEmissionMax is 33.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter spriteVelocityTowardsCameraMin is 30.
Long Identifier,SimpleScene.Demos,SLaserParameters,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserParameters.cs,,The length of the parameter spriteVelocityTowardsCameraMax is 30.
Long Statement,SimpleScene,SSScene,C:\repos\jeske_SimpleScene\SimpleScene\SSScene.cs,Intersect,The length of the statement  "                        Console.WriteLine("intersect: [{0}] @distance: {1}  in {2}ms"' obj.Name' distanceAlongRay' (DateTime.Now - start).TotalMilliseconds); " is 133.
Long Statement,SimpleScene,SSTexture,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSTexture.cs,loadFromBitmap,The length of the statement  "			GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (float)TextureMinFilter.LinearMipmapLinear); " is 125.
Long Statement,SimpleScene,SSTexture,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSTexture.cs,loadFromImageBuffer,The length of the statement  "			GL.TexParameter (TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (float)TextureMinFilter.LinearMipmapLinear); " is 125.
Long Statement,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The length of the statement  "			Console.WriteLine ("VertexSoup_VertexFormatBinder:generateDrawIndexBuffer : \r\n   {0} verticies' {1} indicies.  Dedup = {2}"' " is 126.
Long Statement,SimpleScene,SSObjectMesh,C:\repos\jeske_SimpleScene\SimpleScene\Objects\SSObjectMesh.cs,PreciseIntersect,The length of the statement  "                    //Console.WriteLine ("Nearest Triangle Hit @ {0} vs Sphere {1} : Object {2}"' worldSpaceContactDistance' distanceAlongRay' Name); " is 129.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,refitVolume,The length of the statement  "            if (gobjects.Count == 0) { throw new NotImplementedException(); }  // TODO: fix this... we should never get called in this case... " is 130.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                 default: throw new NotImplementedException("missing implementation for BVH Rotation SAH Computation .. " + rot.ToString());                                      " is 123.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                    case Rot.L_RL: swap = left;  left  = right.left;   left.parent = this; right.left  = swap;  swap.parent = right; right.childRefit(nAda'propagate:false); break; " is 159.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                    case Rot.L_RR: swap = left;  left  = right.right;  left.parent = this; right.right = swap;  swap.parent = right; right.childRefit(nAda'propagate:false); break; " is 159.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                    case Rot.R_LL: swap = right; right =  left.left;  right.parent = this;  left.left  = swap;  swap.parent = left;   left.childRefit(nAda'propagate:false); break; " is 159.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                    case Rot.R_LR: swap = right; right =  left.right; right.parent = this;  left.right = swap;  swap.parent = left;   left.childRefit(nAda'propagate:false); break; " is 159.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                    case Rot.LL_RR: swap = left.left; left.left = right.right; right.right = swap; left.left.parent = left; swap.parent = right; left.childRefit(nAda'propagate:false); right.childRefit(nAda'propagate:false); break; " is 210.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The length of the statement  "                    case Rot.LL_RL: swap = left.left; left.left = right.left;  right.left  = swap; left.left.parent = left; swap.parent = right; left.childRefit(nAda'propagate:false); right.childRefit(nAda'propagate:false); break; " is 210.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,splitNode,The length of the statement  "            this.left = new ssBVHNode<GO>(nAda.BVH' this' bestSplit.left' bestSplit.axis' this.depth + 1); // Split the Hierarchy to the left " is 129.
Long Statement,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,splitNode,The length of the statement  "            this.right = new ssBVHNode<GO>(nAda.BVH' this' bestSplit.right' bestSplit.axis' this.depth + 1); // Split the Hierarchy to the right                                 " is 132.
Long Statement,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The length of the statement  "                return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb(); " is 121.
Long Statement,SimpleScene.Util3d,SSFrustumCuller,C:\repos\jeske_SimpleScene\SimpleScene\Util\SSFrustumCuller.cs,isPointInsideFrustum,The length of the statement  "					// Console.WriteLine("point {0} is {1} units outside frustrum plane {2}:{3}"' pt' distance' PlaneNames[i]' FrustumPlane[i]); " is 124.
Long Statement,Bend,WhoCalls,C:\repos\jeske_SimpleScene\SimpleScene\Util\WhoCalls.cs,StackTrace,The length of the statement  "                ss = ss + method.ReflectedType + "." + method.Name + ":" + stackFrame.GetFileName() + ":" + stackFrame.GetFileLineNumber() + " ";             " is 129.
Long Statement,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawString,The length of the statement  "            //var s1 = new TypeFacePrinter (text' font.SizeInPoints' new MatterHackers.VectorMath.Vector2 (0' 0)' Justification.Left' Baseline.BoundsTop);     " is 142.
Long Statement,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawString,The length of the statement  "			var s1 = new TypeFacePrinter (text' font.SizeInPoints' new MatterHackers.VectorMath.Vector2 (0' 0)' Justification.Left' Baseline.BoundsTop);	 " is 140.
Long Statement,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The length of the statement  "				arcpath = new arc(originX'originY'radiusX'radiusY'DegreesToRadians(startAngleDeg)'DegreesToRadians(endAngleDeg)'moveToStart:true); " is 130.
Long Statement,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The length of the statement  "				path.concat_path(new arc(originX'originY'radiusX'radiusY'DegreesToRadians(startAngleDeg)'DegreesToRadians(endAngleDeg)'moveToStart:false)); " is 139.
Long Statement,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readWeight,The length of the statement  "				SSMD5Parser._parOpen' SSMD5Parser._floatRegex' SSMD5Parser._floatRegex' SSMD5Parser._floatRegex' SSMD5Parser._parClose // position " is 130.
Long Statement,SimpleScene.Demos,SSSkeletalMeshRuntime,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalMeshRuntime.cs,computeVertexNormal,The length of the statement  "				Vector3 currWeightNormalEndpointPos = Vector3.Transform(weight.baseInfo.position + weight.jointLocalNormal' joint.currentLocation.orientation); " is 143.
Long Statement,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,mouseDownHandler,The length of the statement  "                this.main3dScene.renderConfig.projectionMatrix' this.main3dScene.renderConfig.invCameraViewMatrix' clientRect' mouseLoc); " is 121.
Long Statement,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,keyUpHandler,The length of the statement  "                    main3dScene.renderConfig.drawWireframeMode = SSRenderConfig.NextWireFrameMode(main3dScene.renderConfig.drawWireframeMode); " is 122.
Long Statement,SimpleScene.Demos,SLaserBeam,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeam.cs,update,The length of the statement  "                laserXaxisWorld * driftedEndPlacement.X + laserYaxisWorld * driftedEndPlacement.Y + beamDirWorld * driftedEndPlacement.Z; " is 121.
Complex Conditional,SimpleScene,SSAABB,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSAABB.cs,IntersectsSphere,The conditional expression  "(origin.X + radius < Min.X) ||                  (origin.Y + radius < Min.Y) ||                  (origin.Z + radius < Min.Z) ||                  (origin.X - radius > Max.X) ||                  (origin.Y - radius > Max.Y) ||                  (origin.Z - radius > Max.Z)"  is complex.
Complex Conditional,SimpleScene,SSScene,C:\repos\jeske_SimpleScene\SimpleScene\SSScene.cs,renderPass,The conditional expression  "renderConfig.frustumCulling   				 && obj.localBoundingSphereRadius >= 0f  				 && obj.renderState.frustumCulling                   && fc != null   				 && !fc.isSphereInsideFrustum(obj.worldBoundingSphere)"  is complex.
Complex Conditional,SimpleScene,SSMesh_SphereICO,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMesh_SphereICO.cs,_Create,The conditional expression  "vp1.Z < 0.0f && vp2.Z < 0.0f && vp3.Z < 0.0f &&                      ((v2_left != v1_left) || (v3_left != v1_left))"  is complex.
Complex Conditional,SimpleScene,SSSimpleShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSSimpleShadowMap.cs,ComputeProjections,The conditional expression  "obj.renderState.toBeDeleted || !obj.renderState.visible                       || !obj.renderState.receivesShadows || obj.localBoundingSphereRadius <= 0f"  is complex.
Complex Conditional,SimpleScene,SSSimpleShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSSimpleShadowMap.cs,ComputeProjections,The conditional expression  "obj.renderState.toBeDeleted || !obj.renderState.visible                       || !obj.renderState.castsShadow || obj.localBoundingSphereRadius <= 0f"  is complex.
Complex Conditional,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,ComputeProjections,The conditional expression  "obj.renderState.toBeDeleted  || obj.localBoundingSphereRadius <= 0f                   || !obj.renderState.visible || !obj.renderState.receivesShadows"  is complex.
Complex Conditional,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,ComputeProjections,The conditional expression  "obj.renderState.toBeDeleted || obj.localBoundingSphereRadius <= 0f                    || !obj.renderState.visible || !obj.renderState.castsShadow"  is complex.
Virtual Method Call from Constructor,SimpleScene,SSParticleEmitter,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticleEmitters.cs,SSParticleEmitter,The constructor "SSParticleEmitter" calls a virtual method "reset".
Virtual Method Call from Constructor,SimpleScene,SSInstancedMeshRenderer,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSInstancedMeshRenderer.cs,SSInstancedMeshRenderer,The constructor "SSInstancedMeshRenderer" calls a virtual method "_initAttributeBuffers".
Virtual Method Call from Constructor,SimpleScene,SSInstancedMeshRenderer,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSInstancedMeshRenderer.cs,SSInstancedMeshRenderer,The constructor "SSInstancedMeshRenderer" calls a virtual method "update".
Virtual Method Call from Constructor,SimpleScene,SSParticleSystemData,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSParticleSystemData.cs,SSParticleSystemData,The constructor "SSParticleSystemData" calls a virtual method "reset".
Virtual Method Call from Constructor,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,STrailsData,The constructor "STrailsData" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,STrailsData,The constructor "STrailsData" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,STrailsData,The constructor "STrailsData" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,STrailsData,The constructor "STrailsData" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,STrailsData,The constructor "STrailsData" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,SLaserBeamMiddleObject,The constructor "SLaserBeamMiddleObject" calls a virtual method "Update".
Virtual Method Call from Constructor,SimpleScene.Demos,SLaserBurnParticleSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBurnParticlesObject.cs,SLaserBurnParticleSystem,The constructor "SLaserBurnParticleSystem" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene.Demos,SLaserBurnParticleSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBurnParticlesObject.cs,SLaserBurnParticleSystem,The constructor "SLaserBurnParticleSystem" calls a virtual method "addEffector".
Virtual Method Call from Constructor,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,TestBenchBootstrap,The constructor "TestBenchBootstrap" calls a virtual method "setupInput".
Virtual Method Call from Constructor,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,TestBenchBootstrap,The constructor "TestBenchBootstrap" calls a virtual method "setupScene".
Virtual Method Call from Constructor,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,TestBenchBootstrap,The constructor "TestBenchBootstrap" calls a virtual method "setupCamera".
Virtual Method Call from Constructor,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,TestBenchBootstrap,The constructor "TestBenchBootstrap" calls a virtual method "setupEnvironment".
Virtual Method Call from Constructor,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,TestBenchBootstrap,The constructor "TestBenchBootstrap" calls a virtual method "setupHUD".
Virtual Method Call from Constructor,SimpleScene.Demos,SSpaceMissileData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilelData.cs,SSpaceMissileData,The constructor "SSpaceMissileData" calls a virtual method "updateExecution".
Virtual Method Call from Constructor,SimpleScene.Demos,SSpaceMissileClusterVisualData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilesVisualSimulation.cs,SSpaceMissileClusterVisualData,The constructor "SSpaceMissileClusterVisualData" calls a virtual method "createMissile".
Virtual Method Call from Constructor,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,SExplosionSystem,The constructor "SExplosionSystem" calls a virtual method "addEffector".
Empty Catch Block,SimpleScene,SSTextureMaterial,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSTextureMaterial.cs,FromMaterialString,The method has an empty catch block.
Magic Number,SimpleScene,SSObjectBase,C:\repos\jeske_SimpleScene\SimpleScene\SSObject.cs,calcScaleMax,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  				scaleMax = Math.Max (scaleMax' _scale [i]);  			}
Magic Number,SimpleScene,SSCamera,C:\repos\jeske_SimpleScene\SimpleScene\Cameras\SSCamera.cs,mouseDeltaOrient,The following statement contains a magic number: const float twoPi = (float)(2.0 * Math.PI);
Magic Number,SimpleScene,SSTexture,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSTexture.cs,loadFromBitmap,The following statement contains a magic number: GL.PixelStore (PixelStoreParameter.UnpackAlignment' 4);
Magic Number,SimpleScene,SSTexture,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSTexture.cs,loadFromImageBuffer,The following statement contains a magic number: GL.PixelStore (PixelStoreParameter.UnpackAlignment' 4);
Magic Number,SimpleScene,SSMesh_wfOBJ,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\SSMesh_wfOBJ.cs,_renderSendLines,The following statement contains a magic number: for(int i=0; i<indices.Length; i+=3) {                  var v1 = subset.wireframeMesh.lastAssignedVertices [indices[i]];                  var v2 = subset.wireframeMesh.lastAssignedVertices [indices[i+1]];                  var v3 = subset.wireframeMesh.lastAssignedVertices [indices[i+2]];    				// draw the vertex..  				//GL.Color3(System.Drawing.Color.FromArgb(v1.DiffuseColor));    				GL.Begin(PrimitiveType.LineLoop);  				GL.Vertex3 (v1.Position);  				GL.Vertex3 (v2.Position);  				GL.Vertex3 (v3.Position);  				GL.End();  			}
Magic Number,SimpleScene,SSMesh_wfOBJ,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\SSMesh_wfOBJ.cs,_renderSendLines,The following statement contains a magic number: for(int i=0; i<indices.Length; i+=3) {                  var v1 = subset.wireframeMesh.lastAssignedVertices [indices[i]];                  var v2 = subset.wireframeMesh.lastAssignedVertices [indices[i+1]];                  var v3 = subset.wireframeMesh.lastAssignedVertices [indices[i+2]];    				// draw the vertex..  				//GL.Color3(System.Drawing.Color.FromArgb(v1.DiffuseColor));    				GL.Begin(PrimitiveType.LineLoop);  				GL.Vertex3 (v1.Position);  				GL.Vertex3 (v2.Position);  				GL.Vertex3 (v3.Position);  				GL.End();  			}
Magic Number,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The following statement contains a magic number: foreach (var face in m.faces) {    				// iterate over the vericies of a wave-front FACE...    				// DEREFERENCE each .obj vertex paramater (position' normal' texture coordinate)  				SSVertex_PosNormTex[] vertex_list = new SSVertex_PosNormTex[face.v_idx.Length];                      				for (int facevertex = 0; facevertex < face.v_idx.Length; facevertex++) {         					// position  					vertex_list[facevertex].Position = wff.positions[face.v_idx[facevertex]].Xyz;    					// normal  					int normal_idx = face.n_idx[facevertex];  					if (normal_idx != -1) {  						vertex_list[facevertex].Normal = wff.normals[normal_idx];   					}    					// texture coordinate  					int tex_index = face.tex_idx[facevertex];  					if (tex_index != -1 ) {  						vertex_list[facevertex].Tu = wff.texCoords[tex_index].X;   						vertex_list[facevertex].Tv = 1- wff.texCoords[tex_index].Y;  					}  				}    				// turn them into indicies in the vertex soup..  				//   .. we hand the soup a set of fully configured verticies. It  				//   .. dedups and accumulates them' and hands us back indicies  				//   .. relative to it's growing list of deduped verticies.   				UInt16[] soup_indicies = soup.digestVerticies(vertex_list);    				// now we add these indicies to the draw-list. Right now we assume  				// draw is using GL_TRIANGLE' so we convert NGONS into triange lists  				if (soup_indicies.Length == 3) { // triangle  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);  				} else if (soup_indicies.Length == 4) { // quad  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);    					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[2]);  					draw_indicies.Add(soup_indicies[3]);  				} else {  					// This n-gon algorithm only works if the n-gon is coplanar and convex'  					// which Wavefront OBJ says they must be.   					//  .. to tesselate concave ngons' one must tesselate using a more complex method' see  					//    http://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method  						  					// manually generate a triangle-fan  					for (int x = 1; x < (soup_indicies.Length-1); x++) {  						draw_indicies.Add(soup_indicies[0]);  						draw_indicies.Add(soup_indicies[x]);  						draw_indicies.Add(soup_indicies[x+1]);  					}  					// throw new NotImplementedException("unhandled face size: " + newindicies.Length);                      				}  			}
Magic Number,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The following statement contains a magic number: foreach (var face in m.faces) {    				// iterate over the vericies of a wave-front FACE...    				// DEREFERENCE each .obj vertex paramater (position' normal' texture coordinate)  				SSVertex_PosNormTex[] vertex_list = new SSVertex_PosNormTex[face.v_idx.Length];                      				for (int facevertex = 0; facevertex < face.v_idx.Length; facevertex++) {         					// position  					vertex_list[facevertex].Position = wff.positions[face.v_idx[facevertex]].Xyz;    					// normal  					int normal_idx = face.n_idx[facevertex];  					if (normal_idx != -1) {  						vertex_list[facevertex].Normal = wff.normals[normal_idx];   					}    					// texture coordinate  					int tex_index = face.tex_idx[facevertex];  					if (tex_index != -1 ) {  						vertex_list[facevertex].Tu = wff.texCoords[tex_index].X;   						vertex_list[facevertex].Tv = 1- wff.texCoords[tex_index].Y;  					}  				}    				// turn them into indicies in the vertex soup..  				//   .. we hand the soup a set of fully configured verticies. It  				//   .. dedups and accumulates them' and hands us back indicies  				//   .. relative to it's growing list of deduped verticies.   				UInt16[] soup_indicies = soup.digestVerticies(vertex_list);    				// now we add these indicies to the draw-list. Right now we assume  				// draw is using GL_TRIANGLE' so we convert NGONS into triange lists  				if (soup_indicies.Length == 3) { // triangle  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);  				} else if (soup_indicies.Length == 4) { // quad  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);    					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[2]);  					draw_indicies.Add(soup_indicies[3]);  				} else {  					// This n-gon algorithm only works if the n-gon is coplanar and convex'  					// which Wavefront OBJ says they must be.   					//  .. to tesselate concave ngons' one must tesselate using a more complex method' see  					//    http://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method  						  					// manually generate a triangle-fan  					for (int x = 1; x < (soup_indicies.Length-1); x++) {  						draw_indicies.Add(soup_indicies[0]);  						draw_indicies.Add(soup_indicies[x]);  						draw_indicies.Add(soup_indicies[x+1]);  					}  					// throw new NotImplementedException("unhandled face size: " + newindicies.Length);                      				}  			}
Magic Number,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The following statement contains a magic number: foreach (var face in m.faces) {    				// iterate over the vericies of a wave-front FACE...    				// DEREFERENCE each .obj vertex paramater (position' normal' texture coordinate)  				SSVertex_PosNormTex[] vertex_list = new SSVertex_PosNormTex[face.v_idx.Length];                      				for (int facevertex = 0; facevertex < face.v_idx.Length; facevertex++) {         					// position  					vertex_list[facevertex].Position = wff.positions[face.v_idx[facevertex]].Xyz;    					// normal  					int normal_idx = face.n_idx[facevertex];  					if (normal_idx != -1) {  						vertex_list[facevertex].Normal = wff.normals[normal_idx];   					}    					// texture coordinate  					int tex_index = face.tex_idx[facevertex];  					if (tex_index != -1 ) {  						vertex_list[facevertex].Tu = wff.texCoords[tex_index].X;   						vertex_list[facevertex].Tv = 1- wff.texCoords[tex_index].Y;  					}  				}    				// turn them into indicies in the vertex soup..  				//   .. we hand the soup a set of fully configured verticies. It  				//   .. dedups and accumulates them' and hands us back indicies  				//   .. relative to it's growing list of deduped verticies.   				UInt16[] soup_indicies = soup.digestVerticies(vertex_list);    				// now we add these indicies to the draw-list. Right now we assume  				// draw is using GL_TRIANGLE' so we convert NGONS into triange lists  				if (soup_indicies.Length == 3) { // triangle  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);  				} else if (soup_indicies.Length == 4) { // quad  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);    					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[2]);  					draw_indicies.Add(soup_indicies[3]);  				} else {  					// This n-gon algorithm only works if the n-gon is coplanar and convex'  					// which Wavefront OBJ says they must be.   					//  .. to tesselate concave ngons' one must tesselate using a more complex method' see  					//    http://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method  						  					// manually generate a triangle-fan  					for (int x = 1; x < (soup_indicies.Length-1); x++) {  						draw_indicies.Add(soup_indicies[0]);  						draw_indicies.Add(soup_indicies[x]);  						draw_indicies.Add(soup_indicies[x+1]);  					}  					// throw new NotImplementedException("unhandled face size: " + newindicies.Length);                      				}  			}
Magic Number,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The following statement contains a magic number: foreach (var face in m.faces) {    				// iterate over the vericies of a wave-front FACE...    				// DEREFERENCE each .obj vertex paramater (position' normal' texture coordinate)  				SSVertex_PosNormTex[] vertex_list = new SSVertex_PosNormTex[face.v_idx.Length];                      				for (int facevertex = 0; facevertex < face.v_idx.Length; facevertex++) {         					// position  					vertex_list[facevertex].Position = wff.positions[face.v_idx[facevertex]].Xyz;    					// normal  					int normal_idx = face.n_idx[facevertex];  					if (normal_idx != -1) {  						vertex_list[facevertex].Normal = wff.normals[normal_idx];   					}    					// texture coordinate  					int tex_index = face.tex_idx[facevertex];  					if (tex_index != -1 ) {  						vertex_list[facevertex].Tu = wff.texCoords[tex_index].X;   						vertex_list[facevertex].Tv = 1- wff.texCoords[tex_index].Y;  					}  				}    				// turn them into indicies in the vertex soup..  				//   .. we hand the soup a set of fully configured verticies. It  				//   .. dedups and accumulates them' and hands us back indicies  				//   .. relative to it's growing list of deduped verticies.   				UInt16[] soup_indicies = soup.digestVerticies(vertex_list);    				// now we add these indicies to the draw-list. Right now we assume  				// draw is using GL_TRIANGLE' so we convert NGONS into triange lists  				if (soup_indicies.Length == 3) { // triangle  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);  				} else if (soup_indicies.Length == 4) { // quad  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);    					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[2]);  					draw_indicies.Add(soup_indicies[3]);  				} else {  					// This n-gon algorithm only works if the n-gon is coplanar and convex'  					// which Wavefront OBJ says they must be.   					//  .. to tesselate concave ngons' one must tesselate using a more complex method' see  					//    http://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method  						  					// manually generate a triangle-fan  					for (int x = 1; x < (soup_indicies.Length-1); x++) {  						draw_indicies.Add(soup_indicies[0]);  						draw_indicies.Add(soup_indicies[x]);  						draw_indicies.Add(soup_indicies[x+1]);  					}  					// throw new NotImplementedException("unhandled face size: " + newindicies.Length);                      				}  			}
Magic Number,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The following statement contains a magic number: foreach (var face in m.faces) {    				// iterate over the vericies of a wave-front FACE...    				// DEREFERENCE each .obj vertex paramater (position' normal' texture coordinate)  				SSVertex_PosNormTex[] vertex_list = new SSVertex_PosNormTex[face.v_idx.Length];                      				for (int facevertex = 0; facevertex < face.v_idx.Length; facevertex++) {         					// position  					vertex_list[facevertex].Position = wff.positions[face.v_idx[facevertex]].Xyz;    					// normal  					int normal_idx = face.n_idx[facevertex];  					if (normal_idx != -1) {  						vertex_list[facevertex].Normal = wff.normals[normal_idx];   					}    					// texture coordinate  					int tex_index = face.tex_idx[facevertex];  					if (tex_index != -1 ) {  						vertex_list[facevertex].Tu = wff.texCoords[tex_index].X;   						vertex_list[facevertex].Tv = 1- wff.texCoords[tex_index].Y;  					}  				}    				// turn them into indicies in the vertex soup..  				//   .. we hand the soup a set of fully configured verticies. It  				//   .. dedups and accumulates them' and hands us back indicies  				//   .. relative to it's growing list of deduped verticies.   				UInt16[] soup_indicies = soup.digestVerticies(vertex_list);    				// now we add these indicies to the draw-list. Right now we assume  				// draw is using GL_TRIANGLE' so we convert NGONS into triange lists  				if (soup_indicies.Length == 3) { // triangle  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);  				} else if (soup_indicies.Length == 4) { // quad  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);    					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[2]);  					draw_indicies.Add(soup_indicies[3]);  				} else {  					// This n-gon algorithm only works if the n-gon is coplanar and convex'  					// which Wavefront OBJ says they must be.   					//  .. to tesselate concave ngons' one must tesselate using a more complex method' see  					//    http://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method  						  					// manually generate a triangle-fan  					for (int x = 1; x < (soup_indicies.Length-1); x++) {  						draw_indicies.Add(soup_indicies[0]);  						draw_indicies.Add(soup_indicies[x]);  						draw_indicies.Add(soup_indicies[x+1]);  					}  					// throw new NotImplementedException("unhandled face size: " + newindicies.Length);                      				}  			}
Magic Number,SimpleScene,VertexSoup_VertexFormatBinder,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\wfOBJ\VertexSoup_VertexFormatBinder.cs,generateDrawIndexBuffer,The following statement contains a magic number: foreach (var face in m.faces) {    				// iterate over the vericies of a wave-front FACE...    				// DEREFERENCE each .obj vertex paramater (position' normal' texture coordinate)  				SSVertex_PosNormTex[] vertex_list = new SSVertex_PosNormTex[face.v_idx.Length];                      				for (int facevertex = 0; facevertex < face.v_idx.Length; facevertex++) {         					// position  					vertex_list[facevertex].Position = wff.positions[face.v_idx[facevertex]].Xyz;    					// normal  					int normal_idx = face.n_idx[facevertex];  					if (normal_idx != -1) {  						vertex_list[facevertex].Normal = wff.normals[normal_idx];   					}    					// texture coordinate  					int tex_index = face.tex_idx[facevertex];  					if (tex_index != -1 ) {  						vertex_list[facevertex].Tu = wff.texCoords[tex_index].X;   						vertex_list[facevertex].Tv = 1- wff.texCoords[tex_index].Y;  					}  				}    				// turn them into indicies in the vertex soup..  				//   .. we hand the soup a set of fully configured verticies. It  				//   .. dedups and accumulates them' and hands us back indicies  				//   .. relative to it's growing list of deduped verticies.   				UInt16[] soup_indicies = soup.digestVerticies(vertex_list);    				// now we add these indicies to the draw-list. Right now we assume  				// draw is using GL_TRIANGLE' so we convert NGONS into triange lists  				if (soup_indicies.Length == 3) { // triangle  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);  				} else if (soup_indicies.Length == 4) { // quad  					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[1]);  					draw_indicies.Add(soup_indicies[2]);    					draw_indicies.Add(soup_indicies[0]);  					draw_indicies.Add(soup_indicies[2]);  					draw_indicies.Add(soup_indicies[3]);  				} else {  					// This n-gon algorithm only works if the n-gon is coplanar and convex'  					// which Wavefront OBJ says they must be.   					//  .. to tesselate concave ngons' one must tesselate using a more complex method' see  					//    http://en.wikipedia.org/wiki/Polygon_triangulation#Ear_clipping_method  						  					// manually generate a triangle-fan  					for (int x = 1; x < (soup_indicies.Length-1); x++) {  						draw_indicies.Add(soup_indicies[0]);  						draw_indicies.Add(soup_indicies[x]);  						draw_indicies.Add(soup_indicies[x+1]);  					}  					// throw new NotImplementedException("unhandled face size: " + newindicies.Length);                      				}  			}
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,generateLineIndicies,The following statement contains a magic number: int line_count = indicies.Length / 3;
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,generateLineIndicies,The following statement contains a magic number: UInt16[] line_indicies = new UInt16[line_count * 6];
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,generateLineIndicies,The following statement contains a magic number: for (int i = 2; i < indicies.Length; i += 3) {  				var v1i = indicies [i - 2];   				var v2i = indicies [i - 1];  				var v3i = indicies [i];    				line_indicies [v++] = v1i;  				line_indicies [v++] = v2i;  				line_indicies [v++] = v1i;  				line_indicies [v++] = v3i;  				line_indicies [v++] = v2i;  				line_indicies [v++] = v3i;  			}
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,generateLineIndicies,The following statement contains a magic number: for (int i = 2; i < indicies.Length; i += 3) {  				var v1i = indicies [i - 2];   				var v2i = indicies [i - 1];  				var v3i = indicies [i];    				line_indicies [v++] = v1i;  				line_indicies [v++] = v2i;  				line_indicies [v++] = v1i;  				line_indicies [v++] = v3i;  				line_indicies [v++] = v2i;  				line_indicies [v++] = v3i;  			}
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,generateLineIndicies,The following statement contains a magic number: for (int i = 2; i < indicies.Length; i += 3) {  				var v1i = indicies [i - 2];   				var v2i = indicies [i - 1];  				var v3i = indicies [i];    				line_indicies [v++] = v1i;  				line_indicies [v++] = v2i;  				line_indicies [v++] = v1i;  				line_indicies [v++] = v3i;  				line_indicies [v++] = v2i;  				line_indicies [v++] = v3i;  			}
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,RadialDistanceTo,The following statement contains a magic number: return (float)Math.Acos(2.0 * Math.Pow(inner_product'2.0) - 1);
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,RadialDistanceTo,The following statement contains a magic number: return (float)Math.Acos(2.0 * Math.Pow(inner_product'2.0) - 1);
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,intersectRayAABox2,The following statement contains a magic number: for (int i = 0; i < 3; i++){ //we test slabs in every direction                  if (ray.dir[i] == 0){ // ray parallel to planes in this direction                      if ((ray.pos[i] < box.Min[i]) || (ray.pos[i] > box.Max[i])) {                          return false; // parallel AND outside box : no intersection possible                      }                  } else { // ray not parallel to planes in this direction                      T_1[i] = (box.Min[i] - ray.pos[i]) / ray.dir[i];                      T_2[i] = (box.Max[i] - ray.pos[i]) / ray.dir[i];                        if(T_1[i] > T_2[i]){ // we want T_1 to hold values for intersection with near plane                          var swp = T_2; // swap                          T_1 = swp; T_2 = T_1;                         }                      if (T_1[i] > t_near){                          t_near = T_1[i];                      }                      if (T_2[i] < t_far){                          t_far = T_2[i];                      }                      if( (t_near > t_far) || (t_far < 0) ){                          return false;                      }                  }              }
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,randomDirection,The following statement contains a magic number: double theta = 2.0 * Math.PI * s_debugRandom.NextDouble();
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,randomDirection,The following statement contains a magic number: double phi = Math.PI * s_debugRandom.NextDouble() - Math.PI/2.0;
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,GetClientRect,The following statement contains a magic number: int[] viewport = new int[4];
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,GetClientRect,The following statement contains a magic number: return new Rectangle (viewport [0]' viewport [1]' viewport [2]' viewport [3]);
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,GetClientRect,The following statement contains a magic number: return new Rectangle (viewport [0]' viewport [1]' viewport [2]' viewport [3]);
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,areFramebuffersSupported,The following statement contains a magic number: int minor = version_string [2] - '0';
Magic Number,SimpleScene,OpenTKHelper,C:\repos\jeske_SimpleScene\SimpleScene\Util\OpenTKHelper.cs,areFramebuffersSupported,The following statement contains a magic number: if (version < new Version(3' 0)) {  				var str = GL.GetString(StringName.Extensions).ToLower();  				if (!str.Contains ("framebuffer_object")) {  					Console.WriteLine ("framebuffers not supported by the GL version ");  					return false;  				}  			}
Magic Number,SimpleScene,FPSCalculator,C:\repos\jeske_SimpleScene\SimpleScene\Util\FPSCalculator.cs,newFrame,The following statement contains a magic number: if (FPS_time > 2.0) {  				_framesPerSecond = (double)FPS_frames / FPS_time;  				FPS_frames = 0;  				FPS_time = 0.0;  			}
Magic Number,SimpleScene,SSShader,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSShader.cs,PrintPrettyShaderInfoLog,The following statement contains a magic number: foreach (var line in log_lines) {  				// print log line  				Console.WriteLine(line);    				// try to print the source-line  				var match = regex.Match(line);  				if (!match.Success) {  					match = regex2.Match (line);  				}  				if (match.Success) {  					int lineno = int.Parse(match.Groups[2].Value);  					Console.WriteLine("   > " + programLines[lineno-1]);	  				}  			}
Magic Number,SimpleScene,SSObject2DSurface_AGG,C:\repos\jeske_SimpleScene\SimpleScene\Objects\SSObject2DSurface_AGG.cs,makeValidTextureSize,The following statement contains a magic number: if (false) {                  // if it requires power of two texture sizes                  return new Size(                      nextPowerOf2(Math.Max(w' 64))'                      nextPowerOf2(Math.Max(h' 64)));              } else {                  return new Size(w' h);              }
Magic Number,SimpleScene,SSObject2DSurface_AGG,C:\repos\jeske_SimpleScene\SimpleScene\Objects\SSObject2DSurface_AGG.cs,makeValidTextureSize,The following statement contains a magic number: if (false) {                  // if it requires power of two texture sizes                  return new Size(                      nextPowerOf2(Math.Max(w' 64))'                      nextPowerOf2(Math.Max(h' 64)));              } else {                  return new Size(w' h);              }
Magic Number,SimpleScene,SSMesh_SphereICO,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMesh_SphereICO.cs,_computeEquirectangularUVForSpherePoint,The following statement contains a magic number: u = (float) (( longitude / (2.0 * Math.PI) ) + 0.5);
Magic Number,SimpleScene,SSMesh_SphereICO,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMesh_SphereICO.cs,_computeEquirectangularUVForSpherePoint,The following statement contains a magic number: u = (float) (( longitude / (2.0 * Math.PI) ) + 0.5);
Magic Number,SimpleScene,SSMainShaderProgram,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSMainShaderProgram.cs,SSMainShaderProgram,The following statement contains a magic number: if (GL.GetString(StringName.Extensions).ToLower().Contains("gl_ext_gpu_shader4")) {                  try {                      m_programID = GL.CreateProgram();                        m_vertexShader = SSAssetManager.GetInstance<SSVertexShader>(                          Path.Combine(c_basePath' "ss4_vertex.glsl"));  				    m_vertexShader.Prepend (preprocessorDefs);                      m_vertexShader.LoadShader();                      attach(m_vertexShader);                        m_fragmentShader = SSAssetManager.GetInstance<SSFragmentShader>(                          Path.Combine(c_basePath' "ss4_fragment.glsl"));  				    m_fragmentShader.Prepend (preprocessorDefs);                      m_fragmentShader.LoadShader();                      attach(m_fragmentShader);                        m_geometryShader = SSAssetManager.GetInstance<SSGeometryShader>(                          Path.Combine(c_basePath' "ss4_geometry.glsl"));                      GL.Ext.ProgramParameter (m_programID' ExtGeometryShader4.GeometryInputTypeExt' (int)All.Triangles);                      GL.Ext.ProgramParameter (m_programID' ExtGeometryShader4.GeometryOutputTypeExt' (int)All.TriangleStrip);                      GL.Ext.ProgramParameter (m_programID' ExtGeometryShader4.GeometryVerticesOutExt' 3);  				    m_geometryShader.Prepend (preprocessorDefs);                      m_geometryShader.LoadShader();                      attach(m_geometryShader);                      load_fallback_shader = false;                      Console.WriteLine(" ---- SS4 shader loaded ---- ");                  } catch (SSShaderLoadException e) {                      Console.WriteLine(" ---- SS4 shader load failed... fallback to SS1 ");                      load_fallback_shader = true;                  }              }
Magic Number,SimpleScene,SSMainShaderProgram,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSMainShaderProgram.cs,SSMainShaderProgram,The following statement contains a magic number: UniNumPoissonSamples = 8;
Magic Number,SimpleScene,SSMainShaderProgram,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSMainShaderProgram.cs,SSMainShaderProgram,The following statement contains a magic number: GL.Uniform1(GLun_ambiTex' 2);
Magic Number,SimpleScene,SSMainShaderProgram,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSMainShaderProgram.cs,SSMainShaderProgram,The following statement contains a magic number: GL.Uniform1(GLun_bumpTex' 3);
Magic Number,SimpleScene,SSObjectHUDQuad,C:\repos\jeske_SimpleScene\SimpleScene\Objects\SSObjectHUDQuad.cs,Render,The following statement contains a magic number: float w=500;
Magic Number,SimpleScene,SSObjectHUDQuad,C:\repos\jeske_SimpleScene\SimpleScene\Objects\SSObjectHUDQuad.cs,Render,The following statement contains a magic number: float h=500;
Magic Number,SimpleScene,SSMeshDisk,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMeshDisk.cs,SSMeshDisk,The following statement contains a magic number: UInt16[] indices = new UInt16[divisions * 3];
Magic Number,SimpleScene,SSMeshDisk,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMeshDisk.cs,SSMeshDisk,The following statement contains a magic number: for (int i = 0; i < divisions; ++i) {                  int baseIdx = i * 3;                  indices [baseIdx] = 0;                  indices [baseIdx + 1] = (UInt16)(i + 1);                  indices [baseIdx + 2] = (UInt16)(i + 2);              }
Magic Number,SimpleScene,SSMeshDisk,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMeshDisk.cs,SSMeshDisk,The following statement contains a magic number: for (int i = 0; i < divisions; ++i) {                  int baseIdx = i * 3;                  indices [baseIdx] = 0;                  indices [baseIdx + 1] = (UInt16)(i + 1);                  indices [baseIdx + 2] = (UInt16)(i + 2);              }
Magic Number,SimpleScene,SSMeshDisk,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMeshDisk.cs,SSMeshDisk,The following statement contains a magic number: for (int i = 0; i < divisions; ++i) {                  int baseIdx = i * 3;                  indices [baseIdx] = 0;                  indices [baseIdx + 1] = (UInt16)(i + 1);                  indices [baseIdx + 2] = (UInt16)(i + 2);              }
Magic Number,SimpleScene,SSParallelSplitShadowMap,C:\repos\jeske_SimpleScene\SimpleScene\Lights\SSParallelSplitShadowMap.cs,ComputeProjections,The following statement contains a magic number: for (int i = 0; i < c_numberOfSplits; ++i) {                  // Obtain view + projection + crop matrix' need it later                  Matrix4 shadowView' shadowProj;                  viewProjFromLightAlignedBB(ref m_resultLightBB [i]' ref lightTransform' ref lightY'                                             out shadowView' out shadowProj);                  m_shadowViewProjMatrices[i] = shadowView * shadowProj * c_cropMatrices[i];                  // obtain view + projection + clio + bias                  m_shadowViewProjBiasMatrices[i] = m_shadowViewProjMatrices[i] * c_biasMatrix;                    // There is' currently' no mathematically derived solution to how much Poisson spread scaling                  // you need for each split. Current improvisation combines 1) increasing spread for the near                   // splits; reducing spread for the far splits and 2) reducing spread for splits with larger                   // light-aligned areas; increasing spread for splits with smaller light-aligned areas                  m_poissonScaling [i] = m_resultLightBB [i].Diff().Xy / (100f * (float)Math.Pow(3.0' i - 1));              }
Magic Number,SimpleScene,SSPssmShaderProgram,C:\repos\jeske_SimpleScene\SimpleScene\Core\SSPssmShaderProgram.cs,SSPssmShaderProgram,The following statement contains a magic number: GL.Ext.ProgramParameter (m_programID' ExtGeometryShader4.GeometryVerticesOutExt' 3 * SSParallelSplitShadowMap.c_numberOfSplits);
Magic Number,SimpleScene,SSAttributeVec3,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\AttributeFormats.cs,ComponentNum,The following statement contains a magic number: return 3;
Magic Number,SimpleScene,SSAttributeVec2,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\AttributeFormats.cs,ComponentNum,The following statement contains a magic number: return 2;
Magic Number,SimpleScene,SSAttributeColor,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\AttributeFormats.cs,ComponentNum,The following statement contains a magic number: return 4;
Magic Number,SimpleScene,SSVertexFormatHelper,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,PreparePosition,The following statement contains a magic number: GL.VertexPointer (3' VertexPointerType.Float' stride' offset);
Magic Number,SimpleScene,SSVertexFormatHelper,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,PrepareColor,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' stride' offset);
Magic Number,SimpleScene,SSVertexFormatHelper,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,PrepareNormal,The following statement contains a magic number: if (isp == null) { // no instancing  				// this is the "transitional" GLSL 120 way of assigning buffer contents  				// http://www.opentk.com/node/80?page=1  				GL.EnableClientState (ArrayCap.NormalArray);  				GL.NormalPointer (NormalPointerType.Float' stride' offset);  			} else { // instancing  				preparePerVertexAttribute (stride' offset' isp.AttrNormal' 3);  			}
Magic Number,SimpleScene,SSVertexFormatHelper,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,PrepareTexCoord,The following statement contains a magic number: if (isp == null) { // no instancing  				// this is the "transitional" GLSL 120 way of assigning buffer contents  				// http://www.opentk.com/node/80?page=1  				GL.EnableClientState (ArrayCap.TextureCoordArray);  				GL.TexCoordPointer (2' TexCoordPointerType.Float' stride' offset);  			} else { // instancing  				preparePerVertexAttribute (stride' offset' isp.AttrTexCoord' 2);  			}
Magic Number,SimpleScene,SSVertexFormatHelper,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,PrepareTexCoord,The following statement contains a magic number: if (isp == null) { // no instancing  				// this is the "transitional" GLSL 120 way of assigning buffer contents  				// http://www.opentk.com/node/80?page=1  				GL.EnableClientState (ArrayCap.TextureCoordArray);  				GL.TexCoordPointer (2' TexCoordPointerType.Float' stride' offset);  			} else { // instancing  				preparePerVertexAttribute (stride' offset' isp.AttrTexCoord' 2);  			}
Magic Number,SimpleScene,SSVertex_Pos,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Buffers\VertexFormats.cs,SSVertex_Pos,The following statement contains a magic number: Size = 12;
Magic Number,SimpleScene,SSIndexedMesh<V>,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,preciseIntersect,The following statement contains a magic number: if (useBVHForIntersections) {                  if (_bvh == null && _vbo != null && _ibo != null) {                      // rebuilding BVH                      // TODO try updating instead of rebuilding?                      _bvh = new SSIndexedMeshTrianglesBVH (_vbo' _ibo);                      for (UInt16 triIdx = 0; triIdx < _ibo.numIndices / 3; ++triIdx) {                          _bvh.addObject(triIdx);                      }                      Console.WriteLine("New BVH MaxDepth = {0}"'_bvh.maxDepth);                  }                    if (_bvh != null) {                      List<ssBVHNode<UInt16>> nodesHit = _bvh.traverseRay(localRay);                      foreach (var node in nodesHit) {                          if (!node.IsLeaf) continue;                            foreach (UInt16 triIdx in node.gobjects) {                              Vector3 v0' v1' v2;                              _readTriangleVertices(triIdx' out v0' out v1' out v2);                                float contact;                              if (OpenTKHelper.TriangleRayIntersectionTest(                                      ref v0' ref v1' ref v2' ref localRay.pos' ref localRay.dir' out contact)) {                                  if (contact < nearestLocalRayContact) {                                      nearestLocalRayContact = contact;                                  }                              }                          }                      }                  }              } else {                  _bvh = null;                  // slow' tedious intersection test                  int numTri = lastAssignedIndices.Length / 3;                  for (UInt16 triIdx = 0; triIdx < numTri; ++triIdx) {                      Vector3 v0' v1' v2;                      _readTriangleVertices(triIdx' out v0' out v1' out v2);                      float contact;                      if (OpenTKHelper.TriangleRayIntersectionTest(                          ref v0' ref v1' ref v2' ref localRay.pos' ref localRay.dir' out contact))                      {                          if (contact < nearestLocalRayContact) {                              nearestLocalRayContact = contact;                          }                      }                  }              }
Magic Number,SimpleScene,SSIndexedMesh<V>,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,preciseIntersect,The following statement contains a magic number: if (useBVHForIntersections) {                  if (_bvh == null && _vbo != null && _ibo != null) {                      // rebuilding BVH                      // TODO try updating instead of rebuilding?                      _bvh = new SSIndexedMeshTrianglesBVH (_vbo' _ibo);                      for (UInt16 triIdx = 0; triIdx < _ibo.numIndices / 3; ++triIdx) {                          _bvh.addObject(triIdx);                      }                      Console.WriteLine("New BVH MaxDepth = {0}"'_bvh.maxDepth);                  }                    if (_bvh != null) {                      List<ssBVHNode<UInt16>> nodesHit = _bvh.traverseRay(localRay);                      foreach (var node in nodesHit) {                          if (!node.IsLeaf) continue;                            foreach (UInt16 triIdx in node.gobjects) {                              Vector3 v0' v1' v2;                              _readTriangleVertices(triIdx' out v0' out v1' out v2);                                float contact;                              if (OpenTKHelper.TriangleRayIntersectionTest(                                      ref v0' ref v1' ref v2' ref localRay.pos' ref localRay.dir' out contact)) {                                  if (contact < nearestLocalRayContact) {                                      nearestLocalRayContact = contact;                                  }                              }                          }                      }                  }              } else {                  _bvh = null;                  // slow' tedious intersection test                  int numTri = lastAssignedIndices.Length / 3;                  for (UInt16 triIdx = 0; triIdx < numTri; ++triIdx) {                      Vector3 v0' v1' v2;                      _readTriangleVertices(triIdx' out v0' out v1' out v2);                      float contact;                      if (OpenTKHelper.TriangleRayIntersectionTest(                          ref v0' ref v1' ref v2' ref localRay.pos' ref localRay.dir' out contact))                      {                          if (contact < nearestLocalRayContact) {                              nearestLocalRayContact = contact;                          }                      }                  }              }
Magic Number,SimpleScene,SSIndexedMesh<V>,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,_readTriangleVertices,The following statement contains a magic number: UInt16 baseOffset = (UInt16)(3 * triIdx);
Magic Number,SimpleScene,SSIndexedMesh<V>,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,_readTriangleVertices,The following statement contains a magic number: UInt16 i2 = _ibo.lastAssignedIndices [baseOffset + 2];
Magic Number,SimpleScene,SSIndexedMeshTriangleBVHNodeAdaptor,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,_readTriangleVertices,The following statement contains a magic number: int baseOffset = triIdx * 3;
Magic Number,SimpleScene,SSIndexedMeshTriangleBVHNodeAdaptor,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\SSIndexedMesh.cs,_readTriangleVertices,The following statement contains a magic number: int i2 = _ibo.lastAssignedIndices[baseOffset+2];
Magic Number,SimpleScene,SSTexturedCube,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSTexturedCube.cs,SSTexturedCube,The following statement contains a magic number: SSVertex_PosTex[] vertices = new SSVertex_PosTex[verticesPerQuad * 6];
Magic Number,SimpleScene,SSTexturedCube,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSTexturedCube.cs,SSTexturedCube,The following statement contains a magic number: for (int f = 0; f < 6; ++f) {                  for (int v = 0; v < verticesPerQuad; ++v) {                      SSVertex_PosTex vertex = c_vertices [v];                      vertex.Position = Vector3.Transform(vertex.Position' c_faceTransforms [f]);                      vertices [f * verticesPerQuad + v] = vertex;                  }              }
Magic Number,SimpleScene,SSTexturedNormalCube,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSTexturedNormalCube.cs,SSTexturedNormalCube,The following statement contains a magic number: SSVertex_PosNormTex[] vertices = new SSVertex_PosNormTex[verticesPerQuad * 6];
Magic Number,SimpleScene,SSTexturedNormalCube,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSTexturedNormalCube.cs,SSTexturedNormalCube,The following statement contains a magic number: for (int f = 0; f < 6; ++f) {  				for (int v = 0; v < verticesPerQuad; ++v) {  					SSVertex_PosNormTex vertex = c_vertices [v];  					vertex.Position = Vector3.Transform(vertex.Position' c_faceTransforms [f]);  					vertex.Normal = Vector3.Transform (vertex.Normal' c_faceTransforms [f]);  					vertices [f * verticesPerQuad + v] = vertex;  				}  			}
Magic Number,SimpleScene,SSWavefrontMTLInfo,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontMTLInfo.cs,ReadMTLs,The following statement contains a magic number: while (line != null) {  				string[] tokens = line.Split(" ".ToArray()' 2);  				if (tokens.Length < 2) {  					goto next_line;  				}    				string firstToken = tokens[0];  				string lineContent = tokens[1];    				switch (firstToken) {  				case "#":  					// Nothing to read' these are comments.  					break;  				case "newmtl":  // create new named material                  					parseMaterial = new SSWavefrontMTLInfo();  					materials.Add(parseMaterial);  					parseMaterial.name = lineContent;  					break;  				case "Ka": // ambient color  					parseMaterial.vAmbient = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasAmbient = true;  					break;  				case "Kd": // diffuse color  					parseMaterial.vDiffuse = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasDiffuse = true;  					break;  				case "Ks": // specular color (weighted by Ns)                                   					parseMaterial.vSpecular = WavefrontParser.readVector4(lineContent'null);  					parseMaterial.hasSpecular = true;  					break;  				case "Ns": // specular color weight                  					parseMaterial.vSpecularWeight = WavefrontParser.parseFloat(lineContent);     					break;  				case "d":  				case "Tr": // transparency / dissolve (i.e. alpha)  					parseMaterial.fTransparency = WavefrontParser.parseFloat(lineContent);  					parseMaterial.hasTransparency = true;  					break;  				case "illum": // illumination mode                             					parseMaterial.hasIlluminationMode = true;  					parseMaterial.illuminationMode = (SSWavefrontIlluminationMode) int.Parse(lineContent);  					break;  				case "map_Kd": // diffuse color map                  					parseMaterial.diffuseTextureResourceName = lineContent;  					break;  				case "map_Ka": // ambient color map  					parseMaterial.ambientTextureResourceName = lineContent;  					break;  				case "map_Ks": // specular color map                  					parseMaterial.specularTextureResourceName = lineContent;  					break;  				case "bump":   				case "map_Bump":  				case "map_bump": // bump map    					// bump <filename> [-bm <float intensity>]               					// bump -bm <float intensity> <filename>  					string[] parts = lineContent.Split(' ');  					if (parts.Length == 1) {  						parseMaterial.bumpTextureResourceName = parts[0];  					} else {  						if (parts.Length == 3) {  							if (parts[1].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[0];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[2]);  							} else if (parts[0].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[3];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[1]);  							}  						}  					}      					break;  				}    				next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene,SSWavefrontMTLInfo,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontMTLInfo.cs,ReadMTLs,The following statement contains a magic number: while (line != null) {  				string[] tokens = line.Split(" ".ToArray()' 2);  				if (tokens.Length < 2) {  					goto next_line;  				}    				string firstToken = tokens[0];  				string lineContent = tokens[1];    				switch (firstToken) {  				case "#":  					// Nothing to read' these are comments.  					break;  				case "newmtl":  // create new named material                  					parseMaterial = new SSWavefrontMTLInfo();  					materials.Add(parseMaterial);  					parseMaterial.name = lineContent;  					break;  				case "Ka": // ambient color  					parseMaterial.vAmbient = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasAmbient = true;  					break;  				case "Kd": // diffuse color  					parseMaterial.vDiffuse = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasDiffuse = true;  					break;  				case "Ks": // specular color (weighted by Ns)                                   					parseMaterial.vSpecular = WavefrontParser.readVector4(lineContent'null);  					parseMaterial.hasSpecular = true;  					break;  				case "Ns": // specular color weight                  					parseMaterial.vSpecularWeight = WavefrontParser.parseFloat(lineContent);     					break;  				case "d":  				case "Tr": // transparency / dissolve (i.e. alpha)  					parseMaterial.fTransparency = WavefrontParser.parseFloat(lineContent);  					parseMaterial.hasTransparency = true;  					break;  				case "illum": // illumination mode                             					parseMaterial.hasIlluminationMode = true;  					parseMaterial.illuminationMode = (SSWavefrontIlluminationMode) int.Parse(lineContent);  					break;  				case "map_Kd": // diffuse color map                  					parseMaterial.diffuseTextureResourceName = lineContent;  					break;  				case "map_Ka": // ambient color map  					parseMaterial.ambientTextureResourceName = lineContent;  					break;  				case "map_Ks": // specular color map                  					parseMaterial.specularTextureResourceName = lineContent;  					break;  				case "bump":   				case "map_Bump":  				case "map_bump": // bump map    					// bump <filename> [-bm <float intensity>]               					// bump -bm <float intensity> <filename>  					string[] parts = lineContent.Split(' ');  					if (parts.Length == 1) {  						parseMaterial.bumpTextureResourceName = parts[0];  					} else {  						if (parts.Length == 3) {  							if (parts[1].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[0];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[2]);  							} else if (parts[0].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[3];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[1]);  							}  						}  					}      					break;  				}    				next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene,SSWavefrontMTLInfo,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontMTLInfo.cs,ReadMTLs,The following statement contains a magic number: while (line != null) {  				string[] tokens = line.Split(" ".ToArray()' 2);  				if (tokens.Length < 2) {  					goto next_line;  				}    				string firstToken = tokens[0];  				string lineContent = tokens[1];    				switch (firstToken) {  				case "#":  					// Nothing to read' these are comments.  					break;  				case "newmtl":  // create new named material                  					parseMaterial = new SSWavefrontMTLInfo();  					materials.Add(parseMaterial);  					parseMaterial.name = lineContent;  					break;  				case "Ka": // ambient color  					parseMaterial.vAmbient = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasAmbient = true;  					break;  				case "Kd": // diffuse color  					parseMaterial.vDiffuse = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasDiffuse = true;  					break;  				case "Ks": // specular color (weighted by Ns)                                   					parseMaterial.vSpecular = WavefrontParser.readVector4(lineContent'null);  					parseMaterial.hasSpecular = true;  					break;  				case "Ns": // specular color weight                  					parseMaterial.vSpecularWeight = WavefrontParser.parseFloat(lineContent);     					break;  				case "d":  				case "Tr": // transparency / dissolve (i.e. alpha)  					parseMaterial.fTransparency = WavefrontParser.parseFloat(lineContent);  					parseMaterial.hasTransparency = true;  					break;  				case "illum": // illumination mode                             					parseMaterial.hasIlluminationMode = true;  					parseMaterial.illuminationMode = (SSWavefrontIlluminationMode) int.Parse(lineContent);  					break;  				case "map_Kd": // diffuse color map                  					parseMaterial.diffuseTextureResourceName = lineContent;  					break;  				case "map_Ka": // ambient color map  					parseMaterial.ambientTextureResourceName = lineContent;  					break;  				case "map_Ks": // specular color map                  					parseMaterial.specularTextureResourceName = lineContent;  					break;  				case "bump":   				case "map_Bump":  				case "map_bump": // bump map    					// bump <filename> [-bm <float intensity>]               					// bump -bm <float intensity> <filename>  					string[] parts = lineContent.Split(' ');  					if (parts.Length == 1) {  						parseMaterial.bumpTextureResourceName = parts[0];  					} else {  						if (parts.Length == 3) {  							if (parts[1].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[0];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[2]);  							} else if (parts[0].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[3];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[1]);  							}  						}  					}      					break;  				}    				next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene,SSWavefrontMTLInfo,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontMTLInfo.cs,ReadMTLs,The following statement contains a magic number: while (line != null) {  				string[] tokens = line.Split(" ".ToArray()' 2);  				if (tokens.Length < 2) {  					goto next_line;  				}    				string firstToken = tokens[0];  				string lineContent = tokens[1];    				switch (firstToken) {  				case "#":  					// Nothing to read' these are comments.  					break;  				case "newmtl":  // create new named material                  					parseMaterial = new SSWavefrontMTLInfo();  					materials.Add(parseMaterial);  					parseMaterial.name = lineContent;  					break;  				case "Ka": // ambient color  					parseMaterial.vAmbient = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasAmbient = true;  					break;  				case "Kd": // diffuse color  					parseMaterial.vDiffuse = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasDiffuse = true;  					break;  				case "Ks": // specular color (weighted by Ns)                                   					parseMaterial.vSpecular = WavefrontParser.readVector4(lineContent'null);  					parseMaterial.hasSpecular = true;  					break;  				case "Ns": // specular color weight                  					parseMaterial.vSpecularWeight = WavefrontParser.parseFloat(lineContent);     					break;  				case "d":  				case "Tr": // transparency / dissolve (i.e. alpha)  					parseMaterial.fTransparency = WavefrontParser.parseFloat(lineContent);  					parseMaterial.hasTransparency = true;  					break;  				case "illum": // illumination mode                             					parseMaterial.hasIlluminationMode = true;  					parseMaterial.illuminationMode = (SSWavefrontIlluminationMode) int.Parse(lineContent);  					break;  				case "map_Kd": // diffuse color map                  					parseMaterial.diffuseTextureResourceName = lineContent;  					break;  				case "map_Ka": // ambient color map  					parseMaterial.ambientTextureResourceName = lineContent;  					break;  				case "map_Ks": // specular color map                  					parseMaterial.specularTextureResourceName = lineContent;  					break;  				case "bump":   				case "map_Bump":  				case "map_bump": // bump map    					// bump <filename> [-bm <float intensity>]               					// bump -bm <float intensity> <filename>  					string[] parts = lineContent.Split(' ');  					if (parts.Length == 1) {  						parseMaterial.bumpTextureResourceName = parts[0];  					} else {  						if (parts.Length == 3) {  							if (parts[1].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[0];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[2]);  							} else if (parts[0].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[3];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[1]);  							}  						}  					}      					break;  				}    				next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene,SSWavefrontMTLInfo,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontMTLInfo.cs,ReadMTLs,The following statement contains a magic number: while (line != null) {  				string[] tokens = line.Split(" ".ToArray()' 2);  				if (tokens.Length < 2) {  					goto next_line;  				}    				string firstToken = tokens[0];  				string lineContent = tokens[1];    				switch (firstToken) {  				case "#":  					// Nothing to read' these are comments.  					break;  				case "newmtl":  // create new named material                  					parseMaterial = new SSWavefrontMTLInfo();  					materials.Add(parseMaterial);  					parseMaterial.name = lineContent;  					break;  				case "Ka": // ambient color  					parseMaterial.vAmbient = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasAmbient = true;  					break;  				case "Kd": // diffuse color  					parseMaterial.vDiffuse = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasDiffuse = true;  					break;  				case "Ks": // specular color (weighted by Ns)                                   					parseMaterial.vSpecular = WavefrontParser.readVector4(lineContent'null);  					parseMaterial.hasSpecular = true;  					break;  				case "Ns": // specular color weight                  					parseMaterial.vSpecularWeight = WavefrontParser.parseFloat(lineContent);     					break;  				case "d":  				case "Tr": // transparency / dissolve (i.e. alpha)  					parseMaterial.fTransparency = WavefrontParser.parseFloat(lineContent);  					parseMaterial.hasTransparency = true;  					break;  				case "illum": // illumination mode                             					parseMaterial.hasIlluminationMode = true;  					parseMaterial.illuminationMode = (SSWavefrontIlluminationMode) int.Parse(lineContent);  					break;  				case "map_Kd": // diffuse color map                  					parseMaterial.diffuseTextureResourceName = lineContent;  					break;  				case "map_Ka": // ambient color map  					parseMaterial.ambientTextureResourceName = lineContent;  					break;  				case "map_Ks": // specular color map                  					parseMaterial.specularTextureResourceName = lineContent;  					break;  				case "bump":   				case "map_Bump":  				case "map_bump": // bump map    					// bump <filename> [-bm <float intensity>]               					// bump -bm <float intensity> <filename>  					string[] parts = lineContent.Split(' ');  					if (parts.Length == 1) {  						parseMaterial.bumpTextureResourceName = parts[0];  					} else {  						if (parts.Length == 3) {  							if (parts[1].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[0];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[2]);  							} else if (parts[0].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[3];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[1]);  							}  						}  					}      					break;  				}    				next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector4,The following statement contains a magic number: if (values.Length == 3) {       // W optional  				return new Vector4(  					parseFloat(values[0])'   					parseFloat(values[1])'  					parseFloat(values[2])'  					0f);  			} else if (values.Length == 4) {  				return new Vector4(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2])'  					parseFloat(values[3]));  			} else {  				throw new Exception("readVector4 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector4,The following statement contains a magic number: if (values.Length == 3) {       // W optional  				return new Vector4(  					parseFloat(values[0])'   					parseFloat(values[1])'  					parseFloat(values[2])'  					0f);  			} else if (values.Length == 4) {  				return new Vector4(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2])'  					parseFloat(values[3]));  			} else {  				throw new Exception("readVector4 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector4,The following statement contains a magic number: if (values.Length == 3) {       // W optional  				return new Vector4(  					parseFloat(values[0])'   					parseFloat(values[1])'  					parseFloat(values[2])'  					0f);  			} else if (values.Length == 4) {  				return new Vector4(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2])'  					parseFloat(values[3]));  			} else {  				throw new Exception("readVector4 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector4,The following statement contains a magic number: if (values.Length == 3) {       // W optional  				return new Vector4(  					parseFloat(values[0])'   					parseFloat(values[1])'  					parseFloat(values[2])'  					0f);  			} else if (values.Length == 4) {  				return new Vector4(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2])'  					parseFloat(values[3]));  			} else {  				throw new Exception("readVector4 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector4,The following statement contains a magic number: if (values.Length == 3) {       // W optional  				return new Vector4(  					parseFloat(values[0])'   					parseFloat(values[1])'  					parseFloat(values[2])'  					0f);  			} else if (values.Length == 4) {  				return new Vector4(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2])'  					parseFloat(values[3]));  			} else {  				throw new Exception("readVector4 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector3,The following statement contains a magic number: if (values.Length == 3) {  				return new Vector3(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2]));  			} else {  				throw new Exception("readVector3 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector3,The following statement contains a magic number: if (values.Length == 3) {  				return new Vector3(  					parseFloat(values[0])'  					parseFloat(values[1])'  					parseFloat(values[2]));  			} else {  				throw new Exception("readVector3 found wrong number of vectors : " + strIn);  			}
Magic Number,SimpleScene,WavefrontParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontParser.cs,readVector2,The following statement contains a magic number: ASSERT(values.Length == 2' "readVector2 found wrong number of vectors : " + strIn);
Magic Number,SimpleScene,SSMeshBoundingSphere,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Shapes\SSMeshBoundingSphere.cs,SSMeshBoundingSphere,The following statement contains a magic number: var icoSphereGeometry = icoSphereCreator.Create(3);
Magic Number,SimpleScene,ParticlesSphereGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesFieldGenerators.cs,Generate,The following statement contains a magic number: for (int i = 0; i < numParticles; ++i) {                  bool accepted = false;                  while (!accepted) {                      if (numTries >= numParticles * c_maxTriesFactor) {                          // This is somewhat of a hack to add a failsafe for the random strategy of                           // fitting things in. Currently we just give up if we tried too many time with                           // no luck. This can happen when trying to fit too much into a small space.                          // In the future a smarter packing strategy may be employed before giving up.                          // todo: print something  						System.Console.WriteLine (  							"Too many rejections when generating a field. " +   							"Giving up after " + numTries + " fitting attempts.");                          return;                      }  					++numTries;                      float theta = (float)(2.0 * Math.PI * m_rand.NextDouble());                      float alpha = (float)(Math.PI * (m_rand.NextDouble() - 0.5));                      float r = Radius * (float)m_rand.NextDouble();                      float z = r * (float)Math.Sin(alpha);                      float r_xy = r * (float)Math.Cos(alpha);                      float x = r_xy * (float)Math.Cos(theta);                      float y = r_xy * (float)Math.Sin(theta);                      accepted = newPartDel(i' Center + new Vector3(x' y' z));                  }              }
Magic Number,SimpleScene,ParticlesSphereGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesFieldGenerators.cs,Generate,The following statement contains a magic number: for (int i = 0; i < numParticles; ++i) {                  bool accepted = false;                  while (!accepted) {                      if (numTries >= numParticles * c_maxTriesFactor) {                          // This is somewhat of a hack to add a failsafe for the random strategy of                           // fitting things in. Currently we just give up if we tried too many time with                           // no luck. This can happen when trying to fit too much into a small space.                          // In the future a smarter packing strategy may be employed before giving up.                          // todo: print something  						System.Console.WriteLine (  							"Too many rejections when generating a field. " +   							"Giving up after " + numTries + " fitting attempts.");                          return;                      }  					++numTries;                      float theta = (float)(2.0 * Math.PI * m_rand.NextDouble());                      float alpha = (float)(Math.PI * (m_rand.NextDouble() - 0.5));                      float r = Radius * (float)m_rand.NextDouble();                      float z = r * (float)Math.Sin(alpha);                      float r_xy = r * (float)Math.Cos(alpha);                      float x = r_xy * (float)Math.Cos(theta);                      float y = r_xy * (float)Math.Sin(theta);                      accepted = newPartDel(i' Center + new Vector3(x' y' z));                  }              }
Magic Number,SimpleScene,ParticlesBoxGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesFieldGenerators.cs,Generate,The following statement contains a magic number: for (int i = 0; i < numParticles; ++i) {                  bool accepted = false;                  while (!accepted) {                      if (numTries >= numParticles * c_maxTriesFactor) {                          // This is somewhat of a hack to add a failsafe for the random strategy of                           // fitting things in. Currently we just give up if we tried too many time with                           // no luck. This can happen when trying to fit too much into a small space.                          // In the future a smarter packing strategy may be employed before giving up.                          // TODO: print something  						System.Console.WriteLine (  							"Too many rejections when generating a field. " +   							"Giving up after " + numTries + " fitting attempts.");                          return;                      }  					++numTries;                      float x = (float)(m_dimmensions.X * (m_rand.NextDouble() - 0.5));                      float y = (float)(m_dimmensions.Y * (m_rand.NextDouble() - 0.5));                      float z = (float)(m_dimmensions.Z * (m_rand.NextDouble() - 0.5));                      accepted = newPartDel(i' m_center + new Vector3(x' y' z));                  }              }
Magic Number,SimpleScene,ParticlesBoxGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesFieldGenerators.cs,Generate,The following statement contains a magic number: for (int i = 0; i < numParticles; ++i) {                  bool accepted = false;                  while (!accepted) {                      if (numTries >= numParticles * c_maxTriesFactor) {                          // This is somewhat of a hack to add a failsafe for the random strategy of                           // fitting things in. Currently we just give up if we tried too many time with                           // no luck. This can happen when trying to fit too much into a small space.                          // In the future a smarter packing strategy may be employed before giving up.                          // TODO: print something  						System.Console.WriteLine (  							"Too many rejections when generating a field. " +   							"Giving up after " + numTries + " fitting attempts.");                          return;                      }  					++numTries;                      float x = (float)(m_dimmensions.X * (m_rand.NextDouble() - 0.5));                      float y = (float)(m_dimmensions.Y * (m_rand.NextDouble() - 0.5));                      float z = (float)(m_dimmensions.Z * (m_rand.NextDouble() - 0.5));                      accepted = newPartDel(i' m_center + new Vector3(x' y' z));                  }              }
Magic Number,SimpleScene,ParticlesBoxGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesFieldGenerators.cs,Generate,The following statement contains a magic number: for (int i = 0; i < numParticles; ++i) {                  bool accepted = false;                  while (!accepted) {                      if (numTries >= numParticles * c_maxTriesFactor) {                          // This is somewhat of a hack to add a failsafe for the random strategy of                           // fitting things in. Currently we just give up if we tried too many time with                           // no luck. This can happen when trying to fit too much into a small space.                          // In the future a smarter packing strategy may be employed before giving up.                          // TODO: print something  						System.Console.WriteLine (  							"Too many rejections when generating a field. " +   							"Giving up after " + numTries + " fitting attempts.");                          return;                      }  					++numTries;                      float x = (float)(m_dimmensions.X * (m_rand.NextDouble() - 0.5));                      float y = (float)(m_dimmensions.Y * (m_rand.NextDouble() - 0.5));                      float z = (float)(m_dimmensions.Z * (m_rand.NextDouble() - 0.5));                      accepted = newPartDel(i' m_center + new Vector3(x' y' z));                  }              }
Magic Number,SimpleScene,ParticlesOvalGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\ParticlesPlaneGenerators.cs,Generate,The following statement contains a magic number: for (int i = 0; i < numParticles; ++i) {                  bool accepted = false;                  while (!accepted) {                      float r = (float)m_rand.NextDouble();                      float theta = (float)(m_rand.NextDouble() * 2.0 * Math.PI);                      float x = r * (float)Math.Cos(theta) * m_horizontalMax;                      float y = r * (float)Math.Sin(theta) * m_verticalMax;                      accepted = newPartDel(i' new Vector2(x' y));                  }              }
Magic Number,SimpleScene,BodiesFieldGenerator,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\BodiesFieldGenerators.cs,randomOrient,The following statement contains a magic number: float angle = (float) (2.0 * Math.PI * (float)m_rand.NextDouble());
Magic Number,SimpleScene,SSParticleSystemData,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSParticleSystemData.cs,addEffector,The following statement contains a magic number: if (effector.preAddHook != null) {                  for (int i = 0; i < _activeBlockLength; ++i) {                      if (isAlive(i)) {                          ushort effectorMask = (ushort)((int)_readElement (_effectorMasksHigh' i) << 8                                                       | (int)_readElement (_effectorMasksLow' i));                          if (effector.effectorMaskCheck(effectorMask)) {                              SSParticle particle = new SSParticle ();                              readParticle(i' particle);                              effector.preAddHook(particle);                              writeParticle(i' particle);                          }                      }                  }              }
Magic Number,SimpleScene,SSParticleSystemData,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSParticleSystemData.cs,removeEffector,The following statement contains a magic number: if (effector.preRemoveHook != null) {                  for (int i = 0; i < _activeBlockLength; ++i) {                      if (isAlive(i)) {                          ushort effectorMask = (ushort)((int)_readElement (_effectorMasksHigh' i) << 8                                                       | (int)_readElement (_effectorMasksLow' i));                          if (effector.effectorMaskCheck(effectorMask)) {                              SSParticle particle = new SSParticle ();                              readParticle(i' particle);                              effector.preRemoveHook(particle);                              writeParticle(i' particle);                          }                      }                  }              }
Magic Number,SimpleScene,SSParticleSystemData,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSParticleSystemData.cs,readParticle,The following statement contains a magic number: p.effectorMask = (ushort)((int)_readElement (_effectorMasksHigh' idx) << 8  							 	    | (int)_readElement (_effectorMasksLow' idx));
Magic Number,SimpleScene,SSParticleSystemData,C:\repos\jeske_SimpleScene\SimpleScene\Meshes\Instancing\SSParticleSystemData.cs,writeParticle,The following statement contains a magic number: writeDataIfNeeded(ref _effectorMasksHigh' idx' (byte)((p.effectorMask & 0xFF00) >> 8));
Magic Number,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,generateSplines,The following statement contains a magic number: if (diff.LengthFast >= trailsParams.minSegmentLength) {  					Vector3 prevSlope = _prevSplineIntervalEndSlope [jetIdx];  					Vector3 prevPos = _prevSplineIntervalEndPos [jetIdx];  					float angleBetweenSlopes = Vector3.CalculateAngle(jetSlope' prevSlope);  					int numCylinders = (int)(angleBetweenSlopes / trailsParams.radiansPerExtraCylinder);  					numCylinders = Math.Max(numCylinders' trailsParams.numCylindersPerEmissionMin);  					numCylinders = Math.Min(numCylinders' trailsParams.numCylindersPerEmissionMax);  					if (numCylinders == 1) {  						_newSplinePos = jetPos;  						storeNewParticle(createNewParticle());  					} else {  						float dt = 1f / numCylinders;  						for (int i = 1; i <= numCylinders; ++i) {  							float t = i * dt;  							float tSq = t * t;  							float tMinusOne = t - 1;  							float tMinusOneSq = tMinusOne * tMinusOne;  							float h00 = (1 + 2 * t) * tMinusOneSq;  							float h10 = t * tMinusOneSq;  							float h01 = tSq * (3 - 2 * t);  							float h11 = tSq * tMinusOne;  							//float slopeScale = pos - _prevSplineIntervalEndPos;    							_newSplinePos = h00 * prevPos + h10 * prevSlope * trailsParams.trailsEmissionInterval  								+ h01 * jetPos + h11 * jetSlope * trailsParams.trailsEmissionInterval;  							storeNewParticle(createNewParticle());  						}  					}  					_prevSplineIntervalEndPos[jetIdx] = jetPos;  					_prevSplineIntervalEndSlope[jetIdx] = jetSlope;  				}
Magic Number,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,generateSplines,The following statement contains a magic number: if (diff.LengthFast >= trailsParams.minSegmentLength) {  					Vector3 prevSlope = _prevSplineIntervalEndSlope [jetIdx];  					Vector3 prevPos = _prevSplineIntervalEndPos [jetIdx];  					float angleBetweenSlopes = Vector3.CalculateAngle(jetSlope' prevSlope);  					int numCylinders = (int)(angleBetweenSlopes / trailsParams.radiansPerExtraCylinder);  					numCylinders = Math.Max(numCylinders' trailsParams.numCylindersPerEmissionMin);  					numCylinders = Math.Min(numCylinders' trailsParams.numCylindersPerEmissionMax);  					if (numCylinders == 1) {  						_newSplinePos = jetPos;  						storeNewParticle(createNewParticle());  					} else {  						float dt = 1f / numCylinders;  						for (int i = 1; i <= numCylinders; ++i) {  							float t = i * dt;  							float tSq = t * t;  							float tMinusOne = t - 1;  							float tMinusOneSq = tMinusOne * tMinusOne;  							float h00 = (1 + 2 * t) * tMinusOneSq;  							float h10 = t * tMinusOneSq;  							float h01 = tSq * (3 - 2 * t);  							float h11 = tSq * tMinusOne;  							//float slopeScale = pos - _prevSplineIntervalEndPos;    							_newSplinePos = h00 * prevPos + h10 * prevSlope * trailsParams.trailsEmissionInterval  								+ h01 * jetPos + h11 * jetSlope * trailsParams.trailsEmissionInterval;  							storeNewParticle(createNewParticle());  						}  					}  					_prevSplineIntervalEndPos[jetIdx] = jetPos;  					_prevSplineIntervalEndSlope[jetIdx] = jetSlope;  				}
Magic Number,SimpleScene,STrailsData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\STrailsRenderer.cs,generateSplines,The following statement contains a magic number: if (diff.LengthFast >= trailsParams.minSegmentLength) {  					Vector3 prevSlope = _prevSplineIntervalEndSlope [jetIdx];  					Vector3 prevPos = _prevSplineIntervalEndPos [jetIdx];  					float angleBetweenSlopes = Vector3.CalculateAngle(jetSlope' prevSlope);  					int numCylinders = (int)(angleBetweenSlopes / trailsParams.radiansPerExtraCylinder);  					numCylinders = Math.Max(numCylinders' trailsParams.numCylindersPerEmissionMin);  					numCylinders = Math.Min(numCylinders' trailsParams.numCylindersPerEmissionMax);  					if (numCylinders == 1) {  						_newSplinePos = jetPos;  						storeNewParticle(createNewParticle());  					} else {  						float dt = 1f / numCylinders;  						for (int i = 1; i <= numCylinders; ++i) {  							float t = i * dt;  							float tSq = t * t;  							float tMinusOne = t - 1;  							float tMinusOneSq = tMinusOne * tMinusOne;  							float h00 = (1 + 2 * t) * tMinusOneSq;  							float h10 = t * tMinusOneSq;  							float h01 = tSq * (3 - 2 * t);  							float h11 = tSq * tMinusOne;  							//float slopeScale = pos - _prevSplineIntervalEndPos;    							_newSplinePos = h00 * prevPos + h10 * prevSlope * trailsParams.trailsEmissionInterval  								+ h01 * jetPos + h11 * jetSlope * trailsParams.trailsEmissionInterval;  							storeNewParticle(createNewParticle());  						}  					}  					_prevSplineIntervalEndPos[jetIdx] = jetPos;  					_prevSplineIntervalEndSlope[jetIdx] = jetSlope;  				}
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,ToUInt32,The following statement contains a magic number: return (UInt32)color.A << 24   				| (UInt32)color.B << 16   				| (UInt32)color.G << 8   				| (UInt32)color.R;
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,ToUInt32,The following statement contains a magic number: return (UInt32)color.A << 24   				| (UInt32)color.B << 16   				| (UInt32)color.G << 8   				| (UInt32)color.R;
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,ToUInt32,The following statement contains a magic number: return (UInt32)color.A << 24   				| (UInt32)color.B << 16   				| (UInt32)color.G << 8   				| (UInt32)color.R;
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,FromUInt32,The following statement contains a magic number: return new Color4 (  				(byte)((rgba & 0xFF))'              // R  				(byte)((rgba & 0xFF00) >> 8)'       // G  				(byte)((rgba & 0xFF0000) >> 16)'    // B  				(byte)((rgba & 0xFF000000) >> 24)   // A  			);
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,FromUInt32,The following statement contains a magic number: return new Color4 (  				(byte)((rgba & 0xFF))'              // R  				(byte)((rgba & 0xFF00) >> 8)'       // G  				(byte)((rgba & 0xFF0000) >> 16)'    // B  				(byte)((rgba & 0xFF000000) >> 24)   // A  			);
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,FromUInt32,The following statement contains a magic number: return new Color4 (  				(byte)((rgba & 0xFF))'              // R  				(byte)((rgba & 0xFF00) >> 8)'       // G  				(byte)((rgba & 0xFF0000) >> 16)'    // B  				(byte)((rgba & 0xFF000000) >> 24)   // A  			);
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,fromVector4,The following statement contains a magic number: return new Color4 (vect4 [0]' vect4 [1]' vect4 [2]' vect4 [3]);
Magic Number,SimpleScene.Util,Color4Helper,C:\repos\jeske_SimpleScene\SimpleScene\Util\Color4Helper.cs,fromVector4,The following statement contains a magic number: return new Color4 (vect4 [0]' vect4 [1]' vect4 [2]' vect4 [3]);
Magic Number,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,SA,The following statement contains a magic number: float size = radius * 2;
Magic Number,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The following statement contains a magic number: if (bestRot.rot != Rot.NONE) {                  // if the best rotation is no-rotation... we check our parents anyhow..                                  if (parent != null) {                       // but only do it some random percentage of the time.                      if ((DateTime.Now.Ticks % 100) < 2) {                          bvh.refitNodes.Add(parent);                       }                  }                              } else {                    if (parent != null) { bvh.refitNodes.Add(parent); }                    if ( ((mySA - bestRot.SAH) / mySA ) < 0.3f) {                      return; // the benefit is not worth the cost                  }                  Console.WriteLine("BVH swap {0} from {1} to {2}"' bestRot.rot.ToString()' mySA' bestRot.SAH);                    // in order to swap we need to:                  //  1. swap the node locations                  //  2. update the depth (if child-to-grandchild)                  //  3. update the parent pointers                  //  4. refit the boundary box                  ssBVHNode<GO> swap = null;                  switch (bestRot.rot) {                      case Rot.NONE: break;                      // child to grandchild rotations                      case Rot.L_RL: swap = left;  left  = right.left;   left.parent = this; right.left  = swap;  swap.parent = right; right.childRefit(nAda'propagate:false); break;                      case Rot.L_RR: swap = left;  left  = right.right;  left.parent = this; right.right = swap;  swap.parent = right; right.childRefit(nAda'propagate:false); break;                      case Rot.R_LL: swap = right; right =  left.left;  right.parent = this;  left.left  = swap;  swap.parent = left;   left.childRefit(nAda'propagate:false); break;                      case Rot.R_LR: swap = right; right =  left.right; right.parent = this;  left.right = swap;  swap.parent = left;   left.childRefit(nAda'propagate:false); break;                                            // grandchild to grandchild rotations                      case Rot.LL_RR: swap = left.left; left.left = right.right; right.right = swap; left.left.parent = left; swap.parent = right; left.childRefit(nAda'propagate:false); right.childRefit(nAda'propagate:false); break;                      case Rot.LL_RL: swap = left.left; left.left = right.left;  right.left  = swap; left.left.parent = left; swap.parent = right; left.childRefit(nAda'propagate:false); right.childRefit(nAda'propagate:false); break;                                            // unknown...                      default: throw new NotImplementedException("missing implementation for BVH Rotation .. " + bestRot.rot.ToString());                                                       }                    // fix the depths if necessary....                  switch (bestRot.rot) {                      case Rot.L_RL:                      case Rot.L_RR:                      case Rot.R_LL:                      case Rot.R_LR:                          this.setDepth(nAda'this.depth);                          break;                                     }              }
Magic Number,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The following statement contains a magic number: if (bestRot.rot != Rot.NONE) {                  // if the best rotation is no-rotation... we check our parents anyhow..                                  if (parent != null) {                       // but only do it some random percentage of the time.                      if ((DateTime.Now.Ticks % 100) < 2) {                          bvh.refitNodes.Add(parent);                       }                  }                              } else {                    if (parent != null) { bvh.refitNodes.Add(parent); }                    if ( ((mySA - bestRot.SAH) / mySA ) < 0.3f) {                      return; // the benefit is not worth the cost                  }                  Console.WriteLine("BVH swap {0} from {1} to {2}"' bestRot.rot.ToString()' mySA' bestRot.SAH);                    // in order to swap we need to:                  //  1. swap the node locations                  //  2. update the depth (if child-to-grandchild)                  //  3. update the parent pointers                  //  4. refit the boundary box                  ssBVHNode<GO> swap = null;                  switch (bestRot.rot) {                      case Rot.NONE: break;                      // child to grandchild rotations                      case Rot.L_RL: swap = left;  left  = right.left;   left.parent = this; right.left  = swap;  swap.parent = right; right.childRefit(nAda'propagate:false); break;                      case Rot.L_RR: swap = left;  left  = right.right;  left.parent = this; right.right = swap;  swap.parent = right; right.childRefit(nAda'propagate:false); break;                      case Rot.R_LL: swap = right; right =  left.left;  right.parent = this;  left.left  = swap;  swap.parent = left;   left.childRefit(nAda'propagate:false); break;                      case Rot.R_LR: swap = right; right =  left.right; right.parent = this;  left.right = swap;  swap.parent = left;   left.childRefit(nAda'propagate:false); break;                                            // grandchild to grandchild rotations                      case Rot.LL_RR: swap = left.left; left.left = right.right; right.right = swap; left.left.parent = left; swap.parent = right; left.childRefit(nAda'propagate:false); right.childRefit(nAda'propagate:false); break;                      case Rot.LL_RL: swap = left.left; left.left = right.left;  right.left  = swap; left.left.parent = left; swap.parent = right; left.childRefit(nAda'propagate:false); right.childRefit(nAda'propagate:false); break;                                            // unknown...                      default: throw new NotImplementedException("missing implementation for BVH Rotation .. " + bestRot.rot.ToString());                                                       }                    // fix the depths if necessary....                  switch (bestRot.rot) {                      case Rot.L_RL:                      case Rot.L_RR:                      case Rot.R_LL:                      case Rot.R_LR:                          this.setDepth(nAda'this.depth);                          break;                                     }              }
Magic Number,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,splitNode,The following statement contains a magic number: int center = (int)(splitlist.Count / 2);
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util.ssBVH,SSBVHRender,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_SSObject.cs,renderCells,The following statement contains a magic number: if (highlightNodes.Contains(n)) {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'25'25'100));                  } else {                      GL.Color4(Color.Green);                   }                              } else {                  if (n.gobjects == null) {                      GL.Color4(Color.FromArgb(255'20'20'20));                  } else {                      GL.Color4(Color.DarkRed);                              }              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,The following statement contains a magic number: while (line != null)   			{                  // handle line continuation with "\"                  if (line.Length > 0) {                      while (line[line.Length-1] == '\\') {                          line = line.Substring(0'line.Length-1); // remove line extender..                          var nextline = sr.ReadLine();                          if (nextline != null && nextline.Length != 0) {                              line = line + nextline; // merge with next line                          } else {                              break; // be sure to avoid infinite loop...                          }                      }                  }                    // split the line into tokens' separated by space                  string[] tokens = line.Split(" ".ToArray()' 2);                  if (tokens.Length < 2) {                      goto next_line;                  }                    string firstToken = tokens[0];                  string lineContent = tokens[1];                    switch(firstToken) {                          /* unsupported features - fatal */                      case "cstype":    // curved surface type (bmatrix' bezier' bspline' cardinal' taylor)                      case "deg":       // curve attr: degree                      case "step":       // curve attr: step size                      case "bmat":      // curve attr: basis matrix                      case "surf":      // surface                      case "parm":      // curve body: paramater value                      case "trim":      // curve body: outer trimming loop                      case "hole":      // curve body: inner trimming loop                      case "scrv":      // curve body: special curve                      case "sp":        // curve body: special point                      case "end":       // curve body: end                      case "con":       // connection between free form surfaces                      case "vp":        // paramater space vertex (for free form surfaces)                        case "bevel":     // bevel interpolation                      case "c_interp":  // color interpolation                      case "d_interp":  // dissolve interpolation                      case "lod":       // level of detail                                                              case "ctech":     // Curve approximation technique                      case "stech":     // Surface approximation technique                      case "mg":        // merging group (for free form surfaces)                            throw new WavefrontObjParseException("WavefrontObjLoader.cs: fatal error' token not supported :  " + firstToken);                          /* unsupported features - warning */                      case "o":         // object name                                        case "g":         // group name                      case "s":         // smoothing group                      case "shadow_obj":// shadow casting                      case "trace_obj": // ray tracing                          Console.WriteLine("WavefrontObjLoader.cs: warning - unsupported wavefront token : " + firstToken);                          break;                            /* supported features */                      case "#":   // Nothing to read' these are comments.                                                  break;                      case "v":   // Vertex position  						positions.Add(WavefrontParser.readVector4(lineContent' null));                          break;                      case "vn":  // vertex normal direction vector  						normals.Add(WavefrontParser.readVector3(lineContent' null));                             break;                      case "vt":  // Vertex texcoordinate  						texCoords.Add(WavefrontParser.readVector2(lineContent'null));                          break;                      case "f":   // Face                      						string[] values = WavefrontParser.FilteredSplit(lineContent' null);                          int numPoints = values.Length;                                                Face face = new Face();                           face.v_idx = new Int16[numPoints];                          face.n_idx = new Int16[numPoints];                          face.tex_idx = new Int16[numPoints];  // todo: how do outside clients know if there were texcoords or not?!?!                             for (int i = 0; i < numPoints; i++)                          {                                                            // format is "loc_index[/tex_index[/normal_index]]"  e.g. 3 ; 3/2 ; 3/2/5                              // but middle part can me empty' e.g. 3//5                              string[] indexes = values[i].Split('/');                                    int iPosition = (int.Parse(indexes[0]) - 1);  // adjust 1-based index                                                  if (iPosition < 0) { iPosition += positions.Count + 1; } // adjust negative indicies                              face.v_idx[i] = (Int16)iPosition;                               numIndices++;                                                                            // initialize other indicies to not provided' in case they are missing                              face.n_idx[i] = -1;                              face.tex_idx[i] = -1;                                                            if (indexes.Length > 1)                              {                                  string tex_index = indexes[1];                                  if (tex_index != "") {                                      int iTexCoord = int.Parse(tex_index) - 1; // adjust 1-based index                                      if (iTexCoord < 0) { iTexCoord += texCoords.Count + 1; }  // adjust negative indicies                                        face.tex_idx[i] = (Int16)iTexCoord;                                  }                                    if (indexes.Length > 2)                                  {                                          hasNormals = true;                                      int iNormal = int.Parse(indexes[2]) - 1; // adjust 1 based index                                      if (iNormal < 0) { iNormal += normals.Count + 1; } // adjust negative indicies                                        face.n_idx[i] = (Int16)iNormal;                                                                  }                              }                          }                          if (currentMaterial == null) {                              // no material in file' so create one                              currentMaterial = createImplicitMaterial();                          }                          currentMaterial.faces.Add(face);                          currentMaterial.nbrIndices += face.v_idx.Length;                          numFaces++;                                                                      break;                      case "mtllib":  // load named material file                          string mtlFile = lineContent;  						{                          var mtls = SSWavefrontMTLInfo.ReadMTLs (Path.Combine(basePath' mtlFile));  							foreach (var mtl in mtls) {  								materials.Add (new MaterialInfoWithFaces (mtl));  							}  						}                          break;                      case "usemtl":  // use named material (from material file previously loaded)                          bool found = false;                            string matName = lineContent;                            for (int i = 0; i < materials.Count; i++)                          {                              if (matName.Equals(materials[i].mtl.name))                              {                                  found = true;                                  currentMaterial = materials[i];                                                          }                          }                            if (!found)                          {                              throw new WavefrontObjParseException("Materials are already loaded so we should have it!");                          }                          break;                  }                                next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,The following statement contains a magic number: while (line != null)   			{                  // handle line continuation with "\"                  if (line.Length > 0) {                      while (line[line.Length-1] == '\\') {                          line = line.Substring(0'line.Length-1); // remove line extender..                          var nextline = sr.ReadLine();                          if (nextline != null && nextline.Length != 0) {                              line = line + nextline; // merge with next line                          } else {                              break; // be sure to avoid infinite loop...                          }                      }                  }                    // split the line into tokens' separated by space                  string[] tokens = line.Split(" ".ToArray()' 2);                  if (tokens.Length < 2) {                      goto next_line;                  }                    string firstToken = tokens[0];                  string lineContent = tokens[1];                    switch(firstToken) {                          /* unsupported features - fatal */                      case "cstype":    // curved surface type (bmatrix' bezier' bspline' cardinal' taylor)                      case "deg":       // curve attr: degree                      case "step":       // curve attr: step size                      case "bmat":      // curve attr: basis matrix                      case "surf":      // surface                      case "parm":      // curve body: paramater value                      case "trim":      // curve body: outer trimming loop                      case "hole":      // curve body: inner trimming loop                      case "scrv":      // curve body: special curve                      case "sp":        // curve body: special point                      case "end":       // curve body: end                      case "con":       // connection between free form surfaces                      case "vp":        // paramater space vertex (for free form surfaces)                        case "bevel":     // bevel interpolation                      case "c_interp":  // color interpolation                      case "d_interp":  // dissolve interpolation                      case "lod":       // level of detail                                                              case "ctech":     // Curve approximation technique                      case "stech":     // Surface approximation technique                      case "mg":        // merging group (for free form surfaces)                            throw new WavefrontObjParseException("WavefrontObjLoader.cs: fatal error' token not supported :  " + firstToken);                          /* unsupported features - warning */                      case "o":         // object name                                        case "g":         // group name                      case "s":         // smoothing group                      case "shadow_obj":// shadow casting                      case "trace_obj": // ray tracing                          Console.WriteLine("WavefrontObjLoader.cs: warning - unsupported wavefront token : " + firstToken);                          break;                            /* supported features */                      case "#":   // Nothing to read' these are comments.                                                  break;                      case "v":   // Vertex position  						positions.Add(WavefrontParser.readVector4(lineContent' null));                          break;                      case "vn":  // vertex normal direction vector  						normals.Add(WavefrontParser.readVector3(lineContent' null));                             break;                      case "vt":  // Vertex texcoordinate  						texCoords.Add(WavefrontParser.readVector2(lineContent'null));                          break;                      case "f":   // Face                      						string[] values = WavefrontParser.FilteredSplit(lineContent' null);                          int numPoints = values.Length;                                                Face face = new Face();                           face.v_idx = new Int16[numPoints];                          face.n_idx = new Int16[numPoints];                          face.tex_idx = new Int16[numPoints];  // todo: how do outside clients know if there were texcoords or not?!?!                             for (int i = 0; i < numPoints; i++)                          {                                                            // format is "loc_index[/tex_index[/normal_index]]"  e.g. 3 ; 3/2 ; 3/2/5                              // but middle part can me empty' e.g. 3//5                              string[] indexes = values[i].Split('/');                                    int iPosition = (int.Parse(indexes[0]) - 1);  // adjust 1-based index                                                  if (iPosition < 0) { iPosition += positions.Count + 1; } // adjust negative indicies                              face.v_idx[i] = (Int16)iPosition;                               numIndices++;                                                                            // initialize other indicies to not provided' in case they are missing                              face.n_idx[i] = -1;                              face.tex_idx[i] = -1;                                                            if (indexes.Length > 1)                              {                                  string tex_index = indexes[1];                                  if (tex_index != "") {                                      int iTexCoord = int.Parse(tex_index) - 1; // adjust 1-based index                                      if (iTexCoord < 0) { iTexCoord += texCoords.Count + 1; }  // adjust negative indicies                                        face.tex_idx[i] = (Int16)iTexCoord;                                  }                                    if (indexes.Length > 2)                                  {                                          hasNormals = true;                                      int iNormal = int.Parse(indexes[2]) - 1; // adjust 1 based index                                      if (iNormal < 0) { iNormal += normals.Count + 1; } // adjust negative indicies                                        face.n_idx[i] = (Int16)iNormal;                                                                  }                              }                          }                          if (currentMaterial == null) {                              // no material in file' so create one                              currentMaterial = createImplicitMaterial();                          }                          currentMaterial.faces.Add(face);                          currentMaterial.nbrIndices += face.v_idx.Length;                          numFaces++;                                                                      break;                      case "mtllib":  // load named material file                          string mtlFile = lineContent;  						{                          var mtls = SSWavefrontMTLInfo.ReadMTLs (Path.Combine(basePath' mtlFile));  							foreach (var mtl in mtls) {  								materials.Add (new MaterialInfoWithFaces (mtl));  							}  						}                          break;                      case "usemtl":  // use named material (from material file previously loaded)                          bool found = false;                            string matName = lineContent;                            for (int i = 0; i < materials.Count; i++)                          {                              if (matName.Equals(materials[i].mtl.name))                              {                                  found = true;                                  currentMaterial = materials[i];                                                          }                          }                            if (!found)                          {                              throw new WavefrontObjParseException("Materials are already loaded so we should have it!");                          }                          break;                  }                                next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,The following statement contains a magic number: while (line != null)   			{                  // handle line continuation with "\"                  if (line.Length > 0) {                      while (line[line.Length-1] == '\\') {                          line = line.Substring(0'line.Length-1); // remove line extender..                          var nextline = sr.ReadLine();                          if (nextline != null && nextline.Length != 0) {                              line = line + nextline; // merge with next line                          } else {                              break; // be sure to avoid infinite loop...                          }                      }                  }                    // split the line into tokens' separated by space                  string[] tokens = line.Split(" ".ToArray()' 2);                  if (tokens.Length < 2) {                      goto next_line;                  }                    string firstToken = tokens[0];                  string lineContent = tokens[1];                    switch(firstToken) {                          /* unsupported features - fatal */                      case "cstype":    // curved surface type (bmatrix' bezier' bspline' cardinal' taylor)                      case "deg":       // curve attr: degree                      case "step":       // curve attr: step size                      case "bmat":      // curve attr: basis matrix                      case "surf":      // surface                      case "parm":      // curve body: paramater value                      case "trim":      // curve body: outer trimming loop                      case "hole":      // curve body: inner trimming loop                      case "scrv":      // curve body: special curve                      case "sp":        // curve body: special point                      case "end":       // curve body: end                      case "con":       // connection between free form surfaces                      case "vp":        // paramater space vertex (for free form surfaces)                        case "bevel":     // bevel interpolation                      case "c_interp":  // color interpolation                      case "d_interp":  // dissolve interpolation                      case "lod":       // level of detail                                                              case "ctech":     // Curve approximation technique                      case "stech":     // Surface approximation technique                      case "mg":        // merging group (for free form surfaces)                            throw new WavefrontObjParseException("WavefrontObjLoader.cs: fatal error' token not supported :  " + firstToken);                          /* unsupported features - warning */                      case "o":         // object name                                        case "g":         // group name                      case "s":         // smoothing group                      case "shadow_obj":// shadow casting                      case "trace_obj": // ray tracing                          Console.WriteLine("WavefrontObjLoader.cs: warning - unsupported wavefront token : " + firstToken);                          break;                            /* supported features */                      case "#":   // Nothing to read' these are comments.                                                  break;                      case "v":   // Vertex position  						positions.Add(WavefrontParser.readVector4(lineContent' null));                          break;                      case "vn":  // vertex normal direction vector  						normals.Add(WavefrontParser.readVector3(lineContent' null));                             break;                      case "vt":  // Vertex texcoordinate  						texCoords.Add(WavefrontParser.readVector2(lineContent'null));                          break;                      case "f":   // Face                      						string[] values = WavefrontParser.FilteredSplit(lineContent' null);                          int numPoints = values.Length;                                                Face face = new Face();                           face.v_idx = new Int16[numPoints];                          face.n_idx = new Int16[numPoints];                          face.tex_idx = new Int16[numPoints];  // todo: how do outside clients know if there were texcoords or not?!?!                             for (int i = 0; i < numPoints; i++)                          {                                                            // format is "loc_index[/tex_index[/normal_index]]"  e.g. 3 ; 3/2 ; 3/2/5                              // but middle part can me empty' e.g. 3//5                              string[] indexes = values[i].Split('/');                                    int iPosition = (int.Parse(indexes[0]) - 1);  // adjust 1-based index                                                  if (iPosition < 0) { iPosition += positions.Count + 1; } // adjust negative indicies                              face.v_idx[i] = (Int16)iPosition;                               numIndices++;                                                                            // initialize other indicies to not provided' in case they are missing                              face.n_idx[i] = -1;                              face.tex_idx[i] = -1;                                                            if (indexes.Length > 1)                              {                                  string tex_index = indexes[1];                                  if (tex_index != "") {                                      int iTexCoord = int.Parse(tex_index) - 1; // adjust 1-based index                                      if (iTexCoord < 0) { iTexCoord += texCoords.Count + 1; }  // adjust negative indicies                                        face.tex_idx[i] = (Int16)iTexCoord;                                  }                                    if (indexes.Length > 2)                                  {                                          hasNormals = true;                                      int iNormal = int.Parse(indexes[2]) - 1; // adjust 1 based index                                      if (iNormal < 0) { iNormal += normals.Count + 1; } // adjust negative indicies                                        face.n_idx[i] = (Int16)iNormal;                                                                  }                              }                          }                          if (currentMaterial == null) {                              // no material in file' so create one                              currentMaterial = createImplicitMaterial();                          }                          currentMaterial.faces.Add(face);                          currentMaterial.nbrIndices += face.v_idx.Length;                          numFaces++;                                                                      break;                      case "mtllib":  // load named material file                          string mtlFile = lineContent;  						{                          var mtls = SSWavefrontMTLInfo.ReadMTLs (Path.Combine(basePath' mtlFile));  							foreach (var mtl in mtls) {  								materials.Add (new MaterialInfoWithFaces (mtl));  							}  						}                          break;                      case "usemtl":  // use named material (from material file previously loaded)                          bool found = false;                            string matName = lineContent;                            for (int i = 0; i < materials.Count; i++)                          {                              if (matName.Equals(materials[i].mtl.name))                              {                                  found = true;                                  currentMaterial = materials[i];                                                          }                          }                            if (!found)                          {                              throw new WavefrontObjParseException("Materials are already loaded so we should have it!");                          }                          break;                  }                                next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,The following statement contains a magic number: while (line != null)   			{                  // handle line continuation with "\"                  if (line.Length > 0) {                      while (line[line.Length-1] == '\\') {                          line = line.Substring(0'line.Length-1); // remove line extender..                          var nextline = sr.ReadLine();                          if (nextline != null && nextline.Length != 0) {                              line = line + nextline; // merge with next line                          } else {                              break; // be sure to avoid infinite loop...                          }                      }                  }                    // split the line into tokens' separated by space                  string[] tokens = line.Split(" ".ToArray()' 2);                  if (tokens.Length < 2) {                      goto next_line;                  }                    string firstToken = tokens[0];                  string lineContent = tokens[1];                    switch(firstToken) {                          /* unsupported features - fatal */                      case "cstype":    // curved surface type (bmatrix' bezier' bspline' cardinal' taylor)                      case "deg":       // curve attr: degree                      case "step":       // curve attr: step size                      case "bmat":      // curve attr: basis matrix                      case "surf":      // surface                      case "parm":      // curve body: paramater value                      case "trim":      // curve body: outer trimming loop                      case "hole":      // curve body: inner trimming loop                      case "scrv":      // curve body: special curve                      case "sp":        // curve body: special point                      case "end":       // curve body: end                      case "con":       // connection between free form surfaces                      case "vp":        // paramater space vertex (for free form surfaces)                        case "bevel":     // bevel interpolation                      case "c_interp":  // color interpolation                      case "d_interp":  // dissolve interpolation                      case "lod":       // level of detail                                                              case "ctech":     // Curve approximation technique                      case "stech":     // Surface approximation technique                      case "mg":        // merging group (for free form surfaces)                            throw new WavefrontObjParseException("WavefrontObjLoader.cs: fatal error' token not supported :  " + firstToken);                          /* unsupported features - warning */                      case "o":         // object name                                        case "g":         // group name                      case "s":         // smoothing group                      case "shadow_obj":// shadow casting                      case "trace_obj": // ray tracing                          Console.WriteLine("WavefrontObjLoader.cs: warning - unsupported wavefront token : " + firstToken);                          break;                            /* supported features */                      case "#":   // Nothing to read' these are comments.                                                  break;                      case "v":   // Vertex position  						positions.Add(WavefrontParser.readVector4(lineContent' null));                          break;                      case "vn":  // vertex normal direction vector  						normals.Add(WavefrontParser.readVector3(lineContent' null));                             break;                      case "vt":  // Vertex texcoordinate  						texCoords.Add(WavefrontParser.readVector2(lineContent'null));                          break;                      case "f":   // Face                      						string[] values = WavefrontParser.FilteredSplit(lineContent' null);                          int numPoints = values.Length;                                                Face face = new Face();                           face.v_idx = new Int16[numPoints];                          face.n_idx = new Int16[numPoints];                          face.tex_idx = new Int16[numPoints];  // todo: how do outside clients know if there were texcoords or not?!?!                             for (int i = 0; i < numPoints; i++)                          {                                                            // format is "loc_index[/tex_index[/normal_index]]"  e.g. 3 ; 3/2 ; 3/2/5                              // but middle part can me empty' e.g. 3//5                              string[] indexes = values[i].Split('/');                                    int iPosition = (int.Parse(indexes[0]) - 1);  // adjust 1-based index                                                  if (iPosition < 0) { iPosition += positions.Count + 1; } // adjust negative indicies                              face.v_idx[i] = (Int16)iPosition;                               numIndices++;                                                                            // initialize other indicies to not provided' in case they are missing                              face.n_idx[i] = -1;                              face.tex_idx[i] = -1;                                                            if (indexes.Length > 1)                              {                                  string tex_index = indexes[1];                                  if (tex_index != "") {                                      int iTexCoord = int.Parse(tex_index) - 1; // adjust 1-based index                                      if (iTexCoord < 0) { iTexCoord += texCoords.Count + 1; }  // adjust negative indicies                                        face.tex_idx[i] = (Int16)iTexCoord;                                  }                                    if (indexes.Length > 2)                                  {                                          hasNormals = true;                                      int iNormal = int.Parse(indexes[2]) - 1; // adjust 1 based index                                      if (iNormal < 0) { iNormal += normals.Count + 1; } // adjust negative indicies                                        face.n_idx[i] = (Int16)iNormal;                                                                  }                              }                          }                          if (currentMaterial == null) {                              // no material in file' so create one                              currentMaterial = createImplicitMaterial();                          }                          currentMaterial.faces.Add(face);                          currentMaterial.nbrIndices += face.v_idx.Length;                          numFaces++;                                                                      break;                      case "mtllib":  // load named material file                          string mtlFile = lineContent;  						{                          var mtls = SSWavefrontMTLInfo.ReadMTLs (Path.Combine(basePath' mtlFile));  							foreach (var mtl in mtls) {  								materials.Add (new MaterialInfoWithFaces (mtl));  							}  						}                          break;                      case "usemtl":  // use named material (from material file previously loaded)                          bool found = false;                            string matName = lineContent;                            for (int i = 0; i < materials.Count; i++)                          {                              if (matName.Equals(materials[i].mtl.name))                              {                                  found = true;                                  currentMaterial = materials[i];                                                          }                          }                            if (!found)                          {                              throw new WavefrontObjParseException("Materials are already loaded so we should have it!");                          }                          break;                  }                                next_line:  				//Read the next line  				line = sr.ReadLine();  			}
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoColor,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150);              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255));              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoColor,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150);              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255));              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoColor,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150);              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255));              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoColor,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150);              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255));              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoColor,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150);              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255));              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoColor,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150);              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255));              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150).ToArgb();              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb();              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150).ToArgb();              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb();              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150).ToArgb();              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb();              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150).ToArgb();              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb();              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150).ToArgb();              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb();              }
Magic Number,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,CIEXYZtoRGB,The following statement contains a magic number: if (xyzColor.X + xyzColor.Y + xyzColor.Z < 0.01f) {                  return System.Drawing.Color.FromArgb(150' 150' 150).ToArgb();              } else {                  // this is not a proper color conversion.. just a hack approximation..                  return System.Drawing.Color.FromArgb((int)(xyzColor.X * 255)' (int)(xyzColor.Y * 255)' (int)(xyzColor.Z * 255)).ToArgb();              }
Magic Number,Bend,WhoCalls,C:\repos\jeske_SimpleScene\SimpleScene\Util\WhoCalls.cs,WhoCalledMe,The following statement contains a magic number: StackFrame stackFrame = stackTrace.GetFrame(2);
Magic Number,UG,Bitmap,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,Bitmap,The following statement contains a magic number: this.buffer = new ImageBuffer(width'height'32' new BlenderBGRA());
Magic Number,UG,Bitmap,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,Bitmap,The following statement contains a magic number: switch (format) {  			case PixelFormat.Format32bppArgb:   				bpp = 32;  				byteBlender = new BlenderBGRA();  				break;  			case PixelFormat.Format32bppRgb:  				bpp = 32;  				byteBlender = new BlenderBGR();  				break;  			case PixelFormat.Format24bppRgb:  				bpp = 24;  				byteBlender = new BlenderBGR();  				break;  			default:  				throw new NotImplementedException(String.Format("UG.Bitmap unsupported format {0}"'format));  			}
Magic Number,UG,Bitmap,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,Bitmap,The following statement contains a magic number: switch (format) {  			case PixelFormat.Format32bppArgb:   				bpp = 32;  				byteBlender = new BlenderBGRA();  				break;  			case PixelFormat.Format32bppRgb:  				bpp = 32;  				byteBlender = new BlenderBGR();  				break;  			case PixelFormat.Format24bppRgb:  				bpp = 24;  				byteBlender = new BlenderBGR();  				break;  			default:  				throw new NotImplementedException(String.Format("UG.Bitmap unsupported format {0}"'format));  			}
Magic Number,UG,Bitmap,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,Bitmap,The following statement contains a magic number: switch (format) {  			case PixelFormat.Format32bppArgb:   				bpp = 32;  				byteBlender = new BlenderBGRA();  				break;  			case PixelFormat.Format32bppRgb:  				bpp = 32;  				byteBlender = new BlenderBGR();  				break;  			case PixelFormat.Format24bppRgb:  				bpp = 24;  				byteBlender = new BlenderBGR();  				break;  			default:  				throw new NotImplementedException(String.Format("UG.Bitmap unsupported format {0}"'format));  			}
Magic Number,UG,GraphicsPath,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,AddPie,The following statement contains a magic number: double originX = (rect.Left + rect.Right) / 2.0;
Magic Number,UG,GraphicsPath,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,AddPie,The following statement contains a magic number: double originY = (rect.Top + rect.Bottom) / 2.0;
Magic Number,UG,GraphicsPath,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,AddPie,The following statement contains a magic number: double radiusX = (rect.Height) / 2.0;
Magic Number,UG,GraphicsPath,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,AddPie,The following statement contains a magic number: double radiusY = (rect.Width) / 2.0;
Magic Number,UG,GraphicsPath,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,AddPie,The following statement contains a magic number: if (Math.Abs (endAngleDeg - startAngleDeg) >= 360.0) {  				// if it's a full circle' we don't need to connect to the origin  				path.concat_path(new arc(originX'originY'radiusX'radiusY'  					Graphics.DegreesToRadians(startAngleDeg)'  					Graphics.DegreesToRadians(endAngleDeg)'moveToStart:true));  			} else {  				// if it's a partial arc' we need to connect to the origin  				path.MoveTo(originX'originY);  				path.concat_path(new arc(originX'originY'radiusX'radiusY'  					Graphics.DegreesToRadians(startAngleDeg)'  					Graphics.DegreesToRadians(endAngleDeg)'moveToStart:false));  				path.LineTo(originX'originY);				  			}
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DegreesToRadians,The following statement contains a magic number: return (angleDeg / 180.0 * Math.PI);
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,Graphics,The following statement contains a magic number: this.aggGc.SetTransform(Affine.NewTranslation(0.5'0.5));
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,Graphics,The following statement contains a magic number: this.aggGc.SetTransform(Affine.NewTranslation(0.5'0.5));
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawArc,The following statement contains a magic number: double originX = (rect.Left + rect.Right) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawArc,The following statement contains a magic number: double originY = (rect.Top + rect.Bottom) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawArc,The following statement contains a magic number: double radiusX = (rect.Height) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,DrawArc,The following statement contains a magic number: double radiusY = (rect.Width) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,SetClip,The following statement contains a magic number: switch (mode) {  			case System.Drawing.Drawing2D.CombineMode.Exclude:  				shapeMaskColor = new RGBA_Bytes (0'0'0'255);  				backgroundMaskColor = new RGBA_Bytes (255'255'255'255);  				break;  			default:  				throw new NotImplementedException ();  			}
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,SetClip,The following statement contains a magic number: switch (mode) {  			case System.Drawing.Drawing2D.CombineMode.Exclude:  				shapeMaskColor = new RGBA_Bytes (0'0'0'255);  				backgroundMaskColor = new RGBA_Bytes (255'255'255'255);  				break;  			default:  				throw new NotImplementedException ();  			}
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,SetClip,The following statement contains a magic number: switch (mode) {  			case System.Drawing.Drawing2D.CombineMode.Exclude:  				shapeMaskColor = new RGBA_Bytes (0'0'0'255);  				backgroundMaskColor = new RGBA_Bytes (255'255'255'255);  				break;  			default:  				throw new NotImplementedException ();  			}
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,SetClip,The following statement contains a magic number: switch (mode) {  			case System.Drawing.Drawing2D.CombineMode.Exclude:  				shapeMaskColor = new RGBA_Bytes (0'0'0'255);  				backgroundMaskColor = new RGBA_Bytes (255'255'255'255);  				break;  			default:  				throw new NotImplementedException ();  			}
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,SetClip,The following statement contains a magic number: switch (mode) {  			case System.Drawing.Drawing2D.CombineMode.Exclude:  				shapeMaskColor = new RGBA_Bytes (0'0'0'255);  				backgroundMaskColor = new RGBA_Bytes (255'255'255'255);  				break;  			default:  				throw new NotImplementedException ();  			}
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,SetClip,The following statement contains a magic number: _clipBuffer = new ImageBuffer (bounds.Width' bounds.Height' 8' new blender_gray (1));
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The following statement contains a magic number: double originX = (rect.Left + rect.Right) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The following statement contains a magic number: double originY = (rect.Top + rect.Bottom) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The following statement contains a magic number: double radiusX = (rect.Height) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The following statement contains a magic number: double radiusY = (rect.Width) / 2.0;
Magic Number,UG,Graphics,C:\repos\jeske_SimpleScene\SimpleScene\Util\GDIviaAGG.cs,FillPie,The following statement contains a magic number: if (Math.Abs (endAngleDeg - startAngleDeg) >= 360.0) {  				// if it's a full circle' we don't need to connect to the origin  				arcpath = new arc(originX'originY'radiusX'radiusY'DegreesToRadians(startAngleDeg)'DegreesToRadians(endAngleDeg)'moveToStart:true);  			} else {  				// if it's a partial arc' we need to connect to the origin  				var path = new PathStorage();  				path.MoveTo(originX'originY);  				path.concat_path(new arc(originX'originY'radiusX'radiusY'DegreesToRadians(startAngleDeg)'DegreesToRadians(endAngleDeg)'moveToStart:false));  				path.LineTo(originX'originY);  				arcpath = path;  			}
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,getMiddlePoint,The following statement contains a magic number: Int64 key = (smallerIndex << 32) + greaterIndex;
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: float t = (float)((1.0f + Math.Sqrt (5.0)) / 2.0);
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: float t = (float)((1.0f + Math.Sqrt (5.0)) / 2.0);
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 11' 5));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 11' 5));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 5' 1));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 1' 7));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 7' 10));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 7' 10));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 10' 11));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (0' 10' 11));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (1' 5' 9));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (1' 5' 9));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (5' 11' 4));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (5' 11' 4));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (5' 11' 4));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (11' 10' 2));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (11' 10' 2));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (11' 10' 2));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (10' 7' 6));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (10' 7' 6));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (10' 7' 6));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (7' 1' 8));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (7' 1' 8));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 9' 4));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 9' 4));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 9' 4));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 4' 2));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 4' 2));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 4' 2));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 2' 6));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 2' 6));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 2' 6));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 6' 8));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 6' 8));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 6' 8));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 8' 9));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 8' 9));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (3' 8' 9));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (4' 9' 5));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (4' 9' 5));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (4' 9' 5));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (2' 4' 11));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (2' 4' 11));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (2' 4' 11));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (6' 2' 10));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (6' 2' 10));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (6' 2' 10));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (8' 6' 7));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (8' 6' 7));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (8' 6' 7));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (9' 8' 1));
Magic Number,Util.IcoSphere,IcoSphereCreator,C:\repos\jeske_SimpleScene\SimpleScene\Util\IcoSphereCreator.cs,Create,The following statement contains a magic number: faces.Add (new TriangleIndices (9' 8' 1));
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readHierarchyEntry,The following statement contains a magic number: flags = Convert.ToByte(matches[2].Value);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBounds,The following statement contains a magic number: ret.Min.Y = (float)Convert.ToDouble (matches [2].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBounds,The following statement contains a magic number: ret.Min.Z = (float)Convert.ToDouble (matches [3].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBounds,The following statement contains a magic number: ret.Max.X = (float)Convert.ToDouble (matches [6].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBounds,The following statement contains a magic number: ret.Max.Y = (float)Convert.ToDouble (matches [7].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBounds,The following statement contains a magic number: ret.Max.Z = (float)Convert.ToDouble (matches [8].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBaseFrame,The following statement contains a magic number: loc.position.Y = (float)Convert.ToDouble (matches [2].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBaseFrame,The following statement contains a magic number: loc.position.Z = (float)Convert.ToDouble (matches [3].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBaseFrame,The following statement contains a magic number: loc.orientation.X = (float)Convert.ToDouble (matches [6].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBaseFrame,The following statement contains a magic number: loc.orientation.Y = (float)Convert.ToDouble (matches [7].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5AnimParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5AnimParser.cs,readBaseFrame,The following statement contains a magic number: loc.orientation.Z = (float)Convert.ToDouble (matches [8].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readJoint,The following statement contains a magic number: ret.bindPoseLocation.position.X = (float)Convert.ToDouble(matches[3].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readJoint,The following statement contains a magic number: ret.bindPoseLocation.position.Y = (float)Convert.ToDouble(matches[4].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readJoint,The following statement contains a magic number: ret.bindPoseLocation.position.Z = (float)Convert.ToDouble(matches[5].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readJoint,The following statement contains a magic number: ret.bindPoseLocation.orientation.X = (float)Convert.ToDouble(matches[8].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readJoint,The following statement contains a magic number: ret.bindPoseLocation.orientation.Y = (float)Convert.ToDouble(matches[9].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readJoint,The following statement contains a magic number: ret.bindPoseLocation.orientation.Z = (float)Convert.ToDouble(matches[10].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readMesh,The following statement contains a magic number: newMesh.triangleIndices = new UInt16[numTris * 3];
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readVertex,The following statement contains a magic number: ret.textureCoords.X = (float)Convert.ToDouble(matches[3].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readVertex,The following statement contains a magic number: ret.textureCoords.Y = (float)Convert.ToDouble(matches[4].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readVertex,The following statement contains a magic number: ret.weightStartIndex = Convert.ToInt32(matches[6].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readVertex,The following statement contains a magic number: ret.weightCount = Convert.ToInt32(matches[7].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readTriangle,The following statement contains a magic number: UInt32 indexBaseIdx = triIdx * 3;
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readTriangle,The following statement contains a magic number: triangleIndices [indexBaseIdx] = Convert.ToUInt16 (matches [2].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readTriangle,The following statement contains a magic number: triangleIndices [indexBaseIdx+2] = Convert.ToUInt16 (matches [3].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readTriangle,The following statement contains a magic number: triangleIndices [indexBaseIdx+2] = Convert.ToUInt16 (matches [3].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readTriangle,The following statement contains a magic number: triangleIndices [indexBaseIdx+1] = Convert.ToUInt16 (matches [4].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readWeight,The following statement contains a magic number: ret.jointIndex = Convert.ToInt32(matches[2].Value);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readWeight,The following statement contains a magic number: ret.bias = (float)Convert.ToDouble(matches[3].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readWeight,The following statement contains a magic number: ret.position.X = (float)Convert.ToDouble(matches[5].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readWeight,The following statement contains a magic number: ret.position.Y = (float)Convert.ToDouble(matches[6].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SSMD5MeshParser,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSMD5MeshParser.cs,readWeight,The following statement contains a magic number: ret.position.Z = (float)Convert.ToDouble(matches[7].Value' CultureInfo.InvariantCulture);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices = new SSVertex_PosTex[8];
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices [2].TexCoord = new Vector2 (1f-padding' padding);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices [3].TexCoord = new Vector2 (1f-padding' 1f-padding);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices [4].TexCoord = new Vector2 (1f-padding' padding);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices [5].TexCoord = new Vector2 (1f-padding' 1f-padding);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices [6].TexCoord = new Vector2 (1f' padding);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initMiddleMesh,The following statement contains a magic number: _middleVertices [7].TexCoord = new Vector2 (1f' 1f-padding);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: for (int i = 0; i < 8; i += 2) {  				_middleVertices [i].Position.Y = +halfWidth;  				_middleVertices [i + 1].Position.Y = -halfWidth;  			}
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: for (int i = 0; i < 8; i += 2) {  				_middleVertices [i].Position.Y = +halfWidth;  				_middleVertices [i + 1].Position.Y = -halfWidth;  			}
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: _middleVertices [2].Position.X = _middleVertices[3].Position.X = -halfLength + halfWidth;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: _middleVertices [2].Position.X = _middleVertices[3].Position.X = -halfLength + halfWidth;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: _middleVertices [4].Position.X = _middleVertices[5].Position.X = +halfLength - halfWidth;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: _middleVertices [4].Position.X = _middleVertices[5].Position.X = +halfLength - halfWidth;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: _middleVertices [6].Position.X = _middleVertices[7].Position.X = +halfLength + halfWidth;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateMiddleMesh,The following statement contains a magic number: _middleVertices [6].Position.X = _middleVertices[7].Position.X = +halfLength + halfWidth;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initInterferenceVertices,The following statement contains a magic number: _interferenceVertices = new SSVertex_PosTex[4];
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initInterferenceVertices,The following statement contains a magic number: _interferenceVertices[2].Position = new Vector3(+0.5f' +0.5f' 0f);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initInterferenceVertices,The following statement contains a magic number: _interferenceVertices[3].Position = new Vector3(+0.5f' -0.5f' 0f);
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initInterferenceVertices,The following statement contains a magic number: _interferenceVertices[0].TexCoord.Y = _interferenceVertices[2].TexCoord.Y = 1f;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_initInterferenceVertices,The following statement contains a magic number: _interferenceVertices[1].TexCoord.Y = _interferenceVertices[3].TexCoord.Y = 0f;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateInterfernenceVertices,The following statement contains a magic number: _interferenceVertices [2].TexCoord.X = _interferenceVertices [3].TexCoord.X  				= (beam.interferenceOffset + 1f) * vScale;
Magic Number,SimpleScene.Demos,SLaserBeamMiddleObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBeamMiddleObject.cs,_updateInterfernenceVertices,The following statement contains a magic number: _interferenceVertices [2].TexCoord.X = _interferenceVertices [3].TexCoord.X  				= (beam.interferenceOffset + 1f) * vScale;
Magic Number,SimpleScene.Demos,SLaserBurnParticleSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBurnParticlesObject.cs,addHitSpots,The following statement contains a magic number: _nextEffectorMask += 2;
Magic Number,SimpleScene.Demos,SLaserBurnParticleSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserBurnParticlesObject.cs,addHitSpots,The following statement contains a magic number: if (_nextEffectorMask == 0) { // 0 is reserved for the global smoke dimmer                  _nextEffectorMask = 2;              }
Magic Number,SimpleScene.Demos,SLaserEmissionFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserEmissionFlareUpdater.cs,updateSprites,The following statement contains a magic number: var alpha = occDiskAreaRatio*1.2f * (float)Math.Pow(beamIntensity' 0.1) * (float)Math.Pow(dot' 0.1);
Magic Number,SimpleScene.Demos,SLaserEmissionFlareUpdater,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Lasers\SLaserEmissionFlareUpdater.cs,updateSprites,The following statement contains a magic number: var alpha = occDiskAreaRatio*1.2f * (float)Math.Pow(beamIntensity' 0.1) * (float)Math.Pow(dot' 0.1);
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SStarfieldObject,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SStarfieldObject.cs,SStarfieldObject,The following statement contains a magic number: for (int i = 0; i < numstars; i++) {                  // generate a random position                  vertices[i].Position = new Vector3(                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f'                      (float)rgen.NextDouble() * 2.0f - 1.0f);                    // the normals are simplified                  vertices[i].Normal = vertices[i].Position;                  int intensity = rgen.Next(80);                  if (intensity > 70) { intensity += 20 + rgen.Next(50); }                  // TODO: add a couple dominant standout colors (red giant' yellow)' maybe a star-color-palette                  vertices[i].DiffuseColor = Color.FromArgb(255'                      rgen.Next(40) + intensity'                      rgen.Next(25) + intensity'                      rgen.Next(25)+ intensity).ToArgb();              }
Magic Number,SimpleScene.Demos,SSSkeletalMeshRuntime,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalMeshRuntime.cs,_preComputeNormals,The following statement contains a magic number: for (int i = 0; i < numTriangles; ++i) {  				int baseIdx = i * 3;  				int v0 = _triangleIndices [baseIdx];  				int v1 = _triangleIndices [baseIdx + 1];  				int v2 = _triangleIndices [baseIdx + 2];  				Vector3 p0 = computeVertexPos (v0);  				Vector3 p1 = computeVertexPos (v1);  				Vector3 p2 = computeVertexPos (v2);  				Vector3 triNormal = Vector3.Cross (p1 - p0' p2 - p0);  				_vertices [v0].bindPoseNormal += triNormal;  				_vertices [v1].bindPoseNormal += triNormal;  				_vertices [v2].bindPoseNormal += triNormal;  			}
Magic Number,SimpleScene.Demos,SSSkeletalMeshRuntime,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalMeshRuntime.cs,_preComputeNormals,The following statement contains a magic number: for (int i = 0; i < numTriangles; ++i) {  				int baseIdx = i * 3;  				int v0 = _triangleIndices [baseIdx];  				int v1 = _triangleIndices [baseIdx + 1];  				int v2 = _triangleIndices [baseIdx + 2];  				Vector3 p0 = computeVertexPos (v0);  				Vector3 p1 = computeVertexPos (v1);  				Vector3 p2 = computeVertexPos (v2);  				Vector3 triNormal = Vector3.Cross (p1 - p0' p2 - p0);  				_vertices [v0].bindPoseNormal += triNormal;  				_vertices [v1].bindPoseNormal += triNormal;  				_vertices [v2].bindPoseNormal += triNormal;  			}
Magic Number,SimpleScene.Demos,RenderSubMesh,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalRenderMesh.cs,renderFaceNormals,The following statement contains a magic number: for (int i=0;i<_runtimeMesh.numTriangles;i++) {  					int baseIdx = i * 3;                  					Vector3 p0 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx);  					Vector3 p1 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 1);  					Vector3 p2 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 2);    					Vector3 face_center = (p0 + p1 + p2) / 3.0f;  					Vector3 face_normal = Vector3.Cross(p1 - p0' p2 - p0).Normalized();    					GL.Begin(PrimitiveType.Lines);  					GL.Vertex3(face_center);  					GL.Vertex3(face_center + face_normal * 0.2f);  					GL.End();                  				}
Magic Number,SimpleScene.Demos,RenderSubMesh,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalRenderMesh.cs,renderFaceNormals,The following statement contains a magic number: for (int i=0;i<_runtimeMesh.numTriangles;i++) {  					int baseIdx = i * 3;                  					Vector3 p0 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx);  					Vector3 p1 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 1);  					Vector3 p2 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 2);    					Vector3 face_center = (p0 + p1 + p2) / 3.0f;  					Vector3 face_normal = Vector3.Cross(p1 - p0' p2 - p0).Normalized();    					GL.Begin(PrimitiveType.Lines);  					GL.Vertex3(face_center);  					GL.Vertex3(face_center + face_normal * 0.2f);  					GL.End();                  				}
Magic Number,SimpleScene.Demos,RenderSubMesh,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalRenderMesh.cs,renderFaceAveragedVertexNormals,The following statement contains a magic number: for (int i = 0; i < _runtimeMesh.numTriangles; i++) {  					int baseIdx = i * 3;  					Vector3 p0 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx);  					Vector3 p1 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 1);  					Vector3 p2 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 2);    					Vector3 face_normal = Vector3.Cross(p1 - p0' p2 - p0).Normalized();    					int v0 = _runtimeMesh.indices[baseIdx];  					int v1 = _runtimeMesh.indices[baseIdx + 1];  					int v2 = _runtimeMesh.indices[baseIdx + 2];    					perVertexNormals[v0] += face_normal;  					perVertexNormals[v1] += face_normal;  					perVertexNormals[v2] += face_normal;    				}
Magic Number,SimpleScene.Demos,RenderSubMesh,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalRenderMesh.cs,renderFaceAveragedVertexNormals,The following statement contains a magic number: for (int i = 0; i < _runtimeMesh.numTriangles; i++) {  					int baseIdx = i * 3;  					Vector3 p0 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx);  					Vector3 p1 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 1);  					Vector3 p2 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 2);    					Vector3 face_normal = Vector3.Cross(p1 - p0' p2 - p0).Normalized();    					int v0 = _runtimeMesh.indices[baseIdx];  					int v1 = _runtimeMesh.indices[baseIdx + 1];  					int v2 = _runtimeMesh.indices[baseIdx + 2];    					perVertexNormals[v0] += face_normal;  					perVertexNormals[v1] += face_normal;  					perVertexNormals[v2] += face_normal;    				}
Magic Number,SimpleScene.Demos,RenderSubMesh,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Skeletal\SSSkeletalRenderMesh.cs,renderFaceAveragedVertexNormals,The following statement contains a magic number: for (int i = 0; i < _runtimeMesh.numTriangles; i++) {  					int baseIdx = i * 3;  					Vector3 p0 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx);  					Vector3 p1 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 1);  					Vector3 p2 = _runtimeMesh.computeVertexPosFromTriIndex(baseIdx + 2);    					Vector3 face_normal = Vector3.Cross(p1 - p0' p2 - p0).Normalized();    					int v0 = _runtimeMesh.indices[baseIdx];  					int v1 = _runtimeMesh.indices[baseIdx + 1];  					int v2 = _runtimeMesh.indices[baseIdx + 2];    					perVertexNormals[v0] += face_normal;  					perVertexNormals[v1] += face_normal;  					perVertexNormals[v2] += face_normal;    				}
Magic Number,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,OnRenderFrame,The following statement contains a magic number: float fovy = (float)Math.PI / 4;
Magic Number,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,setupScene,The following statement contains a magic number: if (light.ShadowMap != null) {                  shadowmapDebugQuad = new SSObjectHUDQuad (light.ShadowMap.TextureID);                  shadowmapDebugQuad.Scale = new Vector3(0.3f);                  shadowmapDebugQuad.Pos = new Vector3(50f' 200' 0f);                  hud2dScene.AddObject(shadowmapDebugQuad);              }
Magic Number,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,setupEnvironment,The following statement contains a magic number: skyboxStars = new SStarfieldObject(1600);
Magic Number,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,TargetSpecific,The following statement contains a magic number: const int numCircleVertices = 16;
Magic Number,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,preRenderUpdate,The following statement contains a magic number: if (_outline.enableLineStipple) {                      ushort stipplePattern = _outline.lineStipplePattern;                      _stippleTimeAccumulator += timeElapsed;                      while (_stippleTimeAccumulator >= stippleStepInterval) {                          ushort firstBit = (ushort)((uint)stipplePattern & 0x1);                          stipplePattern >>= 1;                          stipplePattern |= (ushort)((uint)firstBit << 15);                          _outline.lineStipplePattern = stipplePattern;                            _stippleTimeAccumulator -= stippleStepInterval;                      }                  }
Magic Number,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,preRenderUpdate,The following statement contains a magic number: int orientIdx = (above ? 1 : 0) + (below ? 2 : 0) + (left ? 4 : 0) + (right ? 8 : 0);
Magic Number,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,preRenderUpdate,The following statement contains a magic number: int orientIdx = (above ? 1 : 0) + (below ? 2 : 0) + (left ? 4 : 0) + (right ? 8 : 0);
Magic Number,SimpleScene.Demos,TargetSpecific,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SHudTargetsManager.cs,preRenderUpdate,The following statement contains a magic number: int orientIdx = (above ? 1 : 0) + (below ? 2 : 0) + (left ? 4 : 0) + (right ? 8 : 0);
Magic Number,SimpleScene.Demos,ExplosionChainInfo,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,update,The following statement contains a magic number: for (int i = 0; i < _delaysRemaining.Length; ++i) {                      if (_explosionsRemaining > 0 && _delaysRemaining [i] <= 0f) {                          float intensity = _chainParams.minIntensity                              + (float)rand.NextDouble() * (_chainParams.maxIntensity - _chainParams.minIntensity);                          double r = _chainParams.radiusMin                               + rand.NextDouble() * (_chainParams.radiusMax - _chainParams.radiusMin);                          double theta = 2.0 * Math.PI * rand.NextDouble();                          double phi = Math.PI * (rand.NextDouble() - 0.5);                          double xy = r * Math.Cos(theta);                          Vector3 radialOffset = new Vector3 (                              (float)(xy * Math.Cos(theta))'                              (float)(xy * Math.Sin(theta))'                              (float)(r * Math.Sin(phi)));                                                    Vector3 pos = _position + radialOffset;                          double spreadVelScale = _chainParams.spreadVelocityMin                                  + rand.NextDouble() * (_chainParams.spreadVelocityMax - _chainParams.spreadVelocityMin);                          Vector3 vel = _velocity;                          if (radialOffset.LengthFast > 0f) {                              var radialDir = radialOffset.Normalized();                              var radialVelOffset = (float)spreadVelScale * radialDir;                              pos += radialVelOffset * _timeElapsedTotal;                              vel += radialVelOffset ;                          }                          _em.showExplosion(_chainParams' intensity' pos'  vel);                             _delaysRemaining [i] = _chainParams.minDelay                              + (float)rand.NextDouble() * (_chainParams.maxDelay - _chainParams.minDelay);                            --_explosionsRemaining;                      }                      _delaysRemaining [i] -= timeElapsed;                  }
Magic Number,SimpleScene.Demos,ExplosionChainInfo,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,update,The following statement contains a magic number: for (int i = 0; i < _delaysRemaining.Length; ++i) {                      if (_explosionsRemaining > 0 && _delaysRemaining [i] <= 0f) {                          float intensity = _chainParams.minIntensity                              + (float)rand.NextDouble() * (_chainParams.maxIntensity - _chainParams.minIntensity);                          double r = _chainParams.radiusMin                               + rand.NextDouble() * (_chainParams.radiusMax - _chainParams.radiusMin);                          double theta = 2.0 * Math.PI * rand.NextDouble();                          double phi = Math.PI * (rand.NextDouble() - 0.5);                          double xy = r * Math.Cos(theta);                          Vector3 radialOffset = new Vector3 (                              (float)(xy * Math.Cos(theta))'                              (float)(xy * Math.Sin(theta))'                              (float)(r * Math.Sin(phi)));                                                    Vector3 pos = _position + radialOffset;                          double spreadVelScale = _chainParams.spreadVelocityMin                                  + rand.NextDouble() * (_chainParams.spreadVelocityMax - _chainParams.spreadVelocityMin);                          Vector3 vel = _velocity;                          if (radialOffset.LengthFast > 0f) {                              var radialDir = radialOffset.Normalized();                              var radialVelOffset = (float)spreadVelScale * radialDir;                              pos += radialVelOffset * _timeElapsedTotal;                              vel += radialVelOffset ;                          }                          _em.showExplosion(_chainParams' intensity' pos'  vel);                             _delaysRemaining [i] = _chainParams.minDelay                              + (float)rand.NextDouble() * (_chainParams.maxDelay - _chainParams.minDelay);                            --_explosionsRemaining;                      }                      _delaysRemaining [i] -= timeElapsed;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,configureFlameSmoke,The following statement contains a magic number: if (_eParams.doFlameSmoke) {                      if (_flameSmokeEmitter == null) {                          _flameSmokeEmitter = new SSRadialEmitter ();                          _flamesSmokeColorEffector = new SSColorKeyframesEffector ();                          _flameSmokeScaleEffector = new SSMasterScaleKeyframesEffector ();                          addEmitter(_flameSmokeEmitter);                          addEffector(_flamesSmokeColorEffector);                          addEffector(_flameSmokeScaleEffector);                          _flameSmokeEmitter.effectorMask = _flameSmokeScaleEffector.effectorMask                               = _flamesSmokeColorEffector.effectorMask = (ushort)ComponentMask.FlameSmoke;                      }                        _flameSmokeEmitter.spriteRectangles = _eParams.flameSmokeSprites;                      _flameSmokeEmitter.particlesPerEmission = 2;                      _flameSmokeEmitter.emissionInterval = 0.03f * _eParams.flameSmokeDuration;                      _flameSmokeEmitter.totalEmissionsLeft = 0; // Control this in ShowExplosion()                      _flameSmokeEmitter.life = _eParams.flameSmokeDuration;                      _flameSmokeEmitter.orientationMin = new Vector3 (0f' 0f' 0f);                      _flameSmokeEmitter.orientationMax = new Vector3 (0f' 0f' 2f * (float)Math.PI);                      _flameSmokeEmitter.billboardXY = true;                      _flameSmokeEmitter.angularVelocityMin = new Vector3 (0f' 0f' -0.5f);                      _flameSmokeEmitter.angularVelocityMax = new Vector3 (0f' 0f' +0.5f);                      _flameSmokeEmitter.radiusOffsetMin = 0f;                      _flameSmokeEmitter.radiusOffsetMax = 0.5f;                        _flamesSmokeColorEffector.colorMask = _eParams.flameColor;                      _flamesSmokeColorEffector.particleLifetime = _eParams.flameSmokeDuration;                      _flamesSmokeColorEffector.keyframes.Clear();                      _flamesSmokeColorEffector.keyframes.Add(0f' new Color4 (1f' 1f' 1f' 1f));                      _flamesSmokeColorEffector.keyframes.Add(0.4f' new Color4 (0f' 0f' 0f' 0.5f));                      _flamesSmokeColorEffector.keyframes.Add(1f' new Color4 (0f' 0f' 0f' 0f));                        _flameSmokeScaleEffector.particleLifetime = _eParams.flameSmokeDuration;                      _flameSmokeScaleEffector.keyframes.Clear();                      _flameSmokeScaleEffector.keyframes.Add(0f' 0.1f);                      _flameSmokeScaleEffector.keyframes.Add(0.25f' 1f);                      _flameSmokeScaleEffector.keyframes.Add(1f' 1.2f);                  } else if (_flameSmokeEmitter != null) {                      removeEmitter(_flameSmokeEmitter);                      removeEffector(_flamesSmokeColorEffector);                      removeEffector(_flameSmokeScaleEffector);                      _flameSmokeEmitter = null;                      _flamesSmokeColorEffector = null;                      _flameSmokeScaleEffector = null;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,emitFlameSmoke,The following statement contains a magic number: _flameSmokeEmitter.totalEmissionsLeft = 5;
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,configureFlash,The following statement contains a magic number: if (_eParams.doFlash) {                      if (_flashEmitter == null) {                          _flashEmitter = new SSParticlesFieldEmitter (new ParticlesSphereGenerator ());                          _flashColorEffector = new SSColorKeyframesEffector ();                          _flashScaleEffector = new SSMasterScaleKeyframesEffector ();                          addEmitter(_flashEmitter);                          addEffector(_flashColorEffector);                          addEffector(_flashScaleEffector);                          _flashEmitter.effectorMask = _flashColorEffector.effectorMask                               = _flashScaleEffector.effectorMask = (ushort)ComponentMask.Flash;                      }                        _flashEmitter.spriteRectangles = _eParams.flashSprites;                      _flashEmitter.particlesPerEmissionMin = 1;                      _flashEmitter.particlesPerEmissionMax = 2;                      _flashEmitter.emissionIntervalMin = 0f;                      _flashEmitter.emissionIntervalMax = 0.2f * _eParams.flashDuration;                      _flashEmitter.life = _eParams.flashDuration;                      _flashEmitter.velocity = Vector3.Zero;                      _flashEmitter.orientationMin = new Vector3 (0f' 0f' 0f);                      _flashEmitter.orientationMax = new Vector3 (0f' 0f' 2f * (float)Math.PI);                      _flashEmitter.billboardXY = true;                      _flashEmitter.totalEmissionsLeft = 0; // Control this in ShowExplosion()                        _flashColorEffector.particleLifetime = _eParams.flashDuration;                      _flashColorEffector.colorMask = _eParams.flashColor;                      _flashColorEffector.keyframes.Clear();                      _flashColorEffector.keyframes.Add(0f' new Color4 (1f' 1f' 1f' 1f));                      _flashColorEffector.keyframes.Add(1f' new Color4 (1f' 1f' 1f' 0f));                        _flashScaleEffector.particleLifetime = _eParams.flashDuration;                      _flashScaleEffector.keyframes.Clear();                      _flashScaleEffector.keyframes.Add(0f' 1f);                      _flashScaleEffector.keyframes.Add(1f' 1.5f);                  } else if (_flashEmitter != null) {                      removeEmitter(_flashEmitter);                      removeEffector(_flashColorEffector);                      removeEffector(_flashScaleEffector);                      _flashEmitter = null;                      _flashColorEffector = null;                      _flashScaleEffector = null;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,emitFlash,The following statement contains a magic number: _flashEmitter.totalEmissionsLeft = 2;
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,emitFlyingSparks,The following statement contains a magic number: _flyingSparksEmitter.particlesPerEmission = (int)(5.0*Math.Log(intensity));
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,configureSmokeTrails,The following statement contains a magic number: if (_eParams.doSmokeTrails) {                      if (_smokeTrailsEmitter == null) {                          _smokeTrailsEmitter = new SSRadialEmitter ();                          _smokeTrailsColorEffector = new SSColorKeyframesEffector ();                          _smokeTrailsScaleEffector = new SSComponentScaleKeyframeEffector ();                          addEmitter(_smokeTrailsEmitter);                          addEffector(_smokeTrailsColorEffector);                          addEffector(_smokeTrailsScaleEffector);                          _smokeTrailsEmitter.effectorMask = _smokeTrailsColorEffector.effectorMask                              = _smokeTrailsScaleEffector.effectorMask = (ushort)ComponentMask.SmokeTrails;                      }                        _smokeTrailsEmitter.radiusOffset = 3f;                      _smokeTrailsEmitter.spriteRectangles = _eParams.smokeTrailsSprites;                      _smokeTrailsEmitter.particlesPerEmission = 16;                      _smokeTrailsEmitter.emissionIntervalMin = 0f;                      _smokeTrailsEmitter.emissionIntervalMax = 0.1f * _eParams.smokeTrailsDuration;                      _smokeTrailsEmitter.life = _eParams.smokeTrailsDuration;                      _smokeTrailsEmitter.totalEmissionsLeft = 0; // control this in ShowExplosion()                      _smokeTrailsEmitter.color = _eParams.smokeTrailsColor;                        _smokeTrailsColorEffector.particleLifetime = _eParams.smokeTrailsDuration;                      _smokeTrailsColorEffector.colorMask = _eParams.smokeTrailsColor;                      _smokeTrailsColorEffector.keyframes.Clear();                      _smokeTrailsColorEffector.keyframes.Add(0f' new Color4 (1f' 1f' 1f' 1f));                      _smokeTrailsColorEffector.keyframes.Add(1f' new Color4 (0.3f' 0.3f' 0.3f' 0f));                        _smokeTrailsScaleEffector.particleLifetime = _eParams.smokeTrailsDuration;                      _smokeTrailsScaleEffector.baseOffset = new Vector3 (1f' 1f' 1f);                      _smokeTrailsScaleEffector.keyframes.Clear();                      _smokeTrailsScaleEffector.keyframes.Add(0f' new Vector3 (0f));                      _smokeTrailsScaleEffector.keyframes.Add(0.5f' new Vector3 (12f' 1.5f' 0f));                      _smokeTrailsScaleEffector.keyframes.Add(1f' new Vector3 (7f' 2f' 0f));                  } else if (_smokeTrailsEmitter != null) {                      removeEmitter(_smokeTrailsEmitter);                      removeEffector(_smokeTrailsColorEffector);                      removeEffector(_smokeTrailsScaleEffector);                      _smokeTrailsEmitter = null;                      _smokeTrailsColorEffector = null;                      _smokeTrailsScaleEffector = null;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,emitSmokeTrails,The following statement contains a magic number: _smokeTrailsEmitter.particlesPerEmission = (int)(5.0*Math.Log(intensity));
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,configureRoundSparks,The following statement contains a magic number: if (_eParams.doRoundSparks) {                      _roundSparksEmitter = new SSRadialEmitter ();                      _roundSparksColorEffector = new SSColorKeyframesEffector ();                      _roundSparksScaleEffector = new SSMasterScaleKeyframesEffector ();                      addEmitter (_roundSparksEmitter);                      addEffector (_roundSparksColorEffector);                      addEffector (_roundSparksScaleEffector);                      _roundSparksEmitter.effectorMask = _roundSparksScaleEffector.effectorMask                           = _roundSparksColorEffector.effectorMask = (ushort)ComponentMask.RoundSparks;                        _roundSparksEmitter.spriteRectangles = _eParams.roundSparksSprites;                      _roundSparksEmitter.particlesPerEmission = 6;                      _roundSparksEmitter.emissionIntervalMin = 0f;                      _roundSparksEmitter.emissionIntervalMax = 0.05f * _eParams.roundSparksDuration;                      _roundSparksEmitter.totalEmissionsLeft = 0; // Control this in ShowExplosion()                      _roundSparksEmitter.life = _eParams.roundSparksDuration;                      _roundSparksEmitter.billboardXY = true;                      _roundSparksEmitter.orientationMin = new Vector3 (0f' 0f' 0f);                      _roundSparksEmitter.orientationMax = new Vector3 (0f' 0f' 2f * (float)Math.PI);                      _roundSparksEmitter.angularVelocityMin = new Vector3 (0f' 0f' -0.25f);                      _roundSparksEmitter.angularVelocityMax = new Vector3 (0f' 0f' +0.25f);                      _roundSparksEmitter.radiusOffsetMin = 0f;                      _roundSparksEmitter.radiusOffsetMax = 1f;                        _roundSparksColorEffector.particleLifetime = _eParams.roundSparksDuration;                      _roundSparksColorEffector.colorMask = _eParams.roundSparksColor;                      _roundSparksColorEffector.keyframes.Clear();                      _roundSparksColorEffector.keyframes.Add(0.1f' new Color4 (1f' 1f' 1f' 1f));                      _roundSparksColorEffector.keyframes.Add(1f' new Color4 (1f' 1f' 1f' 0f));                        _roundSparksScaleEffector.particleLifetime = _eParams.roundSparksDuration;                      _roundSparksScaleEffector.keyframes.Clear();                      _roundSparksScaleEffector.keyframes.Add(0f' 1f);                      _roundSparksScaleEffector.keyframes.Add(0.25f' 3f);                      _roundSparksScaleEffector.keyframes.Add(1f' 6f);                  } else if (_roundSparksEmitter != null) {                      removeEmitter(_roundSparksEmitter);                      removeEffector(_roundSparksColorEffector);                      removeEffector(_roundSparksScaleEffector);                      _roundSparksEmitter = null;                      _roundSparksColorEffector = null;                      _roundSparksScaleEffector = null;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,emitRoundSparks,The following statement contains a magic number: _roundSparksEmitter.totalEmissionsLeft = 3;
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,configureDebris,The following statement contains a magic number: if (_eParams.doDebris) {                      if (_debrisEmitter == null) {                          _debrisEmitter = new SSRadialEmitter ();                          _debrisColorEffector = new SSColorKeyframesEffector ();                          addEmitter (_debrisEmitter);                          addEffector (_debrisColorEffector);                          _debrisEmitter.effectorMask = _debrisColorEffector.effectorMask                              = (ushort)ComponentMask.Debris;                      }                      _debrisEmitter.spriteRectangles = _eParams.debrisSprites;                      _debrisEmitter.particlesPerEmissionMin = 7;                      _debrisEmitter.particlesPerEmissionMax = 10;                      _debrisEmitter.totalEmissionsLeft = 0; // Control this in ShowExplosion()                      _debrisEmitter.life = _eParams.debrisDuration;                      _debrisEmitter.orientationMin = new Vector3 (0f' 0f' 0f);                      _debrisEmitter.orientationMax = new Vector3 (0f' 0f' 2f * (float)Math.PI);                      _debrisEmitter.billboardXY = true;                      _debrisEmitter.angularVelocityMin = new Vector3 (0f' 0f' -0.5f);                      _debrisEmitter.angularVelocityMax = new Vector3 (0f' 0f' +0.5f);                      _debrisEmitter.radiusOffsetMin = 0f;                      _debrisEmitter.radiusOffsetMax = 1f;                        var debrisColorFinal = new Color4 (_eParams.debrisColorEnd.R'                           _eParams.debrisColorEnd.G' _eParams.debrisColorEnd.B' 0f);                      _debrisColorEffector.particleLifetime = _eParams.debrisDuration;                      _debrisColorEffector.keyframes.Clear();                      _debrisColorEffector.keyframes.Add(0f' _eParams.debrisColorStart);                      _debrisColorEffector.keyframes.Add(0.3f' _eParams.debrisColorEnd);                      _debrisColorEffector.keyframes.Add(1f' debrisColorFinal);                  } else if (_debrisEmitter != null) {                      removeEmitter(_debrisEmitter);                      removeEffector(_debrisColorEffector);                      _debrisEmitter = null;                      _debrisColorEffector = null;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,configureDebris,The following statement contains a magic number: if (_eParams.doDebris) {                      if (_debrisEmitter == null) {                          _debrisEmitter = new SSRadialEmitter ();                          _debrisColorEffector = new SSColorKeyframesEffector ();                          addEmitter (_debrisEmitter);                          addEffector (_debrisColorEffector);                          _debrisEmitter.effectorMask = _debrisColorEffector.effectorMask                              = (ushort)ComponentMask.Debris;                      }                      _debrisEmitter.spriteRectangles = _eParams.debrisSprites;                      _debrisEmitter.particlesPerEmissionMin = 7;                      _debrisEmitter.particlesPerEmissionMax = 10;                      _debrisEmitter.totalEmissionsLeft = 0; // Control this in ShowExplosion()                      _debrisEmitter.life = _eParams.debrisDuration;                      _debrisEmitter.orientationMin = new Vector3 (0f' 0f' 0f);                      _debrisEmitter.orientationMax = new Vector3 (0f' 0f' 2f * (float)Math.PI);                      _debrisEmitter.billboardXY = true;                      _debrisEmitter.angularVelocityMin = new Vector3 (0f' 0f' -0.5f);                      _debrisEmitter.angularVelocityMax = new Vector3 (0f' 0f' +0.5f);                      _debrisEmitter.radiusOffsetMin = 0f;                      _debrisEmitter.radiusOffsetMax = 1f;                        var debrisColorFinal = new Color4 (_eParams.debrisColorEnd.R'                           _eParams.debrisColorEnd.G' _eParams.debrisColorEnd.B' 0f);                      _debrisColorEffector.particleLifetime = _eParams.debrisDuration;                      _debrisColorEffector.keyframes.Clear();                      _debrisColorEffector.keyframes.Add(0f' _eParams.debrisColorStart);                      _debrisColorEffector.keyframes.Add(0.3f' _eParams.debrisColorEnd);                      _debrisColorEffector.keyframes.Add(1f' debrisColorFinal);                  } else if (_debrisEmitter != null) {                      removeEmitter(_debrisEmitter);                      removeEffector(_debrisColorEffector);                      _debrisEmitter = null;                      _debrisColorEffector = null;                  }
Magic Number,SimpleScene.Demos,SExplosionSystem,C:\repos\jeske_SimpleScene\SimpleScene\Extra\SExplosionManager.cs,emitDebris,The following statement contains a magic number: _debrisEmitter.particlesPerEmission = (int)(2.5*Math.Log(intensity));
Missing Default,SimpleScene,SSWavefrontMTLInfo,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\SSWavefrontMTLInfo.cs,ReadMTLs,The following switch statement is missing a default case: switch (firstToken) {  				case "#":  					// Nothing to read' these are comments.  					break;  				case "newmtl":  // create new named material                  					parseMaterial = new SSWavefrontMTLInfo();  					materials.Add(parseMaterial);  					parseMaterial.name = lineContent;  					break;  				case "Ka": // ambient color  					parseMaterial.vAmbient = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasAmbient = true;  					break;  				case "Kd": // diffuse color  					parseMaterial.vDiffuse = WavefrontParser.readVector4(lineContent' null);  					parseMaterial.hasDiffuse = true;  					break;  				case "Ks": // specular color (weighted by Ns)                                   					parseMaterial.vSpecular = WavefrontParser.readVector4(lineContent'null);  					parseMaterial.hasSpecular = true;  					break;  				case "Ns": // specular color weight                  					parseMaterial.vSpecularWeight = WavefrontParser.parseFloat(lineContent);     					break;  				case "d":  				case "Tr": // transparency / dissolve (i.e. alpha)  					parseMaterial.fTransparency = WavefrontParser.parseFloat(lineContent);  					parseMaterial.hasTransparency = true;  					break;  				case "illum": // illumination mode                             					parseMaterial.hasIlluminationMode = true;  					parseMaterial.illuminationMode = (SSWavefrontIlluminationMode) int.Parse(lineContent);  					break;  				case "map_Kd": // diffuse color map                  					parseMaterial.diffuseTextureResourceName = lineContent;  					break;  				case "map_Ka": // ambient color map  					parseMaterial.ambientTextureResourceName = lineContent;  					break;  				case "map_Ks": // specular color map                  					parseMaterial.specularTextureResourceName = lineContent;  					break;  				case "bump":   				case "map_Bump":  				case "map_bump": // bump map    					// bump <filename> [-bm <float intensity>]               					// bump -bm <float intensity> <filename>  					string[] parts = lineContent.Split(' ');  					if (parts.Length == 1) {  						parseMaterial.bumpTextureResourceName = parts[0];  					} else {  						if (parts.Length == 3) {  							if (parts[1].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[0];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[2]);  							} else if (parts[0].Equals("-bm")) {  								parseMaterial.bumpTextureResourceName = parts[3];  								parseMaterial.bumpIntensity = WavefrontParser.parseFloat(parts[1]);  							}  						}  					}      					break;  				}
Missing Default,SimpleScene.Util.ssBVH,ssBVHNode<GO>,C:\repos\jeske_SimpleScene\SimpleScene\Util\ssBVH\ssBVH_Node.cs,tryRotate,The following switch statement is missing a default case: switch (bestRot.rot) {                      case Rot.L_RL:                      case Rot.L_RR:                      case Rot.R_LL:                      case Rot.R_LR:                          this.setDepth(nAda'this.depth);                          break;                                     }
Missing Default,SimpleScene.Util3d,WavefrontObjLoader,C:\repos\jeske_SimpleScene\SimpleScene\Util\Files\WavefrontObjLoader.cs,parseOBJ,The following switch statement is missing a default case: switch(firstToken) {                          /* unsupported features - fatal */                      case "cstype":    // curved surface type (bmatrix' bezier' bspline' cardinal' taylor)                      case "deg":       // curve attr: degree                      case "step":       // curve attr: step size                      case "bmat":      // curve attr: basis matrix                      case "surf":      // surface                      case "parm":      // curve body: paramater value                      case "trim":      // curve body: outer trimming loop                      case "hole":      // curve body: inner trimming loop                      case "scrv":      // curve body: special curve                      case "sp":        // curve body: special point                      case "end":       // curve body: end                      case "con":       // connection between free form surfaces                      case "vp":        // paramater space vertex (for free form surfaces)                        case "bevel":     // bevel interpolation                      case "c_interp":  // color interpolation                      case "d_interp":  // dissolve interpolation                      case "lod":       // level of detail                                                              case "ctech":     // Curve approximation technique                      case "stech":     // Surface approximation technique                      case "mg":        // merging group (for free form surfaces)                            throw new WavefrontObjParseException("WavefrontObjLoader.cs: fatal error' token not supported :  " + firstToken);                          /* unsupported features - warning */                      case "o":         // object name                                        case "g":         // group name                      case "s":         // smoothing group                      case "shadow_obj":// shadow casting                      case "trace_obj": // ray tracing                          Console.WriteLine("WavefrontObjLoader.cs: warning - unsupported wavefront token : " + firstToken);                          break;                            /* supported features */                      case "#":   // Nothing to read' these are comments.                                                  break;                      case "v":   // Vertex position  						positions.Add(WavefrontParser.readVector4(lineContent' null));                          break;                      case "vn":  // vertex normal direction vector  						normals.Add(WavefrontParser.readVector3(lineContent' null));                             break;                      case "vt":  // Vertex texcoordinate  						texCoords.Add(WavefrontParser.readVector2(lineContent'null));                          break;                      case "f":   // Face                      						string[] values = WavefrontParser.FilteredSplit(lineContent' null);                          int numPoints = values.Length;                                                Face face = new Face();                           face.v_idx = new Int16[numPoints];                          face.n_idx = new Int16[numPoints];                          face.tex_idx = new Int16[numPoints];  // todo: how do outside clients know if there were texcoords or not?!?!                             for (int i = 0; i < numPoints; i++)                          {                                                            // format is "loc_index[/tex_index[/normal_index]]"  e.g. 3 ; 3/2 ; 3/2/5                              // but middle part can me empty' e.g. 3//5                              string[] indexes = values[i].Split('/');                                    int iPosition = (int.Parse(indexes[0]) - 1);  // adjust 1-based index                                                  if (iPosition < 0) { iPosition += positions.Count + 1; } // adjust negative indicies                              face.v_idx[i] = (Int16)iPosition;                               numIndices++;                                                                            // initialize other indicies to not provided' in case they are missing                              face.n_idx[i] = -1;                              face.tex_idx[i] = -1;                                                            if (indexes.Length > 1)                              {                                  string tex_index = indexes[1];                                  if (tex_index != "") {                                      int iTexCoord = int.Parse(tex_index) - 1; // adjust 1-based index                                      if (iTexCoord < 0) { iTexCoord += texCoords.Count + 1; }  // adjust negative indicies                                        face.tex_idx[i] = (Int16)iTexCoord;                                  }                                    if (indexes.Length > 2)                                  {                                          hasNormals = true;                                      int iNormal = int.Parse(indexes[2]) - 1; // adjust 1 based index                                      if (iNormal < 0) { iNormal += normals.Count + 1; } // adjust negative indicies                                        face.n_idx[i] = (Int16)iNormal;                                                                  }                              }                          }                          if (currentMaterial == null) {                              // no material in file' so create one                              currentMaterial = createImplicitMaterial();                          }                          currentMaterial.faces.Add(face);                          currentMaterial.nbrIndices += face.v_idx.Length;                          numFaces++;                                                                      break;                      case "mtllib":  // load named material file                          string mtlFile = lineContent;  						{                          var mtls = SSWavefrontMTLInfo.ReadMTLs (Path.Combine(basePath' mtlFile));  							foreach (var mtl in mtls) {  								materials.Add (new MaterialInfoWithFaces (mtl));  							}  						}                          break;                      case "usemtl":  // use named material (from material file previously loaded)                          bool found = false;                            string matName = lineContent;                            for (int i = 0; i < materials.Count; i++)                          {                              if (matName.Equals(materials[i].mtl.name))                              {                                  found = true;                                  currentMaterial = materials[i];                                                          }                          }                            if (!found)                          {                              throw new WavefrontObjParseException("Materials are already loaded so we should have it!");                          }                          break;                  }
Missing Default,SimpleScene.Demos,TestBenchBootstrap,C:\repos\jeske_SimpleScene\SimpleScene\Extra\TestBenchBootstrap\TestBenchBootstrap.cs,keyUpHandler,The following switch statement is missing a default case: switch (e.Key) {  			case Key.Number1:  				System.Console.WriteLine ("Toggling wireframe");  				if (autoWireframeMode == true) {  					autoWireframeMode = false;  				} else {                      main3dScene.renderConfig.drawWireframeMode = SSRenderConfig.NextWireFrameMode(main3dScene.renderConfig.drawWireframeMode);                      if (main3dScene.renderConfig.drawWireframeMode == WireframeMode.None) {  						autoWireframeMode = true; // rollover completes toggling modes  					}  				}  				updateTextDisplay ();  				break;  			case Key.Escape:  				Exit ();  				break;  			}
Missing Default,SimpleScene.Demos,SSpaceMissileData,C:\repos\jeske_SimpleScene\SimpleScene\Extra\Missiles\SSpaceMissilelData.cs,updateExecution,The following switch statement is missing a default case: switch (_state) {              case State.Ejection:                  if (this.timeSinceLaunch >= mParams.pursuitActivationTime) {                      state = State.Pursuit;                      if (mParams.debuggingAid) {                          Console.WriteLine("missile pursuit activated at t = " + timeSinceLaunch);                      }                  }                  break;              case State.Pursuit:                  bool forceHit = (mParams.pursuitHitTimeCorrection && timeToHit <= 0f);                  if (forceHit) {                      // fake a velocity large enough to make hit test succeeed                      velocity = target.velocity                          + (target.position - this.position) / timeElapsed;                      if (mParams.debuggingAid) {                          Console.WriteLine("forcing missile at target (hit time correction)");                      }                  }                   Vector3 hitPos;                  bool hitTestSucceeded = target.hitTest(this' out hitPos);                  if (hitTestSucceeded || forceHit) {                      position = hitTestSucceeded ? hitPos : target.position;                      velocity = Vector3.Zero;                      state = State.AtTarget;                      if (mParams.debuggingAid) {                          Console.WriteLine("missile at target at t = " + timeSinceLaunch);                          if (float.IsNaN(position.X)) {                              Console.WriteLine("bad position");                          }                      }                      if (this.atTargetFunc != null) {                          this.atTargetFunc(this);                      }                  }                  break;              case State.AtTarget:                  if (mParams.terminateWhenAtTarget) {                      state = State.Terminated;                      if (mParams.debuggingAid) {                          Console.WriteLine("missile terminated at target at t = " + timeSinceLaunch);                      }                  }                  break;              case State.FadingOut:                  if ((_sharableData.timeSinceLaunch - _sharableData.fadeTime) >= mParams.fadeDuration) {                      state = State.Terminated;                      if (mParams.debuggingAid) {                          Console.WriteLine("missile terminated after fading at t = " + timeSinceLaunch);                      }                  }                  break;              case State.Intercepted:                  // todo                  break;              case State.Terminated:                  //throw new Exception ("missile state machine still running while in the terminated state");                  break;              }
