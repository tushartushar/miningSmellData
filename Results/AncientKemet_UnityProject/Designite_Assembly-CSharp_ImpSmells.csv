Implementation smell,Namespace,Class,File,Method,Description
Long Method,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ClosestPointOnTriangle,The method has 187 lines of code.
Long Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The method has 124 lines of code.
Long Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The method has 137 lines of code.
Long Method,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The method has 121 lines of code.
Long Method,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The method has 105 lines of code.
Long Method,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The method has 110 lines of code.
Long Method,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,The method has 153 lines of code.
Long Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The method has 149 lines of code.
Long Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The method has 137 lines of code.
Long Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The method has 130 lines of code.
Long Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The method has 100 lines of code.
Long Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 100 lines of code.
Complex Method,Pathfinding,AstarData,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphsPartAdditive,Cyclomatic complexity of the method is 12
Complex Method,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ClosestPointOnTriangle,Cyclomatic complexity of the method is 25
Complex Method,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,DistanceSegmentSegment3D,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,Apply,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,AnimationLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,Cyclomatic complexity of the method is 18
Complex Method,Pathfinding,GraphModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\GraphModifier.cs,TriggerEvent,Cyclomatic complexity of the method is 19
Complex Method,Pathfinding,NodeLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink.cs,LinkObjects,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,ThreadControlQueue,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,Pop,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,ThreadControlQueue,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,PopNoBlock,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Trace,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,PathHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,Cyclomatic complexity of the method is 13
Complex Method,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,Cyclomatic complexity of the method is 21
Complex Method,Pathfinding,GraphCollision,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,Check,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,Cyclomatic complexity of the method is 25
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ScanInternal,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateNodePositionCollision,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,Cyclomatic complexity of the method is 24
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,Cyclomatic complexity of the method is 14
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,Cyclomatic complexity of the method is 29
Complex Method,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,Cyclomatic complexity of the method is 15
Complex Method,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,OnDrawGizmos,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,TriangleMeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,Open,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,TriangleMeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,GetPortal,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,ScanInternal,Cyclomatic complexity of the method is 17
Complex Method,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,Cyclomatic complexity of the method is 19
Complex Method,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,Cyclomatic complexity of the method is 43
Complex Method,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,Cyclomatic complexity of the method is 19
Complex Method,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,ValidateLine,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,Apply,Cyclomatic complexity of the method is 14
Complex Method,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothSimple,Cyclomatic complexity of the method is 16
Complex Method,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,Cyclomatic complexity of the method is 12
Complex Method,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,Prepare,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,DebugString,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,Cyclomatic complexity of the method is 14
Complex Method,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,Cyclomatic complexity of the method is 21
Complex Method,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,Cyclomatic complexity of the method is 11
Complex Method,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,Code.Core.Client.Controls,KeyboardInput,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\KeyboardInput.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,Code.Core.Client.Net,PlayerPacketExecutor,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Net\PlayerPacketExecutor.cs,aExecutePacket,Cyclomatic complexity of the method is 16
Complex Method,Code.Core.Client.UI.Controls,CircleButton,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\CircleButton.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,Code.Core.Client.UI.Controls,Clickable,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Clickable.cs,OnMouseOver,Cyclomatic complexity of the method is 14
Complex Method,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,Cyclomatic complexity of the method is 40
Complex Method,Code.Core.Client.UI.Controls.Items,ItemInventoryInterface,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventoryInterface.cs,Handle,Cyclomatic complexity of the method is 24
Complex Method,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,Cyclomatic complexity of the method is 26
Complex Method,Server.Model.Extensions.PlayerExtensions.UIHelpers,ClientUI,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\PlayerExtensions\UIHelpers\ClientUI.cs,OnUIEvent,Cyclomatic complexity of the method is 9
Complex Method,Server.Model.Extensions.UnitExts,UnitActions,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitActions.cs,HandleIncommingAction,Cyclomatic complexity of the method is 10
Complex Method,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,Progress,Cyclomatic complexity of the method is 11
Complex Method,Server.Net,ClientPacketExecutor,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Net\ClientPacketExecutor.cs,aExecutePacket,Cyclomatic complexity of the method is 16
Complex Method,Server.SQL,SQLSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\SQL\SQLSerializer.cs,CacheType,Cyclomatic complexity of the method is 11
Complex Method,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding.Serialization,UnityObjectConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,Cyclomatic complexity of the method is 8
Complex Method,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeExtraInfo,Cyclomatic complexity of the method is 9
Complex Method,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeNodes,Cyclomatic complexity of the method is 10
Complex Method,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,Cyclomatic complexity of the method is 14
Complex Method,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Triangulate,Cyclomatic complexity of the method is 13
Complex Method,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,Update,Cyclomatic complexity of the method is 26
Complex Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,Cyclomatic complexity of the method is 40
Complex Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,AddField,Cyclomatic complexity of the method is 8
Complex Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,MergeRecur,Cyclomatic complexity of the method is 12
Complex Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,Cyclomatic complexity of the method is 61
Complex Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,Cyclomatic complexity of the method is 56
Complex Method,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,ToDictionary,Cyclomatic complexity of the method is 14
Complex Method,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,Cyclomatic complexity of the method is 9
Complex Method,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,Cyclomatic complexity of the method is 34
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,Cyclomatic complexity of the method is 15
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,Cyclomatic complexity of the method is 10
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,HideTileMapPrefabs,Cyclomatic complexity of the method is 11
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,Cyclomatic complexity of the method is 16
Complex Method,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,Cyclomatic complexity of the method is 35
Complex Method,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,Build,Cyclomatic complexity of the method is 8
Complex Method,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,Cyclomatic complexity of the method is 13
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,Cyclomatic complexity of the method is 19
Complex Method,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,Build,Cyclomatic complexity of the method is 10
Long Parameter List,Pathfinding,AstarSplines,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CatmullRom,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarSplines,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CatmullRomOLD,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,DistancePointSegment,The method has 6 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,DistancePointSegment2,The method has 6 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The method has 5 parameters.
Long Parameter List,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,MapTo,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPointOptimized,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactor,The method has 6 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactor,The method has 6 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,IntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The method has 5 parameters.
Long Parameter List,Pathfinding,IRaycastableGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,Linecast,The method has 5 parameters.
Long Parameter List,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetNodeConnection,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearest,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForce,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GetNearestForceBoth,The method has 6 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The method has 5 parameters.
Long Parameter List,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The method has 6 parameters.
Long Parameter List,Pathfinding,TriangleMeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,GetPortal,The method has 6 parameters.
Long Parameter List,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The method has 7 parameters.
Long Parameter List,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The method has 5 parameters.
Long Parameter List,Pathfinding,IFunnelGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,BuildFunnelCorridor,The method has 5 parameters.
Long Parameter List,Pathfinding,MonoModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\Modifiers.cs,Apply,The method has 6 parameters.
Long Parameter List,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,GetPointOnCubic,The method has 5 parameters.
Long Parameter List,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,BFS,The method has 5 parameters.
Long Parameter List,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPointWorld,The method has 5 parameters.
Long Parameter List,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The method has 5 parameters.
Long Parameter List,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Snip,The method has 5 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 5 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 8 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The method has 9 parameters.
Long Parameter List,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The method has 7 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,SpawnPrefabsForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,GetLoopOrder,The method has 9 parameters.
Long Parameter List,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,ApplySpriteVertexTileFlags,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Layer,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,Layer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Init,The method has 5 parameters.
Long Parameter List,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The method has 6 parameters.
Long Parameter List,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The method has 7 parameters.
Long Parameter List,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Vector,The method has 5 parameters.
Long Parameter List,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Color,The method has 5 parameters.
Long Parameter List,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Bezier3,The method has 5 parameters.
Long Statement,Pathfinding,AstarData,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphs,The length of the statement  "				Debug.Log ("Invalid data file (cannot read zip).\nThe data is either corrupt or it was saved using a 3.0.x or earlier version of the system"); " is 142.
Long Statement,Pathfinding,AstarData,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarData.cs,DeserializeGraphsPartAdditive,The length of the statement  "				Debug.LogWarning ("Guid Conflict when importing graphs additively. Imported graph will get a new Guid.\nThis message is (relatively) harmless."); " is 145.
Long Statement,Pathfinding,AstarData,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarData.cs,AddGraph,The length of the statement  "		Debug.LogError ("No NavGraph of type '" + type + "' could be found' " + graphTypes.Length + " graph types are avaliable"); " is 122.
Long Statement,Pathfinding,AstarData,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarData.cs,AddGraph,The length of the statement  "		throw new System.Exception ("Graph Count Limit Reached. You cannot have more than " + GraphNode.MaxGraphCount + " graphs. Some compiler directives can change this limit' e.g ASTAR_MORE_AREAS' look under the " + "'Optimizations' tab in the A* Inspector"); " is 254.
Long Statement,Pathfinding,AstarData,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarData.cs,GetNode,The length of the statement  "				Debug.LogError ("Node index is out of range : "+nodeIndex+ " [0-"+(graph.nodes.Length-1)+"]"+" (graph "+graphIndex+")");" is 120.
Long Statement,Pathfinding,AstarSplines,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CatmullRom,The length of the statement  "					tension*percentCompleteSquared);*/return previous * (-0.5F * percentCompleteCubed + percentCompleteSquared - 0.5F * percentComplete) + start * (1.5F * percentCompleteCubed + -2.5F * percentCompleteSquared + 1.0F) + end * (-1.5F * percentCompleteCubed + 2.0F * percentCompleteSquared + 0.5F * percentComplete) + next * (0.5F * percentCompleteCubed - 0.5F * percentCompleteSquared); " is 380.
Long Statement,Pathfinding,AstarSplines,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CatmullRomOLD,The length of the statement  "	return previous * (-0.5F * percentCompleteCubed + percentCompleteSquared - 0.5F * percentComplete) + start * (1.5F * percentCompleteCubed + -2.5F * percentCompleteSquared + 1.0F) + end * (-1.5F * percentCompleteCubed + 2.0F * percentCompleteSquared + 0.5F * percentComplete) + next * (0.5F * percentCompleteCubed - 0.5F * percentCompleteSquared); " is 346.
Long Statement,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "	return Polygon.IsClockwiseMargin (a' b' p) && Polygon.IsClockwiseMargin (b' c' p) && Polygon.IsClockwiseMargin (c' a' p); " is 121.
Long Statement,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "		if (((polyPoints [i].y <= p.y && p.y < polyPoints [j].y) || (polyPoints [j].y <= p.y && p.y < polyPoints [i].y)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.y - polyPoints [i].y) / (polyPoints [j].y - polyPoints [i].y) + polyPoints [i].x)) " is 248.
Long Statement,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The length of the statement  "		if (((polyPoints [i].z <= p.z && p.z < polyPoints [j].z) || (polyPoints [j].z <= p.z && p.z < polyPoints [i].z)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.z - polyPoints [i].z) / (polyPoints [j].z - polyPoints [i].z) + polyPoints [i].x)) " is 248.
Long Statement,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The length of the statement  "	//Debug.Log ("U1 "+u.ToString ("0.00")+" U2 "+u2.ToString ("0.00")+"\nP1: "+(start1 + dir1*u)+"\nP2: "+(start2 + dir2*u2)+"\nStart1: "+start1+"  End1: "+end1); " is 159.
Long Statement,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The length of the statement  "	Color c = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f); " is 125.
Long Statement,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The length of the statement  "		Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f); " is 130.
Long Statement,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The length of the statement  "			Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length])); " is 133.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "			throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug"); " is 249.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "		//Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size ("+numberOfItems +" "+binaryHeap.Length+")"); " is 154.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The length of the statement  "			//binaryHeap[bubbleIndex].f <= binaryHeap[parentIndex].f) { /* \todo Wouldn't it be more efficient with '<' instead of '<=' ? * / " is 129.
Long Statement,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Validate,The length of the statement  "			throw new System.Exception ("Invalid state at " + i + ":" + parentIndex + " ( " + binaryHeap [parentIndex].F + " > " + binaryHeap [i].F + " ) "); " is 145.
Long Statement,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The length of the statement  "	return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]); " is 135.
Long Statement,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	//This function assumes that connections from the n1'n2 nodes never need to be removed in the future (e.g because the nodes move or something) " is 142.
Long Statement,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	uint cost = (uint)Mathf.RoundToInt (((Int3)(StartTransform.position - EndTransform.position)).costMagnitude * costFactor); " is 122.
Long Statement,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,Apply,The length of the statement  "	endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The length of the statement  "				Vector3 tangent = Vector3.Dot (normal' (Vector3)(other.Position - this.Position) ) > 0 ? link.transform.right*0.5f : -link.transform.right*0.5f;" is 144.
Long Statement,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The length of the statement  "				Debug.DrawLine ( link.transform.position -tangent * link.portalWidth' link.transform.position +tangent * link.portalWidth' Color.red);" is 134.
Long Statement,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOther,The length of the statement  "	return a == connections [0] ? (connections [1] as NodeLink3Node).GetOtherInternal (this) : (connections [0] as NodeLink3Node).GetOtherInternal (this); " is 150.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,InternalOnPostScan,The length of the statement  "	startNode = AstarPath.active.astarData.pointGraph.AddNode (new NodeLink3Node (AstarPath.active)' (Int3)StartTransform.position); " is 128.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,InternalOnPostScan,The length of the statement  "	endNode = AstarPath.active.astarData.pointGraph.AddNode (new NodeLink3Node (AstarPath.active)' (Int3)EndTransform.position); " is 124.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "	//This function assumes that connections from the n1'n2 nodes never need to be removed in the future (e.g because the nodes move or something) " is 142.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "	uint cost = (uint)Mathf.RoundToInt (((Int3)(StartTransform.position - EndTransform.position)).costMagnitude * costFactor); " is 122.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error"); " is 122.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor)); " is 139.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The length of the statement  "					endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor)); " is 135.
Long Statement,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The length of the statement  "	//Gizmos.DrawLine ( transform.position - transform.right*0.5f*portalWidth' transform.position + transform.right*0.5f*portalWidth ); " is 131.
Long Statement,Pathfinding,PathPool,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\PathPool.cs,Recycle,The length of the statement  "			throw new ArgumentException ("Cannot recycle path of type '" + path.GetType ().Name + "' in a pool for path type '" + typeof(T).Name + "'.\n" + "Most likely the path type does not have support for recycling. Please do not call Recycle () on that path"); " is 253.
Long Statement,Pathfinding,ThreadControlQueue,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,Pop,The length of the statement  "				throw new System.InvalidOperationException ("More receivers are blocked than specified in constructor (" + blockedReceivers + " > " + numReceivers + ")"); " is 154.
Long Statement,Pathfinding,ThreadControlQueue,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\ThreadControlQueue.cs,PopNoBlock,The length of the statement  "					throw new System.InvalidOperationException ("More receivers are blocked than specified in constructor (" + blockedReceivers + " > " + numReceivers + ")"); " is 154.
Long Statement,Pathfinding,MeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Nodes\GraphNode.cs,ContainsPoint,The length of the statement  "		if (((GetVertex (i).z <= p.z && p.z < GetVertex (j).z) || (GetVertex (j).z <= p.z && p.z < GetVertex (i).z)) && (p.x < (GetVertex (j).x - GetVertex (i).x) * (p.z - GetVertex (i).z) / (GetVertex (j).z - GetVertex (i).z) + GetVertex (i).x)) " is 238.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The length of the statement  "		return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale); " is 143.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,ErrorCheck,The length of the statement  "		throw new System.Exception ("The path has never been reset. Use pooling API or call Reset() after creating the path with the default constructor."); " is 148.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,ErrorCheck,The length of the statement  "		throw new System.Exception ("This path has already been processed. Do not request a path with the same path object twice."); " is 124.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Reset,The length of the statement  "		throw new System.NullReferenceException ("No AstarPath object found in the scene. " + "Make sure there is one or do not create paths in Awake"); " is 144.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Claim,The length of the statement  "		throw new System.ArgumentException ("You have already claimed the path with that object (" + o.ToString () + "). Are you claiming the path with the same object twice?"); " is 169.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,ReleaseSilent,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which is not claimed at all (most likely it has been pooled already). " + "Are you releasing the path with the same object (" + o.ToString () + ") twice?"); " is 218.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,ReleaseSilent,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which has not been claimed with this object (" + o.ToString () + "). " + "Are you releasing the path with the same object twice?"); " is 193.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Release,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which is not claimed at all (most likely it has been pooled already). " + "Are you releasing the path with the same object (" + o.ToString () + ") twice?"); " is 218.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Release,The length of the statement  "		throw new System.ArgumentException ("You are releasing a path which has not been claimed with this object (" + o.ToString () + "). " + "Are you releasing the path with the same object twice?"); " is 193.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Trace,The length of the statement  "			Debug.LogWarning ("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs' Trace function)"); " is 135.
Long Statement,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,DebugString,The length of the statement  "				+"\nStart Point = "+p.startPoint+"\n"+"Start Node graph: "+p.startNode.graphIndex+" End Node graph: "+p.endNode.graphIndex+" is 123.
Long Statement,Pathfinding,PathHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The length of the statement  "		PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][]; " is 133.
Long Statement,Pathfinding,PathHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The length of the statement  "		//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")"); " is 122.
Long Statement,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,Intersection,The length of the statement  "	IntRect r = new IntRect (System.Math.Max (a.xmin' b.xmin)' System.Math.Max (a.ymin' b.ymin)' System.Math.Min (a.xmax' b.xmax)' System.Math.Min (a.ymax' b.ymax)); " is 161.
Long Statement,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,Union,The length of the statement  "	IntRect r = new IntRect (System.Math.Min (a.xmin' b.xmin)' System.Math.Min (a.ymin' b.ymin)' System.Math.Max (a.xmax' b.xmax)' System.Math.Max (a.ymax' b.ymax)); " is 161.
Long Statement,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,ExpandToContain,The length of the statement  "	IntRect r = new IntRect (System.Math.Min (xmin' x)' System.Math.Min (ymin' y)' System.Math.Max (xmax' x)' System.Math.Max (ymax' y)); " is 133.
Long Statement,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,Rotate,The length of the statement  "	return new IntRect (System.Math.Min (p1x' p2x)' System.Math.Min (p1y' p2y)' System.Math.Max (p1x' p2x)' System.Math.Max (p1y' p2y)); " is 132.
Long Statement,Pathfinding,TargetMover,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\ExampleScenes\ExampleScripts\TargetMover.cs,UpdateTargetPosition,The length of the statement  "	if (Physics.Raycast (cam.ScreenPointToRay (Input.mousePosition)' out hit' Mathf.Infinity' mask) && hit.point != target.position) { " is 130.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,GetNearest,The length of the statement  "	//Debug.LogError ("This function (GetNearest) is not implemented in the navigation graph generator : Type "+this.GetType ().Name); " is 130.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,GetNearestForce,The length of the statement  "	//Debug.LogError ("This should not be called if not GetNearest has been overriden' and if GetNearest has been overriden' you should override this function too' always return a node which returns true when passed to constraint.Suitable (node)"); " is 244.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,Scan,The length of the statement  "	throw new System.Exception ("This method is deprecated. Please use AstarPath.active.Scan or if you really want this.ScanInternal which has the same functionality as this method had."); " is 184.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "		c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.Penalty / (float)AstarPath.active.debugRoof); " is 134.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "			c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.G / (float)AstarPath.active.debugRoof); " is 129.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "			c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.H / (float)AstarPath.active.debugRoof); " is 129.
Long Statement,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,The length of the statement  "			c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.F / (float)AstarPath.active.debugRoof); " is 129.
Long Statement,Pathfinding,GraphCollision,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The length of the statement  "					Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit); " is 121.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,OnDestroy,The length of the statement  "	//Clean up a reference in a static variable which otherwise should point to this graph forever and stop the GC from collecting it " is 129.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GenerateMatrix,The length of the statement  "	SetMatrix (Matrix4x4.TRS (boundsMatrix.MultiplyPoint3x4 (-new Vector3 (size.x' 0' size.y) * 0.5F)' Quaternion.Euler (rotation)' new Vector3 (nodeSize * aspectRatio' 1' nodeSize))); " is 180.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearest,The length of the statement  "	nn.clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' x - 0.5f' x + 0.5f) + 0.5f' y' Mathf.Clamp (zf' z - 0.5f' z + 0.5f) + 0.5f)); " is 153.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "		clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' x - 0.5f' x + 0.5f) + 0.5f' y' Mathf.Clamp (zf' z - 0.5f' z + 0.5f) + 0.5f)); " is 150.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The length of the statement  "					clampedPosition = matrix.MultiplyPoint3x4 (new Vector3 (Mathf.Clamp (xf' nx - 0.5f' nx + 0.5f) + 0.5f' inverseMatrix.MultiplyPoint3x4 ((Vector3)minNode.position).y' Mathf.Clamp (zf' nz - 0.5f' nz + 0.5f) + 0.5f)); " is 213.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The length of the statement  "			Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)"); " is 172.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The length of the statement  "				//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too " is 130.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The length of the statement  "			physicsRect = new IntRect (Mathf.RoundToInt (min.x - 0.5F)' Mathf.RoundToInt (min.z - 0.5F)' Mathf.RoundToInt (max.x - 0.5F)' Mathf.RoundToInt (max.z - 0.5F)); " is 159.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,UpdateArea,The length of the statement  "				after calculation since their erosion might not be correctly calculated (nodes outside erosionRect2 would maybe have effect)" is 124.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,PostDeserialization,The length of the statement  "		Debug.LogWarning ("Node data did not match with bounds data. Probably a change to the bounds/width/depth data was made after scanning the graph just prior to saving it. Nodes will be discarded"); " is 195.
Long Statement,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,PostDeserialization,The length of the statement  "				Debug.LogError ("Deserialization Error : Couldn't cast the node to the appropriate type - GridGenerator. Check the CreateNodes function"); " is 138.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RelocateNodes,The length of the statement  "	if (vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length) { " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The length of the statement  "		Debug.LogError ("Couldn't cast graph to the appropriate type (graph isn't a Navmesh type graph' it doesn't implement the INavmesh interface)"); " is 143.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The length of the statement  "				if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) { " is 123.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The length of the statement  "	IntRect r2 = new IntRect (Mathf.FloorToInt (bounds.min.x * Int3.Precision)' Mathf.FloorToInt (bounds.min.z * Int3.Precision)' Mathf.FloorToInt (bounds.max.x * Int3.Precision)' Mathf.FloorToInt (bounds.max.z * Int3.Precision)); " is 226.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ClosestPointOnNode,The length of the statement  "	return Polygon.ClosestPointOnTriangle ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos); " is 131.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (Polygon.IsClockwise ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' pos) && Polygon.IsClockwise ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos) && Polygon.IsClockwise ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' pos)) { " is 264.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (!Polygon.IsClockwiseMargin ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' (Vector3)vertices [node.v2])) { " is 121.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,ContainsPoint,The length of the statement  "	if (Polygon.IsClockwiseMargin ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' pos) && Polygon.IsClockwiseMargin ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' pos) && Polygon.IsClockwiseMargin ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' pos)) { " is 282.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "		Debug.LogError ("One or more triangles are identical to other triangles' this is not a good thing to have in a navmesh\nIncreasing the scale of the mesh might help\nNumber of triangles with error: " + identicalError + "\n"); " is 224.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The length of the statement  "	//Debug.Log ("Graph Generation - NavMesh - Time to compute graph "+((Time.realtimeSinceStartup-startTime)*1000F).ToString ("0")+"ms"); " is 134.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RebuildBBTree,The length of the statement  "	//BBTrees is a A* Pathfinding Project Pro only feature - The Pro version can be bought in the Unity Asset Store or on arongranberg.com " is 134.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,Sort,The length of the statement  "			if (a [i].x > a [i + 1].x || (a [i].x == a [i + 1].x && (a [i].y > a [i + 1].y || (a [i].y == a [i + 1].y && a [i].z > a [i + 1].z)))) { " is 136.
Long Statement,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,OnDrawGizmos,The length of the statement  "					Gizmos.DrawLine ((Vector3)node.position' Vector3.Lerp ((Vector3)node.position' (Vector3)node.connections [q].position' 0.45f)); " is 127.
Long Statement,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,SetConnectionInternal,The length of the statement  "		gridFlags = (ushort)(gridFlags & ~((ushort)1 << GridFlagsConnectionOffset << dir) | (value ? (ushort)1 : (ushort)0) << GridFlagsConnectionOffset << dir); " is 153.
Long Statement,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,Open,The length of the statement  "					//Debug.Log ("Path better from " + NodeIndex + " to " + otherPN.node.NodeIndex + " " + (pathNode.G+tmpCost+path.GetTraversalCost(other)) + " < " + otherPN.G); " is 158.
Long Statement,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,Open,The length of the statement  "					//Debug.Log ("Path better from " + otherPN.node.NodeIndex + " to " + NodeIndex + " " + (otherPN.G+tmpCost+path.GetTraversalCost (this)) + " < " + pathNode.G); " is 158.
Long Statement,Pathfinding,TriangleMeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,ClosestPointOnNode,The length of the statement  "	return Pathfinding.Polygon.ClosestPointOnTriangle ((Vector3)g.GetVertex (v0)' (Vector3)g.GetVertex (v1)' (Vector3)g.GetVertex (v2)' p); " is 135.
Long Statement,Pathfinding,TriangleMeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,ContainsPoint,The length of the statement  "	//return Polygon.IsClockwiseMargin (a'b' p) && Polygon.IsClockwiseMargin (b'c' p) && Polygon.IsClockwiseMargin (c'a' p); " is 120.
Long Statement,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,GetNearestForce,The length of the statement  "	//Debug.LogError ("This function (GetNearest) is not implemented in the navigation graph generator : Type "+this.GetType ().Name); " is 130.
Long Statement,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,IsValidConnection,The length of the statement  "	if ((!Mathf.Approximately (limits.x' 0) && Mathf.Abs (dir.x) > limits.x) || (!Mathf.Approximately (limits.y' 0) && Mathf.Abs (dir.y) > limits.y) || (!Mathf.Approximately (limits.z' 0) && Mathf.Abs (dir.z) > limits.z)) { " is 219.
Long Statement,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,IsValidConnection,The length of the statement  "				if (!Physics.SphereCast (ray' thickRaycastRadius' dist' mask) && !Physics.SphereCast (invertRay' thickRaycastRadius' dist' mask)) { " is 131.
Long Statement,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,LocalToWorldPosition,The length of the statement  "	/** \bug Change to XY plane' matrix should handle rotation */return new Vector3 ((x + width * 0.5f) * nodeSize' 0' (y + width * 0.5f) * nodeSize); " is 146.
Long Statement,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The length of the statement  "			if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) { " is 141.
Long Statement,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "			if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) { " is 399.
Long Statement,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "					mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3])); " is 165.
Long Statement,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "					mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3])); " is 165.
Long Statement,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The length of the statement  "					while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face. " is 131.
Long Statement,Pathfinding,AlternativePath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\AlternativePath.cs,InversePrevious,The length of the statement  "			Debug.LogWarning ("Penalty for some nodes has been reset while this modifier was active. Penalties might not be correctly set."); " is 129.
Long Statement,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The length of the statement  "	while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) { " is 155.
Long Statement,Pathfinding,ModifierConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\Modifiers.cs,Convert,The length of the statement  "		return ModifierData.VectorPath | (AnyBits (input' ModifierData.StrictNodePath) ? ModifierData.StrictVectorPath : ModifierData.None); " is 132.
Long Statement,Pathfinding,ModifierConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\Modifiers.cs,Convert,The length of the statement  "	Debug.LogError ("This part should not be reached - Error in ModifierConverted\nInput: " + input + " (" + (int)input + ")\nOutput: " + output + " (" + (int)output + ")"); " is 169.
Long Statement,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The length of the statement  "		Debug.LogWarning ("Max Segment Length is <= 0 which would cause DivByZero-exception or other nasty errors (avoid this)"); " is 121.
Long Statement,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The length of the statement  "		Vector3 endVel1 = i < path.Count - 2 ? ((path [i + 2] - path [i + 1]).normalized - (path [i] - path [i + 1]).normalized).normalized : (path [i + 1] - path [i]).normalized; " is 171.
Long Statement,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The length of the statement  "		pStart = AstarMath.NearestPointStrict ((Vector3)p.path [0].position' (Vector3)p.path [1 >= p.path.Count ? 0 : 1].position' pStart); " is 131.
Long Statement,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The length of the statement  "		pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd); " is 160.
Long Statement,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The length of the statement  "		//Vector3[] newPath = new Vector3[p.vectorPath.Length+(exactStartPoint != Exactness.SnapToNode ? 1 : 0) + (exactEndPoint  != Exactness.SnapToNode ? 1 : 0)]; " is 156.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - (b == endNode ? hTarget : b.position)).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 149.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - (a == endNode ? hTarget : a.position)).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 149.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - b.position).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 122.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,GetConnectionSpecialCost,The length of the statement  "			return (uint)((startIntPoint - a.position).costMagnitude * (currentCost * 1.0 / (a.position - b.position).costMagnitude)); " is 122.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,Prepare,The length of the statement  "	//Tell the NNConstraint which node was found as the start node if it is a PathNNConstraint and not a normal NNConstraint " is 120.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,Prepare,The length of the statement  "		LogError ("There is no valid path to the target (start area: " + startNode.Area + "' target area: " + endNode.Area + ")"); " is 122.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,Initialize,The length of the statement  "				callback += ResetCosts; /* \todo Might interfere with other paths since other paths might be calculated before #callback is called *" is 132.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The length of the statement  "			//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag " is 131.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,DebugString,The length of the statement  "			//text.Append (pathHandler.open == null ? "Null" : (pathHandler.open.numberOfItems-2).ToString ());// -2 because numberOfItems includes the next item to be added and item zero is not used " is 187.
Long Statement,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,DebugString,The length of the statement  "				+"\nStart Point = "+p.startPoint+"\n"+"Start Node graph: "+p.startNode.graphIndex+" End Node graph: "+p.endNode.graphIndex+" is 123.
Long Statement,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The length of the statement  "		output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   "); " is 152.
Long Statement,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The length of the statement  "	output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20)); " is 198.
Long Statement,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The length of the statement  "					p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0); " is 152.
Long Statement,Pathfinding,Profile,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\ProfileHelper.cs,Control,The length of the statement  "		throw new System.Exception ("Control numbers do not match (" + name + " " + other.name + ") " + this.ControlValue () + " != " + other.ControlValue ()); " is 151.
Long Statement,Pathfinding,Profile,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\ProfileHelper.cs,ToString,The length of the statement  "	string s = name + " #" + counter + " " + w.Elapsed.TotalMilliseconds.ToString ("0.0 ms") + " avg: " + (w.Elapsed.TotalMilliseconds / counter).ToString ("0.00 ms"); " is 163.
Long Statement,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The length of the statement  "			objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime); " is 149.
Long Statement,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The length of the statement  "			Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3; " is 125.
Long Statement,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,The length of the statement  "	if (transform.position.x > maxxpos || transform.position.x < minxpos || transform.position.z < minzpos || transform.position.z > maxzpos) { " is 139.
Long Statement,Code.Core.Client.UI.Controls,CircleButton,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\CircleButton.cs,RotateCircle,The length of the statement  "		CorotineManager.Instance.StartCoroutine (Ease.Vector (Circle.transform.eulerAngles' new Vector3 (0' 0' 180f)' delegate (Vector3 vector3) { " is 138.
Long Statement,Code.Core.Client.UI.Controls,CircleButton,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\CircleButton.cs,RotateCircle,The length of the statement  "			CorotineManager.Instance.StartCoroutine (Ease.Vector (Circle.transform.eulerAngles' new Vector3 (0' 0' 0)' delegate (Vector3 vector3) { " is 135.
Long Statement,Code.Core.Client.UI.Controls,CircleButton,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\CircleButton.cs,ScaleDownAndBack,The length of the statement  "	CorotineManager.Instance.StartCoroutine (Ease.Vector (transform.localScale' Vector3.one * 0.7f' delegate (Vector3 vector3) { " is 124.
Long Statement,Code.Core.Client.UI.Controls,CircleButton,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\CircleButton.cs,ScaleDown,The length of the statement  "	CorotineManager.Instance.StartCoroutine (Ease.Vector (transform.localScale' Vector3.one * 0.7f' delegate (Vector3 vector3) { " is 124.
Long Statement,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The length of the statement  "	if (UIContentManager.I == null || UIContentManager.I.ItemButtonBackGround == null || UIContentManager.I.ItemButtonBackGround.renderer == null) { " is 144.
Long Statement,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The length of the statement  "			tk2dSlicedSprite buttonBackGround = ((GameObject)Instantiate (UIContentManager.I.ItemButtonBackGround.gameObject)).GetComponent<tk2dSlicedSprite> (); " is 149.
Long Statement,Code.Core.Client.UI.Controls.Items,ItemInventoryInterface,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventoryInterface.cs,CreateInterface,The length of the statement  "	Vector3 unitPosition2D = tk2dUIManager.Instance.UICamera.ScreenToWorldPoint (Camera.main.WorldToScreenPoint (unitPosition)); " is 124.
Long Statement,Code.Core.Client.UI.Controls.Items,ItemInventoryInterface,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventoryInterface.cs,CreateInterface,The length of the statement  "	ItemInventoryInterface newInterface = (Instantiate (I.gameObject) as GameObject).GetComponent<ItemInventoryInterface> (); " is 121.
Long Statement,Code.Core.Client.UI.Interfaces,RightClickMenu,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Interfaces\RightClickMenu.cs,Setup,The length of the statement  "	pos.x = Mathf.Clamp (pos.x' tk2dUIManager.Instance.camera.ViewportToWorldPoint (new Vector2 (0' 0)).x' tk2dUIManager.Instance.camera.ViewportToWorldPoint (new Vector2 (1' 0)).x - _backGround.renderer.bounds.size.x); " is 215.
Long Statement,Code.Core.Client.UI.Interfaces,RightClickMenu,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Interfaces\RightClickMenu.cs,Setup,The length of the statement  "	pos.y = Mathf.Clamp (pos.y' tk2dUIManager.Instance.camera.ViewportToWorldPoint (new Vector2 (0' 0)).y + _backGround.renderer.bounds.size.y' tk2dUIManager.Instance.camera.ViewportToWorldPoint (new Vector2 (1' 1)).y); " is 215.
Long Statement,Code.Core.Client.UI.Interfaces,Unit2D,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Unit2D.cs,LateUpdate,The length of the statement  "		Vector3 pos = tk2dUIManager.Instance.UICamera.ScreenToWorldPoint (Camera.main.WorldToScreenPoint (PlayerUnit.transform.position)); " is 130.
Long Statement,Code.Core.Client.UI.Scripts,KeepRelativePosition,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\KeepRelativePosition.cs,Update,The length of the statement  "		configX = Mathf.Abs ((parent.dimensions.x + parent.borderLeft + parent.borderRight) / (parent.transform.position.x - transform.position.x)); " is 140.
Long Statement,Code.Core.Client.UI.Scripts,KeepRelativePosition,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\KeepRelativePosition.cs,Update,The length of the statement  "		configY = Mathf.Abs ((parent.dimensions.y + parent.borderTop + parent.borderBottom) / (parent.transform.position.y - transform.position.y)); " is 140.
Long Statement,Code.Core.Client.UI.Scripts,KeepRelativePosition,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\KeepRelativePosition.cs,Update,The length of the statement  "			transform.position = new Vector3 (parent.transform.position.x + (parent.dimensions.x + parent.borderLeft + parent.borderRight) / configX' parent.transform.position.y + (parent.dimensions.y + parent.borderTop + parent.borderBottom) / configY' transform.position.z); " is 264.
Long Statement,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,ProcessLookAtRotation,The length of the statement  "	if (_lookAtUnit == null || Vector3.Distance (transform.position + transform.forward' _lookAtUnit.transform.position) > Vector3.Distance (transform.position + transform.forward * -1f' _lookAtUnit.transform.position)) " is 215.
Long Statement,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,ProcessLookAtRotation,The length of the statement  "	_lookAtPositionLerped = Vector3.Lerp (_lookAtPositionLerped' !lookAtItReally ? transform.position + transform.forward * 10f : _lookAtUnit.transform.position' Time.deltaTime * 10); " is 179.
Long Statement,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,OnUpdate,The length of the statement  "	distanceToTarget = Vector2.Distance (new Vector2 (transform.localPosition.x' transform.localPosition.z)' new Vector2 (movementTargetPosition.x' movementTargetPosition.z)); " is 171.
Long Statement,Server.Model.Extensions.UnitExts,UnitActions,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitActions.cs,DoAction,The length of the statement  "	if (Vector3.Distance (Unit.Movement.Position' selectedUnit.Movement.Position) > Unit.Display.Size + selectedUnit.Display.Size) { " is 128.
Long Statement,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,Progress,The length of the statement  "				if (RotateTo (Quaternion.LookRotation (dir * _rotationSpeed * Unit.Attributes.Mobility * Time.fixedDeltaTime + (Quaternion.Euler (new Vector3 (0' _rotation' 0)) * Vector3.forward)).eulerAngles.y)) { " is 198.
Long Statement,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,Progress,The length of the statement  "					if (!_dontWalk && Vector3.Distance (Position + Forward * 1.25f' waypoint) < Vector3.Distance (Position + Forward * -1' waypoint)) { " is 131.
Long Statement,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,Progress,The length of the statement  "			if (Vector2.Distance (new Vector2 (_position.x' _position.z)' new Vector2 (wayPoint.x' wayPoint.z)) < Unit.Display.Size * 0.75f) { " is 130.
Long Statement,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,Progress,The length of the statement  "            RotateTo(Quaternion.LookRotation(new Vector3(destination.x' 0' destination.z) - new Vector3(_position.x' 0' _position.z)).eulerAngles.y);" is 137.
Long Statement,Server.SQL,SQLSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\SQL\SQLSerializer.cs,IsNumber,The length of the statement  "	return value is sbyte || value is byte || value is short || value is ushort || value is int || value is uint || value is long || value is ulong || value is float || value is double || value is decimal; " is 201.
Long Statement,Server.SQL,SQLSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\SQL\SQLSerializer.cs,CacheType,The length of the statement  "	BindingFlags flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance | BindingFlags.DeclaredOnly; " is 140.
Long Statement,Code.Core.Shared.Content.Spawns,ItemSpawn,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Spawns\ItemSpawn.cs,Start,The length of the statement  "	ServerSpawnManager.Instance (Server.Server.Instance.swm.Get.Kemet).AddItemSpawn (new ServerItemSpawn (transform.position' transform.eulerAngles' ItemToSpawn' RespawnTime)); " is 172.
Long Statement,Code.Core.Shared.Content.Types.ItemExtensions,ItemRigid,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\ItemExtensions\ItemRigid.cs,Disable,The length of the statement  "                CorotineManager.Instance.RunCoroutine(Ease.Vector(transform.localPosition' new Vector3(0'(collider as BoxCollider).size.y' 0)'" is 126.
Long Statement,Pathfinding.Util,ObjectPool,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\ObjectPool.cs,Release,The length of the statement  "			throw new System.InvalidOperationException ("The object is released even though it is in the pool. Are you releasing it twice?"); " is 129.
Long Statement,Pathfinding.Serialization,UnityObjectConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The length of the statement  "		UnityReferenceHelper[] helpers = UnityEngine.Object.FindObjectsOfType (typeof(UnityReferenceHelper)) as UnityReferenceHelper[]; " is 127.
Long Statement,Pathfinding.Serialization,VectorConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,CanConvert,The length of the statement  "	return System.Type.Equals (type' typeof(Vector2)) || System.Type.Equals (type' typeof(Vector3)) || System.Type.Equals (type' typeof(Vector4)); " is 142.
Long Statement,Pathfinding.Serialization,VectorConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The length of the statement  "		return new Vector4 (CastFloat (values ["x"])' CastFloat (values ["y"])' CastFloat (values ["z"])' CastFloat (values ["w"])); " is 124.
Long Statement,Pathfinding.Serialization,IntKeyDictionaryConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,CanConvert,The length of the statement  "	return (System.Type.Equals (type' typeof(Dictionary<int' int>)) || System.Type.Equals (type' typeof(SortedDictionary<int' int>))); " is 130.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeExtraInfo,The length of the statement  "			throw new System.Exception ("Some graphs are not consistent in their GetNodes calls' sequential calls give different results."); " is 128.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeNodeConnections,The length of the statement  "					throw new IndexOutOfRangeException ("Node.connections.Length != Node.connectionCosts.Length. In node "+i+" in graph "+index);" is 125.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,OpenDeserialize,The length of the statement  "		Debug.LogWarning ("Trying to load data from a newer version of the A* Pathfinding Project\nCurrent version: " + AstarPath.Version + " Data version: " + meta.version); " is 166.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,OpenDeserialize,The length of the statement  "		Debug.LogWarning ("Trying to load data from an older version of the A* Pathfinding Project\nCurrent version: " + AstarPath.Version + " Data version: " + meta.version + "\nThis is usually fine' it just means you have upgraded to a new version.\nHowever node data (not settings) can get corrupted between versions' so it is recommended" + "to recalculate any caches (those for faster startup) and resave any files. Even if it seems to load fine' it might cause subtle bugs.\n"); " is 476.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeGraphs,The length of the statement  "			throw new FileNotFoundException ("Could not find data for graph " + i + " in zip. Entry 'graph+" + i + jsonExt + "' does not exist"); " is 133.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeGraphs,The length of the statement  "			throw new System.Exception ("Guid in graph file not equal to guid defined in meta file. Have you edited the data manually?\n" + graphs [i].guid.ToString () + " != " + meta.guids [i]); " is 183.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,The length of the statement  "			throw new System.Exception ("Node references not found in the data. Was this loaded from an older version of the A* Pathfinding Project?"); " is 139.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,The length of the statement  "			throw new System.Exception ("Some graph(s) has thrown an exception during GetNodes' or some graph(s) have deserialized more or fewer nodes than were serialized"' e); " is 165.
Long Statement,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,DeserializeExtraInfo,The length of the statement  "				throw new System.Exception ("Node references for graph " + i + " not found in the data. Was this loaded from an older version of the A* Pathfinding Project?"); " is 159.
Long Statement,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,GetBranchNeightbour,The length of the statement  "			Vector2 repeatOffset = new Vector2 (Mathf.Repeat (Mathf.Abs (offset.x)' Root._size.x)' Mathf.Repeat (Mathf.Abs (offset.y)' Root._size.y)); " is 138.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "			UnityEditor.EditorUtility.DisplayDialog ("tk2dRuntimeSpriteCollection Error"' "The tk2d/BlendVertexColor shader needs to be in a resources folder for this to work.\n\n" + "Create a subdirectory named 'resources' where the shaders are' and move the BlendVertexColor shader into this directory.\n\n" + "eg. TK2DROOT/tk2d/Shaders/Resources/BlendVertexColor\n\n" + "Be sure to do this from within Unity and not from Explorer/Finder."' "Ok"); " is 437.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexture,The length of the statement  "		sc.spriteDefinitions [i] = CreateDefinitionForRegionInTexture (names [i]' textureDimensions' scale' regions [i]' trimRect' anchors [i]' defRotated); " is 148.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v0 = new Vector2 ((uvRegion.x + uvOffset.x) / fwidth' 1.0f - (uvRegion.y + uvRegion.height + uvOffset.y) / fheight); " is 124.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The length of the statement  "	Vector2 v1 = new Vector2 ((uvRegion.x + uvRegion.width - uvOffset.x) / fwidth' 1.0f - (uvRegion.y - uvOffset.y) / fheight); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "							entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4])); " is 123.
Long Statement,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The length of the statement  "	return CreateFromTexture (texture' spriteCollectionSize' textureDimensions' names.ToArray ()' rects.ToArray ()' trimRects.ToArray ()' anchors.ToArray ()' rotated.ToArray ()); " is 174.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "			tileMap.Layers [i] = new Layer (tileMap.data.Layers [i].hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 141.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "				newLayers [i] = new Layer (layerInfo.hash' tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 122.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,InitDataStore,The length of the statement  "		tileMap.ColorChannel = new ColorChannel (tileMap.width' tileMap.height' tileMap.partitionSizeX' tileMap.partitionSizeY); " is 120.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			#if UNITY_3_0 || UNITY_3_1 || UNITY_3_2 || UNITY_3_3 || UNITY_3_4 || UNITY_3_5 || UNITY_3_6 || UNITY_3_7 || UNITY_3_8 || UNITY_3_9 " is 130.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "			layer.gameObject.transform.localPosition = new Vector3 (0' 0' tileMap.data.layersFixedZ ? (-layerInfoZ) : accumulatedLayerZ); " is 125.
Long Statement,tk2dRuntime.TileMap,BuilderUtil,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapBuilderUtil.cs,CreateRenderData,The length of the statement  "		BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' layer.numColumns' layer.numRows' out x0' out x1' out dx' out y0' out y1' out dy); " is 132.
Long Statement,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The length of the statement  "					Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90); " is 136.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "	BuilderUtil.GetLoopOrder (tileMap.data.sortMethod' tileMap.partitionSizeX' tileMap.partitionSizeY' out x0' out x1' out dx' out y0' out y1' out dy); " is 147.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' sprite' sprite.positions [v]' flipH' flipV' rot90); " is 121.
Long Statement,tk2dRuntime.TileMap,RenderMeshBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapMeshBuilder.cs,BuildForChunk,The length of the statement  "					Color color = Color.Lerp (Color.Lerp (tileColorx0y0' tileColorx1y0' tileColorX)' Color.Lerp (tileColorx0y1' tileColorx1y1' tileColorX)' tileColorY); " is 148.
Complex Conditional,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The conditional expression  "((polyPoints [i].y <= p.y && p.y < polyPoints [j].y) || (polyPoints [j].y <= p.y && p.y < polyPoints [i].y)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.y - polyPoints [i].y) / (polyPoints [j].y - polyPoints [i].y) + polyPoints [i].x)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ContainsPoint,The conditional expression  "((polyPoints [i].z <= p.z && p.z < polyPoints [j].z) || (polyPoints [j].z <= p.z && p.z < polyPoints [i].z)) && (p.x < (polyPoints [j].x - polyPoints [i].x) * (p.z - polyPoints [i].z) / (polyPoints [j].z - polyPoints [i].z) + polyPoints [i].x)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,Intersects,The conditional expression  "u < 0F || u > 1F || u2 < 0F || u2 > 1F"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,IntersectionFactorRaySegment,The conditional expression  "(den >= 0 && nom2 > den) || (den < 0 && nom2 <= den)"  is complex.
Complex Conditional,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,SegmentIntersectionPoint,The conditional expression  "u < 0F || u > 1F || u2 < 0F || u2 > 1F"  is complex.
Complex Conditional,Pathfinding,MeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Nodes\GraphNode.cs,ContainsPoint,The conditional expression  "((GetVertex (i).z <= p.z && p.z < GetVertex (j).z) || (GetVertex (j).z <= p.z && p.z < GetVertex (i).z)) && (p.x < (GetVertex (j).x - GetVertex (i).x) * (p.z - GetVertex (i).z) / (GetVertex (j).z - GetVertex (i).z) + GetVertex (i).x)"  is complex.
Complex Conditional,Pathfinding,TargetMover,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\ExampleScenes\ExampleScripts\TargetMover.cs,OnGUI,The conditional expression  "onlyOnDoubleClick && cam != null && Event.current.type == EventType.MouseDown && Event.current.clickCount == 2"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetNearestForce,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The conditional expression  "nx < 0 || nz < 0 || nx >= width || nz >= depth"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,RelocateNodes,The conditional expression  "vertices == null || vertices.Length == 0 || originalVertices == null || originalVertices.Length != vertices.Length"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The conditional expression  "allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The conditional expression  "node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,Sort,The conditional expression  "a [i].x > a [i + 1].x || (a [i].x == a [i + 1].x && (a [i].y > a [i + 1].y || (a [i].y == a [i + 1].y && a [i].z > a [i + 1].z)))"  is complex.
Complex Conditional,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,SerializeExtraInfo,The conditional expression  "nodes == null || originalVertices == null || _vertices == null || originalVertices.Length != _vertices.Length"  is complex.
Complex Conditional,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,GetNearestForce,The conditional expression  "constraint == null || (dist < minConstDist && dist < maxDistSqr && constraint.Suitable (node))"  is complex.
Complex Conditional,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,IsValidConnection,The conditional expression  "(!Mathf.Approximately (limits.x' 0) && Mathf.Abs (dir.x) > limits.x) || (!Mathf.Approximately (limits.y' 0) && Mathf.Abs (dir.y) > limits.y) || (!Mathf.Approximately (limits.z' 0) && Mathf.Abs (dir.z) > limits.z)"  is complex.
Complex Conditional,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The conditional expression  "!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")"  is complex.
Complex Conditional,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The conditional expression  "!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")"  is complex.
Complex Conditional,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,Apply,The conditional expression  "path == null || path.Count == 0 || vectorPath == null || vectorPath.Count != path.Count"  is complex.
Complex Conditional,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,The conditional expression  "transform.position.x > maxxpos || transform.position.x < minxpos || transform.position.z < minzpos || transform.position.z > maxzpos"  is complex.
Complex Conditional,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,ContainsPoint,The conditional expression  "shortBoundary.x <= point.x && shortBoundary.y <= point.y && longBoundary.x > point.x && longBoundary.y > point.y"  is complex.
Complex Conditional,tk2dRuntime.TileMap,ColorChannel,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapChunks.cs,Optimize,The conditional expression  "c.r != clearColor32.r || c.g != clearColor32.g || c.b != clearColor32.b || c.a != clearColor32.a"  is complex.
Virtual Method Call from Constructor,Code.Libaries.Generic,LilSingleton,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Singleton.cs,LilSingleton,The constructor "LilSingleton" calls a virtual method "OnInstanceWasCreated".
Empty Catch Block,Server,ServerSingleton,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\ServerSingleton.cs,FixedUpdate,The method has an empty catch block.
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ComputeVertexHash,The following statement contains a magic number: return (int)(n & ((1 << 30) - 1));  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return t2 * t2 * t2 * p0 + 3 * t2 * t2 * t * p1 + 3 * t2 * t * t * p2 + t * t * t * p3;  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,CubicBezier,The following statement contains a magic number: return t2 * t2 * t2 * p0 + 3 * t2 * t2 * t * p1 + 3 * t2 * t * t * p2 + t * t * t * p3;  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000) {  	return ((bytes / 1000D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytes,The following statement contains a magic number: if (bytes < 1000000000) {  	return ((bytes / 1000000D) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / 1000000000D) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024) {  	return (bytes * sign).ToString () + " bytes";  }  else if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024) {  	return ((bytes / 1024D) * sign).ToString ("0.0") + " kb";  }  else if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,AstarMath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,FormatBytesBinary,The following statement contains a magic number: if (bytes < 1024 * 1024 * 1024) {  	return ((bytes / (1024D * 1024D)) * sign).ToString ("0.0") + " mb";  }  else {  	return ((bytes / (1024D * 1024D * 1024D)) * sign).ToString ("0.0") + " gb";  }  
Magic Number,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ConvexHull,The following statement contains a magic number: lock (hullCache) {  	List<Vector3> hull = hullCache;  	hull.Clear ();  	int pointOnHull = 0;  	for (int i = 1; i < points.Length; i++)  		if (points [i].x < points [pointOnHull].x)  			pointOnHull = i;  	int startpoint = pointOnHull;  	int counter = 0;  	do {  		hull.Add (points [pointOnHull]);  		int endpoint = 0;  		for (int i = 0; i < points.Length; i++)  			if (endpoint == pointOnHull || !Left (points [pointOnHull]' points [endpoint]' points [i]))  				endpoint = i;  		pointOnHull = endpoint;  		counter++;  		if (counter > 10000) {  			Debug.LogWarning ("Infinite Loop in Convex Hull Calculation");  			break;  		}  	}  	while (pointOnHull != startpoint);  	return hull.ToArray ();  }  
Magic Number,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ConvexHull,The following statement contains a magic number: do {  	hull.Add (points [pointOnHull]);  	int endpoint = 0;  	for (int i = 0; i < points.Length; i++)  		if (endpoint == pointOnHull || !Left (points [pointOnHull]' points [endpoint]' points [i]))  			endpoint = i;  	pointOnHull = endpoint;  	counter++;  	if (counter > 10000) {  		Debug.LogWarning ("Infinite Loop in Convex Hull Calculation");  		break;  	}  }  while (pointOnHull != startpoint);  
Magic Number,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ConvexHull,The following statement contains a magic number: if (counter > 10000) {  	Debug.LogWarning ("Infinite Loop in Convex Hull Calculation");  	break;  }  
Magic Number,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,Subdivide,The following statement contains a magic number: for (int p = 0; p < path.Length - 1; p++) {  	float step = 1.0F / Mathf.Pow (2' subdivisions);  	for (float i = 0; i < 1.0F; i += step) {  		path2 [c] = Vector3.Lerp (path [p]' path [p + 1]' Mathf.SmoothStep (0' 1' i));  		c++;  	}  }  
Magic Number,Pathfinding,Polygon,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\AstarMath.cs,ClosestPointOnTriangle,The following statement contains a magic number: return ClosestPointOnTriangle (triangle [0]' triangle [1]' triangle [2]' point);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: if (convex) {  	if (convexPoints == null)  		RecalcConvex ();  	Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  	for (int i = 0; i < convexPoints.Length; i++) {  		Gizmos.DrawLine (matrix.MultiplyPoint3x4 (convexPoints [i])' matrix.MultiplyPoint3x4 (convexPoints [(i + 1) % convexPoints.Length]));  	}  }  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,GraphUpdateScene,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\GraphUpdateScene.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = selected ? new Color (227 / 255f' 61 / 255f' 22 / 255f' 1.0f) : new Color (227 / 255f' 61 / 255f' 22 / 255f' 0.9f);  
Magic Number,Pathfinding,AnimationLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,The following statement contains a magic number: for (int i = 0; i < sequence.Length; i++) {  	LinkClip c = sequence [i];  	if (c == null) {  		endPosition = position;  		return;  	}  	anim [c.clip.name].enabled = true;  	anim [c.clip.name].weight = 1;  	for (int repeat = 0; repeat < c.loopCount; repeat++) {  		anim [c.clip.name].normalizedTime = 0;  		anim.Sample ();  		Vector3 soffset = root.position - transform.position;  		if (i > 0) {  			position += prevOffset - soffset;  		}  		else {  			firstOffset = soffset;  		}  		for (int t = 0; t <= 20; t++) {  			float tf = t / 20.0f;  			anim [c.clip.name].normalizedTime = tf;  			anim.Sample ();  			Vector3 tmp = position + (root.position - transform.position) + c.velocity * tf * c.clip.length;  			trace.Add (tmp);  		}  		position = position + c.velocity * 1 * c.clip.length;  		anim [c.clip.name].normalizedTime = 1;  		anim.Sample ();  		Vector3 eoffset = root.position - transform.position;  		prevOffset = eoffset;  	}  	anim [c.clip.name].enabled = false;  	anim [c.clip.name].weight = 0;  }  
Magic Number,Pathfinding,AnimationLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,The following statement contains a magic number: for (int repeat = 0; repeat < c.loopCount; repeat++) {  	anim [c.clip.name].normalizedTime = 0;  	anim.Sample ();  	Vector3 soffset = root.position - transform.position;  	if (i > 0) {  		position += prevOffset - soffset;  	}  	else {  		firstOffset = soffset;  	}  	for (int t = 0; t <= 20; t++) {  		float tf = t / 20.0f;  		anim [c.clip.name].normalizedTime = tf;  		anim.Sample ();  		Vector3 tmp = position + (root.position - transform.position) + c.velocity * tf * c.clip.length;  		trace.Add (tmp);  	}  	position = position + c.velocity * 1 * c.clip.length;  	anim [c.clip.name].normalizedTime = 1;  	anim.Sample ();  	Vector3 eoffset = root.position - transform.position;  	prevOffset = eoffset;  }  
Magic Number,Pathfinding,AnimationLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\AnimationLink.cs,CalculateOffsets,The following statement contains a magic number: for (int t = 0; t <= 20; t++) {  	float tf = t / 20.0f;  	anim [c.clip.name].normalizedTime = tf;  	anim.Sample ();  	Vector3 tmp = position + (root.position - transform.position) + c.velocity * tf * c.clip.length;  	trace.Add (tmp);  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: if (numberOfItems == binaryHeap.Length) {  	int newSize = System.Math.Max (binaryHeap.Length + 4' (int)System.Math.Round (binaryHeap.Length * growthFactor));  	if (newSize > 1 << 18) {  		throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");  	}  	PathNode[] tmp = new PathNode[newSize];  	for (int i = 0; i < binaryHeap.Length; i++) {  		tmp [i] = binaryHeap [i];  	}  	binaryHeap = tmp;  	//Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size ("+numberOfItems +" "+binaryHeap.Length+")");  	//numberOfItems--;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: if (numberOfItems == binaryHeap.Length) {  	int newSize = System.Math.Max (binaryHeap.Length + 4' (int)System.Math.Round (binaryHeap.Length * growthFactor));  	if (newSize > 1 << 18) {  		throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");  	}  	PathNode[] tmp = new PathNode[newSize];  	for (int i = 0; i < binaryHeap.Length; i++) {  		tmp [i] = binaryHeap [i];  	}  	binaryHeap = tmp;  	//Debug.Log ("Forced to discard nodes because of binary heap size limit' please consider increasing the size ("+numberOfItems +" "+binaryHeap.Length+")");  	//numberOfItems--;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Add,The following statement contains a magic number: if (newSize > 1 << 18) {  	throw new System.Exception ("Binary Heap Size really large (2^18). A heap size this large is probably the cause of pathfinding running in an infinite loop. " + "\nRemove this check (in BinaryHeap.cs) if you are sure that it is not caused by a bug");  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: do {  	if (D == 0) {  		parent = swapItem;  		int p2 = parent * D;  		if (p2 + 1 <= numberOfItems) {  			// Both children exist  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  				//2 * parent;  			}  			if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  				swapItem = p2 + 1;  			}  		}  		else if ((p2) <= numberOfItems) {  			// Only one child exists  			if (binaryHeap [parent].F > binaryHeap [p2].F) {  				swapItem = p2;  			}  		}  	}  	else {  		parent = swapItem;  		uint swapF = binaryHeap [swapItem].F;  		int pd = parent * D + 1;  		if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  			swapF = binaryHeap [pd + 0].F;  			swapItem = pd + 0;  		}  		if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  			swapF = binaryHeap [pd + 1].F;  			swapItem = pd + 1;  		}  		if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  			swapF = binaryHeap [pd + 2].F;  			swapItem = pd + 2;  		}  		if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  			swapF = binaryHeap [pd + 3].F;  			swapItem = pd + 3;  		}  		if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  			swapF = binaryHeap [pd + 4].F;  			swapItem = pd + 4;  		}  		if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  			swapF = binaryHeap [pd + 5].F;  			swapItem = pd + 5;  		}  		if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  			swapF = binaryHeap [pd + 6].F;  			swapItem = pd + 6;  		}  		if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  			swapF = binaryHeap [pd + 7].F;  			swapItem = pd + 7;  		}  		if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  			swapF = binaryHeap [pd + 8].F;  			swapItem = pd + 8;  		}  	}  	// One if the parent's children are smaller or equal' swap them  	if (parent != swapItem) {  		var tmpIndex = binaryHeap [parent];  		//tmpIndex.heapIndex = swapItem;//Heap index  		binaryHeap [parent] = binaryHeap [swapItem];  		binaryHeap [swapItem] = tmpIndex;  		//binaryHeap[parent].heapIndex = parent;//Heap index  	}  	else {  		break;  	}  }  while (true);  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D == 0) {  	parent = swapItem;  	int p2 = parent * D;  	if (p2 + 1 <= numberOfItems) {  		// Both children exist  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  			//2 * parent;  		}  		if (binaryHeap [swapItem].F > binaryHeap [p2 + 1].F) {  			swapItem = p2 + 1;  		}  	}  	else if ((p2) <= numberOfItems) {  		// Only one child exists  		if (binaryHeap [parent].F > binaryHeap [p2].F) {  			swapItem = p2;  		}  	}  }  else {  	parent = swapItem;  	uint swapF = binaryHeap [swapItem].F;  	int pd = parent * D + 1;  	if (D >= 1 && pd + 0 <= numberOfItems && binaryHeap [pd + 0].F < swapF) {  		swapF = binaryHeap [pd + 0].F;  		swapItem = pd + 0;  	}  	if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  		swapF = binaryHeap [pd + 1].F;  		swapItem = pd + 1;  	}  	if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  		swapF = binaryHeap [pd + 2].F;  		swapItem = pd + 2;  	}  	if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  		swapF = binaryHeap [pd + 3].F;  		swapItem = pd + 3;  	}  	if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  		swapF = binaryHeap [pd + 4].F;  		swapItem = pd + 4;  	}  	if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  		swapF = binaryHeap [pd + 5].F;  		swapItem = pd + 5;  	}  	if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  		swapF = binaryHeap [pd + 6].F;  		swapItem = pd + 6;  	}  	if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  		swapF = binaryHeap [pd + 7].F;  		swapItem = pd + 7;  	}  	if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  		swapF = binaryHeap [pd + 8].F;  		swapItem = pd + 8;  	}  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 2 && pd + 1 <= numberOfItems && binaryHeap [pd + 1].F < swapF) {  	swapF = binaryHeap [pd + 1].F;  	swapItem = pd + 1;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  	swapF = binaryHeap [pd + 2].F;  	swapItem = pd + 2;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  	swapF = binaryHeap [pd + 2].F;  	swapItem = pd + 2;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  	swapF = binaryHeap [pd + 2].F;  	swapItem = pd + 2;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  	swapF = binaryHeap [pd + 2].F;  	swapItem = pd + 2;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 3 && pd + 2 <= numberOfItems && binaryHeap [pd + 2].F < swapF) {  	swapF = binaryHeap [pd + 2].F;  	swapItem = pd + 2;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 2].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 2;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  	swapF = binaryHeap [pd + 3].F;  	swapItem = pd + 3;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  	swapF = binaryHeap [pd + 3].F;  	swapItem = pd + 3;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  	swapF = binaryHeap [pd + 3].F;  	swapItem = pd + 3;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  	swapF = binaryHeap [pd + 3].F;  	swapItem = pd + 3;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 4 && pd + 3 <= numberOfItems && binaryHeap [pd + 3].F < swapF) {  	swapF = binaryHeap [pd + 3].F;  	swapItem = pd + 3;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 3].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 3;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  	swapF = binaryHeap [pd + 4].F;  	swapItem = pd + 4;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  	swapF = binaryHeap [pd + 4].F;  	swapItem = pd + 4;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  	swapF = binaryHeap [pd + 4].F;  	swapItem = pd + 4;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  	swapF = binaryHeap [pd + 4].F;  	swapItem = pd + 4;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 5 && pd + 4 <= numberOfItems && binaryHeap [pd + 4].F < swapF) {  	swapF = binaryHeap [pd + 4].F;  	swapItem = pd + 4;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 4].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 4;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  	swapF = binaryHeap [pd + 5].F;  	swapItem = pd + 5;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  	swapF = binaryHeap [pd + 5].F;  	swapItem = pd + 5;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  	swapF = binaryHeap [pd + 5].F;  	swapItem = pd + 5;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  	swapF = binaryHeap [pd + 5].F;  	swapItem = pd + 5;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 6 && pd + 5 <= numberOfItems && binaryHeap [pd + 5].F < swapF) {  	swapF = binaryHeap [pd + 5].F;  	swapItem = pd + 5;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 5].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 5;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  	swapF = binaryHeap [pd + 6].F;  	swapItem = pd + 6;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  	swapF = binaryHeap [pd + 6].F;  	swapItem = pd + 6;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  	swapF = binaryHeap [pd + 6].F;  	swapItem = pd + 6;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  	swapF = binaryHeap [pd + 6].F;  	swapItem = pd + 6;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 7 && pd + 6 <= numberOfItems && binaryHeap [pd + 6].F < swapF) {  	swapF = binaryHeap [pd + 6].F;  	swapItem = pd + 6;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 6].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 6;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  	swapF = binaryHeap [pd + 7].F;  	swapItem = pd + 7;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  	swapF = binaryHeap [pd + 7].F;  	swapItem = pd + 7;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  	swapF = binaryHeap [pd + 7].F;  	swapItem = pd + 7;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  	swapF = binaryHeap [pd + 7].F;  	swapItem = pd + 7;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 8 && pd + 7 <= numberOfItems && binaryHeap [pd + 7].F < swapF) {  	swapF = binaryHeap [pd + 7].F;  	swapItem = pd + 7;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 7].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 7;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  	swapF = binaryHeap [pd + 8].F;  	swapItem = pd + 8;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  	swapF = binaryHeap [pd + 8].F;  	swapItem = pd + 8;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  	swapF = binaryHeap [pd + 8].F;  	swapItem = pd + 8;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  	swapF = binaryHeap [pd + 8].F;  	swapItem = pd + 8;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: if (D >= 9 && pd + 8 <= numberOfItems && binaryHeap [pd + 8].F < swapF) {  	swapF = binaryHeap [pd + 8].F;  	swapItem = pd + 8;  }  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapF = binaryHeap [pd + 8].F;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Remove,The following statement contains a magic number: swapItem = pd + 8;  
Magic Number,Pathfinding,BinaryHeapM,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\BinaryHeap.cs,Rebuild,The following statement contains a magic number: for (int i = 2; i < numberOfItems; i++) {  	int bubbleIndex = i;  	var node = binaryHeap [i];  	uint nodeF = node.F;  	while (bubbleIndex != 1) {  		int parentIndex = bubbleIndex / D;  		if (nodeF < binaryHeap [parentIndex].F) {  			//Node tmpValue = binaryHeap[parentIndex];  			binaryHeap [bubbleIndex] = binaryHeap [parentIndex];  			binaryHeap [parentIndex] = node;  			bubbleIndex = parentIndex;  		}  		else {  			break;  		}  	}  }  
Magic Number,Pathfinding,Int3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 73856093 ^ y * 19349663 ^ z * 83492791;  
Magic Number,Pathfinding,Int3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 73856093 ^ y * 19349663 ^ z * 83492791;  
Magic Number,Pathfinding,Int3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 73856093 ^ y * 19349663 ^ z * 83492791;  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 49157 + y * 98317;  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,GetHashCode,The following statement contains a magic number: return x * 49157 + y * 98317;  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: r = r % 4;  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,Int2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\Int3.cs,Rotate,The following statement contains a magic number: return new Int2 (v.x * Rotations [r * 4 + 0] + v.y * Rotations [r * 4 + 1]' v.x * Rotations [r * 4 + 2] + v.y * Rotations [r * 4 + 3]);  
Magic Number,Pathfinding,NodeLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink.cs,DrawGizmoBezier,The following statement contains a magic number: for (int i = 1; i <= 20; i++) {  	float t = i / 20.0f;  	Vector3 p = AstarMath.CubicBezier (p1' p1c' p2c' p2' t);  	Gizmos.DrawLine (prev' p);  	prev = p;  }  
Magic Number,Pathfinding,NodeLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink.cs,LinkObjects,The following statement contains a magic number: if (tfs.Length == 2) {  	LinkObjects (tfs [0]' tfs [1]' false);  }  
Magic Number,Pathfinding,NodeLink,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink.cs,UnlinkObjects,The following statement contains a magic number: if (tfs.Length == 2) {  	LinkObjects (tfs [0]' tfs [1]' true);  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,DrawGizmoBezier,The following statement contains a magic number: for (int i = 1; i <= 20; i++) {  	float t = i / 20.0f;  	Vector3 p = AstarMath.CubicBezier (p1' p1c' p2c' p2' t);  	Gizmos.DrawLine (prev' p);  	prev = p;  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: if (StartTransform != null) {  	DrawCircle (StartTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (StartTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: if (EndTransform != null) {  	DrawCircle (EndTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink2,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink2.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (EndTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The following statement contains a magic number: if (this.connections.Length < 2)  	return false;  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetPortal,The following statement contains a magic number: if (this.connections.Length != 2)  	throw new System.Exception ("Invalid NodeLink3Node. Expected 2 connections' found " + this.connections.Length);  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOther,The following statement contains a magic number: if (this.connections.Length < 2)  	return null;  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOther,The following statement contains a magic number: if (this.connections.Length != 2)  	throw new System.Exception ("Invalid NodeLink3Node. Expected 2 connections' found " + this.connections.Length);  
Magic Number,Pathfinding,NodeLink3Node,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,GetOtherInternal,The following statement contains a magic number: if (this.connections.Length < 2)  	return null;  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (true) {  	NNInfo n1 = AstarPath.active.GetNearest (StartTransform.position' nn);  	same &= n1.node == connectedNode1 && n1.node != null;  	connectedNode1 = n1.node as MeshNode;  	clamped1 = n1.clampedPosition;  	if (connectedNode1 != null)  		Debug.DrawRay ((Vector3)connectedNode1.position' Vector3.up * 5' Color.red);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (connectedNode1 != null)  	Debug.DrawRay ((Vector3)connectedNode1.position' Vector3.up * 5' Color.red);  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: Debug.DrawRay ((Vector3)connectedNode1.position' Vector3.up * 5' Color.red);  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (true) {  	NNInfo n2 = AstarPath.active.GetNearest (EndTransform.position' nn);  	same &= n2.node == connectedNode2 && n2.node != null;  	connectedNode2 = n2.node as MeshNode;  	clamped2 = n2.clampedPosition;  	if (connectedNode2 != null)  		Debug.DrawRay ((Vector3)connectedNode2.position' Vector3.up * 5' Color.cyan);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (connectedNode2 != null)  	Debug.DrawRay ((Vector3)connectedNode2.position' Vector3.up * 5' Color.cyan);  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: Debug.DrawRay ((Vector3)connectedNode2.position' Vector3.up * 5' Color.cyan);  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int a = 0; a < connectedNode1.GetVertexCount (); a++) {  	Int3 va1 = connectedNode1.GetVertex (a);  	Int3 va2 = connectedNode1.GetVertex ((a + 1) % connectedNode1.GetVertexCount ());  	if (Int3.DotLong ((va2 - va1).Normal2D ()' dir) > 0)  		continue;  	for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  		Int3 vb1 = connectedNode2.GetVertex (b);  		Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  		if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  			continue;  		//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  		//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  		//Debug.Break ();  		if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  			float t1 = 0;  			float t2 = 1;  			t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  			t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  			if (t2 < t1) {  				Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  			}  			else {  				Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  				Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  				startNode.portalA = pa;  				startNode.portalB = pb;  				endNode.portalA = pb;  				endNode.portalB = pa;  				//Add connections between nodes' or replace old connections if existing  				connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				return;  			}  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int a = 0; a < connectedNode1.GetVertexCount (); a++) {  	Int3 va1 = connectedNode1.GetVertex (a);  	Int3 va2 = connectedNode1.GetVertex ((a + 1) % connectedNode1.GetVertexCount ());  	if (Int3.DotLong ((va2 - va1).Normal2D ()' dir) > 0)  		continue;  	for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  		Int3 vb1 = connectedNode2.GetVertex (b);  		Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  		if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  			continue;  		//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  		//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  		//Debug.Break ();  		if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  			float t1 = 0;  			float t2 = 1;  			t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  			t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  			if (t2 < t1) {  				Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  			}  			else {  				Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  				Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  				startNode.portalA = pa;  				startNode.portalB = pb;  				endNode.portalA = pb;  				endNode.portalB = pa;  				//Add connections between nodes' or replace old connections if existing  				connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  				endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  				return;  			}  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  	Int3 vb1 = connectedNode2.GetVertex (b);  	Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  	if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  		continue;  	//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  	//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  	//Debug.Break ();  	if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  		float t1 = 0;  		float t2 = 1;  		t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  		t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  		if (t2 < t1) {  			Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  		}  		else {  			Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  			Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  			startNode.portalA = pa;  			startNode.portalB = pb;  			endNode.portalA = pb;  			endNode.portalB = pa;  			//Add connections between nodes' or replace old connections if existing  			connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			return;  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: for (int b = 0; b < connectedNode2.GetVertexCount (); b++) {  	Int3 vb1 = connectedNode2.GetVertex (b);  	Int3 vb2 = connectedNode2.GetVertex ((b + 1) % connectedNode2.GetVertexCount ());  	if (Int3.DotLong ((vb2 - vb1).Normal2D ()' dir) < 0)  		continue;  	//Debug.DrawLine ((Vector3)va1' (Vector3)va2' Color.magenta);  	//Debug.DrawLine ((Vector3)vb1' (Vector3)vb2' Color.cyan);  	//Debug.Break ();  	if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  		float t1 = 0;  		float t2 = 1;  		t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  		t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  		if (t2 < t1) {  			Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  		}  		else {  			Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  			Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  			startNode.portalA = pa;  			startNode.portalB = pb;  			endNode.portalA = pb;  			endNode.portalB = pa;  			//Add connections between nodes' or replace old connections if existing  			connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  			endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  			return;  		}  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  	float t1 = 0;  	float t2 = 1;  	t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  	t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  	if (t2 < t1) {  		Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  	}  	else {  		Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  		Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  		startNode.portalA = pa;  		startNode.portalB = pb;  		endNode.portalA = pb;  		endNode.portalB = pa;  		//Add connections between nodes' or replace old connections if existing  		connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		return;  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,Apply,The following statement contains a magic number: if (Int3.Angle ((vb2 - vb1)' (va2 - va1)) > (170.0 / 360.0f) * Mathf.PI * 2) {  	float t1 = 0;  	float t2 = 1;  	t2 = System.Math.Min (t2' AstarMath.NearestPointFactor (va1' va2' vb1));  	t1 = System.Math.Max (t1' AstarMath.NearestPointFactor (va1' va2' vb2));  	if (t2 < t1) {  		Debug.LogError ("Wait wut!? " + t1 + " " + t2 + " " + va1 + " " + va2 + " " + vb1 + " " + vb2 + "\nTODO' fix this error");  	}  	else {  		Vector3 pa = (Vector3)(va2 - va1) * t1 + (Vector3)va1;  		Vector3 pb = (Vector3)(va2 - va1) * t2 + (Vector3)va1;  		startNode.portalA = pa;  		startNode.portalB = pb;  		endNode.portalA = pb;  		endNode.portalB = pa;  		//Add connections between nodes' or replace old connections if existing  		connectedNode1.AddConnection (startNode' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		connectedNode2.AddConnection (endNode' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		startNode.AddConnection (connectedNode1' (uint)Mathf.RoundToInt (((Int3)(clamped1 - StartTransform.position)).costMagnitude * costFactor));  		endNode.AddConnection (connectedNode2' (uint)Mathf.RoundToInt (((Int3)(clamped2 - EndTransform.position)).costMagnitude * costFactor));  		return;  	}  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,DrawGizmoBezier,The following statement contains a magic number: for (int i = 1; i <= 20; i++) {  	float t = i / 20.0f;  	Vector3 p = AstarMath.CubicBezier (p1' p1c' p2c' p2' t);  	Gizmos.DrawLine (prev' p);  	prev = p;  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: if (StartTransform != null) {  	DrawCircle (StartTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (StartTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: if (EndTransform != null) {  	DrawCircle (EndTransform.position' 0.4f' 10' col);  }  
Magic Number,Pathfinding,NodeLink3,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\NodeLink3.cs,OnDrawGizmos,The following statement contains a magic number: DrawCircle (EndTransform.position' 0.4f' 10' col);  
Magic Number,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: switch (heuristic) {  case Heuristic.Euclidean:  	return (uint)(((GetHTarget () - node.position).costMagnitude) * heuristicScale);  case Heuristic.Manhattan:  	Int3 p2 = node.position;  	return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale);  case Heuristic.DiagonalManhattan:  	Int3 p = GetHTarget () - node.position;  	p.x = System.Math.Abs (p.x);  	p.y = System.Math.Abs (p.y);  	p.z = System.Math.Abs (p.z);  	int diag = System.Math.Min (p.x' p.z);  	int diag2 = System.Math.Max (p.x' p.z);  	return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  }  
Magic Number,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: switch (heuristic) {  case Heuristic.Euclidean:  	return (uint)(((GetHTarget () - node.position).costMagnitude) * heuristicScale);  case Heuristic.Manhattan:  	Int3 p2 = node.position;  	return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale);  case Heuristic.DiagonalManhattan:  	Int3 p = GetHTarget () - node.position;  	p.x = System.Math.Abs (p.x);  	p.y = System.Math.Abs (p.y);  	p.z = System.Math.Abs (p.z);  	int diag = System.Math.Min (p.x' p.z);  	int diag2 = System.Math.Max (p.x' p.z);  	return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  }  
Magic Number,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  
Magic Number,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following statement contains a magic number: return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  
Magic Number,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Trace,The following statement contains a magic number: while (c != null) {  	c = c.parent;  	count++;  	if (count > 1024) {  		Debug.LogWarning ("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs' Trace function)");  		break;  	}  }  
Magic Number,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,Trace,The following statement contains a magic number: if (count > 1024) {  	Debug.LogWarning ("Inifinity loop? >1024 node path. Remove this message if you really have that long paths (Path.cs' Trace function)");  	break;  }  
Magic Number,Pathfinding,PathHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The following statement contains a magic number: if (bucketNumber >= nodes.Length) {  	//At least increase the size to:  	//Current size * 1.5  	//Current size + 2 or  	//bucketNumber  	PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][];  	for (int i = 0; i < nodes.Length; i++)  		newNodes [i] = nodes [i];  	//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")");  	bool[] newBucketNew = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketNew [i] = bucketNew [i];  	bool[] newBucketCreated = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketCreated [i] = bucketCreated [i];  	nodes = newNodes;  	bucketNew = newBucketNew;  	bucketCreated = newBucketCreated;  }  
Magic Number,Pathfinding,PathHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The following statement contains a magic number: if (bucketNumber >= nodes.Length) {  	//At least increase the size to:  	//Current size * 1.5  	//Current size + 2 or  	//bucketNumber  	PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][];  	for (int i = 0; i < nodes.Length; i++)  		newNodes [i] = nodes [i];  	//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")");  	bool[] newBucketNew = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketNew [i] = bucketNew [i];  	bool[] newBucketCreated = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketCreated [i] = bucketCreated [i];  	nodes = newNodes;  	bucketNew = newBucketNew;  	bucketCreated = newBucketCreated;  }  
Magic Number,Pathfinding,PathHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\PathHandler.cs,InitializeNode,The following statement contains a magic number: if (bucketNumber >= nodes.Length) {  	//At least increase the size to:  	//Current size * 1.5  	//Current size + 2 or  	//bucketNumber  	PathNode[][] newNodes = new PathNode[System.Math.Max (System.Math.Max (nodes.Length * 3 / 2' bucketNumber + 1)' nodes.Length + 2)][];  	for (int i = 0; i < nodes.Length; i++)  		newNodes [i] = nodes [i];  	//Debug.Log ("Resizing Bucket List from " + nodes.Length + " to " + newNodes.Length + " (bucketNumber="+bucketNumber+")");  	bool[] newBucketNew = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketNew [i] = bucketNew [i];  	bool[] newBucketCreated = new bool[newNodes.Length];  	for (int i = 0; i < nodes.Length; i++)  		newBucketCreated [i] = bucketCreated [i];  	nodes = newNodes;  	bucketNew = newBucketNew;  	bucketCreated = newBucketCreated;  }  
Magic Number,Pathfinding,TagMask,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,ToString,The following statement contains a magic number: return "" + System.Convert.ToString (tagsChange' 2) + "\n" + System.Convert.ToString (tagsSet' 2);  
Magic Number,Pathfinding,TagMask,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,ToString,The following statement contains a magic number: return "" + System.Convert.ToString (tagsChange' 2) + "\n" + System.Convert.ToString (tagsSet' 2);  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,WillUpdateNode,The following statement contains a magic number: if (trackChangedNodes && node != null) {  	if (changedNodes == null) {  		changedNodes = ListPool<GraphNode>.Claim ();  		backupData = ListPool<ulong>.Claim ();  		backupPositionData = ListPool<Int3>.Claim ();  	}  	changedNodes.Add (node);  	backupPositionData.Add (node.position);  	backupData.Add ((ulong)node.Penalty << 32 | (ulong)node.Flags);  }  
Magic Number,Pathfinding,GraphUpdateObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,WillUpdateNode,The following statement contains a magic number: backupData.Add ((ulong)node.Penalty << 32 | (ulong)node.Flags);  
Magic Number,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,IntRect,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\astarclasses.cs,GetHashCode,The following statement contains a magic number: return xmin * 131071 ^ xmax * 3571 ^ ymin * 3109 ^ ymax * 7;  
Magic Number,Pathfinding,MineBotAI,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\ExampleScenes\ExampleScripts\MineBotAI.cs,Start,The following statement contains a magic number: anim ["forward"].layer = 10;  
Magic Number,Pathfinding,TargetMover,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\ExampleScenes\ExampleScripts\TargetMover.cs,OnGUI,The following statement contains a magic number: if (onlyOnDoubleClick && cam != null && Event.current.type == EventType.MouseDown && Event.current.clickCount == 2) {  	UpdateTargetPosition ();  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: while (true) {  	RaycastHit hit;  	Raycast (cpos' out hit' out walkable);  	if (hit.transform == null) {  		//Raycast did not hit anything  		break;  	}  	else {  		//Make sure we didn't hit the same position  		if (hit.point != prevHit || hits.Count == 0) {  			cpos = hit.point - up * RaycastErrorMargin;  			prevHit = hit.point;  			numberSame = 0;  			hits.Add (hit);  		}  		else {  			cpos -= up * 0.001F;  			numberSame++;  			//Check if we are hitting the same position all the time' even though we are decrementing the cpos variable  			if (numberSame > 10) {  				Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  				break;  			}  		}  	}  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: if (hit.transform == null) {  	//Raycast did not hit anything  	break;  }  else {  	//Make sure we didn't hit the same position  	if (hit.point != prevHit || hits.Count == 0) {  		cpos = hit.point - up * RaycastErrorMargin;  		prevHit = hit.point;  		numberSame = 0;  		hits.Add (hit);  	}  	else {  		cpos -= up * 0.001F;  		numberSame++;  		//Check if we are hitting the same position all the time' even though we are decrementing the cpos variable  		if (numberSame > 10) {  			Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  			break;  		}  	}  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: if (hit.point != prevHit || hits.Count == 0) {  	cpos = hit.point - up * RaycastErrorMargin;  	prevHit = hit.point;  	numberSame = 0;  	hits.Add (hit);  }  else {  	cpos -= up * 0.001F;  	numberSame++;  	//Check if we are hitting the same position all the time' even though we are decrementing the cpos variable  	if (numberSame > 10) {  		Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  		break;  	}  }  
Magic Number,Pathfinding,GraphCollision,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,CheckHeightAll,The following statement contains a magic number: if (numberSame > 10) {  	Debug.LogError ("Infinite Loop when raycasting. Please report this error (arongranberg.com)\n" + cpos + " : " + prevHit);  	break;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GridGraph,The following statement contains a magic number: unclampedSize = new Vector2 (10' 10);  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GridGraph,The following statement contains a magic number: unclampedSize = new Vector2 (10' 10);  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [2] = width;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [3] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [4] = -width + 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [5] = width + 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [6] = width - 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourOffsets [7] = -width - 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [2] = straightCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [3] = straightCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [4] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [5] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [6] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourCosts [7] = diagonalCost;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [2] = 0;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [3] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [4] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [5] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [6] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourXOffsets [7] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [2] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [3] = 0;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [4] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [5] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [6] = 1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,SetUpOffsetsAndCosts,The following statement contains a magic number: neighbourZOffsets [7] = -1;  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ScanInternal,The following statement contains a magic number: if (width > 1024 || depth > 1024) {  	Debug.LogError ("One of the grid's sides is longer than 1024 nodes");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ScanInternal,The following statement contains a magic number: if (width > 1024 || depth > 1024) {  	Debug.LogError ("One of the grid's sides is longer than 1024 nodes");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!erosionUseTags) {  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				if (!node.Walkable) {  					/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  				else {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!this.HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Walkable = false;  					}  				}  			}  		}  		//Recalculate connections  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * Width + x];  				CalculateConnections (nodes' x' z' node);  			}  		}  	}  }  else {  	if (erodeIterations + erosionFirstTag > 31) {  		Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  		return;  	}  	if (erosionFirstTag <= 0) {  		Debug.LogError ("First erosion tag must be greater or equal to 1");  		return;  	}  	for (int it = 0; it < erodeIterations; it++) {  		for (int z = zmin; z < zmax; z++) {  			for (int x = xmin; x < xmax; x++) {  				GridNode node = nodes [z * width + x] as GridNode;  				if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  					for (int i = 0; i < 4; i++) {  						GridNode other = GetNodeConnection (node' i);  						if (other != null) {  							uint tag = other.Tag;  							if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  								other.Tag = (uint)(erosionFirstTag + it);  							}  						}  					}  				}  				else if (node.Walkable && it == 0) {  					bool anyFalseConnections = false;  					for (int i = 0; i < 4; i++) {  						if (!HasNodeConnection (node' i)) {  							anyFalseConnections = true;  							break;  						}  					}  					if (anyFalseConnections) {  						node.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * Width + x];  			if (!node.Walkable) {  				/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  			else {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!this.HasNodeConnection (node' i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.Walkable = false;  				}  			}  		}  	}  	//Recalculate connections  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * Width + x];  			CalculateConnections (nodes' x' z' node);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = zmin; z < zmax; z++) {  	for (int x = xmin; x < xmax; x++) {  		GridNode node = nodes [z * Width + x];  		if (!node.Walkable) {  			/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  		else {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!this.HasNodeConnection (node' i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.Walkable = false;  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = xmin; x < xmax; x++) {  	GridNode node = nodes [z * Width + x];  	if (!node.Walkable) {  		/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  	else {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!this.HasNodeConnection (node' i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.Walkable = false;  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (!node.Walkable) {  	/*int index = node.GetIndex (); 								 								for (int i=0;i<4;i++) { 									if (node.GetConnection (i)) { 										nodes[index+neighbourOffsets[i]].walkable = false; 									} 								}*/}  else {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!this.HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Walkable = false;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (!this.HasNodeConnection (node' i)) {  		anyFalseConnections = true;  		break;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (erodeIterations + erosionFirstTag > 31) {  	Debug.LogError ("Too few tags available for " + erodeIterations + " erode iterations and starting with tag " + erosionFirstTag + " (erodeIterations+erosionFirstTag > 31)");  	return;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * width + x] as GridNode;  			if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  				for (int i = 0; i < 4; i++) {  					GridNode other = GetNodeConnection (node' i);  					if (other != null) {  						uint tag = other.Tag;  						if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  							other.Tag = (uint)(erosionFirstTag + it);  						}  					}  				}  			}  			else if (node.Walkable && it == 0) {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!HasNodeConnection (node' i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int it = 0; it < erodeIterations; it++) {  	for (int z = zmin; z < zmax; z++) {  		for (int x = xmin; x < xmax; x++) {  			GridNode node = nodes [z * width + x] as GridNode;  			if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  				for (int i = 0; i < 4; i++) {  					GridNode other = GetNodeConnection (node' i);  					if (other != null) {  						uint tag = other.Tag;  						if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  							other.Tag = (uint)(erosionFirstTag + it);  						}  					}  				}  			}  			else if (node.Walkable && it == 0) {  				bool anyFalseConnections = false;  				for (int i = 0; i < 4; i++) {  					if (!HasNodeConnection (node' i)) {  						anyFalseConnections = true;  						break;  					}  				}  				if (anyFalseConnections) {  					node.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = zmin; z < zmax; z++) {  	for (int x = xmin; x < xmax; x++) {  		GridNode node = nodes [z * width + x] as GridNode;  		if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  			for (int i = 0; i < 4; i++) {  				GridNode other = GetNodeConnection (node' i);  				if (other != null) {  					uint tag = other.Tag;  					if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  						other.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  		else if (node.Walkable && it == 0) {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!HasNodeConnection (node' i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int z = zmin; z < zmax; z++) {  	for (int x = xmin; x < xmax; x++) {  		GridNode node = nodes [z * width + x] as GridNode;  		if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  			for (int i = 0; i < 4; i++) {  				GridNode other = GetNodeConnection (node' i);  				if (other != null) {  					uint tag = other.Tag;  					if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  						other.Tag = (uint)(erosionFirstTag + it);  					}  				}  			}  		}  		else if (node.Walkable && it == 0) {  			bool anyFalseConnections = false;  			for (int i = 0; i < 4; i++) {  				if (!HasNodeConnection (node' i)) {  					anyFalseConnections = true;  					break;  				}  			}  			if (anyFalseConnections) {  				node.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = xmin; x < xmax; x++) {  	GridNode node = nodes [z * width + x] as GridNode;  	if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  		for (int i = 0; i < 4; i++) {  			GridNode other = GetNodeConnection (node' i);  			if (other != null) {  				uint tag = other.Tag;  				if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  					other.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  	else if (node.Walkable && it == 0) {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!HasNodeConnection (node' i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.Tag = (uint)(erosionFirstTag + it);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int x = xmin; x < xmax; x++) {  	GridNode node = nodes [z * width + x] as GridNode;  	if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  		for (int i = 0; i < 4; i++) {  			GridNode other = GetNodeConnection (node' i);  			if (other != null) {  				uint tag = other.Tag;  				if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  					other.Tag = (uint)(erosionFirstTag + it);  				}  			}  		}  	}  	else if (node.Walkable && it == 0) {  		bool anyFalseConnections = false;  		for (int i = 0; i < 4; i++) {  			if (!HasNodeConnection (node' i)) {  				anyFalseConnections = true;  				break;  			}  		}  		if (anyFalseConnections) {  			node.Tag = (uint)(erosionFirstTag + it);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  	for (int i = 0; i < 4; i++) {  		GridNode other = GetNodeConnection (node' i);  		if (other != null) {  			uint tag = other.Tag;  			if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  				other.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  else if (node.Walkable && it == 0) {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Tag = (uint)(erosionFirstTag + it);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (node.Walkable && node.Tag >= erosionFirstTag && node.Tag < erosionFirstTag + it) {  	for (int i = 0; i < 4; i++) {  		GridNode other = GetNodeConnection (node' i);  		if (other != null) {  			uint tag = other.Tag;  			if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  				other.Tag = (uint)(erosionFirstTag + it);  			}  		}  	}  }  else if (node.Walkable && it == 0) {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Tag = (uint)(erosionFirstTag + it);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	GridNode other = GetNodeConnection (node' i);  	if (other != null) {  		uint tag = other.Tag;  		if (tag > erosionFirstTag + it || tag < erosionFirstTag) {  			other.Tag = (uint)(erosionFirstTag + it);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: if (node.Walkable && it == 0) {  	bool anyFalseConnections = false;  	for (int i = 0; i < 4; i++) {  		if (!HasNodeConnection (node' i)) {  			anyFalseConnections = true;  			break;  		}  	}  	if (anyFalseConnections) {  		node.Tag = (uint)(erosionFirstTag + it);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,ErodeWalkableArea,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (!HasNodeConnection (node' i)) {  		anyFalseConnections = true;  		break;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners == null) {  	corners = new int[4];  }  else {  	for (int i = 0; i < 4; i++) {  		corners [i] = 0;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners == null) {  	corners = new int[4];  }  else {  	for (int i = 0; i < 4; i++) {  		corners [i] = 0;  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: corners = new int[4];  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	corners [i] = 0;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0' j = 3; i < 4; j = i' i++) {  	int nx = x + neighbourXOffsets [i];  	int nz = z + neighbourZOffsets [i];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i]] as GridNode;  	if (IsValidConnection (node' other)) {  		node.SetConnectionInternal (i' true);  		//SetNodeConnection (node' i' true);  		corners [i]++;  		corners [j]++;  	}  	else {  		node.SetConnectionInternal (i' false);  		//SetNodeConnection (node' i' false);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0' j = 3; i < 4; j = i' i++) {  	int nx = x + neighbourXOffsets [i];  	int nz = z + neighbourZOffsets [i];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i]] as GridNode;  	if (IsValidConnection (node' other)) {  		node.SetConnectionInternal (i' true);  		//SetNodeConnection (node' i' true);  		corners [i]++;  		corners [j]++;  	}  	else {  		node.SetConnectionInternal (i' false);  		//SetNodeConnection (node' i' false);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	if (cutCorners) {  		for (int i = 0; i < 4; i++) {  			if (corners [i] >= 1) {  				int nx = x + neighbourXOffsets [i + 4];  				int nz = z + neighbourZOffsets [i + 4];  				if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  					continue;  				}  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  	else {  		for (int i = 0; i < 4; i++) {  			//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  			if (corners [i] == 2) {  				GridNode other = nodes [index + neighbourOffsets [i + 4]];  				node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  				//SetNodeConnection (node' i+4' IsValidConnection (node'other));  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (cutCorners) {  	for (int i = 0; i < 4; i++) {  		if (corners [i] >= 1) {  			int nx = x + neighbourXOffsets [i + 4];  			int nz = z + neighbourZOffsets [i + 4];  			if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  				continue;  			}  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  else {  	for (int i = 0; i < 4; i++) {  		//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  		if (corners [i] == 2) {  			GridNode other = nodes [index + neighbourOffsets [i + 4]];  			node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  			//SetNodeConnection (node' i+4' IsValidConnection (node'other));  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (corners [i] >= 1) {  		int nx = x + neighbourXOffsets [i + 4];  		int nz = z + neighbourZOffsets [i + 4];  		if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  			continue;  		}  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] >= 1) {  	int nx = x + neighbourXOffsets [i + 4];  	int nz = z + neighbourZOffsets [i + 4];  	if (nx < 0 || nz < 0 || nx >= width || nz >= depth) {  		continue;  	}  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//We don't need to check if it is out of bounds because if both of the other neighbours are inside the bounds this one must be too  	if (corners [i] == 2) {  		GridNode other = nodes [index + neighbourOffsets [i + 4]];  		node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  		//SetNodeConnection (node' i+4' IsValidConnection (node'other));  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: if (corners [i] == 2) {  	GridNode other = nodes [index + neighbourOffsets [i + 4]];  	node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  	//SetNodeConnection (node' i+4' IsValidConnection (node'other));  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CalculateConnections,The following statement contains a magic number: node.SetConnectionInternal (i + 4' IsValidConnection (node' other));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int z = 0; z < depth; z++) {  	for (int x = 0; x < width; x++) {  		node = nodes [z * width + x] as GridNode;  		if (!node.Walkable) {  			// || node.activePath != AstarPath.active.debugPath)    			continue;  		}  		//Gizmos.color = node.walkable ? Color.green : Color.red;  		//Gizmos.DrawSphere (node.position'0.2F);  		Gizmos.color = NodeColor (node' AstarPath.active.debugPathData);  		//if (true) {  		//	Gizmos.DrawCube (node.position'Vector3.one*nodeSize);  		//}  		//else   		if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {  			if (InSearchTree (node' AstarPath.active.debugPath)) {  				PathNode nodeR = debugData.GetPathNode (node);  				if (nodeR != null && nodeR.parent != null) {  					Gizmos.DrawLine ((Vector3)node.position' (Vector3)nodeR.parent.node.position);  				}  			}  		}  		else {  			for (int i = 0; i < 8; i++) {  				GridNode other = GetNodeConnection (node' i);  				if (other != null) {  					Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  				}  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	node = nodes [z * width + x] as GridNode;  	if (!node.Walkable) {  		// || node.activePath != AstarPath.active.debugPath)    		continue;  	}  	//Gizmos.color = node.walkable ? Color.green : Color.red;  	//Gizmos.DrawSphere (node.position'0.2F);  	Gizmos.color = NodeColor (node' AstarPath.active.debugPathData);  	//if (true) {  	//	Gizmos.DrawCube (node.position'Vector3.one*nodeSize);  	//}  	//else   	if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {  		if (InSearchTree (node' AstarPath.active.debugPath)) {  			PathNode nodeR = debugData.GetPathNode (node);  			if (nodeR != null && nodeR.parent != null) {  				Gizmos.DrawLine ((Vector3)node.position' (Vector3)nodeR.parent.node.position);  			}  		}  	}  	else {  		for (int i = 0; i < 8; i++) {  			GridNode other = GetNodeConnection (node' i);  			if (other != null) {  				Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  			}  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {  	if (InSearchTree (node' AstarPath.active.debugPath)) {  		PathNode nodeR = debugData.GetPathNode (node);  		if (nodeR != null && nodeR.parent != null) {  			Gizmos.DrawLine ((Vector3)node.position' (Vector3)nodeR.parent.node.position);  		}  	}  }  else {  	for (int i = 0; i < 8; i++) {  		GridNode other = GetNodeConnection (node' i);  		if (other != null) {  			Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  		}  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,OnDrawGizmos,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = GetNodeConnection (node' i);  	if (other != null) {  		Gizmos.DrawLine ((Vector3)node.position' (Vector3)other.position);  	}  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [2] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (b.extents.x' -b.extents.y' b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [3] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (b.extents.x' -b.extents.y' -b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [4] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' b.extents.y' b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [5] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' b.extents.y' -b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [6] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' -b.extents.y' b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: p [7] = matrix.MultiplyPoint3x4 (b.center + new Vector3 (-b.extents.x' -b.extents.y' -b.extents.z));  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,GetBoundsMinMax,The following statement contains a magic number: for (int i = 1; i < 8; i++) {  	min = Vector3.Min (min' p [i]);  	max = Vector3.Max (max' p [i]);  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CheckConnection,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	return HasNodeConnection (node' dir);  }  else {  	int dir1 = (dir - 4 - 1) & 0x3;  	int dir2 = (dir - 4 + 1) & 0x3;  	if (!HasNodeConnection (node' dir1) || !HasNodeConnection (node' dir2)) {  		return false;  	}  	else {  		GridNode n1 = nodes [node.NodeInGridIndex + neighbourOffsets [dir1]];  		GridNode n2 = nodes [node.NodeInGridIndex + neighbourOffsets [dir2]];  		if (!n1.Walkable || !n2.Walkable) {  			return false;  		}  		if (!HasNodeConnection (n2' dir1) || !HasNodeConnection (n1' dir2)) {  			return false;  		}  	}  	return true;  }  
Magic Number,Pathfinding,GridGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\GridGenerator.cs,CheckConnection,The following statement contains a magic number: if (neighbours == NumNeighbours.Eight) {  	return HasNodeConnection (node' dir);  }  else {  	int dir1 = (dir - 4 - 1) & 0x3;  	int dir2 = (dir - 4 + 1) & 0x3;  	if (!HasNodeConnection (node' dir1) || !HasNodeConnection (node' dir2)) {  		return false;  	}  	else {  		GridNode n1 = nodes [node.NodeInGridIndex + neighbourOffsets [dir1]];  		GridNode n2 = nodes [node.NodeInGridIndex + neighbourOffsets [dir2]];  		if (!n1.Walkable || !n2.Walkable) {  			return false;  		}  		if (!HasNodeConnection (n2' dir1) || !HasNodeConnection (n1' dir2)) {  			return false;  		}  	}  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int i = startIndex; i < endIndex; i++) {  	//Find the connection between the nodes  	TriangleMeshNode n1 = path [i] as TriangleMeshNode;  	TriangleMeshNode n2 = path [i + 1] as TriangleMeshNode;  	int a;  	bool search = true;  	for (a = 0; a < 3; a++) {  		for (int b = 0; b < 3; b++) {  			if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  				search = false;  				break;  			}  		}  		if (!search)  			break;  	}  	if (a == 3) {  		left.Add ((Vector3)n1.position);  		right.Add ((Vector3)n1.position);  		left.Add ((Vector3)n2.position);  		right.Add ((Vector3)n2.position);  	}  	else {  		left.Add ((Vector3)n1.GetVertex (a));  		right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (a = 0; a < 3; a++) {  	for (int b = 0; b < 3; b++) {  		if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  			search = false;  			break;  		}  	}  	if (!search)  		break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int b = 0; b < 3; b++) {  	if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  		search = false;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int b = 0; b < 3; b++) {  	if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  		search = false;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: for (int b = 0; b < 3; b++) {  	if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  		search = false;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  	search = false;  	break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (n1.GetVertexIndex (a) == n2.GetVertexIndex ((b + 1) % 3) && n1.GetVertexIndex ((a + 1) % 3) == n2.GetVertexIndex (b)) {  	search = false;  	break;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (a == 3) {  	left.Add ((Vector3)n1.position);  	right.Add ((Vector3)n1.position);  	left.Add ((Vector3)n2.position);  	right.Add ((Vector3)n2.position);  }  else {  	left.Add ((Vector3)n1.GetVertex (a));  	right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: if (a == 3) {  	left.Add ((Vector3)n1.position);  	right.Add ((Vector3)n1.position);  	left.Add ((Vector3)n2.position);  	right.Add ((Vector3)n2.position);  }  else {  	left.Add ((Vector3)n1.GetVertex (a));  	right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,BuildFunnelCorridor,The following statement contains a magic number: right.Add ((Vector3)n1.GetVertex ((a + 1) % 3));  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: graph.GetNodes (delegate (GraphNode _node) {  	TriangleMeshNode node = _node as TriangleMeshNode;  	bool inside = false;  	int allLeft = 0;  	int allRight = 0;  	int allTop = 0;  	int allBottom = 0;  	for (int v = 0; v < 3; v++) {  		Int3 p = node.GetVertex (v);  		Vector3 vert = (Vector3)p;  		//Vector2 vert2D = new Vector2 (vert.x'vert.z);  		if (r2.Contains (p.x' p.z)) {  			//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  			inside = true;  			break;  		}  		if (vert.x < r.xMin)  			allLeft++;  		if (vert.x > r.xMax)  			allRight++;  		if (vert.z < r.yMin)  			allTop++;  		if (vert.z > r.yMax)  			allBottom++;  		//if (!bounds.Contains (node[v]) {  		//	inside = false;  		//	break;  		//}  	}  	if (!inside) {  		if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  			return true;  		}  	}  	//Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.yellow);  	//Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.yellow);  	for (int v = 0; v < 3; v++) {  		int v2 = v > 1 ? 0 : v + 1;  		Int3 vert1 = node.GetVertex (v);  		Int3 vert2 = node.GetVertex (v2);  		if (Polygon.Intersects (a' b' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (a' c' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (c' d' vert1' vert2)) {  			inside = true;  			break;  		}  		if (Polygon.Intersects (d' b' vert1' vert2)) {  			inside = true;  			break;  		}  	}  	if (node.ContainsPoint (ia) || node.ContainsPoint (ib) || node.ContainsPoint (ic) || node.ContainsPoint (id)) {  		inside = true;  	}  	if (!inside) {  		return true;  	}  	o.WillUpdateNode (node);  	o.Apply (node);  	/*Debug.DrawLine ((Vector3)node.GetVertex(0)'(Vector3)node.GetVertex(1)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(1)'(Vector3)node.GetVertex(2)'Color.blue); 				Debug.DrawLine ((Vector3)node.GetVertex(2)'(Vector3)node.GetVertex(0)'Color.blue); 				Debug.Break ();*/return true;  });  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int v = 0; v < 3; v++) {  	Int3 p = node.GetVertex (v);  	Vector3 vert = (Vector3)p;  	//Vector2 vert2D = new Vector2 (vert.x'vert.z);  	if (r2.Contains (p.x' p.z)) {  		//Debug.DrawRay (vert'Vector3.up*10'Color.yellow);  		inside = true;  		break;  	}  	if (vert.x < r.xMin)  		allLeft++;  	if (vert.x > r.xMax)  		allRight++;  	if (vert.z < r.yMin)  		allTop++;  	if (vert.z > r.yMax)  		allBottom++;  	//if (!bounds.Contains (node[v]) {  	//	inside = false;  	//	break;  	//}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (!inside) {  	if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  		return true;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: if (allLeft == 3 || allRight == 3 || allTop == 3 || allBottom == 3) {  	return true;  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,UpdateArea,The following statement contains a magic number: for (int v = 0; v < 3; v++) {  	int v2 = v > 1 ? 0 : v + 1;  	Int3 vert1 = node.GetVertex (v);  	Int3 vert2 = node.GetVertex (v2);  	if (Polygon.Intersects (a' b' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (a' c' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (c' d' vert1' vert2)) {  		inside = true;  		break;  	}  	if (Polygon.Intersects (d' b' vert1' vert2)) {  		inside = true;  		break;  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: nodes = new TriangleMeshNode[triangles.Length / 3];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Length; i++) {  	nodes [i] = new TriangleMeshNode (active);  	TriangleMeshNode node = nodes [i];  	//new MeshNode ();  	node.Penalty = initialPenalty;  	node.Walkable = true;  	node.v0 = triangles [i * 3];  	node.v1 = triangles [i * 3 + 1];  	node.v2 = triangles [i * 3 + 2];  	if (!Polygon.IsClockwise (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		//Debug.DrawLine (vertices[node.v0]'vertices[node.v1]'Color.red);  		//Debug.DrawLine (vertices[node.v1]'vertices[node.v2]'Color.red);  		//Debug.DrawLine (vertices[node.v2]'vertices[node.v0]'Color.red);  		int tmp = node.v0;  		node.v0 = node.v2;  		node.v2 = tmp;  	}  	if (Polygon.IsColinear (vertices [node.v0]' vertices [node.v1]' vertices [node.v2])) {  		Debug.DrawLine ((Vector3)vertices [node.v0]' (Vector3)vertices [node.v1]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v1]' (Vector3)vertices [node.v2]' Color.red);  		Debug.DrawLine ((Vector3)vertices [node.v2]' (Vector3)vertices [node.v0]' Color.red);  	}  	// Make sure position is correctly set  	node.UpdatePositionFromVertices ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v0 = triangles [i * 3];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v1 = triangles [i * 3 + 1];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v2 = triangles [i * 3 + 2];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: node.v2 = triangles [i * 3 + 2];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0' j = 0; i < triangles.Length; j += 1' i += 3) {  	sides [new Int2 (triangles [i + 0]' triangles [i + 1])] = nodes [j];  	sides [new Int2 (triangles [i + 1]' triangles [i + 2])] = nodes [j];  	sides [new Int2 (triangles [i + 2]' triangles [i + 0])] = nodes [j];  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0' j = 0; i < triangles.Length; j += 1' i += 3) {  	sides [new Int2 (triangles [i + 0]' triangles [i + 1])] = nodes [j];  	sides [new Int2 (triangles [i + 1]' triangles [i + 2])] = nodes [j];  	sides [new Int2 (triangles [i + 2]' triangles [i + 0])] = nodes [j];  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0' j = 0; i < triangles.Length; j += 1' i += 3) {  	sides [new Int2 (triangles [i + 0]' triangles [i + 1])] = nodes [j];  	sides [new Int2 (triangles [i + 1]' triangles [i + 2])] = nodes [j];  	sides [new Int2 (triangles [i + 2]' triangles [i + 0])] = nodes [j];  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: i += 3
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: sides [new Int2 (triangles [i + 1]' triangles [i + 2])] = nodes [j];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: sides [new Int2 (triangles [i + 2]' triangles [i + 0])] = nodes [j];  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0' j = 0; i < triangles.Length; j += 1' i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [j];  	for (int q = 0; q < 3; q++) {  		TriangleMeshNode other;  		if (sides.TryGetValue (new Int2 (triangles [i + ((q + 1) % 3)]' triangles [i + q])' out other)) {  			connections.Add (other);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0' j = 0; i < triangles.Length; j += 1' i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [j];  	for (int q = 0; q < 3; q++) {  		TriangleMeshNode other;  		if (sides.TryGetValue (new Int2 (triangles [i + ((q + 1) % 3)]' triangles [i + q])' out other)) {  			connections.Add (other);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int i = 0' j = 0; i < triangles.Length; j += 1' i += 3) {  	connections.Clear ();  	connectionCosts.Clear ();  	//Int3 indices = new Int3(triangles[i]'triangles[i+1]'triangles[i+2]);  	TriangleMeshNode node = nodes [j];  	for (int q = 0; q < 3; q++) {  		TriangleMeshNode other;  		if (sides.TryGetValue (new Int2 (triangles [i + ((q + 1) % 3)]' triangles [i + q])' out other)) {  			connections.Add (other);  			connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  		}  	}  	node.connections = connections.ToArray ();  	node.connectionCosts = connectionCosts.ToArray ();  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: i += 3
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int q = 0; q < 3; q++) {  	TriangleMeshNode other;  	if (sides.TryGetValue (new Int2 (triangles [i + ((q + 1) % 3)]' triangles [i + q])' out other)) {  		connections.Add (other);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: for (int q = 0; q < 3; q++) {  	TriangleMeshNode other;  	if (sides.TryGetValue (new Int2 (triangles [i + ((q + 1) % 3)]' triangles [i + q])' out other)) {  		connections.Add (other);  		connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  	}  }  
Magic Number,Pathfinding,NavMeshGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NavMeshGenerator.cs,GenerateNodes,The following statement contains a magic number: if (sides.TryGetValue (new Int2 (triangles [i + ((q + 1) % 3)]' triangles [i + q])' out other)) {  	connections.Add (other);  	connectionCosts.Add ((uint)(node.position - other.position).costMagnitude);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (alsoReverse) {  	GridGraph gg = GetGridGraph (GraphIndex);  	for (int i = 0; i < 8; i++) {  		GridNode other = gg.GetNodeConnection (this' i);  		if (other != null) {  			//Remove reverse connection  			other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	GridNode other = gg.GetNodeConnection (this' i);  	if (other != null) {  		//Remove reverse connection  		other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: if (other != null) {  	//Remove reverse connection  	other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,ClearConnections,The following statement contains a magic number: other.SetConnectionInternal (i < 4 ? ((i + 2) % 4) : (((5 - 2) % 4) + 4)' false);  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetConnections,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		if (other != null)  			del (other);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 0.5f;  		left.Add (middle - cross);  		right.Add (middle + cross);  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: for (int i = 4; i < 8; i++) {  	if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  		bool rClear = false;  		bool lClear = false;  		if (GetConnectionInternal (i - 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  			if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  				rClear = true;  			}  		}  		if (GetConnectionInternal ((i - 4 + 1) % 4)) {  			GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  			if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  				lClear = true;  			}  		}  		Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  		Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  		cross.Normalize ();  		cross *= gg.nodeSize * 1.4142f;  		left.Add (middle - (lClear ? cross : Vector3.zero));  		right.Add (middle + (rClear ? cross : Vector3.zero));  		return true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i) && other == nodes [nodeInGridIndex + neighbourOffsets [i]]) {  	bool rClear = false;  	bool lClear = false;  	if (GetConnectionInternal (i - 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  		if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  			rClear = true;  		}  	}  	if (GetConnectionInternal ((i - 4 + 1) % 4)) {  		GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  		if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  			lClear = true;  		}  	}  	Vector3 middle = ((Vector3)(position + other.position)) * 0.5f;  	Vector3 cross = Vector3.Cross (gg.collision.up' (Vector3)(other.position - position));  	cross.Normalize ();  	cross *= gg.nodeSize * 1.4142f;  	left.Add (middle - (lClear ? cross : Vector3.zero));  	right.Add (middle + (rClear ? cross : Vector3.zero));  	return true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal (i - 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [i - 4]];  	if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  		rClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  	rClear = true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (n2.Walkable && n2.GetConnectionInternal ((i - 4 + 1) % 4)) {  	rClear = true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (GetConnectionInternal ((i - 4 + 1) % 4)) {  	GridNode n2 = nodes [nodeInGridIndex + neighbourOffsets [(i - 4 + 1) % 4]];  	if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  		lClear = true;  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,GetPortal,The following statement contains a magic number: if (n2.Walkable && n2.GetConnectionInternal (i - 4)) {  	lClear = true;  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,FloodFill,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		if (other != null && other.Area != region) {  			other.Area = region;  			stack.Push (other);  		}  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,UpdateRecursiveG,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		PathNode otherPN = handler.GetPathNode (other);  		if (otherPN.parent == pathNode && otherPN.pathID == pid)  			other.UpdateRecursiveG (path' otherPN' handler);  	}  }  
Magic Number,Pathfinding,GridNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\GridNode.cs,Open,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (GetConnectionInternal (i)) {  		GridNode other = nodes [nodeInGridIndex + neighbourOffsets [i]];  		if (!path.CanTraverse (other))  			continue;  		PathNode otherPN = handler.GetPathNode (other);  		if (otherPN.pathID != pid) {  			otherPN.parent = pathNode;  			otherPN.pathID = pid;  			otherPN.cost = neighbourCosts [i];  			otherPN.H = path.CalculateHScore (other);  			other.UpdateG (path' otherPN);  			//Debug.Log ("G " + otherPN.G + " F " + otherPN.F);  			handler.PushNode (otherPN);  			//Debug.DrawRay ((Vector3)otherPN.node.Position' Vector3.up'Color.blue);  		}  		else {  			//If not we can test if the path from the current node to this one is a better one then the one already used  			uint tmpCost = neighbourCosts [i];  			if (pathNode.G + tmpCost + path.GetTraversalCost (other) < otherPN.G) {  				//Debug.Log ("Path better from " + NodeIndex + " to " + otherPN.node.NodeIndex + " " + (pathNode.G+tmpCost+path.GetTraversalCost(other)) + " < " + otherPN.G);  				otherPN.cost = tmpCost;  				otherPN.parent = pathNode;  				other.UpdateRecursiveG (path' otherPN' handler);  				//Or if the path from this node ("other") to the current ("current") is better  			}  			else if (otherPN.G + tmpCost + path.GetTraversalCost (this) < pathNode.G) {  				//Debug.Log ("Path better from " + otherPN.node.NodeIndex + " to " + NodeIndex + " " + (otherPN.G+tmpCost+path.GetTraversalCost (this)) + " < " + pathNode.G);  				pathNode.parent = otherPN;  				pathNode.cost = tmpCost;  				UpdateRecursiveG (path' pathNode' handler);  			}  		}  	}  }  
Magic Number,Pathfinding,TriangleMeshNode,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\NodeClasses\TriangleMeshNode.cs,GetVertexCount,The following statement contains a magic number: return 3;  
Magic Number,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,AddNode,The following statement contains a magic number: if (nodes == null || nodeCount == nodes.Length) {  	PointNode[] nds = new PointNode[nodes != null ? System.Math.Max (nodes.Length + 4' nodes.Length * 2) : 4];  	for (int i = 0; i < nodeCount; i++)  		nds [i] = nodes [i];  	nodes = nds;  }  
Magic Number,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,AddNode,The following statement contains a magic number: if (nodes == null || nodeCount == nodes.Length) {  	PointNode[] nds = new PointNode[nodes != null ? System.Math.Max (nodes.Length + 4' nodes.Length * 2) : 4];  	for (int i = 0; i < nodeCount; i++)  		nds [i] = nodes [i];  	nodes = nds;  }  
Magic Number,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,AddNode,The following statement contains a magic number: if (nodes == null || nodeCount == nodes.Length) {  	PointNode[] nds = new PointNode[nodes != null ? System.Math.Max (nodes.Length + 4' nodes.Length * 2) : 4];  	for (int i = 0; i < nodeCount; i++)  		nds [i] = nodes [i];  	nodes = nds;  }  
Magic Number,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,ScanInternal,The following statement contains a magic number: if (maxDistance >= 0) {  	//To avoid too many allocations' these lists are reused for each node  	List<PointNode> connections = new List<PointNode> (3);  	List<uint> costs = new List<uint> (3);  	//Loop through all nodes and add connections to other nodes  	for (int i = 0; i < nodes.Length; i++) {  		connections.Clear ();  		costs.Clear ();  		PointNode node = nodes [i];  		// Only brute force is available in the free version  		for (int j = 0; j < nodes.Length; j++) {  			if (i == j)  				continue;  			PointNode other = nodes [j];  			float dist = 0;  			if (IsValidConnection (node' other' out dist)) {  				connections.Add (other);  				/** \todo Is this equal to .costMagnitude */costs.Add ((uint)Mathf.RoundToInt (dist * Int3.FloatPrecision));  			}  		}  		node.connections = connections.ToArray ();  		node.connectionCosts = costs.ToArray ();  	}  }  
Magic Number,Pathfinding,PointGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\PointGenerator.cs,ScanInternal,The following statement contains a magic number: if (maxDistance >= 0) {  	//To avoid too many allocations' these lists are reused for each node  	List<PointNode> connections = new List<PointNode> (3);  	List<uint> costs = new List<uint> (3);  	//Loop through all nodes and add connections to other nodes  	for (int i = 0; i < nodes.Length; i++) {  		connections.Clear ();  		costs.Clear ();  		PointNode node = nodes [i];  		// Only brute force is available in the free version  		for (int j = 0; j < nodes.Length; j++) {  			if (i == j)  				continue;  			PointNode other = nodes [j];  			float dist = 0;  			if (IsValidConnection (node' other' out dist)) {  				connections.Add (other);  				/** \todo Is this equal to .costMagnitude */costs.Add ((uint)Mathf.RoundToInt (dist * Int3.FloatPrecision));  			}  		}  		node.connections = connections.ToArray ();  		node.connectionCosts = costs.ToArray ();  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: if (holder.node != null) {  	RecalculateConnections (holder' depth' x' y);  }  else {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	RecalculateConnectionsRec (holder.c0' depth + 1' x' y);  	RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  	RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c1' depth + 1' x + width / 2' y);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,RecalculateConnectionsRec,The following statement contains a magic number: RecalculateConnectionsRec (holder.c3' depth + 1' x' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: if (walkable == 1 || walkable == 0 || width == 1) {  	QuadtreeNode node = new QuadtreeNode (active);  	node.SetPosition ((Int3)LocalToWorldPosition (x' y' width));  	node.Walkable = walkable == 1;  	holder.node = node;  }  else {  	//walkable = -1 //Undefined  	holder.c0 = new QuadtreeNodeHolder ();  	holder.c1 = new QuadtreeNodeHolder ();  	holder.c2 = new QuadtreeNodeHolder ();  	holder.c3 = new QuadtreeNodeHolder ();  	CreateNodeRec (holder.c0' depth + 1' x' y);  	CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  	CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  	CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c1' depth + 1' x + width / 2' y);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c2' depth + 1' x + width / 2' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,CreateNodeRec,The following statement contains a magic number: CreateNodeRec (holder.c3' depth + 1' x' y + width / 2);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: if (holder.node != null) {  	if (holder.node != dontInclude) {  		arr.Add (holder.node);  	}  }  else {  	AddNeighboursRec (arr' holder.c0' depth + 1' x' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  	AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c1' depth + 1' x + width / 2' y' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c2' depth + 1' x + width / 2' y + width / 2' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,AddNeighboursRec,The following statement contains a magic number: AddNeighboursRec (arr' holder.c3' depth + 1' x' y + width / 2' bounds' dontInclude);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: while (c.node == null) {  	int width = 1 << (System.Math.Min (editorHeightLog2' editorWidthLog2) - depth);  	if (qx >= x + width / 2) {  		x = x + width / 2;  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c2;  		}  		else {  			c = c.c1;  		}  	}  	else {  		if (qy >= y + width / 2) {  			y = y + width / 2;  			c = c.c3;  		}  		else {  			c = c.c0;  		}  	}  	depth++;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qx >= x + width / 2) {  	x = x + width / 2;  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c2;  	}  	else {  		c = c.c1;  	}  }  else {  	if (qy >= y + width / 2) {  		y = y + width / 2;  		c = c.c3;  	}  	else {  		c = c.c0;  	}  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: x = x + width / 2;  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c2;  }  else {  	c = c.c1;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c2;  }  else {  	c = c.c1;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: y = y + width / 2;  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c3;  }  else {  	c = c.c0;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: if (qy >= y + width / 2) {  	y = y + width / 2;  	c = c.c3;  }  else {  	c = c.c0;  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,QueryPoint,The following statement contains a magic number: y = y + width / 2;  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: if (h.node != null) {  	Debug.DrawRay (pos' Vector3.down' h.node.Walkable ? Color.green : Color.yellow);  }  else {  	DrawRec (h.c0' depth + 1' x' y' pos);  	DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  	DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  	DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  }  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c1' depth + 1' x + width / 2' y' pos);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c2' depth + 1' x + width / 2' y + width / 2' pos);  
Magic Number,Pathfinding,QuadtreeGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\QuadtreeGraph.cs,DrawRec,The following statement contains a magic number: DrawRec (h.c3' depth + 1' x' y + width / 2' pos);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	string[] brokenString;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			//Trim the current line  			brokenString = currentText.Split (splitIdentifier' 50);  			//Split the line into an array' separating the original line by blank spaces  			switch (brokenString [0]) {  			case "v":  				vertices++;  				break;  			case "vt":  				vt++;  				break;  			case "vn":  				vn++;  				break;  			case "f":  				face = face + brokenString.Length - 1;  				triangles = triangles + 3 * (brokenString.Length - 2);  				/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	string[] brokenString;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			//Trim the current line  			brokenString = currentText.Split (splitIdentifier' 50);  			//Split the line into an array' separating the original line by blank spaces  			switch (brokenString [0]) {  			case "v":  				vertices++;  				break;  			case "vt":  				vt++;  				break;  			case "vn":  				vn++;  				break;  			case "f":  				face = face + brokenString.Length - 1;  				triangles = triangles + 3 * (brokenString.Length - 2);  				/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	string[] brokenString;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			//Trim the current line  			brokenString = currentText.Split (splitIdentifier' 50);  			//Split the line into an array' separating the original line by blank spaces  			switch (brokenString [0]) {  			case "v":  				vertices++;  				break;  			case "vt":  				vt++;  				break;  			case "vn":  				vn++;  				break;  			case "f":  				face = face + brokenString.Length - 1;  				triangles = triangles + 3 * (brokenString.Length - 2);  				/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		//Trim the current line  		brokenString = currentText.Split (splitIdentifier' 50);  		//Split the line into an array' separating the original line by blank spaces  		switch (brokenString [0]) {  		case "v":  			vertices++;  			break;  		case "vt":  			vt++;  			break;  		case "vn":  			vn++;  			break;  		case "f":  			face = face + brokenString.Length - 1;  			triangles = triangles + 3 * (brokenString.Length - 2);  			/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		//Trim the current line  		brokenString = currentText.Split (splitIdentifier' 50);  		//Split the line into an array' separating the original line by blank spaces  		switch (brokenString [0]) {  		case "v":  			vertices++;  			break;  		case "vt":  			vt++;  			break;  		case "vn":  			vn++;  			break;  		case "f":  			face = face + brokenString.Length - 1;  			triangles = triangles + 3 * (brokenString.Length - 2);  			/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		//Trim the current line  		brokenString = currentText.Split (splitIdentifier' 50);  		//Split the line into an array' separating the original line by blank spaces  		switch (brokenString [0]) {  		case "v":  			vertices++;  			break;  		case "vt":  			vt++;  			break;  		case "vn":  			vn++;  			break;  		case "f":  			face = face + brokenString.Length - 1;  			triangles = triangles + 3 * (brokenString.Length - 2);  			/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	//Trim the current line  	brokenString = currentText.Split (splitIdentifier' 50);  	//Split the line into an array' separating the original line by blank spaces  	switch (brokenString [0]) {  	case "v":  		vertices++;  		break;  	case "vt":  		vt++;  		break;  	case "vn":  		vn++;  		break;  	case "f":  		face = face + brokenString.Length - 1;  		triangles = triangles + 3 * (brokenString.Length - 2);  		/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	//Trim the current line  	brokenString = currentText.Split (splitIdentifier' 50);  	//Split the line into an array' separating the original line by blank spaces  	switch (brokenString [0]) {  	case "v":  		vertices++;  		break;  	case "vt":  		vt++;  		break;  	case "vn":  		vn++;  		break;  	case "f":  		face = face + brokenString.Length - 1;  		triangles = triangles + 3 * (brokenString.Length - 2);  		/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	//Trim the current line  	brokenString = currentText.Split (splitIdentifier' 50);  	//Split the line into an array' separating the original line by blank spaces  	switch (brokenString [0]) {  	case "v":  		vertices++;  		break;  	case "vt":  		vt++;  		break;  	case "vn":  		vn++;  		break;  	case "f":  		face = face + brokenString.Length - 1;  		triangles = triangles + 3 * (brokenString.Length - 2);  		/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: brokenString = currentText.Split (splitIdentifier' 50);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "v":  	vertices++;  	break;  case "vt":  	vt++;  	break;  case "vn":  	vn++;  	break;  case "f":  	face = face + brokenString.Length - 1;  	triangles = triangles + 3 * (brokenString.Length - 2);  	/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "v":  	vertices++;  	break;  case "vt":  	vt++;  	break;  case "vn":  	vn++;  	break;  case "f":  	face = face + brokenString.Length - 1;  	triangles = triangles + 3 * (brokenString.Length - 2);  	/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: triangles = triangles + 3 * (brokenString.Length - 2);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following statement contains a magic number: triangles = triangles + 3 * (brokenString.Length - 2);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: using (StringReader reader = new StringReader (entireText)) {  	string currentText = reader.ReadLine ();  	char[] splitIdentifier =  {  		' '  	};  	char[] splitIdentifier2 =  {  		'/'  	};  	string[] brokenString;  	string[] brokenBrokenString;  	int f = 0;  	int f2 = 0;  	int v = 0;  	int vn = 0;  	int vt = 0;  	int vt1 = 0;  	int vt2 = 0;  	while (currentText != null) {  		if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  			}  		}  		else {  			currentText = currentText.Trim ();  			brokenString = currentText.Split (splitIdentifier' 50);  			switch (brokenString [0]) {  			case "g":  				break;  			case "usemtl":  				break;  			case "usemap":  				break;  			case "mtllib":  				break;  			case "v":  				mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				v++;  				break;  			case "vt":  				mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt++;  				break;  			case "vt1":  				mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt1++;  				break;  			case "vt2":  				mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  				vt2++;  				break;  			case "vn":  				mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  				vn++;  				break;  			case "vc":  				break;  			case "f":  				int j = 1;  				List<int> intArray = new List<int> ();  				while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  					Vector3 temp = new Vector3 ();  					brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  					//Separate the face into individual components (vert' uv' normal)  					temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  					if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  					 {  						if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  						 {  							temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  						}  						temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  					}  					j++;  					mesh.faceData [f2] = temp;  					intArray.Add (f2);  					f2++;  				}  				j = 1;  				while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  				 {  					mesh.triangles [f] = intArray [0];  					f++;  					mesh.triangles [f] = intArray [j];  					f++;  					mesh.triangles [f] = intArray [j + 1];  					f++;  					j++;  				}  				break;  			}  			currentText = reader.ReadLine ();  			if (currentText != null) {  				currentText = currentText.Replace ("  "' " ");  				//Some .obj files insert double spaces' this removes them.  			}  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (currentText != null) {  	if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  		}  	}  	else {  		currentText = currentText.Trim ();  		brokenString = currentText.Split (splitIdentifier' 50);  		switch (brokenString [0]) {  		case "g":  			break;  		case "usemtl":  			break;  		case "usemap":  			break;  		case "mtllib":  			break;  		case "v":  			mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			v++;  			break;  		case "vt":  			mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt++;  			break;  		case "vt1":  			mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt1++;  			break;  		case "vt2":  			mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  			vt2++;  			break;  		case "vn":  			mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  			vn++;  			break;  		case "vc":  			break;  		case "f":  			int j = 1;  			List<int> intArray = new List<int> ();  			while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  				Vector3 temp = new Vector3 ();  				brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  				//Separate the face into individual components (vert' uv' normal)  				temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  				if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  				 {  					if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  					 {  						temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  					}  					temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  				}  				j++;  				mesh.faceData [f2] = temp;  				intArray.Add (f2);  				f2++;  			}  			j = 1;  			while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  			 {  				mesh.triangles [f] = intArray [0];  				f++;  				mesh.triangles [f] = intArray [j];  				f++;  				mesh.triangles [f] = intArray [j + 1];  				f++;  				j++;  			}  			break;  		}  		currentText = reader.ReadLine ();  		if (currentText != null) {  			currentText = currentText.Replace ("  "' " ");  			//Some .obj files insert double spaces' this removes them.  		}  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (!currentText.StartsWith ("f ") && !currentText.StartsWith ("v ") && !currentText.StartsWith ("vt ") && !currentText.StartsWith ("vn ") && !currentText.StartsWith ("g ") && !currentText.StartsWith ("usemtl ") && !currentText.StartsWith ("mtllib ") && !currentText.StartsWith ("vt1 ") && !currentText.StartsWith ("vt2 ") && !currentText.StartsWith ("vc ") && !currentText.StartsWith ("usemap ")) {  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  	}  }  else {  	currentText = currentText.Trim ();  	brokenString = currentText.Split (splitIdentifier' 50);  	switch (brokenString [0]) {  	case "g":  		break;  	case "usemtl":  		break;  	case "usemap":  		break;  	case "mtllib":  		break;  	case "v":  		mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		v++;  		break;  	case "vt":  		mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt++;  		break;  	case "vt1":  		mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt1++;  		break;  	case "vt2":  		mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  		vt2++;  		break;  	case "vn":  		mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  		vn++;  		break;  	case "vc":  		break;  	case "f":  		int j = 1;  		List<int> intArray = new List<int> ();  		while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  			Vector3 temp = new Vector3 ();  			brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  			//Separate the face into individual components (vert' uv' normal)  			temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  			if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  			 {  				if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  				 {  					temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  				}  				temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  			}  			j++;  			mesh.faceData [f2] = temp;  			intArray.Add (f2);  			f2++;  		}  		j = 1;  		while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  		 {  			mesh.triangles [f] = intArray [0];  			f++;  			mesh.triangles [f] = intArray [j];  			f++;  			mesh.triangles [f] = intArray [j + 1];  			f++;  			j++;  		}  		break;  	}  	currentText = reader.ReadLine ();  	if (currentText != null) {  		currentText = currentText.Replace ("  "' " ");  		//Some .obj files insert double spaces' this removes them.  	}  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: brokenString = currentText.Split (splitIdentifier' 50);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  	Vector3 temp = new Vector3 ();  	brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  	//Separate the face into individual components (vert' uv' normal)  	temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  	if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  	 {  		if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  		 {  			temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  		}  		temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  	}  	j++;  	mesh.faceData [f2] = temp;  	intArray.Add (f2);  	f2++;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  	Vector3 temp = new Vector3 ();  	brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  	//Separate the face into individual components (vert' uv' normal)  	temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  	if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  	 {  		if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  		 {  			temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  		}  		temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  	}  	j++;  	mesh.faceData [f2] = temp;  	intArray.Add (f2);  	f2++;  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal   {  	if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  	 {  		temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  	}  	temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  }  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  
Magic Number,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following statement contains a magic number: while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.   {  	mesh.triangles [f] = intArray [0];  	f++;  	mesh.triangles [f] = intArray [j];  	f++;  	mesh.triangles [f] = intArray [j + 1];  	f++;  	j++;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (left.Count <= 3) {  	return false;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (left [1] == left [2] && right [1] == right [2]) {  	//System.Console.WriteLine ("Removing identical left and right");  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (left [1] == left [2] && right [1] == right [2]) {  	//System.Console.WriteLine ("Removing identical left and right");  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (left [1] == left [2] && right [1] == right [2]) {  	//System.Console.WriteLine ("Removing identical left and right");  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (left.Count <= 3) {  	return false;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (swPoint == left [1]) {  	swPoint = right [2];  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: swPoint = right [2];  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) {  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  	swPoint = left [2];  	if (swPoint == left [1]) {  		swPoint = right [2];  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) {  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  	swPoint = left [2];  	if (swPoint == left [1]) {  		swPoint = right [2];  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: while (Polygon.IsColinear (left [0]' left [1]' right [1]) || Polygon.Left (left [1]' right [1]' swPoint) == Polygon.Left (left [1]' right [1]' left [0])) {  	left.RemoveAt (1);  	right.RemoveAt (1);  	if (left.Count <= 3) {  		return false;  	}  	swPoint = left [2];  	if (swPoint == left [1]) {  		swPoint = right [2];  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (left.Count <= 3) {  	return false;  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: swPoint = left [2];  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (swPoint == left [1]) {  	swPoint = right [2];  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: swPoint = right [2];  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: for (int i = 2; i < left.Count; i++) {  	if (funnelPath.Count > 2000) {  		Debug.LogWarning ("Avoiding infinite loop. Remove this check if you have this long paths.");  		break;  	}  	Vector3 pLeft = left [i];  	Vector3 pRight = right [i];  	/*Debug.DrawLine (portalApex'portalLeft'Color.red); 				Debug.DrawLine (portalApex'portalRight'Color.yellow); 				Debug.DrawLine (portalApex'left'Color.cyan); 				Debug.DrawLine (portalApex'right'Color.cyan);*/if (Polygon.TriangleArea2 (portalApex' portalRight' pRight) >= 0) {  		if (portalApex == portalRight || Polygon.TriangleArea2 (portalApex' portalLeft' pRight) <= 0) {  			portalRight = pRight;  			rightIndex = i;  		}  		else {  			funnelPath.Add (portalLeft);  			portalApex = portalLeft;  			apexIndex = leftIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  	if (Polygon.TriangleArea2 (portalApex' portalLeft' pLeft) <= 0) {  		if (portalApex == portalLeft || Polygon.TriangleArea2 (portalApex' portalRight' pLeft) >= 0) {  			portalLeft = pLeft;  			leftIndex = i;  		}  		else {  			funnelPath.Add (portalRight);  			portalApex = portalRight;  			apexIndex = rightIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: for (int i = 2; i < left.Count; i++) {  	if (funnelPath.Count > 2000) {  		Debug.LogWarning ("Avoiding infinite loop. Remove this check if you have this long paths.");  		break;  	}  	Vector3 pLeft = left [i];  	Vector3 pRight = right [i];  	/*Debug.DrawLine (portalApex'portalLeft'Color.red); 				Debug.DrawLine (portalApex'portalRight'Color.yellow); 				Debug.DrawLine (portalApex'left'Color.cyan); 				Debug.DrawLine (portalApex'right'Color.cyan);*/if (Polygon.TriangleArea2 (portalApex' portalRight' pRight) >= 0) {  		if (portalApex == portalRight || Polygon.TriangleArea2 (portalApex' portalLeft' pRight) <= 0) {  			portalRight = pRight;  			rightIndex = i;  		}  		else {  			funnelPath.Add (portalLeft);  			portalApex = portalLeft;  			apexIndex = leftIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  	if (Polygon.TriangleArea2 (portalApex' portalLeft' pLeft) <= 0) {  		if (portalApex == portalLeft || Polygon.TriangleArea2 (portalApex' portalRight' pLeft) >= 0) {  			portalLeft = pLeft;  			leftIndex = i;  		}  		else {  			funnelPath.Add (portalRight);  			portalApex = portalRight;  			apexIndex = rightIndex;  			portalLeft = portalApex;  			portalRight = portalApex;  			leftIndex = apexIndex;  			rightIndex = apexIndex;  			i = apexIndex;  			continue;  		}  	}  }  
Magic Number,Pathfinding,FunnelModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\FunnelModifier.cs,RunFunnel,The following statement contains a magic number: if (funnelPath.Count > 2000) {  	Debug.LogWarning ("Avoiding infinite loop. Remove this check if you have this long paths.");  	break;  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int it = 0; it < iterations; it++) {  	if (subdivideEveryIter && it != 0) {  		if (nodes.Capacity < nodes.Count * 3) {  			nodes.Capacity = nodes.Count * 3;  		}  		int preLength = nodes.Count;  		for (int j = 0; j < preLength - 1; j++) {  			nodes.Add (Vector3.zero);  			nodes.Add (Vector3.zero);  		}  		for (int j = preLength - 1; j > 0; j--) {  			Vector3 p1 = nodes [j];  			Vector3 p2 = nodes [j + 1];  			nodes [j * 3] = nodes [j];  			if (j != preLength - 1) {  				nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  				nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  			}  		}  	}  	int i = 0;  	while (i < nodes.Count - 2) {  		Vector3 start = nodes [i];  		Vector3 end = nodes [i + 2];  		/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  		watch.Start ();  		if (ValidateLine (null' null' start' end)) {  			//Debug.Log ("+++ Simplified "+i+" +++");  			//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  			nodes.RemoveAt (i + 1);  			//i++;  		}  		else {  			//Debug.DrawLine (start'end'Color.red);  			i++;  		}  		watch.Stop ();  		//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (subdivideEveryIter && it != 0) {  	if (nodes.Capacity < nodes.Count * 3) {  		nodes.Capacity = nodes.Count * 3;  	}  	int preLength = nodes.Count;  	for (int j = 0; j < preLength - 1; j++) {  		nodes.Add (Vector3.zero);  		nodes.Add (Vector3.zero);  	}  	for (int j = preLength - 1; j > 0; j--) {  		Vector3 p1 = nodes [j];  		Vector3 p2 = nodes [j + 1];  		nodes [j * 3] = nodes [j];  		if (j != preLength - 1) {  			nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  			nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  		}  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (nodes.Capacity < nodes.Count * 3) {  	nodes.Capacity = nodes.Count * 3;  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (nodes.Capacity < nodes.Count * 3) {  	nodes.Capacity = nodes.Count * 3;  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes.Capacity = nodes.Count * 3;  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: for (int j = preLength - 1; j > 0; j--) {  	Vector3 p1 = nodes [j];  	Vector3 p2 = nodes [j + 1];  	nodes [j * 3] = nodes [j];  	if (j != preLength - 1) {  		nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  		nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  	}  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3] = nodes [j];  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (j != preLength - 1) {  	nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  	nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (j != preLength - 1) {  	nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  	nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: if (j != preLength - 1) {  	nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  	nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3 + 1] = Vector3.Lerp (p1' p2' 0.33F);  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: nodes [j * 3 + 2] = Vector3.Lerp (p1' p2' 0.66F);  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: while (i < nodes.Count - 2) {  	Vector3 start = nodes [i];  	Vector3 end = nodes [i + 2];  	/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  	System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  	watch.Start ();  	if (ValidateLine (null' null' start' end)) {  		//Debug.Log ("+++ Simplified "+i+" +++");  		//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  		nodes.RemoveAt (i + 1);  		//i++;  	}  	else {  		//Debug.DrawLine (start'end'Color.red);  		i++;  	}  	watch.Stop ();  	//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  }  
Magic Number,Pathfinding,RaycastModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\RaycastModifier.cs,Apply,The following statement contains a magic number: while (i < nodes.Count - 2) {  	Vector3 start = nodes [i];  	Vector3 end = nodes [i + 2];  	/*if (i == 0 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							start = p.originalStartPoint; 						} else { 							start = p.startPoint; 						} 					} 					 					if (i == nodes.Count-3 && exactStartAndEnd) { 						if (overrideClampedExacts) { 							end = p.originalEndPoint; 						} else { 							end = p.endPoint; 						} 					}*///if (ValidateLine (nodes[i]'nodes[i+2]'start'end)) {  	System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();  	watch.Start ();  	if (ValidateLine (null' null' start' end)) {  		//Debug.Log ("+++ Simplified "+i+" +++");  		//Debug.DrawLine (start+raycastOffset'end+raycastOffset'new Color (1'0'0.5F));  		nodes.RemoveAt (i + 1);  		//i++;  	}  	else {  		//Debug.DrawLine (start'end'Color.red);  		i++;  	}  	watch.Stop ();  	//Debug.Log ("Validate Line Took "+(watch.ElapsedTicks * 0.0001) +" Magnitude: "+(start-end).magnitude);  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	//subdivided[counter] = path[i];  	//counter++;  	float dist = (path [i] - path [i + 1]).magnitude;  	Vector3 startVel1 = preEndVel;  	Vector3 endVel1 = i < path.Count - 2 ? ((path [i + 2] - path [i + 1]).normalized - (path [i] - path [i + 1]).normalized).normalized : (path [i + 1] - path [i]).normalized;  	Vector3 startVel = startVel1 * dist * factor;  	Vector3 endVel = endVel1 * dist * factor;  	Vector3 start = path [i];  	Vector3 end = path [i + 1];  	//Vector3 p1 = start + startVel;  	//Vector3 p2 = end - endVel;  	float onedivdist = 1F / dist;  	for (float t = 0; t <= dist; t += maxSegmentLength) {  		float t2 = t * onedivdist;  		subdivided.Add (GetPointOnCubic (start' end' startVel' endVel' t2));  		//counter++;  	}  	preEndVel = endVel1;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,CurvedNonuniform,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	//subdivided[counter] = path[i];  	//counter++;  	float dist = (path [i] - path [i + 1]).magnitude;  	Vector3 startVel1 = preEndVel;  	Vector3 endVel1 = i < path.Count - 2 ? ((path [i + 2] - path [i + 1]).normalized - (path [i] - path [i + 1]).normalized).normalized : (path [i + 1] - path [i]).normalized;  	Vector3 startVel = startVel1 * dist * factor;  	Vector3 endVel = endVel1 * dist * factor;  	Vector3 start = path [i];  	Vector3 end = path [i + 1];  	//Vector3 p1 = start + startVel;  	//Vector3 p2 = end - endVel;  	float onedivdist = 1F / dist;  	for (float t = 0; t <= dist; t += maxSegmentLength) {  		float t2 = t * onedivdist;  		subdivided.Add (GetPointOnCubic (start' end' startVel' endVel' t2));  		//counter++;  	}  	preEndVel = endVel1;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (path.Count <= 2 || iterations <= 0) {  	return path;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (iterations > 12) {  	Debug.LogWarning ("A very high iteration count was passed' won't let this one through");  	return path;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int iteration = 0; iteration < iterations; iteration++) {  	int currentPathLength = (path.Count - 2) * (int)Mathf.Pow (2' iteration) + 2;  	//Switch the arrays  	List<Vector3> tmp = subdivided;  	subdivided = subdivided2;  	subdivided2 = tmp;  	float nextMultiplier = 1F;  	for (int i = 0; i < currentPathLength - 1; i++) {  		Vector3 current = subdivided2 [i];  		Vector3 next = subdivided2 [i + 1];  		Vector3 normal = Vector3.Cross (next - current' Vector3.up);  		normal = normal.normalized;  		//This didn't work very well' made the path jaggy  		/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  		bool secondRight = false;  		bool setFirst = false;  		bool setSecond = false;  		if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  			setFirst = true;  			firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  		}  		if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  			setSecond = true;  			secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  		}  		if (setFirst) {  			subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2] = current;  		}  		//Didn't work very well  		/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  			subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  		}  		else {  			subdivided [i * 2 + 1] = next;  		}  	}  	subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: for (int i = 0; i < currentPathLength - 1; i++) {  	Vector3 current = subdivided2 [i];  	Vector3 next = subdivided2 [i + 1];  	Vector3 normal = Vector3.Cross (next - current' Vector3.up);  	normal = normal.normalized;  	//This didn't work very well' made the path jaggy  	/*Vector3 dir = next-current; 					dir *= strength*0.5F; 					current += dir; 					next -= dir;*/bool firstRight = false;  	bool secondRight = false;  	bool setFirst = false;  	bool setSecond = false;  	if (i != 0 && !Polygon.IsColinear (current' next' subdivided2 [i - 1])) {  		setFirst = true;  		firstRight = Polygon.Left (current' next' subdivided2 [i - 1]);  	}  	if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  		setSecond = true;  		secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  	}  	if (setFirst) {  		subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2] = current;  	}  	//Didn't work very well  	/*if (setFirst && setSecond) { 						if (firstRight != secondRight) { 							nextMultiplier = 0.5F; 						} else { 							nextMultiplier = 1F; 						} 					}*/if (setSecond) {  		subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  	}  	else {  		subdivided [i * 2 + 1] = next;  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  	setSecond = true;  	secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (i < currentPathLength - 1 && !Polygon.IsColinear (current' next' subdivided2 [i + 2])) {  	setSecond = true;  	secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: secondRight = Polygon.Left (current' next' subdivided2 [i + 2]);  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setFirst) {  	subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2] = current;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setFirst) {  	subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2] = current;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2] = current + (firstRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2] = current;  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setSecond) {  	subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2 + 1] = next;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: if (setSecond) {  	subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  }  else {  	subdivided [i * 2 + 1] = next;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2 + 1] = next + (secondRight ? normal * offset * nextMultiplier : -normal * offset * nextMultiplier);  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [i * 2 + 1] = next;  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothOffsetSimple,The following statement contains a magic number: subdivided [(path.Count - 2) * (int)Mathf.Pow (2' iteration + 1) + 2 - 1] = subdivided2 [currentPathLength - 1];  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothSimple,The following statement contains a magic number: if (path.Count < 2) {  	return path;  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	Vector3 tangent1 = Vector3.zero;  	Vector3 tangent2 = Vector3.zero;  	if (i == 0) {  		tangent1 = path [i + 1] - path [i];  	}  	else {  		tangent1 = path [i + 1] - path [i - 1];  	}  	if (i == path.Count - 2) {  		tangent2 = path [i] - path [i + 1];  	}  	else {  		tangent2 = path [i] - path [i + 2];  	}  	tangent1 *= bezierTangentLength;  	tangent2 *= bezierTangentLength;  	Vector3 v1 = path [i];  	Vector3 v2 = v1 + tangent1;  	Vector3 v4 = path [i + 1];  	Vector3 v3 = v4 + tangent2;  	for (int j = 0; j < subMult; j++) {  		subdivided.Add (AstarMath.CubicBezier (v1' v2' v3' v4' (float)j / subMult));  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: for (int i = 0; i < path.Count - 1; i++) {  	Vector3 tangent1 = Vector3.zero;  	Vector3 tangent2 = Vector3.zero;  	if (i == 0) {  		tangent1 = path [i + 1] - path [i];  	}  	else {  		tangent1 = path [i + 1] - path [i - 1];  	}  	if (i == path.Count - 2) {  		tangent2 = path [i] - path [i + 1];  	}  	else {  		tangent2 = path [i] - path [i + 2];  	}  	tangent1 *= bezierTangentLength;  	tangent2 *= bezierTangentLength;  	Vector3 v1 = path [i];  	Vector3 v2 = v1 + tangent1;  	Vector3 v4 = path [i + 1];  	Vector3 v3 = v4 + tangent2;  	for (int j = 0; j < subMult; j++) {  		subdivided.Add (AstarMath.CubicBezier (v1' v2' v3' v4' (float)j / subMult));  	}  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: if (i == path.Count - 2) {  	tangent2 = path [i] - path [i + 1];  }  else {  	tangent2 = path [i] - path [i + 2];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: if (i == path.Count - 2) {  	tangent2 = path [i] - path [i + 1];  }  else {  	tangent2 = path [i] - path [i + 2];  }  
Magic Number,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,SmoothBezier,The following statement contains a magic number: tangent2 = path [i] - path [i + 2];  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (p.vectorPath.Count == 0) {  	return;  }  else if (p.vectorPath.Count < 2 && !addPoints) {  	//Vector3[] arr = new Vector3[2];  	//arr[0] = p.vectorPath[0];  	//arr[1] = p.vectorPath[0];  	//p.vectorPath = arr;  	p.vectorPath.Add (p.vectorPath [0]);  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (p.vectorPath.Count < 2 && !addPoints) {  	//Vector3[] arr = new Vector3[2];  	//arr[0] = p.vectorPath[0];  	//arr[1] = p.vectorPath[0];  	//p.vectorPath = arr;  	p.vectorPath.Add (p.vectorPath [0]);  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Original) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Original) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.ClosestOnNode) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.endPoint' p.path [p.path.Count - 1]);  }  else if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: if (exactEndPoint == Exactness.Interpolate) {  	pEnd = GetClampedPoint ((Vector3)p.path [p.path.Count - 1].position' p.originalEndPoint' p.path [p.path.Count - 1]);  	pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  }  else {  	pEnd = (Vector3)p.path [p.path.Count - 1].position;  }  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  
Magic Number,Pathfinding,StartEndModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\StartEndModifier.cs,Apply,The following statement contains a magic number: pEnd = AstarMath.NearestPointStrict ((Vector3)p.path [p.path.Count - 1].position' (Vector3)p.path [p.path.Count - 2 < 0 ? 0 : p.path.Count - 2].position' pEnd);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f' 0.4f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f' 0.4f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmos,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f' 0.4f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmosSelected,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmosSelected,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f);  
Magic Number,Pathfinding,RelevantGraphSurface,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Navmesh\RelevantGraphSurface.cs,OnDrawGizmosSelected,The following statement contains a magic number: Gizmos.color = new Color (57 / 255f' 211 / 255f' 46 / 255f);  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: while (CompleteState == PathCompleteState.NotCalculated) {  	searchedNodes++;  	//Close the current node' if the current node is the target node then the path is finished  	if (currentR.node == endNode) {  		CompleteState = PathCompleteState.Complete;  		break;  	}  	if (currentR.H < partialBestTarget.H) {  		partialBestTarget = currentR;  	}  	AstarProfiler.StartFastProfile (4);  	//Debug.DrawRay ((Vector3)currentR.node.Position' Vector3.up*2'Color.red);  	//Loop through all walkable neighbours of the node and add them to the open list.  	currentR.node.Open (this' currentR' pathHandler);  	AstarProfiler.EndFastProfile (4);  	//any nodes left to search?  	if (pathHandler.HeapEmpty ()) {  		Error ();  		LogError ("No open points' whole area searched");  		return;  	}  	//Select the node with the lowest F score and remove it from the open list  	AstarProfiler.StartFastProfile (7);  	currentR = pathHandler.PopNode ();  	AstarProfiler.EndFastProfile (7);  	//Check for time every 500 nodes' roughly every 0.5 ms usually  	if (counter > 500) {  		//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  		if (System.DateTime.UtcNow.Ticks >= targetTick) {  			//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  			return;  		}  		counter = 0;  		if (searchedNodes > 1000000) {  			throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  		}  	}  	counter++;  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.StartFastProfile (4);  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.EndFastProfile (4);  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.StartFastProfile (7);  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: AstarProfiler.EndFastProfile (7);  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if (System.DateTime.UtcNow.Ticks >= targetTick) {  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return;  	}  	counter = 0;  	if (searchedNodes > 1000000) {  		throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  	}  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: if (counter > 500) {  	//Have we exceded the maxFrameTime' if so we should wait one frame before continuing the search since we don't want the game to lag  	if (System.DateTime.UtcNow.Ticks >= targetTick) {  		//Return instead of yield'ing' a separate function handles the yield (CalculatePaths)  		return;  	}  	counter = 0;  	if (searchedNodes > 1000000) {  		throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  	}  }  
Magic Number,Pathfinding,ABPath,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Pathfinders\ABPath.cs,CalculateStep,The following statement contains a magic number: if (searchedNodes > 1000000) {  	throw new System.Exception ("Probable infinite loop. Over 1'000'000 nodes searched");  }  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,InitializeFastProfile,The following statement contains a magic number: fastProfileNames = new string[profileNames.Length + 2];  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,InitializeFastProfile,The following statement contains a magic number: fastProfileNames [fastProfileNames.Length - 2] = "__Control1__";  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: StartFastProfile (fastProfiles.Length - 2);  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < 1000; i++) {  	StartFastProfile (fastProfiles.Length - 1);  	EndFastProfile (fastProfiles.Length - 1);  }  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: EndFastProfile (fastProfiles.Length - 2);  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: for (int i = 0; i < fastProfiles.Length; i++) {  	string name = fastProfileNames [i];  	ProfilePoint value = fastProfiles [i];  	int totalCalls = value.totalCalls;  	double totalTime = value.watch.Elapsed.TotalMilliseconds - avgOverhead * totalCalls;  	if (totalCalls < 1)  		continue;  	output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  	output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  	output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  	/* output.Append("\nProfile"); 				output.Append(name); 				output.Append(" took \t"); 				output.Append(totalTime.ToString("0.0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging \t"); 				output.Append((totalTime / totalCalls).ToString("0.000")); 				output.Append(" ms per call"); */}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append ("\n").Append (name.PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append (totalTime.ToString ("0.0 ").PadLeft (10)).Append (value.watch.Elapsed.TotalMilliseconds.ToString ("(0.0)").PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append (totalCalls.ToString ().PadLeft (10)).Append ("|   ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintFastResults,The following statement contains a magic number: output.Append ((totalTime / totalCalls).ToString ("0.000").PadLeft (10));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (" Name ".PadRight (maxLength)).Append ("|").Append (" Total Time	".PadRight (20)).Append ("|").Append (" Total Calls ".PadRight (20)).Append ("|").Append (" Avg/Call ".PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: foreach (KeyValuePair<string' ProfilePoint> pair in profiles) {  	double totalTime = pair.Value.watch.Elapsed.TotalMilliseconds;  	int totalCalls = pair.Value.totalCalls;  	if (totalCalls < 1)  		continue;  	string name = pair.Key;  	output.Append ("\n").Append (name.PadRight (maxLength)).Append ("| ");  	output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  	output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  	output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  	output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  	/*output.Append("\nProfile "); 				output.Append(pair.Key); 				output.Append(" took "); 				output.Append(totalTime.ToString("0")); 				output.Append(" ms to complete over "); 				output.Append(totalCalls); 				output.Append(" iteration"); 				if (totalCalls != 1) output.Append("s"); 				output.Append("' averaging "); 				output.Append((totalTime / totalCalls).ToString("0.0")); 				output.Append(" ms per call");*/}  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (totalTime.ToString ("0.0").PadRight (20)).Append ("| ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (totalCalls.ToString ().PadRight (20)).Append ("| ");  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append ((totalTime / totalCalls).ToString ("0.000").PadRight (20));  
Magic Number,Pathfinding,AstarProfiler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarProfiler.cs,PrintResults,The following statement contains a magic number: output.Append (Pathfinding.AstarMath.FormatBytesBinary ((int)pair.Value.totalBytes).PadLeft (10));  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	Vector3 prev = pts [pts.Count - 1];  	// d = -t0/2 + sqrt( t0^2/4 + 2d/a )  	// Minimum angle (radians) which would create an arc distance greater than clearance  	float d = -t / 2 + Mathf.Sqrt (t * t / 4 + 2 * clearance / a);  	// Binary search for separating this point and the previous one  	float mn = t + d;  	float mx = t + 2 * d;  	while (mx - mn > 0.01f) {  		float mid = (mn + mx) / 2;  		Vector3 p = InvoluteOfCircle (a' mid);  		if ((p - prev).sqrMagnitude < clearance * clearance) {  			mn = mid;  		}  		else {  			mx = mid;  		}  	}  	pts.Add (InvoluteOfCircle (a' mx));  	t = mx;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetSpiralPoints,The following statement contains a magic number: while (mx - mn > 0.01f) {  	float mid = (mn + mx) / 2;  	Vector3 p = InvoluteOfCircle (a' mid);  	if ((p - prev).sqrMagnitude < clearance * clearance) {  		mn = mid;  	}  	else {  		mx = mid;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: for (int i = 0; i < previousPoints.Count; i++) {  	Vector3 dir = previousPoints [i];  	float magn = dir.magnitude;  	if (magn > 0)  		dir /= magn;  	float newMagn = radius;  	//magn > radius ? radius : magn;  	dir *= newMagn;  	bool worked = false;  	GraphHitInfo hit;  	int tests = 0;  	do {  		Vector3 pt = p + dir;  		if (g.Linecast (p' pt' nn.node' out hit)) {  			pt = hit.point;  		}  		for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  			Vector3 qt = (pt - p) * q + p;  			worked = true;  			for (int j = 0; j < i; j++) {  				if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  			if (worked) {  				previousPoints [i] = qt;  				break;  			}  		}  		if (!worked) {  			// Abort after 5 tries  			if (tests > 8) {  				worked = true;  			}  			else {  				clearanceRadius *= 0.9f;  				// This will pick points in 2D closer to the edge of the circle with a higher probability  				dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  				dir.y = 0;  				tests++;  			}  		}  	}  	while (!worked);  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: for (int i = 0; i < previousPoints.Count; i++) {  	Vector3 dir = previousPoints [i];  	float magn = dir.magnitude;  	if (magn > 0)  		dir /= magn;  	float newMagn = radius;  	//magn > radius ? radius : magn;  	dir *= newMagn;  	bool worked = false;  	GraphHitInfo hit;  	int tests = 0;  	do {  		Vector3 pt = p + dir;  		if (g.Linecast (p' pt' nn.node' out hit)) {  			pt = hit.point;  		}  		for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  			Vector3 qt = (pt - p) * q + p;  			worked = true;  			for (int j = 0; j < i; j++) {  				if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  			if (worked) {  				previousPoints [i] = qt;  				break;  			}  		}  		if (!worked) {  			// Abort after 5 tries  			if (tests > 8) {  				worked = true;  			}  			else {  				clearanceRadius *= 0.9f;  				// This will pick points in 2D closer to the edge of the circle with a higher probability  				dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  				dir.y = 0;  				tests++;  			}  		}  	}  	while (!worked);  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: do {  	Vector3 pt = p + dir;  	if (g.Linecast (p' pt' nn.node' out hit)) {  		pt = hit.point;  	}  	for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  		Vector3 qt = (pt - p) * q + p;  		worked = true;  		for (int j = 0; j < i; j++) {  			if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  		if (worked) {  			previousPoints [i] = qt;  			break;  		}  	}  	if (!worked) {  		// Abort after 5 tries  		if (tests > 8) {  			worked = true;  		}  		else {  			clearanceRadius *= 0.9f;  			// This will pick points in 2D closer to the edge of the circle with a higher probability  			dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  			dir.y = 0;  			tests++;  		}  	}  }  while (!worked);  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: do {  	Vector3 pt = p + dir;  	if (g.Linecast (p' pt' nn.node' out hit)) {  		pt = hit.point;  	}  	for (float q = 0.1f; q <= 1.0f; q += 0.05f) {  		Vector3 qt = (pt - p) * q + p;  		worked = true;  		for (int j = 0; j < i; j++) {  			if ((previousPoints [j] - qt).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  		if (worked) {  			previousPoints [i] = qt;  			break;  		}  	}  	if (!worked) {  		// Abort after 5 tries  		if (tests > 8) {  			worked = true;  		}  		else {  			clearanceRadius *= 0.9f;  			// This will pick points in 2D closer to the edge of the circle with a higher probability  			dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  			dir.y = 0;  			tests++;  		}  	}  }  while (!worked);  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (!worked) {  	// Abort after 5 tries  	if (tests > 8) {  		worked = true;  	}  	else {  		clearanceRadius *= 0.9f;  		// This will pick points in 2D closer to the edge of the circle with a higher probability  		dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  		dir.y = 0;  		tests++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (!worked) {  	// Abort after 5 tries  	if (tests > 8) {  		worked = true;  	}  	else {  		clearanceRadius *= 0.9f;  		// This will pick points in 2D closer to the edge of the circle with a higher probability  		dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  		dir.y = 0;  		tests++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (tests > 8) {  	worked = true;  }  else {  	clearanceRadius *= 0.9f;  	// This will pick points in 2D closer to the edge of the circle with a higher probability  	dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  	dir.y = 0;  	tests++;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: if (tests > 8) {  	worked = true;  }  else {  	clearanceRadius *= 0.9f;  	// This will pick points in 2D closer to the edge of the circle with a higher probability  	dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  	dir.y = 0;  	tests++;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsAroundPoint,The following statement contains a magic number: dir = Random.onUnitSphere * Mathf.Lerp (newMagn' radius' tests / 5);  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (nodes [0] is TriangleMeshNode || nodes [0] is GridNode) {  	//Assume all nodes are triangle nodes or grid nodes  	List<float> accs = Pathfinding.Util.ListPool<float>.Claim (nodes.Count);  	float tot = 0;  	for (int i = 0; i < nodes.Count; i++) {  		TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  		if (tnode != null) {  			float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  			tot += a;  			accs.Add (tot);  		}  		else {  			GridNode gnode = nodes [i] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float a = gg.nodeSize * gg.nodeSize;  				tot += a;  				accs.Add (tot);  			}  			else {  				accs.Add (tot);  			}  		}  	}  	for (int i = 0; i < count; i++) {  		//Pick point  		int testCount = 0;  		int testLimit = 10;  		bool worked = false;  		while (!worked) {  			worked = true;  			//If no valid points can be found' progressively lower the clearance radius until such a point is found  			if (testCount >= testLimit) {  				clearanceRadius *= 0.8f;  				testLimit += 10;  				if (testLimit > 100)  					clearanceRadius = 0;  			}  			float tg = (float)rnd.NextDouble () * tot;  			int v = accs.BinarySearch (tg);  			if (v < 0)  				v = ~v;  			if (v >= nodes.Count) {  				// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  				worked = false;  				continue;  			}  			TriangleMeshNode node = nodes [v] as TriangleMeshNode;  			Vector3 p;  			if (node != null) {  				// Find a random point inside the triangle  				float v1;  				float v2;  				do {  					v1 = (float)rnd.NextDouble ();  					v2 = (float)rnd.NextDouble ();  				}  				while (v1 + v2 > 1);  				p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  			}  			else {  				GridNode gnode = nodes [v] as GridNode;  				if (gnode != null) {  					GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  					float v1 = (float)rnd.NextDouble ();  					float v2 = (float)rnd.NextDouble ();  					p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  				}  				else {  					//Point nodes have no area' so we break directly instead  					pts.Add ((Vector3)nodes [v].position);  					break;  				}  			}  			// Test if it is some distance away from the other points  			if (clearanceRadius > 0) {  				for (int j = 0; j < pts.Count; j++) {  					if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  						worked = false;  						break;  					}  				}  			}  			if (worked) {  				pts.Add (p);  				break;  			}  			else {  				testCount++;  			}  		}  	}  	Pathfinding.Util.ListPool<float>.Release (accs);  }  else {  	for (int i = 0; i < count; i++) {  		pts.Add ((Vector3)nodes [rnd.Next (nodes.Count)].position);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < nodes.Count; i++) {  	TriangleMeshNode tnode = nodes [i] as TriangleMeshNode;  	if (tnode != null) {  		float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  		tot += a;  		accs.Add (tot);  	}  	else {  		GridNode gnode = nodes [i] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float a = gg.nodeSize * gg.nodeSize;  			tot += a;  			accs.Add (tot);  		}  		else {  			accs.Add (tot);  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (tnode != null) {  	float a = System.Math.Abs (Polygon.TriangleArea (tnode.GetVertex (0)' tnode.GetVertex (1)' tnode.GetVertex (2)));  	tot += a;  	accs.Add (tot);  }  else {  	GridNode gnode = nodes [i] as GridNode;  	if (gnode != null) {  		GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  		float a = gg.nodeSize * gg.nodeSize;  		tot += a;  		accs.Add (tot);  	}  	else {  		accs.Add (tot);  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: for (int i = 0; i < count; i++) {  	//Pick point  	int testCount = 0;  	int testLimit = 10;  	bool worked = false;  	while (!worked) {  		worked = true;  		//If no valid points can be found' progressively lower the clearance radius until such a point is found  		if (testCount >= testLimit) {  			clearanceRadius *= 0.8f;  			testLimit += 10;  			if (testLimit > 100)  				clearanceRadius = 0;  		}  		float tg = (float)rnd.NextDouble () * tot;  		int v = accs.BinarySearch (tg);  		if (v < 0)  			v = ~v;  		if (v >= nodes.Count) {  			// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  			worked = false;  			continue;  		}  		TriangleMeshNode node = nodes [v] as TriangleMeshNode;  		Vector3 p;  		if (node != null) {  			// Find a random point inside the triangle  			float v1;  			float v2;  			do {  				v1 = (float)rnd.NextDouble ();  				v2 = (float)rnd.NextDouble ();  			}  			while (v1 + v2 > 1);  			p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  		}  		else {  			GridNode gnode = nodes [v] as GridNode;  			if (gnode != null) {  				GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  				float v1 = (float)rnd.NextDouble ();  				float v2 = (float)rnd.NextDouble ();  				p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  			}  			else {  				//Point nodes have no area' so we break directly instead  				pts.Add ((Vector3)nodes [v].position);  				break;  			}  		}  		// Test if it is some distance away from the other points  		if (clearanceRadius > 0) {  			for (int j = 0; j < pts.Count; j++) {  				if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  					worked = false;  					break;  				}  			}  		}  		if (worked) {  			pts.Add (p);  			break;  		}  		else {  			testCount++;  		}  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: while (!worked) {  	worked = true;  	//If no valid points can be found' progressively lower the clearance radius until such a point is found  	if (testCount >= testLimit) {  		clearanceRadius *= 0.8f;  		testLimit += 10;  		if (testLimit > 100)  			clearanceRadius = 0;  	}  	float tg = (float)rnd.NextDouble () * tot;  	int v = accs.BinarySearch (tg);  	if (v < 0)  		v = ~v;  	if (v >= nodes.Count) {  		// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  		worked = false;  		continue;  	}  	TriangleMeshNode node = nodes [v] as TriangleMeshNode;  	Vector3 p;  	if (node != null) {  		// Find a random point inside the triangle  		float v1;  		float v2;  		do {  			v1 = (float)rnd.NextDouble ();  			v2 = (float)rnd.NextDouble ();  		}  		while (v1 + v2 > 1);  		p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  	}  	else {  		GridNode gnode = nodes [v] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float v1 = (float)rnd.NextDouble ();  			float v2 = (float)rnd.NextDouble ();  			p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  		}  		else {  			//Point nodes have no area' so we break directly instead  			pts.Add ((Vector3)nodes [v].position);  			break;  		}  	}  	// Test if it is some distance away from the other points  	if (clearanceRadius > 0) {  		for (int j = 0; j < pts.Count; j++) {  			if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  	}  	if (worked) {  		pts.Add (p);  		break;  	}  	else {  		testCount++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: while (!worked) {  	worked = true;  	//If no valid points can be found' progressively lower the clearance radius until such a point is found  	if (testCount >= testLimit) {  		clearanceRadius *= 0.8f;  		testLimit += 10;  		if (testLimit > 100)  			clearanceRadius = 0;  	}  	float tg = (float)rnd.NextDouble () * tot;  	int v = accs.BinarySearch (tg);  	if (v < 0)  		v = ~v;  	if (v >= nodes.Count) {  		// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  		worked = false;  		continue;  	}  	TriangleMeshNode node = nodes [v] as TriangleMeshNode;  	Vector3 p;  	if (node != null) {  		// Find a random point inside the triangle  		float v1;  		float v2;  		do {  			v1 = (float)rnd.NextDouble ();  			v2 = (float)rnd.NextDouble ();  		}  		while (v1 + v2 > 1);  		p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  	}  	else {  		GridNode gnode = nodes [v] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float v1 = (float)rnd.NextDouble ();  			float v2 = (float)rnd.NextDouble ();  			p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  		}  		else {  			//Point nodes have no area' so we break directly instead  			pts.Add ((Vector3)nodes [v].position);  			break;  		}  	}  	// Test if it is some distance away from the other points  	if (clearanceRadius > 0) {  		for (int j = 0; j < pts.Count; j++) {  			if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  	}  	if (worked) {  		pts.Add (p);  		break;  	}  	else {  		testCount++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: while (!worked) {  	worked = true;  	//If no valid points can be found' progressively lower the clearance radius until such a point is found  	if (testCount >= testLimit) {  		clearanceRadius *= 0.8f;  		testLimit += 10;  		if (testLimit > 100)  			clearanceRadius = 0;  	}  	float tg = (float)rnd.NextDouble () * tot;  	int v = accs.BinarySearch (tg);  	if (v < 0)  		v = ~v;  	if (v >= nodes.Count) {  		// This shouldn't happen' due to NextDouble being smaller than 1... but I don't trust floating point arithmetic.  		worked = false;  		continue;  	}  	TriangleMeshNode node = nodes [v] as TriangleMeshNode;  	Vector3 p;  	if (node != null) {  		// Find a random point inside the triangle  		float v1;  		float v2;  		do {  			v1 = (float)rnd.NextDouble ();  			v2 = (float)rnd.NextDouble ();  		}  		while (v1 + v2 > 1);  		p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  	}  	else {  		GridNode gnode = nodes [v] as GridNode;  		if (gnode != null) {  			GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  			float v1 = (float)rnd.NextDouble ();  			float v2 = (float)rnd.NextDouble ();  			p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  		}  		else {  			//Point nodes have no area' so we break directly instead  			pts.Add ((Vector3)nodes [v].position);  			break;  		}  	}  	// Test if it is some distance away from the other points  	if (clearanceRadius > 0) {  		for (int j = 0; j < pts.Count; j++) {  			if ((pts [j] - p).sqrMagnitude < clearanceRadius) {  				worked = false;  				break;  			}  		}  	}  	if (worked) {  		pts.Add (p);  		break;  	}  	else {  		testCount++;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (testCount >= testLimit) {  	clearanceRadius *= 0.8f;  	testLimit += 10;  	if (testLimit > 100)  		clearanceRadius = 0;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (testCount >= testLimit) {  	clearanceRadius *= 0.8f;  	testLimit += 10;  	if (testLimit > 100)  		clearanceRadius = 0;  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: testLimit += 10;  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (testLimit > 100)  	clearanceRadius = 0;  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: if (node != null) {  	// Find a random point inside the triangle  	float v1;  	float v2;  	do {  		v1 = (float)rnd.NextDouble ();  		v2 = (float)rnd.NextDouble ();  	}  	while (v1 + v2 > 1);  	p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  }  else {  	GridNode gnode = nodes [v] as GridNode;  	if (gnode != null) {  		GridGraph gg = GridNode.GetGridGraph (gnode.GraphIndex);  		float v1 = (float)rnd.NextDouble ();  		float v2 = (float)rnd.NextDouble ();  		p = (Vector3)gnode.position + new Vector3 (v1 - 0.5f' 0' v2 - 0.5f) * gg.nodeSize;  	}  	else {  		//Point nodes have no area' so we break directly instead  		pts.Add ((Vector3)nodes [v].position);  		break;  	}  }  
Magic Number,Pathfinding,PathUtilities,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\PathUtilities.cs,GetPointsOnNodes,The following statement contains a magic number: p = ((Vector3)(node.GetVertex (1) - node.GetVertex (0))) * v1 + ((Vector3)(node.GetVertex (2) - node.GetVertex (0))) * v2 + (Vector3)node.GetVertex (0);  
Magic Number,Pathfinding,Profile,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\ProfileHelper.cs,Stop,The following statement contains a magic number: if (this.control == 1 << 30)  	this.control = control;  else if (this.control != control)  	throw new System.Exception ("Control numbers do not match " + this.control + " != " + control);  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_objectToFollow != null) {  	Vector3 objectPos = _objectToFollow.transform.position;  	if (lastObjectPosition == Vector3.zero) {  		lastObjectPosition = objectPos;  	}  	//CINEMATIC CAMERA  	if (_type == CameraType.Cinematic) {  		Vector3 positionAboveObject = objectPos;  		positionAboveObject.y += _cameraY;  		if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  			if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  				transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  			}  			transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  		}  	}  	//Locked CAMERA  	if (_type == CameraType.Locked) {  		PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  		objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  		float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  		float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  		lookAtOffset = objectLookVector3;  		Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  		transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  		lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  	}  	//Follow CAMERA  	if (_type == CameraType.Follow) {  		transform.parent = _objectToFollow.transform;  		transform.localPosition = new Vector3 (0' _cameraY' _cameraToObjectDistance);  		/*_rotation = _objectToFollow.transform.eulerAngles.y/16;                     float x = _objectToFollow.transform.DirecionVector.x + _cameraToObjectDistance * Mathf.Cos(_rotation);                     float z = _objectToFollow.transform.DirecionVector.z + _cameraToObjectDistance * Mathf.Sin(_rotation);                     Vector3 _targetPos = new Vector3(x' _objectToFollow.transform.DirecionVector.y + _cameraY' z);                      transform.DirecionVector = Vector3.Lerp(transform.DirecionVector' _targetPos' Time.deltaTime * 10);*/}  	transform.LookAt (objectPos + Vector3.up + lookAtOffset);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_objectToFollow != null) {  	Vector3 objectPos = _objectToFollow.transform.position;  	if (lastObjectPosition == Vector3.zero) {  		lastObjectPosition = objectPos;  	}  	//CINEMATIC CAMERA  	if (_type == CameraType.Cinematic) {  		Vector3 positionAboveObject = objectPos;  		positionAboveObject.y += _cameraY;  		if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  			if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  				transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  			}  			transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  		}  	}  	//Locked CAMERA  	if (_type == CameraType.Locked) {  		PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  		objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  		float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  		float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  		lookAtOffset = objectLookVector3;  		Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  		transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  		lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  	}  	//Follow CAMERA  	if (_type == CameraType.Follow) {  		transform.parent = _objectToFollow.transform;  		transform.localPosition = new Vector3 (0' _cameraY' _cameraToObjectDistance);  		/*_rotation = _objectToFollow.transform.eulerAngles.y/16;                     float x = _objectToFollow.transform.DirecionVector.x + _cameraToObjectDistance * Mathf.Cos(_rotation);                     float z = _objectToFollow.transform.DirecionVector.z + _cameraToObjectDistance * Mathf.Sin(_rotation);                     Vector3 _targetPos = new Vector3(x' _objectToFollow.transform.DirecionVector.y + _cameraY' z);                      transform.DirecionVector = Vector3.Lerp(transform.DirecionVector' _targetPos' Time.deltaTime * 10);*/}  	transform.LookAt (objectPos + Vector3.up + lookAtOffset);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_objectToFollow != null) {  	Vector3 objectPos = _objectToFollow.transform.position;  	if (lastObjectPosition == Vector3.zero) {  		lastObjectPosition = objectPos;  	}  	//CINEMATIC CAMERA  	if (_type == CameraType.Cinematic) {  		Vector3 positionAboveObject = objectPos;  		positionAboveObject.y += _cameraY;  		if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  			if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  				transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  			}  			transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  		}  	}  	//Locked CAMERA  	if (_type == CameraType.Locked) {  		PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  		objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  		float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  		float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  		lookAtOffset = objectLookVector3;  		Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  		transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  		lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  	}  	//Follow CAMERA  	if (_type == CameraType.Follow) {  		transform.parent = _objectToFollow.transform;  		transform.localPosition = new Vector3 (0' _cameraY' _cameraToObjectDistance);  		/*_rotation = _objectToFollow.transform.eulerAngles.y/16;                     float x = _objectToFollow.transform.DirecionVector.x + _cameraToObjectDistance * Mathf.Cos(_rotation);                     float z = _objectToFollow.transform.DirecionVector.z + _cameraToObjectDistance * Mathf.Sin(_rotation);                     Vector3 _targetPos = new Vector3(x' _objectToFollow.transform.DirecionVector.y + _cameraY' z);                      transform.DirecionVector = Vector3.Lerp(transform.DirecionVector' _targetPos' Time.deltaTime * 10);*/}  	transform.LookAt (objectPos + Vector3.up + lookAtOffset);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_objectToFollow != null) {  	Vector3 objectPos = _objectToFollow.transform.position;  	if (lastObjectPosition == Vector3.zero) {  		lastObjectPosition = objectPos;  	}  	//CINEMATIC CAMERA  	if (_type == CameraType.Cinematic) {  		Vector3 positionAboveObject = objectPos;  		positionAboveObject.y += _cameraY;  		if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  			if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  				transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  			}  			transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  		}  	}  	//Locked CAMERA  	if (_type == CameraType.Locked) {  		PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  		objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  		float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  		float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  		lookAtOffset = objectLookVector3;  		Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  		transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  		lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  	}  	//Follow CAMERA  	if (_type == CameraType.Follow) {  		transform.parent = _objectToFollow.transform;  		transform.localPosition = new Vector3 (0' _cameraY' _cameraToObjectDistance);  		/*_rotation = _objectToFollow.transform.eulerAngles.y/16;                     float x = _objectToFollow.transform.DirecionVector.x + _cameraToObjectDistance * Mathf.Cos(_rotation);                     float z = _objectToFollow.transform.DirecionVector.z + _cameraToObjectDistance * Mathf.Sin(_rotation);                     Vector3 _targetPos = new Vector3(x' _objectToFollow.transform.DirecionVector.y + _cameraY' z);                      transform.DirecionVector = Vector3.Lerp(transform.DirecionVector' _targetPos' Time.deltaTime * 10);*/}  	transform.LookAt (objectPos + Vector3.up + lookAtOffset);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_objectToFollow != null) {  	Vector3 objectPos = _objectToFollow.transform.position;  	if (lastObjectPosition == Vector3.zero) {  		lastObjectPosition = objectPos;  	}  	//CINEMATIC CAMERA  	if (_type == CameraType.Cinematic) {  		Vector3 positionAboveObject = objectPos;  		positionAboveObject.y += _cameraY;  		if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  			if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  				transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  			}  			transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  		}  	}  	//Locked CAMERA  	if (_type == CameraType.Locked) {  		PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  		objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  		float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  		float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  		lookAtOffset = objectLookVector3;  		Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  		transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  		lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  	}  	//Follow CAMERA  	if (_type == CameraType.Follow) {  		transform.parent = _objectToFollow.transform;  		transform.localPosition = new Vector3 (0' _cameraY' _cameraToObjectDistance);  		/*_rotation = _objectToFollow.transform.eulerAngles.y/16;                     float x = _objectToFollow.transform.DirecionVector.x + _cameraToObjectDistance * Mathf.Cos(_rotation);                     float z = _objectToFollow.transform.DirecionVector.z + _cameraToObjectDistance * Mathf.Sin(_rotation);                     Vector3 _targetPos = new Vector3(x' _objectToFollow.transform.DirecionVector.y + _cameraY' z);                      transform.DirecionVector = Vector3.Lerp(transform.DirecionVector' _targetPos' Time.deltaTime * 10);*/}  	transform.LookAt (objectPos + Vector3.up + lookAtOffset);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_type == CameraType.Cinematic) {  	Vector3 positionAboveObject = objectPos;  	positionAboveObject.y += _cameraY;  	if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  		if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  			transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  		}  		transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  	}  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance) {  	if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  		transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  	}  	transform.position = Vector3.Lerp (transform.position' positionAboveObject' Time.deltaTime);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (Vector3.Distance (transform.position' positionAboveObject) > _cameraToObjectDistance * 2) {  	transform.position = Vector3.MoveTowards (transform.position' positionAboveObject' Time.deltaTime);  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_type == CameraType.Locked) {  	PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  	objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  	float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  	float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  	lookAtOffset = objectLookVector3;  	Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  	transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  	lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_type == CameraType.Locked) {  	PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  	objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  	float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  	float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  	lookAtOffset = objectLookVector3;  	Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  	transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  	lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_type == CameraType.Locked) {  	PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  	objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  	float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  	float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  	lookAtOffset = objectLookVector3;  	Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  	transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  	lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: if (_type == CameraType.Locked) {  	PlayerUnit moveableUnit = _objectToFollow.GetComponent<PlayerUnit> ();  	objectLookVector3 = Vector3.Lerp (objectLookVector3' _objectToFollow.transform.forward * (objectPos - lastObjectPosition).magnitude' Time.deltaTime);  	float x = objectPos.x + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Cos (_rotation);  	float z = objectPos.z + _cameraToObjectDistance * (Input.GetMouseButton (2) ? 0.5f : 1f) * Mathf.Sin (_rotation);  	lookAtOffset = objectLookVector3;  	Vector3 _targetPos = new Vector3 (x' objectPos.y + _cameraY * (Input.GetMouseButton (2) ? 0.5f : 1f)' z) + objectLookVector3;  	transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  	lastObjectPosition += (objectPos - lastObjectPosition) / 50f;  }  
Magic Number,Code.Core.Client.Controls.Camera,CameraController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\CameraController.cs,LateUpdate,The following statement contains a magic number: transform.position = Vector3.Lerp (transform.position' _targetPos' Time.deltaTime * 10);  
Magic Number,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,The following statement contains a magic number: maindir = cameraspeed * Mathf.Cos (transform.rotation.eulerAngles [1] * (Mathf.PI / 180));  
Magic Number,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,The following statement contains a magic number: offdir = cameraspeed * Mathf.Sin (transform.rotation.eulerAngles [1] * (Mathf.PI / 180));  
Magic Number,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,The following statement contains a magic number: if (Input.GetMouseButtonUp (2) == true)  	midmouseisdown = false;  
Magic Number,Code.Core.Client.Controls.Camera,cameracontrolxz,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontrolxz.cs,Update,The following statement contains a magic number: if (Input.GetMouseButtonDown (2) == true)  	midmouseisdown = true;  
Magic Number,Code.Core.Client.Controls.Camera,cameracontroly,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontroly.cs,FixedUpdate,The following statement contains a magic number: offdir = zoomSpeed * Mathf.Cos (transform.rotation.eulerAngles [1] * (Mathf.PI / 180));  
Magic Number,Code.Core.Client.Controls.Camera,cameracontroly,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Controls\Camera\cameracontroly.cs,FixedUpdate,The following statement contains a magic number: maindir = zoomSpeed * Mathf.Sin (transform.rotation.eulerAngles [1] * (Mathf.PI / 180));  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,Update,The following statement contains a magic number: if (isHolding)  	if (Input.GetMouseButton (1)) {  		if (PlayerUnit.MyPlayerUnit != null) {  			RaycastHit hit;  			Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  			float distance = 1000;  			int layerMask = 1 << 8;  			//layerMask = ~layerMask;  			if (Physics.Raycast (ray' out hit' distance' layerMask)) {  				SendPacket (hit' true);  				_wasMovingLastFrame = true;  			}  		}  	}  	else if (_wasMovingLastFrame) {  		//This will make the player stop' once he's not holding right mouse anymore  		RaycastHit hit = new RaycastHit ();  		StartCoroutine (StopAndResumeWalk ());  		_wasMovingLastFrame = false;  	}  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,Update,The following statement contains a magic number: if (isHolding)  	if (Input.GetMouseButton (1)) {  		if (PlayerUnit.MyPlayerUnit != null) {  			RaycastHit hit;  			Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  			float distance = 1000;  			int layerMask = 1 << 8;  			//layerMask = ~layerMask;  			if (Physics.Raycast (ray' out hit' distance' layerMask)) {  				SendPacket (hit' true);  				_wasMovingLastFrame = true;  			}  		}  	}  	else if (_wasMovingLastFrame) {  		//This will make the player stop' once he's not holding right mouse anymore  		RaycastHit hit = new RaycastHit ();  		StartCoroutine (StopAndResumeWalk ());  		_wasMovingLastFrame = false;  	}  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,Update,The following statement contains a magic number: if (Input.GetMouseButton (1)) {  	if (PlayerUnit.MyPlayerUnit != null) {  		RaycastHit hit;  		Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  		float distance = 1000;  		int layerMask = 1 << 8;  		//layerMask = ~layerMask;  		if (Physics.Raycast (ray' out hit' distance' layerMask)) {  			SendPacket (hit' true);  			_wasMovingLastFrame = true;  		}  	}  }  else if (_wasMovingLastFrame) {  	//This will make the player stop' once he's not holding right mouse anymore  	RaycastHit hit = new RaycastHit ();  	StartCoroutine (StopAndResumeWalk ());  	_wasMovingLastFrame = false;  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,Update,The following statement contains a magic number: if (Input.GetMouseButton (1)) {  	if (PlayerUnit.MyPlayerUnit != null) {  		RaycastHit hit;  		Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  		float distance = 1000;  		int layerMask = 1 << 8;  		//layerMask = ~layerMask;  		if (Physics.Raycast (ray' out hit' distance' layerMask)) {  			SendPacket (hit' true);  			_wasMovingLastFrame = true;  		}  	}  }  else if (_wasMovingLastFrame) {  	//This will make the player stop' once he's not holding right mouse anymore  	RaycastHit hit = new RaycastHit ();  	StartCoroutine (StopAndResumeWalk ());  	_wasMovingLastFrame = false;  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,Update,The following statement contains a magic number: if (PlayerUnit.MyPlayerUnit != null) {  	RaycastHit hit;  	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  	float distance = 1000;  	int layerMask = 1 << 8;  	//layerMask = ~layerMask;  	if (Physics.Raycast (ray' out hit' distance' layerMask)) {  		SendPacket (hit' true);  		_wasMovingLastFrame = true;  	}  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,Update,The following statement contains a magic number: if (PlayerUnit.MyPlayerUnit != null) {  	RaycastHit hit;  	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  	float distance = 1000;  	int layerMask = 1 << 8;  	//layerMask = ~layerMask;  	if (Physics.Raycast (ray' out hit' distance' layerMask)) {  		SendPacket (hit' true);  		_wasMovingLastFrame = true;  	}  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,MoveMyPlayerFromMouse,The following statement contains a magic number: if (PlayerUnit.MyPlayerUnit != null) {  	RaycastHit hit;  	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  	float distance = 100;  	int layerMask = 1 << 7;  	layerMask = ~layerMask;  	if (Physics.Raycast (ray' out hit' distance' layerMask)) {  		SendPacket (hit' true' true);  	}  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,MoveMyPlayerFromMouse,The following statement contains a magic number: if (PlayerUnit.MyPlayerUnit != null) {  	RaycastHit hit;  	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  	float distance = 100;  	int layerMask = 1 << 7;  	layerMask = ~layerMask;  	if (Physics.Raycast (ray' out hit' distance' layerMask)) {  		SendPacket (hit' true' true);  	}  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,MoveMyPlayerToClick,The following statement contains a magic number: if (PlayerUnit.MyPlayerUnit != null) {  	RaycastHit hit;  	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  	float distance = 100;  	int layerMask = 1 << 7;  	layerMask = ~layerMask;  	if (Physics.Raycast (ray' out hit' distance' layerMask)) {  		SendPacket (hit' false);  	}  }  
Magic Number,Code.Core.Client.Terrain,KemetTerrain,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Enviroment\KemetTerrain.cs,MoveMyPlayerToClick,The following statement contains a magic number: if (PlayerUnit.MyPlayerUnit != null) {  	RaycastHit hit;  	Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);  	float distance = 100;  	int layerMask = 1 << 7;  	layerMask = ~layerMask;  	if (Physics.Raycast (ray' out hit' distance' layerMask)) {  		SendPacket (hit' false);  	}  }  
Magic Number,Code.Core.Client.UI.Controls,Clickable,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Clickable.cs,OnMouseOver,The following statement contains a magic number: if (Input.GetMouseButtonUp (2))  	if (OnWheelClick != null)  		OnWheelClick ();  
Magic Number,Client.UI.Controls.Inputs,Listener,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Inputs\TextField.cs,KeyWasPressed,The following statement contains a magic number: if (c == "\b" [0]) {  	if (text.Length != 0) {  		text = text.Substring (0' text.Length - 1);  	}  }  else if (c == "\r" [0]) {  	Deattach ();  }  else if ((int)c != 9 && (int)c != 27)//deal with a Mac only Unity bug where it returns a char for escape and tab   {  	text += c;  }  
Magic Number,Client.UI.Controls.Inputs,Listener,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Inputs\TextField.cs,KeyWasPressed,The following statement contains a magic number: if (c == "\b" [0]) {  	if (text.Length != 0) {  		text = text.Substring (0' text.Length - 1);  	}  }  else if (c == "\r" [0]) {  	Deattach ();  }  else if ((int)c != 9 && (int)c != 27)//deal with a Mac only Unity bug where it returns a char for escape and tab   {  	text += c;  }  
Magic Number,Client.UI.Controls.Inputs,Listener,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Inputs\TextField.cs,KeyWasPressed,The following statement contains a magic number: if (c == "\r" [0]) {  	Deattach ();  }  else if ((int)c != 9 && (int)c != 27)//deal with a Mac only Unity bug where it returns a char for escape and tab   {  	text += c;  }  
Magic Number,Client.UI.Controls.Inputs,Listener,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Inputs\TextField.cs,KeyWasPressed,The following statement contains a magic number: if (c == "\r" [0]) {  	Deattach ();  }  else if ((int)c != 9 && (int)c != 27)//deal with a Mac only Unity bug where it returns a char for escape and tab   {  	text += c;  }  
Magic Number,Client.UI.Controls.Inputs,Listener,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Inputs\TextField.cs,KeyWasPressed,The following statement contains a magic number: if ((int)c != 9 && (int)c != 27)//deal with a Mac only Unity bug where it returns a char for escape and tab   {  	text += c;  }  
Magic Number,Client.UI.Controls.Inputs,Listener,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Inputs\TextField.cs,KeyWasPressed,The following statement contains a magic number: if ((int)c != 9 && (int)c != 27)//deal with a Mac only Unity bug where it returns a char for escape and tab   {  	text += c;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ax = Width / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ax = -Width / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ay = Height / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ax = Width / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ay = Height / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ax = -Width / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ay = Height / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ax = Width / 2;  
Magic Number,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following statement contains a magic number: ax = -Width / 2;  
Magic Number,Code.Core.Shared.Content.Types,ColorChanger,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\OnHoverColorChanger.cs,OnMouseEnter,The following statement contains a magic number: if (renderer != null) {  	foreach (Material material in renderer.materials) {  		originalColors [material] = material.color;  		material.color = ChangeToColor * 2;  	}  }  
Magic Number,Code.Core.Shared.Content.Types,ColorChanger,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\OnHoverColorChanger.cs,OnMouseEnter,The following statement contains a magic number: foreach (Material material in renderer.materials) {  	originalColors [material] = material.color;  	material.color = ChangeToColor * 2;  }  
Magic Number,Code.Core.Shared.Content.Types,ColorChanger,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\OnHoverColorChanger.cs,OnMouseEnter,The following statement contains a magic number: material.color = ChangeToColor * 2;  
Magic Number,Code.Core.Shared.Content.Types,Spell,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\Spell.cs,StartCasting,The following statement contains a magic number: if (p != null) {  	p.ClientUi.ShowControl (InterfaceType.ActionBars' 4);  }  
Magic Number,Code.Core.Shared.Content.Types,Spell,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\Spell.cs,StartCasting,The following statement contains a magic number: p.ClientUi.ShowControl (InterfaceType.ActionBars' 4);  
Magic Number,Code.Core.Shared.Content.Types,Spell,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\Spell.cs,FinishCasting,The following statement contains a magic number: if (p != null) {  	p.ClientUi.HideControl (InterfaceType.ActionBars' 4);  }  
Magic Number,Code.Core.Shared.Content.Types,Spell,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\Spell.cs,FinishCasting,The following statement contains a magic number: p.ClientUi.HideControl (InterfaceType.ActionBars' 4);  
Magic Number,Code.Core.Shared.Content.Types,Spell,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\Spell.cs,StrenghtChanged,The following statement contains a magic number: if (p != null) {  	List<float> floats = new List<float> ();  	floats.Add (strenght);  	p.ClientUi.SetControlValues (InterfaceType.ActionBars' 4' floats);  }  
Magic Number,Code.Core.Shared.Content.Types,Spell,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Shared\Content\Types\Spell.cs,StrenghtChanged,The following statement contains a magic number: p.ClientUi.SetControlValues (InterfaceType.ActionBars' 4' floats);  
Magic Number,Code.Core.Client.UI.Interfaces,RightClickMenu,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Interfaces\RightClickMenu.cs,Setup,The following statement contains a magic number: _backGround.dimensions = new Vector2 (8 + maxWidth * _buttonWidthRatio' 8 + _buttonHeightRatio * buttons.Count);  
Magic Number,Code.Core.Client.UI.Interfaces,RightClickMenu,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Interfaces\RightClickMenu.cs,Setup,The following statement contains a magic number: _backGround.dimensions = new Vector2 (8 + maxWidth * _buttonWidthRatio' 8 + _buttonHeightRatio * buttons.Count);  
Magic Number,Code.Core.Client.UI.Interfaces,Unit2D,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Unit2D.cs,LateUpdate,The following statement contains a magic number: if (PlayerUnit != null) {  	Vector3 pos = tk2dUIManager.Instance.UICamera.ScreenToWorldPoint (Camera.main.WorldToScreenPoint (PlayerUnit.transform.position));  	pos.z = -10;  	transform.position = pos;  }  
Magic Number,Code.Core.Client.UI.Interfaces,Unit2D,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Unit2D.cs,LateUpdate,The following statement contains a magic number: pos.z = -10;  
Magic Number,Code.Code.Libaries.Net.Packets,UnitSelectionPacketData,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Interfaces\UpperLeft\UnitSelectionInterface.cs,GetOpCode,The following statement contains a magic number: return 23;  
Magic Number,Code.Code.Libaries.Net.Packets,EnterWorldPacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForClient\EnterWorldPacket.cs,GetOpCode,The following statement contains a magic number: return 19;  
Magic Number,Code.Code.Libaries.Net.Packets,UIInventoryInterfacePacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForClient\UIInventoryInterfacePacket.cs,GetOpCode,The following statement contains a magic number: return 52;  
Magic Number,Code.Code.Libaries.Net.Packets,UIPacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForClient\UIPacket.cs,GetOpCode,The following statement contains a magic number: return 50;  
Magic Number,Code.Core.Client.UI.Scripts,Icon,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\Icon.cs,RecreateMesh,The following statement contains a magic number: newTriangles.Add (3);  
Magic Number,Code.Core.Client.UI.Scripts,Icon,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\Icon.cs,RecreateMesh,The following statement contains a magic number: newTriangles.Add (2);  
Magic Number,Code.Core.Client.UI.Scripts,Icon,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\Icon.cs,RecreateMesh,The following statement contains a magic number: newTriangles.Add (3);  
Magic Number,Code.Core.Client.UI.Scripts,KeepRelativePosition,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Scripts\KeepRelativePosition.cs,FindParent,The following statement contains a magic number: for (int i = 0; i < 10; i++) {  	if (p == null) {  		return null;  	}  	if (p.GetComponent<T> () == null) {  		p = p.parent;  	}  }  
Magic Number,Code.Core.Client.Units.Extensions,CombatUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\Extensions\CombatUnit.cs,Awake,The following statement contains a magic number: _fullHealthBarSize = 170;  
Magic Number,Code.Core.Client.Units.Extensions,CombatUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\Extensions\CombatUnit.cs,Awake,The following statement contains a magic number: _fullEnergyBarSize = 170;  
Magic Number,Code.Core.Client.Units.UnitControllers,Equipment,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\Extensions\Equipment.cs,EquipItem,The following statement contains a magic number: if (item != null) {  	if (item.EquipType == EquipmentItem.Type.LeftHand) {  		_replaceItem (skeleton._leftFingers' item);  		if (item != null) {  			skeleton.PlayAnimation ("LeftOneHand"' 2' 0.75f);  		}  	}  	else if (item.EquipType == EquipmentItem.Type.RightHand) {  		_replaceItem (skeleton._rightFingers' item);  	}  	else if (item.EquipType == EquipmentItem.Type.Helm) {  		_replaceItem (skeleton._neck' item);  	}  }  else {  	Debug.LogError ("Equiping null item.");  }  
Magic Number,Code.Core.Client.Units.UnitControllers,Equipment,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\Extensions\Equipment.cs,EquipItem,The following statement contains a magic number: if (item.EquipType == EquipmentItem.Type.LeftHand) {  	_replaceItem (skeleton._leftFingers' item);  	if (item != null) {  		skeleton.PlayAnimation ("LeftOneHand"' 2' 0.75f);  	}  }  else if (item.EquipType == EquipmentItem.Type.RightHand) {  	_replaceItem (skeleton._rightFingers' item);  }  else if (item.EquipType == EquipmentItem.Type.Helm) {  	_replaceItem (skeleton._neck' item);  }  
Magic Number,Code.Core.Client.Units.UnitControllers,Equipment,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\Extensions\Equipment.cs,EquipItem,The following statement contains a magic number: if (item != null) {  	skeleton.PlayAnimation ("LeftOneHand"' 2' 0.75f);  }  
Magic Number,Code.Core.Client.Units.UnitControllers,Equipment,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\Extensions\Equipment.cs,EquipItem,The following statement contains a magic number: skeleton.PlayAnimation ("LeftOneHand"' 2' 0.75f);  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,ProcessLookAtRotation,The following statement contains a magic number: _lookAtPositionLerped = Vector3.Lerp (_lookAtPositionLerped' !lookAtItReally ? transform.position + transform.forward * 10f : _lookAtUnit.transform.position' Time.deltaTime * 10);  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,LookAtBone,The following statement contains a magic number: if (bone != null) {  	Vector3 euler = Quaternion.LookRotation (_lookAtPositionLerped - bone.position' Vector3.up).eulerAngles;  	euler.z -= 90;  	Quaternion rot = Quaternion.Lerp (Quaternion.Euler (euler)' bone.rotation' strenght);  	bone.rotation = rot;  }  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,LookAtBone,The following statement contains a magic number: euler.z -= 90;  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,PlayAnimation,The following statement contains a magic number: if (id != "-1")  	if (_animation != null) {  		if (_animation [id] == null) {  			Debug.LogError ("missing anim id: " + id);  			return;  		}  		_animation [id].layer = layer;  		_animation.Blend (id' strenght' FADE_OUT_TIME);  		if (layer == 1) {  			_animation [id].AddMixingTransform (_chest);  		}  		if (layer == 2) {  			_animation [id].AddMixingTransform (_leftShoulder);  		}  		if (layer == 3) {  			_animation [id].AddMixingTransform (_rightShoulder);  		}  	}  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,PlayAnimation,The following statement contains a magic number: if (id != "-1")  	if (_animation != null) {  		if (_animation [id] == null) {  			Debug.LogError ("missing anim id: " + id);  			return;  		}  		_animation [id].layer = layer;  		_animation.Blend (id' strenght' FADE_OUT_TIME);  		if (layer == 1) {  			_animation [id].AddMixingTransform (_chest);  		}  		if (layer == 2) {  			_animation [id].AddMixingTransform (_leftShoulder);  		}  		if (layer == 3) {  			_animation [id].AddMixingTransform (_rightShoulder);  		}  	}  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,PlayAnimation,The following statement contains a magic number: if (_animation != null) {  	if (_animation [id] == null) {  		Debug.LogError ("missing anim id: " + id);  		return;  	}  	_animation [id].layer = layer;  	_animation.Blend (id' strenght' FADE_OUT_TIME);  	if (layer == 1) {  		_animation [id].AddMixingTransform (_chest);  	}  	if (layer == 2) {  		_animation [id].AddMixingTransform (_leftShoulder);  	}  	if (layer == 3) {  		_animation [id].AddMixingTransform (_rightShoulder);  	}  }  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,PlayAnimation,The following statement contains a magic number: if (_animation != null) {  	if (_animation [id] == null) {  		Debug.LogError ("missing anim id: " + id);  		return;  	}  	_animation [id].layer = layer;  	_animation.Blend (id' strenght' FADE_OUT_TIME);  	if (layer == 1) {  		_animation [id].AddMixingTransform (_chest);  	}  	if (layer == 2) {  		_animation [id].AddMixingTransform (_leftShoulder);  	}  	if (layer == 3) {  		_animation [id].AddMixingTransform (_rightShoulder);  	}  }  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,PlayAnimation,The following statement contains a magic number: if (layer == 2) {  	_animation [id].AddMixingTransform (_leftShoulder);  }  
Magic Number,Code.Core.Client.Units.UnitControllers,UnitDisplay,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\UnitControllers\UnitDisplay.cs,PlayAnimation,The following statement contains a magic number: if (layer == 3) {  	_animation [id].AddMixingTransform (_rightShoulder);  }  
Magic Number,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,The following statement contains a magic number: if (movementUpdate) {  	int mask2 = b.getByte ();  	bitArray = new BitArray (new[] {  		mask2  	});  	bool positionUpdate = bitArray [0];  	bool rotationUpdate = bitArray [1];  	bool teleported = bitArray [2];  	if (positionUpdate) {  		Vector3 pos = b.getPosition6B ();  		if (!teleported) {  			MovementTargetPosition = pos;  		}  		else {  			MovementTargetPosition = pos;  			FixYOnTerrain (ref pos);  			transform.localPosition = pos;  		}  	}  	if (rotationUpdate) {  		float rotation = b.getFloat4B ();  		TargetRotation = rotation;  	}  	#if DEBUG_NETWORK  	                log = "";                 log += "\n" + "post movement offset " + b.Offset;                 log += "\n" + "positionUpdate " + positionUpdate;                 log += "\n" + "rotationUpdate " + rotationUpdate;                 Debug.Log(log); #endif  }  
Magic Number,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,The following statement contains a magic number: if (animUpdate) {  	int mask2 = b.getByte ();  	var bitArray2 = new BitArray (new[] {  		mask2  	});  	#if DEBUG_NETWORK  	                log = "";                 log += "\n" + "pre anim offset " + b.Offset;                 log += "\n" + "bitArray2 " + bitArray2;                 Debug.Log(log); #endif  	if (bitArray2 [0]) {  		string a = b.getString ();  		if (Display != null)  			Display.StandAnimation = a;  	}  	if (bitArray2 [1]) {  		string a = b.getString ();  		if (Display != null)  			Display.WalkAnimation = a;  	}  	if (bitArray2 [2]) {  		string a = b.getString ();  		if (Display != null)  			Display.RunAnimation = a;  	}  	if (bitArray2 [3]) {  		string a = b.getString ();  		if (Display != null)  			Display.ActionAnimation = a;  	}  	int lookingAtUnitID = b.getShort ();  	Display.LookAtUnit = lookingAtUnitID == -1 ? null : UnitManager.Instance.GetUnit (lookingAtUnitID);  }  
Magic Number,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,The following statement contains a magic number: if (animUpdate) {  	int mask2 = b.getByte ();  	var bitArray2 = new BitArray (new[] {  		mask2  	});  	#if DEBUG_NETWORK  	                log = "";                 log += "\n" + "pre anim offset " + b.Offset;                 log += "\n" + "bitArray2 " + bitArray2;                 Debug.Log(log); #endif  	if (bitArray2 [0]) {  		string a = b.getString ();  		if (Display != null)  			Display.StandAnimation = a;  	}  	if (bitArray2 [1]) {  		string a = b.getString ();  		if (Display != null)  			Display.WalkAnimation = a;  	}  	if (bitArray2 [2]) {  		string a = b.getString ();  		if (Display != null)  			Display.RunAnimation = a;  	}  	if (bitArray2 [3]) {  		string a = b.getString ();  		if (Display != null)  			Display.ActionAnimation = a;  	}  	int lookingAtUnitID = b.getShort ();  	Display.LookAtUnit = lookingAtUnitID == -1 ? null : UnitManager.Instance.GetUnit (lookingAtUnitID);  }  
Magic Number,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,The following statement contains a magic number: if (bitArray2 [2]) {  	string a = b.getString ();  	if (Display != null)  		Display.RunAnimation = a;  }  
Magic Number,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,DecodeUnitUpdate,The following statement contains a magic number: if (bitArray2 [3]) {  	string a = b.getString ();  	if (Display != null)  		Display.ActionAnimation = a;  }  
Magic Number,Code.Core.Client.Units,PlayerUnit,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\Units\PlayerUnit.cs,GetBit,The following statement contains a magic number: if (index < 0 || index > 7)  	throw new ArgumentOutOfRangeException ();  
Magic Number,Server,Server,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Server.cs,CreateServerSocket,The following statement contains a magic number: newSocket.Listen (10);  
Magic Number,Server.Model.Entities.Human,Human,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Entities\Human\Human.cs,Awake,The following statement contains a magic number: Inventory.Width = 4;  
Magic Number,Server.Model.Entities.Human,Human,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Entities\Human\Human.cs,Awake,The following statement contains a magic number: Inventory.Height = 4;  
Magic Number,Server.Model,World,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\World.cs,CreateWorldInstance,The following statement contains a magic number: world.Tree = new QuadTree (3' Vector2.zero' Vector2.one * 1024);  
Magic Number,Server.Model,World,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\World.cs,CreateWorldInstance,The following statement contains a magic number: world.Tree = new QuadTree (3' Vector2.zero' Vector2.one * 1024);  
Magic Number,Server.Model.Extensions.UnitExts,UnitActions,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitActions.cs,OnExtensionWasAdded,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	Spells.Add (null);  	EquipSpell (ContentManager.I.Spells [i]' i);  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitActions,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitActions.cs,EquipSpell,The following statement contains a magic number: if (p != null) {  	CorotineManager.Instance.RunCoroutine (delegate {  		UIInterfaceEvent packet = new UIInterfaceEvent ();  		packet.interfaceId = InterfaceType.ActionBars;  		packet.controlID = 5 + i;  		packet._eventType = UIInterfaceEvent.EventType.SEND_DATA;  		var floats = new List<float> ();  		floats.Add (spell.InContentManagerId + 0.01f);  		packet.values = floats;  		p.Client.ConnectionHandler.SendPacket (packet);  	}' 1f);  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitActions,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitActions.cs,EquipSpell,The following statement contains a magic number: CorotineManager.Instance.RunCoroutine (delegate {  	UIInterfaceEvent packet = new UIInterfaceEvent ();  	packet.interfaceId = InterfaceType.ActionBars;  	packet.controlID = 5 + i;  	packet._eventType = UIInterfaceEvent.EventType.SEND_DATA;  	var floats = new List<float> ();  	floats.Add (spell.InContentManagerId + 0.01f);  	packet.values = floats;  	p.Client.ConnectionHandler.SendPacket (packet);  }' 1f);  
Magic Number,Server.Model.Extensions.UnitExts,UnitActions,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitActions.cs,EquipSpell,The following statement contains a magic number: packet.controlID = 5 + i;  
Magic Number,Server.Model.Extensions.UnitExts,UnitAttributes,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitAttributes.cs,Progress,The following statement contains a magic number: if (_updateTick == 5) {  	UpdateAttributes ();  	_updateTick = 0;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,Progress,The following statement contains a magic number: if (RegenTick >= RegenUpdateTick) {  	RegenTick = 0;  	Energy += 0.05f;  	Energy = Mathf.Clamp (Energy' 0' 100);  	Health += 0.01f;  	Health = Mathf.Clamp (Health' 0' 100);  	_wasUpdate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,Progress,The following statement contains a magic number: if (RegenTick >= RegenUpdateTick) {  	RegenTick = 0;  	Energy += 0.05f;  	Energy = Mathf.Clamp (Energy' 0' 100);  	Health += 0.01f;  	Health = Mathf.Clamp (Health' 0' 100);  	_wasUpdate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,Progress,The following statement contains a magic number: Energy = Mathf.Clamp (Energy' 0' 100);  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,Progress,The following statement contains a magic number: Health = Mathf.Clamp (Health' 0' 100);  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,OnExtensionWasAdded,The following statement contains a magic number: Health = 100;  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,OnExtensionWasAdded,The following statement contains a magic number: Energy = 100;  
Magic Number,Server.Model.Extensions.UnitExts,UnitCombat,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitCombat.cs,ReduceEnergy,The following statement contains a magic number: Energy = Mathf.Clamp (Energy' 0' 100);  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,Progress,The following statement contains a magic number: if (Running && Unit.Combat.Energy < 20) {  	Running = false;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: if (entity is Human) {  	Teleport (new Vector3 (20' 10' 20));  	WalkTo (new Vector3 (21' 10' 21));  	CanMove = true;  	CanRotate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: if (entity is Human) {  	Teleport (new Vector3 (20' 10' 20));  	WalkTo (new Vector3 (21' 10' 21));  	CanMove = true;  	CanRotate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: if (entity is Human) {  	Teleport (new Vector3 (20' 10' 20));  	WalkTo (new Vector3 (21' 10' 21));  	CanMove = true;  	CanRotate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: if (entity is Human) {  	Teleport (new Vector3 (20' 10' 20));  	WalkTo (new Vector3 (21' 10' 21));  	CanMove = true;  	CanRotate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: if (entity is Human) {  	Teleport (new Vector3 (20' 10' 20));  	WalkTo (new Vector3 (21' 10' 21));  	CanMove = true;  	CanRotate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: if (entity is Human) {  	Teleport (new Vector3 (20' 10' 20));  	WalkTo (new Vector3 (21' 10' 21));  	CanMove = true;  	CanRotate = true;  }  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: Teleport (new Vector3 (20' 10' 20));  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: Teleport (new Vector3 (20' 10' 20));  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: Teleport (new Vector3 (20' 10' 20));  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: WalkTo (new Vector3 (21' 10' 21));  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: WalkTo (new Vector3 (21' 10' 21));  
Magic Number,Server.Model.Extensions.UnitExts,UnitMovement,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Extensions\UnitExts\UnitMovement.cs,OnExtensionWasAdded,The following statement contains a magic number: WalkTo (new Vector3 (21' 10' 21));  
Magic Number,Server.Model.Pathfinding,PathFindingController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Pathfinding\PathFindingController.cs,ForceBuild,The following statement contains a magic number: for (int i = 0; i < _astarPath.graphs.Length; i++) {  	var graph = new GridGraph ();  	graph.Width = GridSize;  	graph.Depth = GridSize;  	graph.maxClimb = 200;  	graph.maxSlope = 30f;  	graph.nodeSize = nodeSize;  	graph.center = new Vector3 (x * GridSize + GridSize / 2f * nodeSize - x' 0' z * GridSize + GridSize / 2f * nodeSize);  	graph.UpdateSizeFromWidthDepth ();  	graph.active = _astarPath;  	_astarPath.graphs [i] = graph;  	x++;  	if (x == Width) {  		x = 0;  		z++;  	}  }  
Magic Number,Server.Model.Pathfinding,PathFindingController,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Server\Model\Pathfinding\PathFindingController.cs,ForceBuild,The following statement contains a magic number: graph.maxClimb = 200;  
Magic Number,Pathfinding.Util,Checksum,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarChecksum.cs,GetChecksum,The following statement contains a magic number: for (int i = 0; i < Value.Length; i++) {  	CRCVal = (CRCVal >> 8) ^ CRCTable [(CRCVal & 0xff) ^ Value [i]];  }  
Magic Number,Pathfinding.Util,Checksum,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarChecksum.cs,GetChecksum,The following statement contains a magic number: CRCVal = (CRCVal >> 8) ^ CRCTable [(CRCVal & 0xff) ^ Value [i]];  
Magic Number,Pathfinding.Util,Memory,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: while (index < length) {  	Buffer.BlockCopy (array' 0' array' index' Math.Min (block' length - index));  	index += block;  	block *= 2;  }  
Magic Number,Pathfinding.Util,Memory,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: block *= 2;  
Magic Number,Pathfinding.Util,Memory,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: while (index < length) {  	Buffer.BlockCopy (array' 0' array' index * byteSize' Math.Min (block' length - index) * byteSize);  	index += block;  	block *= 2;  }  
Magic Number,Pathfinding.Util,Memory,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: block *= 2;  
Magic Number,Pathfinding.Util,Memory,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: while (index < length) {  	Buffer.BlockCopy (array' 0' array' index * byteSize' Math.Min (block' totalSize - index) * byteSize);  	index += block;  	block *= 2;  }  
Magic Number,Pathfinding.Util,Memory,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\AstarMemory.cs,MemSet,The following statement contains a magic number: block *= 2;  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _a = ((ulong)bytes [0] << 8 * 0) | ((ulong)bytes [1] << 8 * 1) | ((ulong)bytes [2] << 8 * 2) | ((ulong)bytes [3] << 8 * 3) | ((ulong)bytes [4] << 8 * 4) | ((ulong)bytes [5] << 8 * 5) | ((ulong)bytes [6] << 8 * 6) | ((ulong)bytes [7] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: _b = ((ulong)bytes [8] << 8 * 0) | ((ulong)bytes [9] << 8 * 1) | ((ulong)bytes [10] << 8 * 2) | ((ulong)bytes [11] << 8 * 3) | ((ulong)bytes [12] << 8 * 4) | ((ulong)bytes [13] << 8 * 5) | ((ulong)bytes [14] << 8 * 6) | ((ulong)bytes [15] << 8 * 7);  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: if (str.Length < 32)  	throw new System.FormatException ("Invalid Guid format");  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 16; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_a |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 16; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_a |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset -= 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset = 15 * 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset = 15 * 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 32; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_b |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: for (; counter < 32; i++) {  	if (i >= str.Length)  		throw new System.FormatException ("Invalid Guid format. String too short");  	char c = str [i];  	if (c == '-')  		continue;  	//Neat trick' perhaps a bit slow' but one will probably not use Guid parsing that much  	int value = hex.IndexOf (char.ToUpperInvariant (c));  	if (value == -1)  		throw new System.FormatException ("Invalid Guid format : " + c + " is not a hexadecimal character");  	_b |= (ulong)value << offset;  	//SetByte (counter'(byte)value);  	offset -= 4;  	counter++;  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,Guid,The following statement contains a magic number: offset -= 4;  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	bytes [i] = ba [i];  	bytes [i + 8] = bb [i];  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,ToByteArray,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	bytes [i] = ba [i];  	bytes [i + 8] = bb [i];  }  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,ToByteArray,The following statement contains a magic number: bytes [i + 8] = bb [i];  
Magic Number,Pathfinding.Util,Guid,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Utilities\DotNetReplacements.cs,GetHashCode,The following statement contains a magic number: return (int)(ab >> 32) ^ (int)ab;  
Magic Number,Pathfinding.Serialization,MatrixConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The following statement contains a magic number: if (arr.Length != 16) {  	Debug.LogError ("Number of elements in matrix was not 16 (got " + arr.Length + ")");  	return m;  }  
Magic Number,Pathfinding.Serialization,MatrixConverter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonConverters.cs,ReadJson,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	m [i] = System.Convert.ToSingle (arr.GetValue (new int[] {  		i  	}));  
Magic Number,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeUserConnections,The following statement contains a magic number: if (bytes.Length <= 2)  	return;  
Magic Number,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeEditorSettings,The following statement contains a magic number: for (int i = 0; i < editors.Length; i++) {  	if (editors [i] == null)  		return;  	System.Text.StringBuilder output = GetStringBuilder ();  	//new System.Text.StringBuilder();  	JsonWriter writer = new JsonWriter (output' writerSettings);  	writer.Write (editors [i]);  	byte[] bytes = encoding.GetBytes (output.ToString ());  	//Less or equal to 2 bytes means that nothing was saved (file is "{}")  	if (bytes.Length <= 2)  		continue;  	AddChecksum (bytes);  	zip.AddEntry ("graph" + i + "_editor" + jsonExt' bytes);  }  
Magic Number,Pathfinding.Serialization,AstarSerializer,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Serialization\JsonSerializer.cs,SerializeEditorSettings,The following statement contains a magic number: if (bytes.Length <= 2)  	continue;  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: if (nodes.Count < 3)  	return null;  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: while (currentNodeIndex + 1 <= nodes.Count) {  	//creating vertices  	for (int i = 0; i < 1; i++) {  		Vector3 pos = nodes [currentNodeIndex].transform.localPosition;  		UV.Add (new Vector2 (pos.x' pos.y));  		vertices.Add (nodes [currentNodeIndex++].transform.localPosition);  	}  	//creating triangles  	if (_triangulate) {  		triangulator = new Triangulator (vertices);  		triangles = new List<int> (triangulator.Triangulate ());  	}  	else {  		triangles.Add (currentNodeIndex - 1);  		triangles.Add (currentNodeIndex - 2);  		triangles.Add (currentNodeIndex - 3);  	}  }  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: while (currentNodeIndex + 1 <= nodes.Count) {  	//creating vertices  	for (int i = 0; i < 1; i++) {  		Vector3 pos = nodes [currentNodeIndex].transform.localPosition;  		UV.Add (new Vector2 (pos.x' pos.y));  		vertices.Add (nodes [currentNodeIndex++].transform.localPosition);  	}  	//creating triangles  	if (_triangulate) {  		triangulator = new Triangulator (vertices);  		triangles = new List<int> (triangulator.Triangulate ());  	}  	else {  		triangles.Add (currentNodeIndex - 1);  		triangles.Add (currentNodeIndex - 2);  		triangles.Add (currentNodeIndex - 3);  	}  }  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: if (_triangulate) {  	triangulator = new Triangulator (vertices);  	triangles = new List<int> (triangulator.Triangulate ());  }  else {  	triangles.Add (currentNodeIndex - 1);  	triangles.Add (currentNodeIndex - 2);  	triangles.Add (currentNodeIndex - 3);  }  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: if (_triangulate) {  	triangulator = new Triangulator (vertices);  	triangles = new List<int> (triangulator.Triangulate ());  }  else {  	triangles.Add (currentNodeIndex - 1);  	triangles.Add (currentNodeIndex - 2);  	triangles.Add (currentNodeIndex - 3);  }  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: triangles.Add (currentNodeIndex - 2);  
Magic Number,Game.Code.Scripts.Meshing,NodeCollection,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\NodeCollection.cs,CreateMesh,The following statement contains a magic number: triangles.Add (currentNodeIndex - 3);  
Magic Number,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Triangulate,The following statement contains a magic number: if (n < 3)  	return indices.ToArray ();  
Magic Number,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Triangulate,The following statement contains a magic number: for (int m = 0' v = nv - 1; nv > 2;) {  	if ((count--) <= 0)  		return indices.ToArray ();  	int u = v;  	if (nv <= u)  		u = 0;  	v = u + 1;  	if (nv <= v)  		v = 0;  	int w = v + 1;  	if (nv <= w)  		w = 0;  	if (Snip (u' v' w' nv' V)) {  		int a' b' c' s' t;  		a = V [u];  		b = V [v];  		c = V [w];  		indices.Add (a);  		indices.Add (b);  		indices.Add (c);  		m++;  		for (s = v' t = v + 1; t < nv; s++' t++)  			V [s] = V [t];  		nv--;  		count = 2 * nv;  	}  }  
Magic Number,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Triangulate,The following statement contains a magic number: for (int m = 0' v = nv - 1; nv > 2;) {  	if ((count--) <= 0)  		return indices.ToArray ();  	int u = v;  	if (nv <= u)  		u = 0;  	v = u + 1;  	if (nv <= v)  		v = 0;  	int w = v + 1;  	if (nv <= w)  		w = 0;  	if (Snip (u' v' w' nv' V)) {  		int a' b' c' s' t;  		a = V [u];  		b = V [v];  		c = V [w];  		indices.Add (a);  		indices.Add (b);  		indices.Add (c);  		m++;  		for (s = v' t = v + 1; t < nv; s++' t++)  			V [s] = V [t];  		nv--;  		count = 2 * nv;  	}  }  
Magic Number,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Triangulate,The following statement contains a magic number: if (Snip (u' v' w' nv' V)) {  	int a' b' c' s' t;  	a = V [u];  	b = V [v];  	c = V [w];  	indices.Add (a);  	indices.Add (b);  	indices.Add (c);  	m++;  	for (s = v' t = v + 1; t < nv; s++' t++)  		V [s] = V [t];  	nv--;  	count = 2 * nv;  }  
Magic Number,Game.Code.Scripts.Meshing,Triangulator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Building\Meshing\Triangulator.cs,Triangulate,The following statement contains a magic number: count = 2 * nv;  
Magic Number,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,DrawGizmos,The following statement contains a magic number: if (!_isDivided) {  	Gizmos.color = Color.white;  	Gizmos.DrawWireCube (_position + _size / 2' _size);  	foreach (var o in objects) {  		Gizmos.DrawCube (o.GetPosition ()' Vector3.one);  	}  }  else {  	Gizmos.color = Color.red;  	Gizmos.DrawWireCube (_position + _size / 2' _size);  	foreach (var item in children) {  		item.DrawGizmos ();  	}  }  
Magic Number,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,DrawGizmos,The following statement contains a magic number: if (!_isDivided) {  	Gizmos.color = Color.white;  	Gizmos.DrawWireCube (_position + _size / 2' _size);  	foreach (var o in objects) {  		Gizmos.DrawCube (o.GetPosition ()' Vector3.one);  	}  }  else {  	Gizmos.color = Color.red;  	Gizmos.DrawWireCube (_position + _size / 2' _size);  	foreach (var item in children) {  		item.DrawGizmos ();  	}  }  
Magic Number,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,DrawGizmos,The following statement contains a magic number: Gizmos.DrawWireCube (_position + _size / 2' _size);  
Magic Number,Code.Libaries.Generic.Trees,QuadTree,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Generic\Trees\QuadTree.cs,DrawGizmos,The following statement contains a magic number: Gizmos.DrawWireCube (_position + _size / 2' _size);  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (!string.IsNullOrEmpty (str)) {  	str = str.Trim (WHITESPACE);  	if (strict) {  		if (str [0] != '[' && str [0] != '{') {  			type = Type.NULL;  			Debug.LogWarning ("Improper (strict) JSON formatting.  First character must be [ or {");  			return;  		}  	}  	if (str.Length > 0) {  		if (string.Compare (str' "true"' true) == 0) {  			type = Type.BOOL;  			b = true;  		}  		else if (string.Compare (str' "false"' true) == 0) {  			type = Type.BOOL;  			b = false;  		}  		else if (string.Compare (str' "null"' true) == 0) {  			type = Type.NULL;  			#if USEFLOAT  		}  		else if (str == INFINITY) {  			type = Type.NUMBER;  			n = float.PositiveInfinity;  		}  		else if (str == NEGINFINITY) {  			type = Type.NUMBER;  			n = float.NegativeInfinity;  		}  		else if (str == NaN) {  			type = Type.NUMBER;  			n = float.NaN;  			#else  							} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  		}  		else if (str [0] == '"') {  			type = Type.STRING;  			this.str = str.Substring (1' str.Length - 2);  		}  		else {  			int tokenTmp = 1;  			/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  			switch (str [offset]) {  			case '{':  				type = Type.OBJECT;  				keys = new List<string> ();  				list = new List<JSONObject> ();  				break;  			case '[':  				type = Type.ARRAY;  				list = new List<JSONObject> ();  				break;  			default:  				try {  					#if USEFLOAT  					n = System.Convert.ToSingle (str);  					#else  													n = System.Convert.ToDouble(str);				  #endif  					type = Type.NUMBER;  				}  				catch (System.FormatException) {  					type = Type.NULL;  					Debug.LogWarning ("improper JSON formatting:" + str);  				}  				return;  			}  			string propName = "";  			bool openQuote = false;  			bool inProp = false;  			int depth = 0;  			while (++offset < str.Length) {  				if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  					continue;  				if (str [offset] == '\\') {  					offset += 1;  					continue;  				}  				if (str [offset] == '"') {  					if (openQuote) {  						if (!inProp && depth == 0 && type == Type.OBJECT)  							propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  						openQuote = false;  					}  					else {  						if (depth == 0 && type == Type.OBJECT)  							tokenTmp = offset;  						openQuote = true;  					}  				}  				if (openQuote)  					continue;  				if (type == Type.OBJECT && depth == 0) {  					if (str [offset] == ':') {  						tokenTmp = offset + 1;  						inProp = true;  					}  				}  				if (str [offset] == '[' || str [offset] == '{') {  					depth++;  				}  				else if (str [offset] == ']' || str [offset] == '}') {  					depth--;  				}  				//if  (encounter a ''' at top level)  || a closing ]/}  				if ((str [offset] == ''' && depth == 0) || depth < 0) {  					inProp = false;  					string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  					if (inner.Length > 0) {  						if (type == Type.OBJECT)  							keys.Add (propName);  						if (maxDepth != -1)  							//maxDepth of -1 is the end of the line  							list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  						else if (storeExcessLevels)  							list.Add (CreateBakedObject (inner));  					}  					tokenTmp = offset + 1;  				}  			}  		}  	}  	else  		type = Type.NULL;  }  else  	type = Type.NULL;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (!string.IsNullOrEmpty (str)) {  	str = str.Trim (WHITESPACE);  	if (strict) {  		if (str [0] != '[' && str [0] != '{') {  			type = Type.NULL;  			Debug.LogWarning ("Improper (strict) JSON formatting.  First character must be [ or {");  			return;  		}  	}  	if (str.Length > 0) {  		if (string.Compare (str' "true"' true) == 0) {  			type = Type.BOOL;  			b = true;  		}  		else if (string.Compare (str' "false"' true) == 0) {  			type = Type.BOOL;  			b = false;  		}  		else if (string.Compare (str' "null"' true) == 0) {  			type = Type.NULL;  			#if USEFLOAT  		}  		else if (str == INFINITY) {  			type = Type.NUMBER;  			n = float.PositiveInfinity;  		}  		else if (str == NEGINFINITY) {  			type = Type.NUMBER;  			n = float.NegativeInfinity;  		}  		else if (str == NaN) {  			type = Type.NUMBER;  			n = float.NaN;  			#else  							} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  		}  		else if (str [0] == '"') {  			type = Type.STRING;  			this.str = str.Substring (1' str.Length - 2);  		}  		else {  			int tokenTmp = 1;  			/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  			switch (str [offset]) {  			case '{':  				type = Type.OBJECT;  				keys = new List<string> ();  				list = new List<JSONObject> ();  				break;  			case '[':  				type = Type.ARRAY;  				list = new List<JSONObject> ();  				break;  			default:  				try {  					#if USEFLOAT  					n = System.Convert.ToSingle (str);  					#else  													n = System.Convert.ToDouble(str);				  #endif  					type = Type.NUMBER;  				}  				catch (System.FormatException) {  					type = Type.NULL;  					Debug.LogWarning ("improper JSON formatting:" + str);  				}  				return;  			}  			string propName = "";  			bool openQuote = false;  			bool inProp = false;  			int depth = 0;  			while (++offset < str.Length) {  				if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  					continue;  				if (str [offset] == '\\') {  					offset += 1;  					continue;  				}  				if (str [offset] == '"') {  					if (openQuote) {  						if (!inProp && depth == 0 && type == Type.OBJECT)  							propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  						openQuote = false;  					}  					else {  						if (depth == 0 && type == Type.OBJECT)  							tokenTmp = offset;  						openQuote = true;  					}  				}  				if (openQuote)  					continue;  				if (type == Type.OBJECT && depth == 0) {  					if (str [offset] == ':') {  						tokenTmp = offset + 1;  						inProp = true;  					}  				}  				if (str [offset] == '[' || str [offset] == '{') {  					depth++;  				}  				else if (str [offset] == ']' || str [offset] == '}') {  					depth--;  				}  				//if  (encounter a ''' at top level)  || a closing ]/}  				if ((str [offset] == ''' && depth == 0) || depth < 0) {  					inProp = false;  					string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  					if (inner.Length > 0) {  						if (type == Type.OBJECT)  							keys.Add (propName);  						if (maxDepth != -1)  							//maxDepth of -1 is the end of the line  							list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  						else if (storeExcessLevels)  							list.Add (CreateBakedObject (inner));  					}  					tokenTmp = offset + 1;  				}  			}  		}  	}  	else  		type = Type.NULL;  }  else  	type = Type.NULL;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str.Length > 0) {  	if (string.Compare (str' "true"' true) == 0) {  		type = Type.BOOL;  		b = true;  	}  	else if (string.Compare (str' "false"' true) == 0) {  		type = Type.BOOL;  		b = false;  	}  	else if (string.Compare (str' "null"' true) == 0) {  		type = Type.NULL;  		#if USEFLOAT  	}  	else if (str == INFINITY) {  		type = Type.NUMBER;  		n = float.PositiveInfinity;  	}  	else if (str == NEGINFINITY) {  		type = Type.NUMBER;  		n = float.NegativeInfinity;  	}  	else if (str == NaN) {  		type = Type.NUMBER;  		n = float.NaN;  		#else  						} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  	}  	else if (str [0] == '"') {  		type = Type.STRING;  		this.str = str.Substring (1' str.Length - 2);  	}  	else {  		int tokenTmp = 1;  		/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  		switch (str [offset]) {  		case '{':  			type = Type.OBJECT;  			keys = new List<string> ();  			list = new List<JSONObject> ();  			break;  		case '[':  			type = Type.ARRAY;  			list = new List<JSONObject> ();  			break;  		default:  			try {  				#if USEFLOAT  				n = System.Convert.ToSingle (str);  				#else  												n = System.Convert.ToDouble(str);				  #endif  				type = Type.NUMBER;  			}  			catch (System.FormatException) {  				type = Type.NULL;  				Debug.LogWarning ("improper JSON formatting:" + str);  			}  			return;  		}  		string propName = "";  		bool openQuote = false;  		bool inProp = false;  		int depth = 0;  		while (++offset < str.Length) {  			if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  				continue;  			if (str [offset] == '\\') {  				offset += 1;  				continue;  			}  			if (str [offset] == '"') {  				if (openQuote) {  					if (!inProp && depth == 0 && type == Type.OBJECT)  						propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  					openQuote = false;  				}  				else {  					if (depth == 0 && type == Type.OBJECT)  						tokenTmp = offset;  					openQuote = true;  				}  			}  			if (openQuote)  				continue;  			if (type == Type.OBJECT && depth == 0) {  				if (str [offset] == ':') {  					tokenTmp = offset + 1;  					inProp = true;  				}  			}  			if (str [offset] == '[' || str [offset] == '{') {  				depth++;  			}  			else if (str [offset] == ']' || str [offset] == '}') {  				depth--;  			}  			//if  (encounter a ''' at top level)  || a closing ]/}  			if ((str [offset] == ''' && depth == 0) || depth < 0) {  				inProp = false;  				string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  				if (inner.Length > 0) {  					if (type == Type.OBJECT)  						keys.Add (propName);  					if (maxDepth != -1)  						//maxDepth of -1 is the end of the line  						list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  					else if (storeExcessLevels)  						list.Add (CreateBakedObject (inner));  				}  				tokenTmp = offset + 1;  			}  		}  	}  }  else  	type = Type.NULL;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str.Length > 0) {  	if (string.Compare (str' "true"' true) == 0) {  		type = Type.BOOL;  		b = true;  	}  	else if (string.Compare (str' "false"' true) == 0) {  		type = Type.BOOL;  		b = false;  	}  	else if (string.Compare (str' "null"' true) == 0) {  		type = Type.NULL;  		#if USEFLOAT  	}  	else if (str == INFINITY) {  		type = Type.NUMBER;  		n = float.PositiveInfinity;  	}  	else if (str == NEGINFINITY) {  		type = Type.NUMBER;  		n = float.NegativeInfinity;  	}  	else if (str == NaN) {  		type = Type.NUMBER;  		n = float.NaN;  		#else  						} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  	}  	else if (str [0] == '"') {  		type = Type.STRING;  		this.str = str.Substring (1' str.Length - 2);  	}  	else {  		int tokenTmp = 1;  		/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  		switch (str [offset]) {  		case '{':  			type = Type.OBJECT;  			keys = new List<string> ();  			list = new List<JSONObject> ();  			break;  		case '[':  			type = Type.ARRAY;  			list = new List<JSONObject> ();  			break;  		default:  			try {  				#if USEFLOAT  				n = System.Convert.ToSingle (str);  				#else  												n = System.Convert.ToDouble(str);				  #endif  				type = Type.NUMBER;  			}  			catch (System.FormatException) {  				type = Type.NULL;  				Debug.LogWarning ("improper JSON formatting:" + str);  			}  			return;  		}  		string propName = "";  		bool openQuote = false;  		bool inProp = false;  		int depth = 0;  		while (++offset < str.Length) {  			if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  				continue;  			if (str [offset] == '\\') {  				offset += 1;  				continue;  			}  			if (str [offset] == '"') {  				if (openQuote) {  					if (!inProp && depth == 0 && type == Type.OBJECT)  						propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  					openQuote = false;  				}  				else {  					if (depth == 0 && type == Type.OBJECT)  						tokenTmp = offset;  					openQuote = true;  				}  			}  			if (openQuote)  				continue;  			if (type == Type.OBJECT && depth == 0) {  				if (str [offset] == ':') {  					tokenTmp = offset + 1;  					inProp = true;  				}  			}  			if (str [offset] == '[' || str [offset] == '{') {  				depth++;  			}  			else if (str [offset] == ']' || str [offset] == '}') {  				depth--;  			}  			//if  (encounter a ''' at top level)  || a closing ]/}  			if ((str [offset] == ''' && depth == 0) || depth < 0) {  				inProp = false;  				string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  				if (inner.Length > 0) {  					if (type == Type.OBJECT)  						keys.Add (propName);  					if (maxDepth != -1)  						//maxDepth of -1 is the end of the line  						list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  					else if (storeExcessLevels)  						list.Add (CreateBakedObject (inner));  				}  				tokenTmp = offset + 1;  			}  		}  	}  }  else  	type = Type.NULL;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (string.Compare (str' "true"' true) == 0) {  	type = Type.BOOL;  	b = true;  }  else if (string.Compare (str' "false"' true) == 0) {  	type = Type.BOOL;  	b = false;  }  else if (string.Compare (str' "null"' true) == 0) {  	type = Type.NULL;  	#if USEFLOAT  }  else if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (string.Compare (str' "true"' true) == 0) {  	type = Type.BOOL;  	b = true;  }  else if (string.Compare (str' "false"' true) == 0) {  	type = Type.BOOL;  	b = false;  }  else if (string.Compare (str' "null"' true) == 0) {  	type = Type.NULL;  	#if USEFLOAT  }  else if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (string.Compare (str' "false"' true) == 0) {  	type = Type.BOOL;  	b = false;  }  else if (string.Compare (str' "null"' true) == 0) {  	type = Type.NULL;  	#if USEFLOAT  }  else if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (string.Compare (str' "false"' true) == 0) {  	type = Type.BOOL;  	b = false;  }  else if (string.Compare (str' "null"' true) == 0) {  	type = Type.NULL;  	#if USEFLOAT  }  else if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (string.Compare (str' "null"' true) == 0) {  	type = Type.NULL;  	#if USEFLOAT  }  else if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (string.Compare (str' "null"' true) == 0) {  	type = Type.NULL;  	#if USEFLOAT  }  else if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str == INFINITY) {  	type = Type.NUMBER;  	n = float.PositiveInfinity;  }  else if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str == NEGINFINITY) {  	type = Type.NUMBER;  	n = float.NegativeInfinity;  }  else if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str == NaN) {  	type = Type.NUMBER;  	n = float.NaN;  	#else  					} else if(str == INFINITY) { 					type = Type.NUMBER; 					n = double.PositiveInfinity; 				} else if(str == NEGINFINITY) { 					type = Type.NUMBER; 					n = double.NegativeInfinity; 				} else if(str == NaN) { 					type = Type.NUMBER; 					n = double.NaN; #endif  }  else if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (str [0] == '"') {  	type = Type.STRING;  	this.str = str.Substring (1' str.Length - 2);  }  else {  	int tokenTmp = 1;  	/* 					 * Checking for the following formatting (www.json.org) 					 * object - {"field1":value'"field2":value} 					 * array - [value'value'value] 					 * value - string	- "string" 					 *		 - number	- 0.0 					 *		 - bool		- true -or- false 					 *		 - null		- null 					 */int offset = 0;  	switch (str [offset]) {  	case '{':  		type = Type.OBJECT;  		keys = new List<string> ();  		list = new List<JSONObject> ();  		break;  	case '[':  		type = Type.ARRAY;  		list = new List<JSONObject> ();  		break;  	default:  		try {  			#if USEFLOAT  			n = System.Convert.ToSingle (str);  			#else  											n = System.Convert.ToDouble(str);				  #endif  			type = Type.NUMBER;  		}  		catch (System.FormatException) {  			type = Type.NULL;  			Debug.LogWarning ("improper JSON formatting:" + str);  		}  		return;  	}  	string propName = "";  	bool openQuote = false;  	bool inProp = false;  	int depth = 0;  	while (++offset < str.Length) {  		if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  			continue;  		if (str [offset] == '\\') {  			offset += 1;  			continue;  		}  		if (str [offset] == '"') {  			if (openQuote) {  				if (!inProp && depth == 0 && type == Type.OBJECT)  					propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  				openQuote = false;  			}  			else {  				if (depth == 0 && type == Type.OBJECT)  					tokenTmp = offset;  				openQuote = true;  			}  		}  		if (openQuote)  			continue;  		if (type == Type.OBJECT && depth == 0) {  			if (str [offset] == ':') {  				tokenTmp = offset + 1;  				inProp = true;  			}  		}  		if (str [offset] == '[' || str [offset] == '{') {  			depth++;  		}  		else if (str [offset] == ']' || str [offset] == '}') {  			depth--;  		}  		//if  (encounter a ''' at top level)  || a closing ]/}  		if ((str [offset] == ''' && depth == 0) || depth < 0) {  			inProp = false;  			string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  			if (inner.Length > 0) {  				if (type == Type.OBJECT)  					keys.Add (propName);  				if (maxDepth != -1)  					//maxDepth of -1 is the end of the line  					list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  				else if (storeExcessLevels)  					list.Add (CreateBakedObject (inner));  			}  			tokenTmp = offset + 1;  		}  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: this.str = str.Substring (1' str.Length - 2);  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: while (++offset < str.Length) {  	if (System.Array.IndexOf (WHITESPACE' str [offset]) > -1)  		continue;  	if (str [offset] == '\\') {  		offset += 1;  		continue;  	}  	if (str [offset] == '"') {  		if (openQuote) {  			if (!inProp && depth == 0 && type == Type.OBJECT)  				propName = str.Substring (tokenTmp + 1' offset - tokenTmp - 1);  			openQuote = false;  		}  		else {  			if (depth == 0 && type == Type.OBJECT)  				tokenTmp = offset;  			openQuote = true;  		}  	}  	if (openQuote)  		continue;  	if (type == Type.OBJECT && depth == 0) {  		if (str [offset] == ':') {  			tokenTmp = offset + 1;  			inProp = true;  		}  	}  	if (str [offset] == '[' || str [offset] == '{') {  		depth++;  	}  	else if (str [offset] == ']' || str [offset] == '}') {  		depth--;  	}  	//if  (encounter a ''' at top level)  || a closing ]/}  	if ((str [offset] == ''' && depth == 0) || depth < 0) {  		inProp = false;  		string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  		if (inner.Length > 0) {  			if (type == Type.OBJECT)  				keys.Add (propName);  			if (maxDepth != -1)  				//maxDepth of -1 is the end of the line  				list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  			else if (storeExcessLevels)  				list.Add (CreateBakedObject (inner));  		}  		tokenTmp = offset + 1;  	}  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if ((str [offset] == ''' && depth == 0) || depth < 0) {  	inProp = false;  	string inner = str.Substring (tokenTmp' offset - tokenTmp).Trim (WHITESPACE);  	if (inner.Length > 0) {  		if (type == Type.OBJECT)  			keys.Add (propName);  		if (maxDepth != -1)  			//maxDepth of -1 is the end of the line  			list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  		else if (storeExcessLevels)  			list.Add (CreateBakedObject (inner));  	}  	tokenTmp = offset + 1;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (inner.Length > 0) {  	if (type == Type.OBJECT)  		keys.Add (propName);  	if (maxDepth != -1)  		//maxDepth of -1 is the end of the line  		list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  	else if (storeExcessLevels)  		list.Add (CreateBakedObject (inner));  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: if (maxDepth != -1)  	//maxDepth of -1 is the end of the line  	list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  else if (storeExcessLevels)  	list.Add (CreateBakedObject (inner));  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Parse,The following statement contains a magic number: list.Add (Create (inner' (maxDepth < -1) ? -2 : maxDepth - 1));  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: switch (type) {  case Type.BAKED:  	builder.Append (str);  	break;  case Type.STRING:  	builder.AppendFormat ("\"{0}\""' str);  	break;  case Type.NUMBER:  	#if USEFLOAT  	if (float.IsInfinity (n))  		builder.Append (INFINITY);  	else if (float.IsNegativeInfinity (n))  		builder.Append (NEGINFINITY);  	else if (float.IsNaN (n))  		builder.Append (NaN);  	#else  					if(double.IsInfinity(n)) 					builder.Append(INFINITY); 				else if(double.IsNegativeInfinity(n)) 					builder.Append(NEGINFINITY); 				else if(double.IsNaN(n)) 					builder.Append(NaN); #endif  	else  		builder.Append (n.ToString ());  	break;  case Type.OBJECT:  	builder.Append ("{");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		#endif  		for (int i = 0; i < list.Count; i++) {  			string key = keys [i];  			JSONObject obj = list [i];  			if (obj) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				builder.AppendFormat ("\"{0}\":"' key);  				foreach (IEnumerable e in obj.StringifyAsync (depth' builder' pretty))  					yield return e;  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("}");  	break;  case Type.ARRAY:  	builder.Append ("[");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		//for a bit more readability  		#endif  		for (int i = 0; i < list.Count; i++) {  			if (list [i]) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				foreach (IEnumerable e in list [i].StringifyAsync (depth' builder' pretty))  					yield return e;  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				//for a bit more readability  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("]");  	break;  case Type.BOOL:  	if (b)  		builder.Append ("true");  	else  		builder.Append ("false");  	break;  case Type.NULL:  	builder.Append ("null");  	break;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: switch (type) {  case Type.BAKED:  	builder.Append (str);  	break;  case Type.STRING:  	builder.AppendFormat ("\"{0}\""' str);  	break;  case Type.NUMBER:  	#if USEFLOAT  	if (float.IsInfinity (n))  		builder.Append (INFINITY);  	else if (float.IsNegativeInfinity (n))  		builder.Append (NEGINFINITY);  	else if (float.IsNaN (n))  		builder.Append (NaN);  	#else  					if(double.IsInfinity(n)) 					builder.Append(INFINITY); 				else if(double.IsNegativeInfinity(n)) 					builder.Append(NEGINFINITY); 				else if(double.IsNaN(n)) 					builder.Append(NaN); #endif  	else  		builder.Append (n.ToString ());  	break;  case Type.OBJECT:  	builder.Append ("{");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		#endif  		for (int i = 0; i < list.Count; i++) {  			string key = keys [i];  			JSONObject obj = list [i];  			if (obj) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				builder.AppendFormat ("\"{0}\":"' key);  				foreach (IEnumerable e in obj.StringifyAsync (depth' builder' pretty))  					yield return e;  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("}");  	break;  case Type.ARRAY:  	builder.Append ("[");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		//for a bit more readability  		#endif  		for (int i = 0; i < list.Count; i++) {  			if (list [i]) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				foreach (IEnumerable e in list [i].StringifyAsync (depth' builder' pretty))  					yield return e;  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				//for a bit more readability  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("]");  	break;  case Type.BOOL:  	if (b)  		builder.Append ("true");  	else  		builder.Append ("false");  	break;  case Type.NULL:  	builder.Append ("null");  	break;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: if (list.Count > 0) {  	#if (PRETTY)  	if (pretty)  		builder.Append ("\n");  	#endif  	for (int i = 0; i < list.Count; i++) {  		string key = keys [i];  		JSONObject obj = list [i];  		if (obj) {  			#if (PRETTY)  			if (pretty)  				for (int j = 0; j < depth; j++)  					builder.Append ("\t");  			//for a bit more readability  			#endif  			builder.AppendFormat ("\"{0}\":"' key);  			foreach (IEnumerable e in obj.StringifyAsync (depth' builder' pretty))  				yield return e;  			builder.Append ("'");  			#if (PRETTY)  			if (pretty)  				builder.Append ("\n");  			#endif  		}  	}  	#if (PRETTY)  	if (pretty)  		builder.Length -= 2;  	else  		#endif  		builder.Length--;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: if (pretty)  	builder.Length -= 2;  else  	#endif  	builder.Length--;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: builder.Length -= 2;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: if (list.Count > 0) {  	#if (PRETTY)  	if (pretty)  		builder.Append ("\n");  	//for a bit more readability  	#endif  	for (int i = 0; i < list.Count; i++) {  		if (list [i]) {  			#if (PRETTY)  			if (pretty)  				for (int j = 0; j < depth; j++)  					builder.Append ("\t");  			//for a bit more readability  			#endif  			foreach (IEnumerable e in list [i].StringifyAsync (depth' builder' pretty))  				yield return e;  			builder.Append ("'");  			#if (PRETTY)  			if (pretty)  				builder.Append ("\n");  			//for a bit more readability  			#endif  		}  	}  	#if (PRETTY)  	if (pretty)  		builder.Length -= 2;  	else  		#endif  		builder.Length--;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: if (pretty)  	builder.Length -= 2;  else  	#endif  	builder.Length--;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following statement contains a magic number: builder.Length -= 2;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: switch (type) {  case Type.BAKED:  	builder.Append (str);  	break;  case Type.STRING:  	builder.AppendFormat ("\"{0}\""' str);  	break;  case Type.NUMBER:  	#if USEFLOAT  	if (float.IsInfinity (n))  		builder.Append (INFINITY);  	else if (float.IsNegativeInfinity (n))  		builder.Append (NEGINFINITY);  	else if (float.IsNaN (n))  		builder.Append (NaN);  	#else  					if(double.IsInfinity(n)) 					builder.Append(INFINITY); 				else if(double.IsNegativeInfinity(n)) 					builder.Append(NEGINFINITY); 				else if(double.IsNaN(n)) 					builder.Append(NaN); #endif  	else  		builder.Append (n.ToString ());  	break;  case Type.OBJECT:  	builder.Append ("{");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		#endif  		for (int i = 0; i < list.Count; i++) {  			string key = keys [i];  			JSONObject obj = list [i];  			if (obj) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				builder.AppendFormat ("\"{0}\":"' key);  				obj.Stringify (depth' builder' pretty);  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("}");  	break;  case Type.ARRAY:  	builder.Append ("[");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		//for a bit more readability  		#endif  		for (int i = 0; i < list.Count; i++) {  			if (list [i]) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				list [i].Stringify (depth' builder' pretty);  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				//for a bit more readability  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("]");  	break;  case Type.BOOL:  	if (b)  		builder.Append ("true");  	else  		builder.Append ("false");  	break;  case Type.NULL:  	builder.Append ("null");  	break;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: switch (type) {  case Type.BAKED:  	builder.Append (str);  	break;  case Type.STRING:  	builder.AppendFormat ("\"{0}\""' str);  	break;  case Type.NUMBER:  	#if USEFLOAT  	if (float.IsInfinity (n))  		builder.Append (INFINITY);  	else if (float.IsNegativeInfinity (n))  		builder.Append (NEGINFINITY);  	else if (float.IsNaN (n))  		builder.Append (NaN);  	#else  					if(double.IsInfinity(n)) 					builder.Append(INFINITY); 				else if(double.IsNegativeInfinity(n)) 					builder.Append(NEGINFINITY); 				else if(double.IsNaN(n)) 					builder.Append(NaN); #endif  	else  		builder.Append (n.ToString ());  	break;  case Type.OBJECT:  	builder.Append ("{");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		#endif  		for (int i = 0; i < list.Count; i++) {  			string key = keys [i];  			JSONObject obj = list [i];  			if (obj) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				builder.AppendFormat ("\"{0}\":"' key);  				obj.Stringify (depth' builder' pretty);  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("}");  	break;  case Type.ARRAY:  	builder.Append ("[");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		//for a bit more readability  		#endif  		for (int i = 0; i < list.Count; i++) {  			if (list [i]) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				list [i].Stringify (depth' builder' pretty);  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				//for a bit more readability  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("]");  	break;  case Type.BOOL:  	if (b)  		builder.Append ("true");  	else  		builder.Append ("false");  	break;  case Type.NULL:  	builder.Append ("null");  	break;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: if (list.Count > 0) {  	#if (PRETTY)  	if (pretty)  		builder.Append ("\n");  	#endif  	for (int i = 0; i < list.Count; i++) {  		string key = keys [i];  		JSONObject obj = list [i];  		if (obj) {  			#if (PRETTY)  			if (pretty)  				for (int j = 0; j < depth; j++)  					builder.Append ("\t");  			//for a bit more readability  			#endif  			builder.AppendFormat ("\"{0}\":"' key);  			obj.Stringify (depth' builder' pretty);  			builder.Append ("'");  			#if (PRETTY)  			if (pretty)  				builder.Append ("\n");  			#endif  		}  	}  	#if (PRETTY)  	if (pretty)  		builder.Length -= 2;  	else  		#endif  		builder.Length--;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: if (pretty)  	builder.Length -= 2;  else  	#endif  	builder.Length--;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: builder.Length -= 2;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: if (list.Count > 0) {  	#if (PRETTY)  	if (pretty)  		builder.Append ("\n");  	//for a bit more readability  	#endif  	for (int i = 0; i < list.Count; i++) {  		if (list [i]) {  			#if (PRETTY)  			if (pretty)  				for (int j = 0; j < depth; j++)  					builder.Append ("\t");  			//for a bit more readability  			#endif  			list [i].Stringify (depth' builder' pretty);  			builder.Append ("'");  			#if (PRETTY)  			if (pretty)  				builder.Append ("\n");  			//for a bit more readability  			#endif  		}  	}  	#if (PRETTY)  	if (pretty)  		builder.Length -= 2;  	else  		#endif  		builder.Length--;  }  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: if (pretty)  	builder.Length -= 2;  else  	#endif  	builder.Length--;  
Magic Number,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following statement contains a magic number: builder.Length -= 2;  
Magic Number,Code.Code.Libaries.Net,BasePacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\BasePacket.cs,Serialize,The following statement contains a magic number: bytestream.addShort (bytestream.Length - 2);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addShort,The following statement contains a magic number: addByte (i >> 8);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addInt,The following statement contains a magic number: addByte (i >> 24);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addInt,The following statement contains a magic number: addByte (i >> 16);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addInt,The following statement contains a magic number: addByte (i >> 8);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 56));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 48));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 40));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 32));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 24));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 16));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addLong,The following statement contains a magic number: addByte ((int)(l >> 8));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFloat4B,The following statement contains a magic number: addInt ((int)(f * 1000));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFloat2B,The following statement contains a magic number: addShort ((int)(f * 100));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getShort,The following statement contains a magic number: if (i > 32767) {  	i -= 65536;  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getShort,The following statement contains a magic number: if (i > 32767) {  	i -= 65536;  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getShort,The following statement contains a magic number: i -= 65536;  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getShortBE,The following statement contains a magic number: if (i > 32767) {  	i -= 65536;  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getShortBE,The following statement contains a magic number: if (i > 32767) {  	i -= 65536;  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getShortBE,The following statement contains a magic number: i -= 65536;  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getUnsignedShort,The following statement contains a magic number: return (getUnsignedByte () << 8) + getUnsignedByte ();  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getUnsignedShortBE,The following statement contains a magic number: return getUnsignedByte () + (getUnsignedByte () << 8);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getInt,The following statement contains a magic number: return (getUnsignedByte () << 24) + (getUnsignedByte () << 16) + (getUnsignedByte () << 8) + getUnsignedByte ();  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getInt,The following statement contains a magic number: return (getUnsignedByte () << 24) + (getUnsignedByte () << 16) + (getUnsignedByte () << 8) + getUnsignedByte ();  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getInt,The following statement contains a magic number: return (getUnsignedByte () << 24) + (getUnsignedByte () << 16) + (getUnsignedByte () << 8) + getUnsignedByte ();  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getIntBE,The following statement contains a magic number: return getUnsignedByte () + (getUnsignedByte () << 8) + (getUnsignedByte () << 16) + (getUnsignedByte () << 24);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getIntBE,The following statement contains a magic number: return getUnsignedByte () + (getUnsignedByte () << 8) + (getUnsignedByte () << 16) + (getUnsignedByte () << 24);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getIntBE,The following statement contains a magic number: return getUnsignedByte () + (getUnsignedByte () << 8) + (getUnsignedByte () << 16) + (getUnsignedByte () << 24);  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,getLong,The following statement contains a magic number: return (l << 32) + l1;  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 2) {  	i = (i | (updates [1] ? 0x02 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 3) {  	i = (i | (updates [2] ? 0x04 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 3) {  	i = (i | (updates [2] ? 0x04 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: i = (i | (updates [2] ? 0x04 : 0x00));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 4) {  	i = (i | (updates [3] ? 0x08 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 4) {  	i = (i | (updates [3] ? 0x08 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: i = (i | (updates [3] ? 0x08 : 0x00));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 5) {  	i = (i | (updates [4] ? 0x10 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 5) {  	i = (i | (updates [4] ? 0x10 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: i = (i | (updates [4] ? 0x10 : 0x00));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 6) {  	i = (i | (updates [5] ? 0x20 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 6) {  	i = (i | (updates [5] ? 0x20 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: i = (i | (updates [5] ? 0x20 : 0x00));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 7) {  	i = (i | (updates [6] ? 0x40 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 7) {  	i = (i | (updates [6] ? 0x40 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: i = (i | (updates [6] ? 0x40 : 0x00));  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 8) {  	i = (i | (updates [7] ? 0x80 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: if (updates.Length >= 8) {  	i = (i | (updates [7] ? 0x80 : 0x00));  }  
Magic Number,Code.Code.Libaries.Net,ByteStream,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ByteStream.cs,addFlag,The following statement contains a magic number: i = (i | (updates [7] ? 0x80 : 0x00));  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: for (int i = 0; i < MAX_PACKETS_PROCEED_AT_ONCE; i++) {  	int available = socket.Available;  	#if DEBUG_NETWORK  	                Debug.Log("AWAILABLE BYTES: "+available); #endif  	if (available > 0) {  		if (available > 2) {  			if (expectedNextLength == -1) {  				//ignore the two bytes for the future  				available -= 2;  				byte[] bytes = new byte[2];  				socket.Receive (bytes' bytes.Length' 0);  				ByteStream _in = new ByteStream (bytes);  				_in.Offset = 0;  				expectedNextLength = _in.getUnsignedShort ();  			}  		}  		if (expectedNextLength != -1) {  			if (available >= expectedNextLength) {  				//ignore the expected lenght for the future  				available -= expectedNextLength;  				byte[] bytes = new byte[expectedNextLength];  				socket.Receive (bytes' expectedNextLength' 0);  				ByteStream _in = new ByteStream (bytes);  				_in.Offset = 0;  				int opcode = _in.getUnsignedByte ();  				BasePacket packet = PacketManager.PacketForOpcode (opcode);  				packet.Size = expectedNextLength;  				packet.Deserialize (_in);  				packetExecutor.ExecutePacket (packet);  				expectedNextLength = -1;  			}  		}  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: for (int i = 0; i < MAX_PACKETS_PROCEED_AT_ONCE; i++) {  	int available = socket.Available;  	#if DEBUG_NETWORK  	                Debug.Log("AWAILABLE BYTES: "+available); #endif  	if (available > 0) {  		if (available > 2) {  			if (expectedNextLength == -1) {  				//ignore the two bytes for the future  				available -= 2;  				byte[] bytes = new byte[2];  				socket.Receive (bytes' bytes.Length' 0);  				ByteStream _in = new ByteStream (bytes);  				_in.Offset = 0;  				expectedNextLength = _in.getUnsignedShort ();  			}  		}  		if (expectedNextLength != -1) {  			if (available >= expectedNextLength) {  				//ignore the expected lenght for the future  				available -= expectedNextLength;  				byte[] bytes = new byte[expectedNextLength];  				socket.Receive (bytes' expectedNextLength' 0);  				ByteStream _in = new ByteStream (bytes);  				_in.Offset = 0;  				int opcode = _in.getUnsignedByte ();  				BasePacket packet = PacketManager.PacketForOpcode (opcode);  				packet.Size = expectedNextLength;  				packet.Deserialize (_in);  				packetExecutor.ExecutePacket (packet);  				expectedNextLength = -1;  			}  		}  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: for (int i = 0; i < MAX_PACKETS_PROCEED_AT_ONCE; i++) {  	int available = socket.Available;  	#if DEBUG_NETWORK  	                Debug.Log("AWAILABLE BYTES: "+available); #endif  	if (available > 0) {  		if (available > 2) {  			if (expectedNextLength == -1) {  				//ignore the two bytes for the future  				available -= 2;  				byte[] bytes = new byte[2];  				socket.Receive (bytes' bytes.Length' 0);  				ByteStream _in = new ByteStream (bytes);  				_in.Offset = 0;  				expectedNextLength = _in.getUnsignedShort ();  			}  		}  		if (expectedNextLength != -1) {  			if (available >= expectedNextLength) {  				//ignore the expected lenght for the future  				available -= expectedNextLength;  				byte[] bytes = new byte[expectedNextLength];  				socket.Receive (bytes' expectedNextLength' 0);  				ByteStream _in = new ByteStream (bytes);  				_in.Offset = 0;  				int opcode = _in.getUnsignedByte ();  				BasePacket packet = PacketManager.PacketForOpcode (opcode);  				packet.Size = expectedNextLength;  				packet.Deserialize (_in);  				packetExecutor.ExecutePacket (packet);  				expectedNextLength = -1;  			}  		}  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (available > 0) {  	if (available > 2) {  		if (expectedNextLength == -1) {  			//ignore the two bytes for the future  			available -= 2;  			byte[] bytes = new byte[2];  			socket.Receive (bytes' bytes.Length' 0);  			ByteStream _in = new ByteStream (bytes);  			_in.Offset = 0;  			expectedNextLength = _in.getUnsignedShort ();  		}  	}  	if (expectedNextLength != -1) {  		if (available >= expectedNextLength) {  			//ignore the expected lenght for the future  			available -= expectedNextLength;  			byte[] bytes = new byte[expectedNextLength];  			socket.Receive (bytes' expectedNextLength' 0);  			ByteStream _in = new ByteStream (bytes);  			_in.Offset = 0;  			int opcode = _in.getUnsignedByte ();  			BasePacket packet = PacketManager.PacketForOpcode (opcode);  			packet.Size = expectedNextLength;  			packet.Deserialize (_in);  			packetExecutor.ExecutePacket (packet);  			expectedNextLength = -1;  		}  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (available > 0) {  	if (available > 2) {  		if (expectedNextLength == -1) {  			//ignore the two bytes for the future  			available -= 2;  			byte[] bytes = new byte[2];  			socket.Receive (bytes' bytes.Length' 0);  			ByteStream _in = new ByteStream (bytes);  			_in.Offset = 0;  			expectedNextLength = _in.getUnsignedShort ();  		}  	}  	if (expectedNextLength != -1) {  		if (available >= expectedNextLength) {  			//ignore the expected lenght for the future  			available -= expectedNextLength;  			byte[] bytes = new byte[expectedNextLength];  			socket.Receive (bytes' expectedNextLength' 0);  			ByteStream _in = new ByteStream (bytes);  			_in.Offset = 0;  			int opcode = _in.getUnsignedByte ();  			BasePacket packet = PacketManager.PacketForOpcode (opcode);  			packet.Size = expectedNextLength;  			packet.Deserialize (_in);  			packetExecutor.ExecutePacket (packet);  			expectedNextLength = -1;  		}  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (available > 0) {  	if (available > 2) {  		if (expectedNextLength == -1) {  			//ignore the two bytes for the future  			available -= 2;  			byte[] bytes = new byte[2];  			socket.Receive (bytes' bytes.Length' 0);  			ByteStream _in = new ByteStream (bytes);  			_in.Offset = 0;  			expectedNextLength = _in.getUnsignedShort ();  		}  	}  	if (expectedNextLength != -1) {  		if (available >= expectedNextLength) {  			//ignore the expected lenght for the future  			available -= expectedNextLength;  			byte[] bytes = new byte[expectedNextLength];  			socket.Receive (bytes' expectedNextLength' 0);  			ByteStream _in = new ByteStream (bytes);  			_in.Offset = 0;  			int opcode = _in.getUnsignedByte ();  			BasePacket packet = PacketManager.PacketForOpcode (opcode);  			packet.Size = expectedNextLength;  			packet.Deserialize (_in);  			packetExecutor.ExecutePacket (packet);  			expectedNextLength = -1;  		}  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (available > 2) {  	if (expectedNextLength == -1) {  		//ignore the two bytes for the future  		available -= 2;  		byte[] bytes = new byte[2];  		socket.Receive (bytes' bytes.Length' 0);  		ByteStream _in = new ByteStream (bytes);  		_in.Offset = 0;  		expectedNextLength = _in.getUnsignedShort ();  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (available > 2) {  	if (expectedNextLength == -1) {  		//ignore the two bytes for the future  		available -= 2;  		byte[] bytes = new byte[2];  		socket.Receive (bytes' bytes.Length' 0);  		ByteStream _in = new ByteStream (bytes);  		_in.Offset = 0;  		expectedNextLength = _in.getUnsignedShort ();  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (available > 2) {  	if (expectedNextLength == -1) {  		//ignore the two bytes for the future  		available -= 2;  		byte[] bytes = new byte[2];  		socket.Receive (bytes' bytes.Length' 0);  		ByteStream _in = new ByteStream (bytes);  		_in.Offset = 0;  		expectedNextLength = _in.getUnsignedShort ();  	}  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (expectedNextLength == -1) {  	//ignore the two bytes for the future  	available -= 2;  	byte[] bytes = new byte[2];  	socket.Receive (bytes' bytes.Length' 0);  	ByteStream _in = new ByteStream (bytes);  	_in.Offset = 0;  	expectedNextLength = _in.getUnsignedShort ();  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: if (expectedNextLength == -1) {  	//ignore the two bytes for the future  	available -= 2;  	byte[] bytes = new byte[2];  	socket.Receive (bytes' bytes.Length' 0);  	ByteStream _in = new ByteStream (bytes);  	_in.Offset = 0;  	expectedNextLength = _in.getUnsignedShort ();  }  
Magic Number,Code.Code.Libaries.Net,ConnectionHandler,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\ConnectionHandler.cs,ReadAndExecute,The following statement contains a magic number: available -= 2;  
Magic Number,Code.Libaries.Net.Packets.ForServer,ChatPacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ChatPacket.cs,GetOpCode,The following statement contains a magic number: return 25;  
Magic Number,Code.Libaries.Net.Packets.ForServer,InputEventPacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForServer\InputEvent.cs,GetOpCode,The following statement contains a magic number: return 81;  
Magic Number,Code.Libaries.Net.Packets.ForServer,UnitActionPacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForServer\UnitActionPacket.cs,GetOpCode,The following statement contains a magic number: return 21;  
Magic Number,Code.Libaries.Net.Packets.ForServer,WalkRequestPacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForServer\WalkRequestPacket.cs,GetOpCode,The following statement contains a magic number: return 80;  
Magic Number,Code.Libaries.Net.Packets.ForServer,UIInterfaceEvent,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\UIInterfaceEvent.cs,GetOpCode,The following statement contains a magic number: return 30;  
Magic Number,Code.Libaries.Net.Packets.ForClient,UnitUpdatePacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\ForClient\UnitUpdatePacket.cs,GetOpCode,The following statement contains a magic number: return 20;  
Magic Number,Code.Libaries.Net.Packets.InGame,TargetUpdatePacket,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\Net\Packets\InGame\TargetUpdatePacket.cs,GetOpCode,The following statement contains a magic number: return 22;  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.indices = new int[] {  	0'  	3'  	1'  	2'  	3'  	0  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.boundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateDefinitionForRegionInTexture,The following statement contains a magic number: def.untrimmedBoundsData = new Vector3[2] {  	(boundsMax + boundsMin) / 2.0f'  	(boundsMax - boundsMin)  };  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: while (line != null) {  	if (line.Length > 0) {  		char cmd = line [0];  		switch (state) {  		case 0:  			{  				switch (cmd) {  				case 'i':  					break;  				// ignore version field for now  				case 'w':  					textureDimensions.x = Int32.Parse (line.Substring (2));  					break;  				case 'h':  					textureDimensions.y = Int32.Parse (line.Substring (2));  					break;  				// total number of sprites would be ideal to statically allocate  				case '~':  					state++;  					break;  				}  			}  			break;  		case 1:  			{  				switch (cmd) {  				case 'n':  					entryName = line.Substring (2);  					break;  				case 'r':  					entryRotated = Int32.Parse (line.Substring (2)) == 1;  					break;  				case 's':  					{  						// sprite  						string[] tokens = line.Split ();  						entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					}  					break;  				case 'o':  					{  						// origin  						string[] tokens = line.Split ();  						entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  						entryTrimmed = true;  					}  					break;  				case '~':  					{  						names.Add (entryName);  						rotated.Add (entryRotated);  						rects.Add (entryRect);  						if (!entryTrimmed) {  							// The entryRect dimensions will be the wrong way around if the sprite is rotated  							if (entryRotated)  								entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  							else  								entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  						}  						trimRects.Add (entryTrimData);  						anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  						anchors.Add (anchor);  						entryName = "";  						entryTrimmed = false;  						entryRotated = false;  					}  					break;  				}  			}  			break;  		}  	}  	line = tr.ReadLine ();  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: if (line.Length > 0) {  	char cmd = line [0];  	switch (state) {  	case 0:  		{  			switch (cmd) {  			case 'i':  				break;  			// ignore version field for now  			case 'w':  				textureDimensions.x = Int32.Parse (line.Substring (2));  				break;  			case 'h':  				textureDimensions.y = Int32.Parse (line.Substring (2));  				break;  			// total number of sprites would be ideal to statically allocate  			case '~':  				state++;  				break;  			}  		}  		break;  	case 1:  		{  			switch (cmd) {  			case 'n':  				entryName = line.Substring (2);  				break;  			case 'r':  				entryRotated = Int32.Parse (line.Substring (2)) == 1;  				break;  			case 's':  				{  					// sprite  					string[] tokens = line.Split ();  					entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				}  				break;  			case 'o':  				{  					// origin  					string[] tokens = line.Split ();  					entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  					entryTrimmed = true;  				}  				break;  			case '~':  				{  					names.Add (entryName);  					rotated.Add (entryRotated);  					rects.Add (entryRect);  					if (!entryTrimmed) {  						// The entryRect dimensions will be the wrong way around if the sprite is rotated  						if (entryRotated)  							entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  						else  							entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  					}  					trimRects.Add (entryTrimData);  					anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  					anchors.Add (anchor);  					entryName = "";  					entryTrimmed = false;  					entryRotated = false;  				}  				break;  			}  		}  		break;  	}  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.x = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: textureDimensions.y = Int32.Parse (line.Substring (2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryName = line.Substring (2);  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRotated = Int32.Parse (line.Substring (2)) == 1;  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following statement contains a magic number: anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildForChunk,The following statement contains a magic number: if (localMeshIndices.Length > 6) {  	// Remove duplicate verts  	localMeshVertices = WeldVertices (localMeshVertices' ref localMeshIndices);  	// Remove duplicate and back-to-back faces  	// Removes inside faces  	localMeshIndices = RemoveDuplicateFaces (localMeshIndices);  	// Merge coplanar faces  	// Optimize (remove unused vertices' reindex)  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int y = 0; y < tileMap.partitionSizeY; ++y) {  	float xOffset = ((baseY + y) & 1) * xOffsetMult;  	for (int x = 0; x < tileMap.partitionSizeX; ++x) {  		int spriteId = chunkData [y * tileMap.partitionSizeX + x];  		int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  		Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  		if (spriteIdx < 0 || spriteIdx >= spriteCount)  			continue;  		if (tilePrefabs [spriteIdx])  			continue;  		bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  		bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  		bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  		bool reverseIndices = false;  		if (flipH)  			reverseIndices = !reverseIndices;  		if (flipV)  			reverseIndices = !reverseIndices;  		var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  		int baseVertexIndex = vertexList.Count;  		if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  			Vector3 origin = spriteData.colliderVertices [0];  			Vector3 extents = spriteData.colliderVertices [1];  			Vector3 min = origin - extents;  			Vector3 max = origin + extents;  			Vector3[] pos = new Vector3[8];  			pos [0] = new Vector3 (min.x' min.y' min.z);  			pos [1] = new Vector3 (min.x' min.y' max.z);  			pos [2] = new Vector3 (max.x' min.y' min.z);  			pos [3] = new Vector3 (max.x' min.y' max.z);  			pos [4] = new Vector3 (min.x' max.y' min.z);  			pos [5] = new Vector3 (min.x' max.y' max.z);  			pos [6] = new Vector3 (max.x' max.y' min.z);  			pos [7] = new Vector3 (max.x' max.y' max.z);  			for (int i = 0; i < 8; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  			int[] indicesFwd =  {  				2'  				1'  				0'  				3'  				1'  				2'  				4'  				5'  				6'  				6'  				5'  				7'  				6'  				7'  				3'  				6'  				3'  				2'  				1'  				5'  				4'  				0'  				1'  				4  			};  			var srcIndices = indicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  		else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  			for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  				Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  				vertexList.Add (flippedPos + currentPos);  			}  			var srcIndices = spriteData.colliderIndicesFwd;  			for (int i = 0; i < srcIndices.Length; ++i) {  				int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  				indexList.Add (baseVertexIndex + srcIndices [j]);  			}  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int x = 0; x < tileMap.partitionSizeX; ++x) {  	int spriteId = chunkData [y * tileMap.partitionSizeX + x];  	int spriteIdx = BuilderUtil.GetTileFromRawTile (spriteId);  	Vector3 currentPos = new Vector3 (tileSize.x * (x + xOffset)' tileSize.y * y' 0);  	if (spriteIdx < 0 || spriteIdx >= spriteCount)  		continue;  	if (tilePrefabs [spriteIdx])  		continue;  	bool flipH = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipX);  	bool flipV = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.FlipY);  	bool rot90 = BuilderUtil.IsRawTileFlagSet (spriteId' tk2dTileFlags.Rot90);  	bool reverseIndices = false;  	if (flipH)  		reverseIndices = !reverseIndices;  	if (flipV)  		reverseIndices = !reverseIndices;  	var spriteData = tileMap.SpriteCollectionInst.spriteDefinitions [spriteIdx];  	int baseVertexIndex = vertexList.Count;  	if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  		Vector3 origin = spriteData.colliderVertices [0];  		Vector3 extents = spriteData.colliderVertices [1];  		Vector3 min = origin - extents;  		Vector3 max = origin + extents;  		Vector3[] pos = new Vector3[8];  		pos [0] = new Vector3 (min.x' min.y' min.z);  		pos [1] = new Vector3 (min.x' min.y' max.z);  		pos [2] = new Vector3 (max.x' min.y' min.z);  		pos [3] = new Vector3 (max.x' min.y' max.z);  		pos [4] = new Vector3 (min.x' max.y' min.z);  		pos [5] = new Vector3 (min.x' max.y' max.z);  		pos [6] = new Vector3 (max.x' max.y' min.z);  		pos [7] = new Vector3 (max.x' max.y' max.z);  		for (int i = 0; i < 8; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  		int[] indicesFwd =  {  			2'  			1'  			0'  			3'  			1'  			2'  			4'  			5'  			6'  			6'  			5'  			7'  			6'  			7'  			3'  			6'  			3'  			2'  			1'  			5'  			4'  			0'  			1'  			4  		};  		var srcIndices = indicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  	else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  		for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  			Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  			vertexList.Add (flippedPos + currentPos);  		}  		var srcIndices = spriteData.colliderIndicesFwd;  		for (int i = 0; i < srcIndices.Length; ++i) {  			int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  			indexList.Add (baseVertexIndex + srcIndices [j]);  		}  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Box) {  	Vector3 origin = spriteData.colliderVertices [0];  	Vector3 extents = spriteData.colliderVertices [1];  	Vector3 min = origin - extents;  	Vector3 max = origin + extents;  	Vector3[] pos = new Vector3[8];  	pos [0] = new Vector3 (min.x' min.y' min.z);  	pos [1] = new Vector3 (min.x' min.y' max.z);  	pos [2] = new Vector3 (max.x' min.y' min.z);  	pos [3] = new Vector3 (max.x' min.y' max.z);  	pos [4] = new Vector3 (min.x' max.y' min.z);  	pos [5] = new Vector3 (min.x' max.y' max.z);  	pos [6] = new Vector3 (max.x' max.y' min.z);  	pos [7] = new Vector3 (max.x' max.y' max.z);  	for (int i = 0; i < 8; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	//						int[] indicesBack = { 0' 1' 2' 2' 1' 3' 6' 5' 4' 7' 5' 6' 3' 7' 6' 2' 3' 6' 4' 5' 1' 4' 1' 0 };  	int[] indicesFwd =  {  		2'  		1'  		0'  		3'  		1'  		2'  		4'  		5'  		6'  		6'  		5'  		7'  		6'  		7'  		3'  		6'  		3'  		2'  		1'  		5'  		4'  		0'  		1'  		4  	};  	var srcIndices = indicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  else if (spriteData.colliderType == tk2dSpriteDefinition.ColliderType.Mesh) {  	for (int i = 0; i < spriteData.colliderVertices.Length; ++i) {  		Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' spriteData.colliderVertices [i]' flipH' flipV' rot90);  		vertexList.Add (flippedPos + currentPos);  	}  	var srcIndices = spriteData.colliderIndicesFwd;  	for (int i = 0; i < srcIndices.Length; ++i) {  		int j = reverseIndices ? (srcIndices.Length - 1 - i) : i;  		indexList.Add (baseVertexIndex + srcIndices [j]);  	}  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [2] = new Vector3 (max.x' min.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [3] = new Vector3 (max.x' min.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [4] = new Vector3 (min.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [5] = new Vector3 (min.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [6] = new Vector3 (max.x' max.y' min.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: pos [7] = new Vector3 (max.x' max.y' max.z);  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,BuildLocalMeshForChunk,The following statement contains a magic number: for (int i = 0; i < 8; ++i) {  	Vector3 flippedPos = BuilderUtil.ApplySpriteVertexTileFlags (tileMap' spriteData' pos [i]' flipH' flipV' rot90);  	vertexList.Add (flippedPos + currentPos);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,CompareDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < 3; ++i) {  	int d = indices [face0index + i] - indices [face1index + i];  	if (d != 0)  		return d;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	int[] faceIndices =  {  		indices [i]'  		indices [i + 1]'  		indices [i + 2]  	};  	System.Array.Sort (faceIndices);  	sortedFaceIndices [i] = faceIndices [0];  	sortedFaceIndices [i + 1] = faceIndices [1];  	sortedFaceIndices [i + 2] = faceIndices [2];  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortedFaceIndices [i + 2] = faceIndices [2];  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < indices.Length; i += 3) {  	sortIndex [i / 3] = i;  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: i += 3
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: sortIndex [i / 3] = i;  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int i = 0; i < sortIndex.Length; ++i) {  	if (i != sortIndex.Length - 1 && CompareDuplicateFaces (sortedFaceIndices' sortIndex [i]' sortIndex [i + 1]) == 0) {  		// skip both faces  		// this will fail in the case where there are 3 coplanar faces  		// but that is probably likely user error / intentional  		i++;  		continue;  	}  	for (int j = 0; j < 3; ++j)  		newIndices.Add (indices [sortIndex [i] + j]);  }  
Magic Number,tk2dRuntime.TileMap,ColliderBuilder,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2dTileMap\Code\tk2dTileMapColliderBuilder.cs,RemoveDuplicateFaces,The following statement contains a magic number: for (int j = 0; j < 3; ++j)  	newIndices.Add (indices [sortIndex [i] + j]);  
Magic Number,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Bezier3,The following statement contains a magic number: return (((-s + 3 * (st - et) + e) * t + (3 * (s + et) - 6 * st)) * t + 3 * (st - s)) * t + s;  
Magic Number,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Bezier3,The following statement contains a magic number: return (((-s + 3 * (st - et) + e) * t + (3 * (s + et) - 6 * st)) * t + 3 * (st - s)) * t + s;  
Magic Number,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Bezier3,The following statement contains a magic number: return (((-s + 3 * (st - et) + e) * t + (3 * (s + et) - 6 * st)) * t + 3 * (st - s)) * t + s;  
Magic Number,Code.Libaries.UnityExtensions.Independent,Ease,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\UnityExtensions\Independent\Ease.cs,Bezier3,The following statement contains a magic number: return (((-s + 3 * (st - et) + e) * t + (3 * (s + et) - 6 * st)) * t + 3 * (st - s)) * t + s;  
Missing Default,Pathfinding,GraphModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Misc\GraphModifier.cs,TriggerEvent,The following switch statement is missing a default case: switch (type) {  case EventType.PreScan:  	while (c != null) {  		c.OnPreScan ();  		c = c.next;  	}  	break;  case EventType.PostScan:  	while (c != null) {  		c.OnPostScan ();  		c = c.next;  	}  	break;  case EventType.LatePostScan:  	while (c != null) {  		c.OnLatePostScan ();  		c = c.next;  	}  	break;  case EventType.PreUpdate:  	while (c != null) {  		c.OnGraphsPreUpdate ();  		c = c.next;  	}  	break;  case EventType.PostUpdate:  	while (c != null) {  		c.OnGraphsPostUpdate ();  		c = c.next;  	}  	break;  case EventType.PostCacheLoad:  	while (c != null) {  		c.OnPostCacheLoad ();  		c = c.next;  	}  	break;  }  
Missing Default,Pathfinding,Path,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Core\Path.cs,CalculateHScore,The following switch statement is missing a default case: switch (heuristic) {  case Heuristic.Euclidean:  	return (uint)(((GetHTarget () - node.position).costMagnitude) * heuristicScale);  case Heuristic.Manhattan:  	Int3 p2 = node.position;  	return (uint)((System.Math.Abs (hTarget.x - p2.x) + System.Math.Abs (hTarget.y - p2.y) + System.Math.Abs (hTarget.z - p2.z)) * heuristicScale);  case Heuristic.DiagonalManhattan:  	Int3 p = GetHTarget () - node.position;  	p.x = System.Math.Abs (p.x);  	p.y = System.Math.Abs (p.y);  	p.z = System.Math.Abs (p.z);  	int diag = System.Math.Min (p.x' p.z);  	int diag2 = System.Math.Max (p.x' p.z);  	return (uint)((((14 * diag) / 10) + (diag2 - diag) + p.y) * heuristicScale);  }  
Missing Default,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,The following switch statement is missing a default case: switch (AstarPath.active.debugMode) {  case GraphDebugMode.Areas:  	c = AstarColor.GetAreaColor (node.Area);  	colSet = true;  	break;  case GraphDebugMode.Penalty:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)node.Penalty / (float)AstarPath.active.debugRoof);  	colSet = true;  	break;  case GraphDebugMode.Tags:  	c = AstarMath.IntToColor ((int)node.Tag' 0.5F);  	colSet = true;  	break;  /* Wasn't really usefull 				case GraphDebugMode.Position: 					float r = Mathf.PingPong (node.position.x/10000F'1F) + Mathf.PingPong (node.position.x/300000F'1F); 					float g = Mathf.PingPong (node.position.y/10000F'1F) + Mathf.PingPong (node.position.y/200000F'1F); 					float b = Mathf.PingPong (node.position.z/10000F'1F) + Mathf.PingPong (node.position.z/100000F'1F); 					 					 					c = new Color (r'g'b); 					break; 				*/}  
Missing Default,Pathfinding,NavGraph,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Base.cs,NodeColor,The following switch statement is missing a default case: switch (AstarPath.active.debugMode) {  case GraphDebugMode.G:  	//c = Mathfx.IntToColor (node.g'0.5F);  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.G / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.H:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.H / (float)AstarPath.active.debugRoof);  	break;  case GraphDebugMode.F:  	c = Color.Lerp (AstarColor.ConnectionLowLerp' AstarColor.ConnectionHighLerp' (float)nodeR.F / (float)AstarPath.active.debugRoof);  	break;  }  
Missing Default,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,createMeshStruct,The following switch statement is missing a default case: switch (brokenString [0]) {  case "v":  	vertices++;  	break;  case "vt":  	vt++;  	break;  case "vn":  	vn++;  	break;  case "f":  	face = face + brokenString.Length - 1;  	triangles = triangles + 3 * (brokenString.Length - 2);  	/*brokenString.Length is 3 or greater since a face must have at least 	                                                                                     3 vertices.  For each additional vertice' there is an additional 	                                                                                     triangle in the mesh (hence this formula).*/break;  }  
Missing Default,Pathfinding,ObjImporter,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Generators\Utilities\ObjImporter.cs,populateMeshStruct,The following switch statement is missing a default case: switch (brokenString [0]) {  case "g":  	break;  case "usemtl":  	break;  case "usemap":  	break;  case "mtllib":  	break;  case "v":  	mesh.vertices [v] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	v++;  	break;  case "vt":  	mesh.uv [vt] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt++;  	break;  case "vt1":  	mesh.uv [vt1] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt1++;  	break;  case "vt2":  	mesh.uv [vt2] = new Vector2 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2]));  	vt2++;  	break;  case "vn":  	mesh.normals [vn] = new Vector3 (System.Convert.ToSingle (brokenString [1])' System.Convert.ToSingle (brokenString [2])' System.Convert.ToSingle (brokenString [3]));  	vn++;  	break;  case "vc":  	break;  case "f":  	int j = 1;  	List<int> intArray = new List<int> ();  	while (j < brokenString.Length && ("" + brokenString [j]).Length > 0) {  		Vector3 temp = new Vector3 ();  		brokenBrokenString = brokenString [j].Split (splitIdentifier2' 3);  		//Separate the face into individual components (vert' uv' normal)  		temp.x = System.Convert.ToInt32 (brokenBrokenString [0]);  		if (brokenBrokenString.Length > 1)//Some .obj files skip UV and normal  		 {  			if (brokenBrokenString [1] != "")//Some .obj files skip the uv and not the normal  			 {  				temp.y = System.Convert.ToInt32 (brokenBrokenString [1]);  			}  			temp.z = System.Convert.ToInt32 (brokenBrokenString [2]);  		}  		j++;  		mesh.faceData [f2] = temp;  		intArray.Add (f2);  		f2++;  	}  	j = 1;  	while (j + 2 < brokenString.Length)//Create triangles out of the face data.  There will generally be more than 1 triangle per face.  	 {  		mesh.triangles [f] = intArray [0];  		f++;  		mesh.triangles [f] = intArray [j];  		f++;  		mesh.triangles [f] = intArray [j + 1];  		f++;  		j++;  	}  	break;  }  
Missing Default,Pathfinding,SimpleSmoothModifier,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\AstarPathfindingProject\Modifiers\SimpleSmoothModifier.cs,Apply,The following switch statement is missing a default case: switch (smoothType) {  case SmoothType.Simple:  	path = SmoothSimple (p.vectorPath);  	break;  case SmoothType.Bezier:  	path = SmoothBezier (p.vectorPath);  	break;  case SmoothType.OffsetSimple:  	path = SmoothOffsetSimple (p.vectorPath);  	break;  case SmoothType.CurvedNonuniform:  	path = CurvedNonuniform (p.vectorPath);  	break;  }  
Missing Default,Code.Core.Client.UI.Controls.Items,ItemInventory,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventory.cs,Build,The following switch statement is missing a default case: switch (Anchor) {  case InterfaceAnchor.LowerCenter:  	ay = Height;  	break;  case InterfaceAnchor.LowerLeft:  	ax = Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.LowerRight:  	ax = -Width / 2;  	ay = Height;  	break;  case InterfaceAnchor.MiddleCenter:  	ax = 0;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleLeft:  	ax = Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.MiddleRight:  	ax = -Width / 2;  	ay = Height / 2;  	break;  case InterfaceAnchor.UpperCenter:  	ax = 0;  	ay = 0;  	break;  case InterfaceAnchor.UpperLeft:  	ax = Width / 2;  	ay = 0;  	break;  case InterfaceAnchor.UpperRight:  	ax = -Width / 2;  	ay = 0;  	break;  }  
Missing Default,Code.Core.Client.UI.Controls.Items,ItemInventoryInterface,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventoryInterface.cs,Handle,The following switch statement is missing a default case: switch (packet.type) {  case UIInventoryInterfacePacket.PacketType.SHOW:  	InventoryInterface.I.ItemInventory.Width = packet.X;  	InventoryInterface.I.ItemInventory.Height = packet.Y;  	InventoryInterface.I.ItemInventory.ForceRebuild ();  	break;  case UIInventoryInterfacePacket.PacketType.HIDE:  	InventoryInterface.I.Hide ();  	break;  case UIInventoryInterfacePacket.PacketType.SetItem:  	int itemID = packet.Value;  	InventoryInterface.I.ItemInventory.SetItem (packet.X' packet.Y' itemID);  	break;  }  
Missing Default,Code.Core.Client.UI.Controls.Items,ItemInventoryInterface,C:\repos\AncientKemet_UnityProject\Assets\Code\Core\Client\UI\Controls\Items\ItemInventoryInterface.cs,Handle,The following switch statement is missing a default case: switch (packet.type) {  case UIInventoryInterfacePacket.PacketType.SHOW:  	instance.ItemInventory.Width = packet.X;  	instance.ItemInventory.Height = packet.Y;  	instance.ItemInventory.ForceRebuild ();  	break;  case UIInventoryInterfacePacket.PacketType.HIDE:  	instance.Hide ();  	break;  case UIInventoryInterfacePacket.PacketType.SetItem:  	int itemID = packet.Value;  	instance.ItemInventory.SetItem (packet.X' packet.Y' itemID);  	break;  }  
Missing Default,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,JSONObject,The following switch statement is missing a default case: switch (t) {  case Type.ARRAY:  	list = new List<JSONObject> ();  	break;  case Type.OBJECT:  	list = new List<JSONObject> ();  	keys = new List<string> ();  	break;  }  
Missing Default,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Create,The following switch statement is missing a default case: switch (t) {  case Type.ARRAY:  	obj.list = new List<JSONObject> ();  	break;  case Type.OBJECT:  	obj.list = new List<JSONObject> ();  	obj.keys = new List<string> ();  	break;  }  
Missing Default,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,StringifyAsync,The following switch statement is missing a default case: switch (type) {  case Type.BAKED:  	builder.Append (str);  	break;  case Type.STRING:  	builder.AppendFormat ("\"{0}\""' str);  	break;  case Type.NUMBER:  	#if USEFLOAT  	if (float.IsInfinity (n))  		builder.Append (INFINITY);  	else if (float.IsNegativeInfinity (n))  		builder.Append (NEGINFINITY);  	else if (float.IsNaN (n))  		builder.Append (NaN);  	#else  					if(double.IsInfinity(n)) 					builder.Append(INFINITY); 				else if(double.IsNegativeInfinity(n)) 					builder.Append(NEGINFINITY); 				else if(double.IsNaN(n)) 					builder.Append(NaN); #endif  	else  		builder.Append (n.ToString ());  	break;  case Type.OBJECT:  	builder.Append ("{");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		#endif  		for (int i = 0; i < list.Count; i++) {  			string key = keys [i];  			JSONObject obj = list [i];  			if (obj) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				builder.AppendFormat ("\"{0}\":"' key);  				foreach (IEnumerable e in obj.StringifyAsync (depth' builder' pretty))  					yield return e;  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("}");  	break;  case Type.ARRAY:  	builder.Append ("[");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		//for a bit more readability  		#endif  		for (int i = 0; i < list.Count; i++) {  			if (list [i]) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				foreach (IEnumerable e in list [i].StringifyAsync (depth' builder' pretty))  					yield return e;  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				//for a bit more readability  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("]");  	break;  case Type.BOOL:  	if (b)  		builder.Append ("true");  	else  		builder.Append ("false");  	break;  case Type.NULL:  	builder.Append ("null");  	break;  }  
Missing Default,Libaries.IO,JSONObject,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\IO\Json.cs,Stringify,The following switch statement is missing a default case: switch (type) {  case Type.BAKED:  	builder.Append (str);  	break;  case Type.STRING:  	builder.AppendFormat ("\"{0}\""' str);  	break;  case Type.NUMBER:  	#if USEFLOAT  	if (float.IsInfinity (n))  		builder.Append (INFINITY);  	else if (float.IsNegativeInfinity (n))  		builder.Append (NEGINFINITY);  	else if (float.IsNaN (n))  		builder.Append (NaN);  	#else  					if(double.IsInfinity(n)) 					builder.Append(INFINITY); 				else if(double.IsNegativeInfinity(n)) 					builder.Append(NEGINFINITY); 				else if(double.IsNaN(n)) 					builder.Append(NaN); #endif  	else  		builder.Append (n.ToString ());  	break;  case Type.OBJECT:  	builder.Append ("{");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		#endif  		for (int i = 0; i < list.Count; i++) {  			string key = keys [i];  			JSONObject obj = list [i];  			if (obj) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				builder.AppendFormat ("\"{0}\":"' key);  				obj.Stringify (depth' builder' pretty);  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("}");  	break;  case Type.ARRAY:  	builder.Append ("[");  	if (list.Count > 0) {  		#if (PRETTY)  		if (pretty)  			builder.Append ("\n");  		//for a bit more readability  		#endif  		for (int i = 0; i < list.Count; i++) {  			if (list [i]) {  				#if (PRETTY)  				if (pretty)  					for (int j = 0; j < depth; j++)  						builder.Append ("\t");  				//for a bit more readability  				#endif  				list [i].Stringify (depth' builder' pretty);  				builder.Append ("'");  				#if (PRETTY)  				if (pretty)  					builder.Append ("\n");  				//for a bit more readability  				#endif  			}  		}  		#if (PRETTY)  		if (pretty)  			builder.Length -= 2;  		else  			#endif  			builder.Length--;  	}  	#if (PRETTY)  	if (pretty && list.Count > 0) {  		builder.Append ("\n");  		for (int j = 0; j < depth - 1; j++)  			builder.Append ("\t");  		//for a bit more readability  	}  	#endif  	builder.Append ("]");  	break;  case Type.BOOL:  	if (b)  		builder.Append ("true");  	else  		builder.Append ("false");  	break;  case Type.NULL:  	builder.Append ("null");  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (state) {  case 0:  	{  		switch (cmd) {  		case 'i':  			break;  		// ignore version field for now  		case 'w':  			textureDimensions.x = Int32.Parse (line.Substring (2));  			break;  		case 'h':  			textureDimensions.y = Int32.Parse (line.Substring (2));  			break;  		// total number of sprites would be ideal to statically allocate  		case '~':  			state++;  			break;  		}  	}  	break;  case 1:  	{  		switch (cmd) {  		case 'n':  			entryName = line.Substring (2);  			break;  		case 'r':  			entryRotated = Int32.Parse (line.Substring (2)) == 1;  			break;  		case 's':  			{  				// sprite  				string[] tokens = line.Split ();  				entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  			}  			break;  		case 'o':  			{  				// origin  				string[] tokens = line.Split ();  				entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  				entryTrimmed = true;  			}  			break;  		case '~':  			{  				names.Add (entryName);  				rotated.Add (entryRotated);  				rects.Add (entryRect);  				if (!entryTrimmed) {  					// The entryRect dimensions will be the wrong way around if the sprite is rotated  					if (entryRotated)  						entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  					else  						entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  				}  				trimRects.Add (entryTrimData);  				anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  				anchors.Add (anchor);  				entryName = "";  				entryTrimmed = false;  				entryRotated = false;  			}  			break;  		}  	}  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'i':  	break;  // ignore version field for now  case 'w':  	textureDimensions.x = Int32.Parse (line.Substring (2));  	break;  case 'h':  	textureDimensions.y = Int32.Parse (line.Substring (2));  	break;  // total number of sprites would be ideal to statically allocate  case '~':  	state++;  	break;  }  
Missing Default,tk2dRuntime,SpriteCollectionGenerator,C:\repos\AncientKemet_UnityProject\Assets\Code\Libaries\TK2DROOT\tk2d\Code\Sprites\tk2dRuntimeSpriteCollection.cs,CreateFromTexturePacker,The following switch statement is missing a default case: switch (cmd) {  case 'n':  	entryName = line.Substring (2);  	break;  case 'r':  	entryRotated = Int32.Parse (line.Substring (2)) == 1;  	break;  case 's':  	{  		// sprite  		string[] tokens = line.Split ();  		entryRect.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  	}  	break;  case 'o':  	{  		// origin  		string[] tokens = line.Split ();  		entryTrimData.Set (Int32.Parse (tokens [1])' Int32.Parse (tokens [2])' Int32.Parse (tokens [3])' Int32.Parse (tokens [4]));  		entryTrimmed = true;  	}  	break;  case '~':  	{  		names.Add (entryName);  		rotated.Add (entryRotated);  		rects.Add (entryRect);  		if (!entryTrimmed) {  			// The entryRect dimensions will be the wrong way around if the sprite is rotated  			if (entryRotated)  				entryTrimData.Set (0' 0' entryRect.height' entryRect.width);  			else  				entryTrimData.Set (0' 0' entryRect.width' entryRect.height);  		}  		trimRects.Add (entryTrimData);  		anchor.Set ((int)(entryTrimData.width / 2)' (int)(entryTrimData.height / 2));  		anchors.Add (anchor);  		entryName = "";  		entryTrimmed = false;  		entryRotated = false;  	}  	break;  }  
