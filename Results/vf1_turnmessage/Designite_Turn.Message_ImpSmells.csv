Implementation smell,Namespace,Class,File,Method,Description
Long Method,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The method has 188 lines of code.
Complex Method,Turn.Message,ReasonPhrase,C:\repos\vf1_turnmessage\Turn.Message\ErrorCode.cs,GetReasonPhrase,Cyclomatic complexity of the method is 17
Complex Method,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,Cyclomatic complexity of the method is 17
Complex Method,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,Cyclomatic complexity of the method is 136
Complex Method,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMsAvedgeaMessageIntegrity,Cyclomatic complexity of the method is 8
Complex Method,System.Text,Saslprep,C:\repos\vf1_turnmessage\Turn.Message\Tools\Saslprep.cs,IsNonAsciiSpace,Cyclomatic complexity of the method is 17
Complex Method,System.Text,Saslprep,C:\repos\vf1_turnmessage\Turn.Message\Tools\Saslprep.cs,IsCommonlyMappedToNothing,Cyclomatic complexity of the method is 27
Long Parameter List,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetBytes,The method has 6 parameters.
Long Parameter List,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The method has 6 parameters.
Long Parameter List,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMsAvedgeaMessageIntegrity,The method has 6 parameters.
Long Parameter List,Turn.Message,Attribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Base\Attribute.cs,CopyBytes,The method has 5 parameters.
Long Statement,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetBytes,The length of the statement  "	return GetBytes (null' 0' password' null' longOrShortTerm ? CreditalsType.LongTerm : CreditalsType.ShortTerm' paddingByte); " is 123.
Long Statement,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The length of the statement  "					(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value); " is 149.
Long Statement,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseHeader,The length of the statement  "		throw new TurnMessageException (ErrorCode.BadRequest' @"The most significant two bits of Message Type MUST be set to zero"); " is 124.
Long Statement,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseHeader,The length of the statement  "		throw new TurnMessageException (ErrorCode.BadRequest' string.Format (@"Wrong message length' wait for {0} actual is {1}"' length - HeaderLength' this.MessageLength)); " is 166.
Long Statement,Turn.Message,AddressAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Base\AddressAttribute.cs,Parse,The length of the statement  "	Port = (UInt16)(bytes.BigendianToUInt16 (ref startIndex) ^ (xorMask == null ? (UInt16)0 : xorMask.BigendianToUInt16 (0))); " is 122.
Long Statement,Turn.Message,AddressAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Base\AddressAttribute.cs,Parse,The length of the statement  "		throw new TurnMessageException (ErrorCode.BadRequest' @"The address family of the attribute field MUST be set to 0x01 or 0x02."); " is 129.
Empty Catch Block,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,SafeGetTransactionId,The method has an empty catch block.
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (Value1)' 0' bytes' startIndex + 0' 8);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (Value2)' 0' bytes' startIndex + 8' 8);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (Value2)' 0' bytes' startIndex + 8' 8);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (Value3)' 0' bytes' startIndex + 16' 4);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,GetBytes,The following statement contains a magic number: Buffer.BlockCopy (BitConverter.GetBytes (Value3)' 0' bytes' startIndex + 16' 4);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,GetBytes,The following statement contains a magic number: startIndex += 20;  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,Parse,The following statement contains a magic number: Value2 = BitConverter.ToInt64 (bytes' startIndex + 8);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,Parse,The following statement contains a magic number: Value3 = BitConverter.ToInt32 (bytes' startIndex + 16);  
Magic Number,Turn.Message,ConnectionId,C:\repos\vf1_turnmessage\Turn.Message\ConnectionId.cs,Parse,The following statement contains a magic number: startIndex += 20;  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: while (Value.Length - startIndex >= 4) {  	hashCode ^= BitConverter.ToInt32 (Value' startIndex);  	startIndex += 4;  }  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: while (Value.Length - startIndex >= 4) {  	hashCode ^= BitConverter.ToInt32 (Value' startIndex);  	startIndex += 4;  }  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: startIndex += 4;  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: if (Value.Length - startIndex >= 2) {  	hashCode ^= BitConverter.ToInt16 (Value' startIndex);  	startIndex += 2;  }  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: if (Value.Length - startIndex >= 2) {  	hashCode ^= BitConverter.ToInt16 (Value' startIndex);  	startIndex += 2;  }  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: startIndex += 2;  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: if (startIndex < Value.Length)  	hashCode ^= (int)Value [startIndex++] << 16;  
Magic Number,Turn.Message,TransactionId,C:\repos\vf1_turnmessage\Turn.Message\TransactionId.cs,GetHashCode,The following statement contains a magic number: hashCode ^= (int)Value [startIndex++] << 16;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,SafeGetMessageType,The following statement contains a magic number: if (length < 2)  	return null;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: foreach (var attribute in allAttributes)  	if (attribute != null && attribute.Ignore == false) {  		MessageLength += attribute.TotalLength;  		if (IsAttributePaddingEnabled ()) {  			if (MessageLength % 4 > 0)  				MessageLength += (UInt16)(4 - MessageLength % 4);  		}  	}  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: foreach (var attribute in allAttributes)  	if (attribute != null && attribute.Ignore == false) {  		MessageLength += attribute.TotalLength;  		if (IsAttributePaddingEnabled ()) {  			if (MessageLength % 4 > 0)  				MessageLength += (UInt16)(4 - MessageLength % 4);  		}  	}  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: foreach (var attribute in allAttributes)  	if (attribute != null && attribute.Ignore == false) {  		MessageLength += attribute.TotalLength;  		if (IsAttributePaddingEnabled ()) {  			if (MessageLength % 4 > 0)  				MessageLength += (UInt16)(4 - MessageLength % 4);  		}  	}  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (attribute != null && attribute.Ignore == false) {  	MessageLength += attribute.TotalLength;  	if (IsAttributePaddingEnabled ()) {  		if (MessageLength % 4 > 0)  			MessageLength += (UInt16)(4 - MessageLength % 4);  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (attribute != null && attribute.Ignore == false) {  	MessageLength += attribute.TotalLength;  	if (IsAttributePaddingEnabled ()) {  		if (MessageLength % 4 > 0)  			MessageLength += (UInt16)(4 - MessageLength % 4);  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (attribute != null && attribute.Ignore == false) {  	MessageLength += attribute.TotalLength;  	if (IsAttributePaddingEnabled ()) {  		if (MessageLength % 4 > 0)  			MessageLength += (UInt16)(4 - MessageLength % 4);  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (IsAttributePaddingEnabled ()) {  	if (MessageLength % 4 > 0)  		MessageLength += (UInt16)(4 - MessageLength % 4);  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (IsAttributePaddingEnabled ()) {  	if (MessageLength % 4 > 0)  		MessageLength += (UInt16)(4 - MessageLength % 4);  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (IsAttributePaddingEnabled ()) {  	if (MessageLength % 4 > 0)  		MessageLength += (UInt16)(4 - MessageLength % 4);  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (MessageLength % 4 > 0)  	MessageLength += (UInt16)(4 - MessageLength % 4);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (MessageLength % 4 > 0)  	MessageLength += (UInt16)(4 - MessageLength % 4);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: if (MessageLength % 4 > 0)  	MessageLength += (UInt16)(4 - MessageLength % 4);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: MessageLength += (UInt16)(4 - MessageLength % 4);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageLength,The following statement contains a magic number: MessageLength += (UInt16)(4 - MessageLength % 4);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: foreach (var attribute in allAttributes) {  	if (attribute != null && attribute.Ignore == false) {  		if (attribute is MessageIntegrity) {  			switch (creditalsType) {  			case CreditalsType.ShortTerm:  				(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  				break;  			case CreditalsType.LongTerm:  				(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  				break;  			case CreditalsType.MsAvedgea:  				(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  				break;  			}  		}  		if (attribute is Fingerprint)  			(attribute as Fingerprint).Value = ComputeFingerprint (bytes' startIndex);  		if (attribute is XorMappedAddress)  			(attribute as XorMappedAddress).GetBytes (bytes' ref startIndex' TransactionId);  		else  			attribute.GetBytes (bytes' ref startIndex);  		if (IsAttributePaddingEnabled ()) {  			if (startIndex % 4 > 0) {  				if (paddingByte != 0)  					PadAttribute (paddingByte' bytes' startIndex);  				startIndex += 4 - startIndex % 4;  			}  		}  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: foreach (var attribute in allAttributes) {  	if (attribute != null && attribute.Ignore == false) {  		if (attribute is MessageIntegrity) {  			switch (creditalsType) {  			case CreditalsType.ShortTerm:  				(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  				break;  			case CreditalsType.LongTerm:  				(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  				break;  			case CreditalsType.MsAvedgea:  				(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  				break;  			}  		}  		if (attribute is Fingerprint)  			(attribute as Fingerprint).Value = ComputeFingerprint (bytes' startIndex);  		if (attribute is XorMappedAddress)  			(attribute as XorMappedAddress).GetBytes (bytes' ref startIndex' TransactionId);  		else  			attribute.GetBytes (bytes' ref startIndex);  		if (IsAttributePaddingEnabled ()) {  			if (startIndex % 4 > 0) {  				if (paddingByte != 0)  					PadAttribute (paddingByte' bytes' startIndex);  				startIndex += 4 - startIndex % 4;  			}  		}  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: foreach (var attribute in allAttributes) {  	if (attribute != null && attribute.Ignore == false) {  		if (attribute is MessageIntegrity) {  			switch (creditalsType) {  			case CreditalsType.ShortTerm:  				(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  				break;  			case CreditalsType.LongTerm:  				(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  				break;  			case CreditalsType.MsAvedgea:  				(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  				break;  			}  		}  		if (attribute is Fingerprint)  			(attribute as Fingerprint).Value = ComputeFingerprint (bytes' startIndex);  		if (attribute is XorMappedAddress)  			(attribute as XorMappedAddress).GetBytes (bytes' ref startIndex' TransactionId);  		else  			attribute.GetBytes (bytes' ref startIndex);  		if (IsAttributePaddingEnabled ()) {  			if (startIndex % 4 > 0) {  				if (paddingByte != 0)  					PadAttribute (paddingByte' bytes' startIndex);  				startIndex += 4 - startIndex % 4;  			}  		}  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (attribute != null && attribute.Ignore == false) {  	if (attribute is MessageIntegrity) {  		switch (creditalsType) {  		case CreditalsType.ShortTerm:  			(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  			break;  		case CreditalsType.LongTerm:  			(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  			break;  		case CreditalsType.MsAvedgea:  			(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  			break;  		}  	}  	if (attribute is Fingerprint)  		(attribute as Fingerprint).Value = ComputeFingerprint (bytes' startIndex);  	if (attribute is XorMappedAddress)  		(attribute as XorMappedAddress).GetBytes (bytes' ref startIndex' TransactionId);  	else  		attribute.GetBytes (bytes' ref startIndex);  	if (IsAttributePaddingEnabled ()) {  		if (startIndex % 4 > 0) {  			if (paddingByte != 0)  				PadAttribute (paddingByte' bytes' startIndex);  			startIndex += 4 - startIndex % 4;  		}  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (attribute != null && attribute.Ignore == false) {  	if (attribute is MessageIntegrity) {  		switch (creditalsType) {  		case CreditalsType.ShortTerm:  			(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  			break;  		case CreditalsType.LongTerm:  			(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  			break;  		case CreditalsType.MsAvedgea:  			(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  			break;  		}  	}  	if (attribute is Fingerprint)  		(attribute as Fingerprint).Value = ComputeFingerprint (bytes' startIndex);  	if (attribute is XorMappedAddress)  		(attribute as XorMappedAddress).GetBytes (bytes' ref startIndex' TransactionId);  	else  		attribute.GetBytes (bytes' ref startIndex);  	if (IsAttributePaddingEnabled ()) {  		if (startIndex % 4 > 0) {  			if (paddingByte != 0)  				PadAttribute (paddingByte' bytes' startIndex);  			startIndex += 4 - startIndex % 4;  		}  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (attribute != null && attribute.Ignore == false) {  	if (attribute is MessageIntegrity) {  		switch (creditalsType) {  		case CreditalsType.ShortTerm:  			(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  			break;  		case CreditalsType.LongTerm:  			(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  			break;  		case CreditalsType.MsAvedgea:  			(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  			break;  		}  	}  	if (attribute is Fingerprint)  		(attribute as Fingerprint).Value = ComputeFingerprint (bytes' startIndex);  	if (attribute is XorMappedAddress)  		(attribute as XorMappedAddress).GetBytes (bytes' ref startIndex' TransactionId);  	else  		attribute.GetBytes (bytes' ref startIndex);  	if (IsAttributePaddingEnabled ()) {  		if (startIndex % 4 > 0) {  			if (paddingByte != 0)  				PadAttribute (paddingByte' bytes' startIndex);  			startIndex += 4 - startIndex % 4;  		}  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (IsAttributePaddingEnabled ()) {  	if (startIndex % 4 > 0) {  		if (paddingByte != 0)  			PadAttribute (paddingByte' bytes' startIndex);  		startIndex += 4 - startIndex % 4;  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (IsAttributePaddingEnabled ()) {  	if (startIndex % 4 > 0) {  		if (paddingByte != 0)  			PadAttribute (paddingByte' bytes' startIndex);  		startIndex += 4 - startIndex % 4;  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (IsAttributePaddingEnabled ()) {  	if (startIndex % 4 > 0) {  		if (paddingByte != 0)  			PadAttribute (paddingByte' bytes' startIndex);  		startIndex += 4 - startIndex % 4;  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (startIndex % 4 > 0) {  	if (paddingByte != 0)  		PadAttribute (paddingByte' bytes' startIndex);  	startIndex += 4 - startIndex % 4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (startIndex % 4 > 0) {  	if (paddingByte != 0)  		PadAttribute (paddingByte' bytes' startIndex);  	startIndex += 4 - startIndex % 4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: if (startIndex % 4 > 0) {  	if (paddingByte != 0)  		PadAttribute (paddingByte' bytes' startIndex);  	startIndex += 4 - startIndex % 4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: startIndex += 4 - startIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following statement contains a magic number: startIndex += 4 - startIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,PadAttribute,The following statement contains a magic number: while (startIndex % 4 > 0) {  	bytes [startIndex] = paddingByte;  	startIndex++;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetHeaderBytes,The following statement contains a magic number: Array.Copy (((UInt16)MessageType).GetBigendianBytes ()' 0' bytes' startIndex + 0' 2);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetHeaderBytes,The following statement contains a magic number: Array.Copy (((UInt16)MessageLength).GetBigendianBytes ()' 0' bytes' startIndex + 2' 2);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetHeaderBytes,The following statement contains a magic number: Array.Copy (((UInt16)MessageLength).GetBigendianBytes ()' 0' bytes' startIndex + 2' 2);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetHeaderBytes,The following statement contains a magic number: Array.Copy (TransactionId.Value' 0' bytes' startIndex + 4' TransactionId.Length);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseHeader,The following statement contains a magic number: this.MessageLength = bytes.BigendianToUInt16 (startIndex + 2);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseHeader,The following statement contains a magic number: this.TransactionId = new TransactionId (bytes' startIndex + 4);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: while (currentIndex < endIndex) {  	UInt16 attributeType1 = bytes.BigendianToUInt16 (currentIndex);  	if (Enum.IsDefined (typeof(AttributeType)' (Int32)attributeType1) == false)  		throw new TurnMessageException (ErrorCode.UnknownAttribute);  	AttributeType attributeType = (AttributeType)attributeType1;  	if (rfc == TurnMessageRfc.Rfc3489)  		if (IsRfc3489 (attributeType))  			throw new TurnMessageException (ErrorCode.UnknownAttribute);  	if (attributeType == AttributeType.Fingerprint) {  		if (Fingerprint == null) {  			if (storedBytes == null) {  				storedBytes = new byte[length];  				Array.Copy (bytes' startIndex' storedBytes' 0' length);  			}  			fingerprintStartOffset = currentIndex - startIndex;  			Fingerprint = new Fingerprint ();  			Fingerprint.Parse (bytes' ref currentIndex);  		}  		else {  			Attribute.Skip (bytes' ref currentIndex);  		}  	}  	else if (MessageIntegrity != null) {  		Attribute.Skip (bytes' ref currentIndex);  	}  	else {  		switch (attributeType) {  		case AttributeType.AlternateServer:  			AlternateServer = new AlternateServer ();  			AlternateServer.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Bandwidth:  			Bandwidth = new Bandwidth ();  			Bandwidth.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Data:  			Data = new Data ();  			Data.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.DestinationAddress:  			DestinationAddress = new DestinationAddress ();  			DestinationAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ErrorCode:  			ErrorCodeAttribute = new ErrorCodeAttribute ();  			ErrorCodeAttribute.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Fingerprint:  			break;  		case AttributeType.Lifetime:  			Lifetime = new Lifetime ();  			Lifetime.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MagicCookie:  			MagicCookie = new MagicCookie ();  			MagicCookie.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MappedAddress:  			MappedAddress = new MappedAddress ();  			MappedAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MessageIntegrity:  			messageIntegrityStartOffset = currentIndex - startIndex;  			if (storedBytes == null) {  				if (rfc == TurnMessageRfc.MsTurn) {  					storedBytes = new byte[GetPadded64 (messageIntegrityStartOffset)];  					Array.Copy (bytes' startIndex' storedBytes' 0' messageIntegrityStartOffset);  				}  				else {  					storedBytes = new byte[length];  					Array.Copy (bytes' startIndex' storedBytes' 0' length);  				}  			}  			MessageIntegrity = new MessageIntegrity ();  			MessageIntegrity.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MsVersion:  			MsVersion = new MsVersion ();  			MsVersion.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MsSequenceNumber:  			MsSequenceNumber = new MsSequenceNumber ();  			MsSequenceNumber.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.RemoteAddress:  			RemoteAddress = new RemoteAddress ();  			RemoteAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Software:  			Software = new Software ();  			Software.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.UnknownAttributes:  			UnknownAttributes = new UnknownAttributes ();  			// Not Implemented  			UnknownAttributes.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Username:  			if (MsVersion != null) {  				MsUsername = new MsUsername ();  				MsUsername.Parse (bytes' ref currentIndex);  			}  			else {  				Username = new Username ();  				Username.Parse (bytes' ref currentIndex);  			}  			break;  		// ietf-mmusic-ice  		case AttributeType.Priority:  		case AttributeType.UseCandidate:  		case AttributeType.IceControlled:  		case AttributeType.IceControlling:  			Attribute.Skip (bytes' ref currentIndex);  			break;  		// rfc3489  		case AttributeType.ChangedAddress:  			ChangedAddress = new ChangedAddress ();  			ChangedAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ChangeRequest:  			ChangeRequest = new ChangeRequest ();  			ChangeRequest.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ResponseAddress:  			ResponseAddress = new ResponseAddress ();  			ResponseAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.SourceAddress:  			SourceAddress = new SourceAddress ();  			SourceAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ReflectedFrom:  			ReflectedFrom = new ReflectedFrom ();  			ReflectedFrom.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Password:  			Password = new Password ();  			Password.Parse (bytes' ref currentIndex);  			break;  		default:  			if (rfc == TurnMessageRfc.MsTurn) {  				switch (attributeType) {  				case AttributeType.Nonce:  					Nonce = new Nonce (rfc);  					Nonce.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.Realm:  					Realm = new Realm (rfc);  					Realm.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.XorMappedAddress:  					XorMappedAddress = new XorMappedAddress (rfc);  					XorMappedAddress.Parse (bytes' ref currentIndex' TransactionId);  					break;  				default:  					throw new NotImplementedException ();  				}  			}  			else {  				switch (attributeType) {  				case AttributeType.NonceStun:  					Nonce = new Nonce (rfc);  					Nonce.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.RealmStun:  					Realm = new Realm (rfc);  					Realm.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.XorMappedAddressStun:  					XorMappedAddress = new XorMappedAddress (rfc);  					XorMappedAddress.Parse (bytes' ref currentIndex' TransactionId);  					break;  				default:  					throw new NotImplementedException ();  				}  			}  			break;  		}  	}  	if (rfc != TurnMessageRfc.MsTurn) {  		if (currentIndex % 4 > 0)  			currentIndex += 4 - currentIndex % 4;  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: while (currentIndex < endIndex) {  	UInt16 attributeType1 = bytes.BigendianToUInt16 (currentIndex);  	if (Enum.IsDefined (typeof(AttributeType)' (Int32)attributeType1) == false)  		throw new TurnMessageException (ErrorCode.UnknownAttribute);  	AttributeType attributeType = (AttributeType)attributeType1;  	if (rfc == TurnMessageRfc.Rfc3489)  		if (IsRfc3489 (attributeType))  			throw new TurnMessageException (ErrorCode.UnknownAttribute);  	if (attributeType == AttributeType.Fingerprint) {  		if (Fingerprint == null) {  			if (storedBytes == null) {  				storedBytes = new byte[length];  				Array.Copy (bytes' startIndex' storedBytes' 0' length);  			}  			fingerprintStartOffset = currentIndex - startIndex;  			Fingerprint = new Fingerprint ();  			Fingerprint.Parse (bytes' ref currentIndex);  		}  		else {  			Attribute.Skip (bytes' ref currentIndex);  		}  	}  	else if (MessageIntegrity != null) {  		Attribute.Skip (bytes' ref currentIndex);  	}  	else {  		switch (attributeType) {  		case AttributeType.AlternateServer:  			AlternateServer = new AlternateServer ();  			AlternateServer.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Bandwidth:  			Bandwidth = new Bandwidth ();  			Bandwidth.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Data:  			Data = new Data ();  			Data.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.DestinationAddress:  			DestinationAddress = new DestinationAddress ();  			DestinationAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ErrorCode:  			ErrorCodeAttribute = new ErrorCodeAttribute ();  			ErrorCodeAttribute.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Fingerprint:  			break;  		case AttributeType.Lifetime:  			Lifetime = new Lifetime ();  			Lifetime.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MagicCookie:  			MagicCookie = new MagicCookie ();  			MagicCookie.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MappedAddress:  			MappedAddress = new MappedAddress ();  			MappedAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MessageIntegrity:  			messageIntegrityStartOffset = currentIndex - startIndex;  			if (storedBytes == null) {  				if (rfc == TurnMessageRfc.MsTurn) {  					storedBytes = new byte[GetPadded64 (messageIntegrityStartOffset)];  					Array.Copy (bytes' startIndex' storedBytes' 0' messageIntegrityStartOffset);  				}  				else {  					storedBytes = new byte[length];  					Array.Copy (bytes' startIndex' storedBytes' 0' length);  				}  			}  			MessageIntegrity = new MessageIntegrity ();  			MessageIntegrity.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MsVersion:  			MsVersion = new MsVersion ();  			MsVersion.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MsSequenceNumber:  			MsSequenceNumber = new MsSequenceNumber ();  			MsSequenceNumber.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.RemoteAddress:  			RemoteAddress = new RemoteAddress ();  			RemoteAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Software:  			Software = new Software ();  			Software.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.UnknownAttributes:  			UnknownAttributes = new UnknownAttributes ();  			// Not Implemented  			UnknownAttributes.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Username:  			if (MsVersion != null) {  				MsUsername = new MsUsername ();  				MsUsername.Parse (bytes' ref currentIndex);  			}  			else {  				Username = new Username ();  				Username.Parse (bytes' ref currentIndex);  			}  			break;  		// ietf-mmusic-ice  		case AttributeType.Priority:  		case AttributeType.UseCandidate:  		case AttributeType.IceControlled:  		case AttributeType.IceControlling:  			Attribute.Skip (bytes' ref currentIndex);  			break;  		// rfc3489  		case AttributeType.ChangedAddress:  			ChangedAddress = new ChangedAddress ();  			ChangedAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ChangeRequest:  			ChangeRequest = new ChangeRequest ();  			ChangeRequest.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ResponseAddress:  			ResponseAddress = new ResponseAddress ();  			ResponseAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.SourceAddress:  			SourceAddress = new SourceAddress ();  			SourceAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ReflectedFrom:  			ReflectedFrom = new ReflectedFrom ();  			ReflectedFrom.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Password:  			Password = new Password ();  			Password.Parse (bytes' ref currentIndex);  			break;  		default:  			if (rfc == TurnMessageRfc.MsTurn) {  				switch (attributeType) {  				case AttributeType.Nonce:  					Nonce = new Nonce (rfc);  					Nonce.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.Realm:  					Realm = new Realm (rfc);  					Realm.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.XorMappedAddress:  					XorMappedAddress = new XorMappedAddress (rfc);  					XorMappedAddress.Parse (bytes' ref currentIndex' TransactionId);  					break;  				default:  					throw new NotImplementedException ();  				}  			}  			else {  				switch (attributeType) {  				case AttributeType.NonceStun:  					Nonce = new Nonce (rfc);  					Nonce.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.RealmStun:  					Realm = new Realm (rfc);  					Realm.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.XorMappedAddressStun:  					XorMappedAddress = new XorMappedAddress (rfc);  					XorMappedAddress.Parse (bytes' ref currentIndex' TransactionId);  					break;  				default:  					throw new NotImplementedException ();  				}  			}  			break;  		}  	}  	if (rfc != TurnMessageRfc.MsTurn) {  		if (currentIndex % 4 > 0)  			currentIndex += 4 - currentIndex % 4;  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: while (currentIndex < endIndex) {  	UInt16 attributeType1 = bytes.BigendianToUInt16 (currentIndex);  	if (Enum.IsDefined (typeof(AttributeType)' (Int32)attributeType1) == false)  		throw new TurnMessageException (ErrorCode.UnknownAttribute);  	AttributeType attributeType = (AttributeType)attributeType1;  	if (rfc == TurnMessageRfc.Rfc3489)  		if (IsRfc3489 (attributeType))  			throw new TurnMessageException (ErrorCode.UnknownAttribute);  	if (attributeType == AttributeType.Fingerprint) {  		if (Fingerprint == null) {  			if (storedBytes == null) {  				storedBytes = new byte[length];  				Array.Copy (bytes' startIndex' storedBytes' 0' length);  			}  			fingerprintStartOffset = currentIndex - startIndex;  			Fingerprint = new Fingerprint ();  			Fingerprint.Parse (bytes' ref currentIndex);  		}  		else {  			Attribute.Skip (bytes' ref currentIndex);  		}  	}  	else if (MessageIntegrity != null) {  		Attribute.Skip (bytes' ref currentIndex);  	}  	else {  		switch (attributeType) {  		case AttributeType.AlternateServer:  			AlternateServer = new AlternateServer ();  			AlternateServer.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Bandwidth:  			Bandwidth = new Bandwidth ();  			Bandwidth.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Data:  			Data = new Data ();  			Data.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.DestinationAddress:  			DestinationAddress = new DestinationAddress ();  			DestinationAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ErrorCode:  			ErrorCodeAttribute = new ErrorCodeAttribute ();  			ErrorCodeAttribute.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Fingerprint:  			break;  		case AttributeType.Lifetime:  			Lifetime = new Lifetime ();  			Lifetime.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MagicCookie:  			MagicCookie = new MagicCookie ();  			MagicCookie.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MappedAddress:  			MappedAddress = new MappedAddress ();  			MappedAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MessageIntegrity:  			messageIntegrityStartOffset = currentIndex - startIndex;  			if (storedBytes == null) {  				if (rfc == TurnMessageRfc.MsTurn) {  					storedBytes = new byte[GetPadded64 (messageIntegrityStartOffset)];  					Array.Copy (bytes' startIndex' storedBytes' 0' messageIntegrityStartOffset);  				}  				else {  					storedBytes = new byte[length];  					Array.Copy (bytes' startIndex' storedBytes' 0' length);  				}  			}  			MessageIntegrity = new MessageIntegrity ();  			MessageIntegrity.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MsVersion:  			MsVersion = new MsVersion ();  			MsVersion.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.MsSequenceNumber:  			MsSequenceNumber = new MsSequenceNumber ();  			MsSequenceNumber.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.RemoteAddress:  			RemoteAddress = new RemoteAddress ();  			RemoteAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Software:  			Software = new Software ();  			Software.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.UnknownAttributes:  			UnknownAttributes = new UnknownAttributes ();  			// Not Implemented  			UnknownAttributes.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Username:  			if (MsVersion != null) {  				MsUsername = new MsUsername ();  				MsUsername.Parse (bytes' ref currentIndex);  			}  			else {  				Username = new Username ();  				Username.Parse (bytes' ref currentIndex);  			}  			break;  		// ietf-mmusic-ice  		case AttributeType.Priority:  		case AttributeType.UseCandidate:  		case AttributeType.IceControlled:  		case AttributeType.IceControlling:  			Attribute.Skip (bytes' ref currentIndex);  			break;  		// rfc3489  		case AttributeType.ChangedAddress:  			ChangedAddress = new ChangedAddress ();  			ChangedAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ChangeRequest:  			ChangeRequest = new ChangeRequest ();  			ChangeRequest.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ResponseAddress:  			ResponseAddress = new ResponseAddress ();  			ResponseAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.SourceAddress:  			SourceAddress = new SourceAddress ();  			SourceAddress.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.ReflectedFrom:  			ReflectedFrom = new ReflectedFrom ();  			ReflectedFrom.Parse (bytes' ref currentIndex);  			break;  		case AttributeType.Password:  			Password = new Password ();  			Password.Parse (bytes' ref currentIndex);  			break;  		default:  			if (rfc == TurnMessageRfc.MsTurn) {  				switch (attributeType) {  				case AttributeType.Nonce:  					Nonce = new Nonce (rfc);  					Nonce.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.Realm:  					Realm = new Realm (rfc);  					Realm.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.XorMappedAddress:  					XorMappedAddress = new XorMappedAddress (rfc);  					XorMappedAddress.Parse (bytes' ref currentIndex' TransactionId);  					break;  				default:  					throw new NotImplementedException ();  				}  			}  			else {  				switch (attributeType) {  				case AttributeType.NonceStun:  					Nonce = new Nonce (rfc);  					Nonce.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.RealmStun:  					Realm = new Realm (rfc);  					Realm.Parse (bytes' ref currentIndex);  					break;  				case AttributeType.XorMappedAddressStun:  					XorMappedAddress = new XorMappedAddress (rfc);  					XorMappedAddress.Parse (bytes' ref currentIndex' TransactionId);  					break;  				default:  					throw new NotImplementedException ();  				}  			}  			break;  		}  	}  	if (rfc != TurnMessageRfc.MsTurn) {  		if (currentIndex % 4 > 0)  			currentIndex += 4 - currentIndex % 4;  	}  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: if (rfc != TurnMessageRfc.MsTurn) {  	if (currentIndex % 4 > 0)  		currentIndex += 4 - currentIndex % 4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: if (rfc != TurnMessageRfc.MsTurn) {  	if (currentIndex % 4 > 0)  		currentIndex += 4 - currentIndex % 4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: if (rfc != TurnMessageRfc.MsTurn) {  	if (currentIndex % 4 > 0)  		currentIndex += 4 - currentIndex % 4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: if (currentIndex % 4 > 0)  	currentIndex += 4 - currentIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: if (currentIndex % 4 > 0)  	currentIndex += 4 - currentIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: if (currentIndex % 4 > 0)  	currentIndex += 4 - currentIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: currentIndex += 4 - currentIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ParseAttributes,The following statement contains a magic number: currentIndex += 4 - currentIndex % 4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: if (bytes.Length < 4)  	throw new ArgumentException ("Too short array"' @"bytes");  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: try {  	// 0x0018 - MessageIntegrity.TotalLength  	((UInt16)(length - HeaderLength + 0x0018)).GetBigendianBytes ().CopyTo (bytes' 2);  	using (HMACSHA1 sha1 = new HMACSHA1 (sha1Key))  		return sha1.ComputeHash (bytes' 0' length);  }  finally {  	bytes [2] = b3;  	bytes [3] = b4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: try {  	// 0x0018 - MessageIntegrity.TotalLength  	((UInt16)(length - HeaderLength + 0x0018)).GetBigendianBytes ().CopyTo (bytes' 2);  	using (HMACSHA1 sha1 = new HMACSHA1 (sha1Key))  		return sha1.ComputeHash (bytes' 0' length);  }  finally {  	bytes [2] = b3;  	bytes [3] = b4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: try {  	// 0x0018 - MessageIntegrity.TotalLength  	((UInt16)(length - HeaderLength + 0x0018)).GetBigendianBytes ().CopyTo (bytes' 2);  	using (HMACSHA1 sha1 = new HMACSHA1 (sha1Key))  		return sha1.ComputeHash (bytes' 0' length);  }  finally {  	bytes [2] = b3;  	bytes [3] = b4;  }  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: ((UInt16)(length - HeaderLength + 0x0018)).GetBigendianBytes ().CopyTo (bytes' 2);  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: bytes [2] = b3;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,ComputeMessageIntegritySha1,The following statement contains a magic number: bytes [3] = b4;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetPadded64,The following statement contains a magic number: return ((value + 63) / 64) * 64;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetPadded64,The following statement contains a magic number: return ((value + 63) / 64) * 64;  
Magic Number,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetPadded64,The following statement contains a magic number: return ((value + 63) / 64) * 64;  
Magic Number,Turn.Message,ErrorCodeAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\ErrorCodeAttribute.cs,GetBytes,The following statement contains a magic number: bytes [startIndex++] = (byte)(ErrorCode / 100);  
Magic Number,Turn.Message,ErrorCodeAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\ErrorCodeAttribute.cs,GetBytes,The following statement contains a magic number: bytes [startIndex++] = (byte)(ErrorCode % 100);  
Magic Number,Turn.Message,ErrorCodeAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\ErrorCodeAttribute.cs,Parse,The following statement contains a magic number: startIndex += 2;  
Magic Number,Turn.Message,ErrorCodeAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\ErrorCodeAttribute.cs,Parse,The following statement contains a magic number: ErrorCode = bytes [startIndex] * 100 + bytes [startIndex + 1];  
Magic Number,Turn.Message,ErrorCodeAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\ErrorCodeAttribute.cs,Parse,The following statement contains a magic number: startIndex += 2;  
Magic Number,Turn.Message,ErrorCodeAttribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\ErrorCodeAttribute.cs,Parse,The following statement contains a magic number: ParseUtf8String (bytes' ref startIndex' length - 4);  
Magic Number,Turn.Message,MsSequenceNumber,C:\repos\vf1_turnmessage\Turn.Message\Attributes\MsSequenceNumber.cs,GetBytes,The following statement contains a magic number: if (ConnectionId.Length != 20)  	throw new ArgumentException ("ConnectionId must be a 20 bytes length.");  
Magic Number,Turn.Message,Attribute,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Base\Attribute.cs,ParseHeader,The following statement contains a magic number: startIndex += 2;  
Magic Number,Turn.Message,ChangeRequest,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Rfc3489\ChangeRequest.cs,Parse,The following statement contains a magic number: ChangeIp = ((bytes [startIndex + 3] & 0x04) != 0);  
Magic Number,Turn.Message,ChangeRequest,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Rfc3489\ChangeRequest.cs,Parse,The following statement contains a magic number: ChangePort = ((bytes [startIndex + 3] & 0x02) != 0);  
Magic Number,Turn.Message,ChangeRequest,C:\repos\vf1_turnmessage\Turn.Message\Attributes\Rfc3489\ChangeRequest.cs,Parse,The following statement contains a magic number: startIndex += 4;  
Magic Number,System,Bigendian,C:\repos\vf1_turnmessage\Turn.Message\Tools\Bigendian.cs,BigendianToUInt16,The following statement contains a magic number: result <<= 8;  
Magic Number,System,Bigendian,C:\repos\vf1_turnmessage\Turn.Message\Tools\Bigendian.cs,BigendianToUInt32,The following statement contains a magic number: result <<= 8;  
Magic Number,System,Bigendian,C:\repos\vf1_turnmessage\Turn.Message\Tools\Bigendian.cs,BigendianToUInt32,The following statement contains a magic number: result <<= 8;  
Magic Number,System,Bigendian,C:\repos\vf1_turnmessage\Turn.Message\Tools\Bigendian.cs,BigendianToUInt32,The following statement contains a magic number: result |= bytes [startIndex + 2];  
Magic Number,System,Bigendian,C:\repos\vf1_turnmessage\Turn.Message\Tools\Bigendian.cs,BigendianToUInt32,The following statement contains a magic number: result <<= 8;  
Magic Number,System,Bigendian,C:\repos\vf1_turnmessage\Turn.Message\Tools\Bigendian.cs,BigendianToUInt32,The following statement contains a magic number: result |= bytes [startIndex + 3];  
Missing Default,Turn.Message,ReasonPhrase,C:\repos\vf1_turnmessage\Turn.Message\ErrorCode.cs,GetReasonPhrase,The following switch statement is missing a default case: switch (errorCode) {  case ErrorCode.BadRequest:  	return @"Bad Request";  case ErrorCode.Unauthorized:  	return @"Unauthorized";  case ErrorCode.UnknownAttribute:  	return @"Unknown Attribute";  case ErrorCode.StaleCredentials:  	return @"Stale Credentials";  case ErrorCode.IntegrityCheckFailure:  	return @"Integrity Check Failure";  case ErrorCode.MissingUsername:  	return @"Missing Username";  case ErrorCode.MissingRealm:  	return @"Missing Realm";  case ErrorCode.MissingNonce:  	return @"Missing Nonce";  case ErrorCode.UnknownUsername:  	return @"Unknown Username";  case ErrorCode.NoBinding:  	return @"No Binding";  case ErrorCode.StaleNonce:  	return @"Stale Nonce";  case ErrorCode.Transitioning:  	return @"Transitioning";  case ErrorCode.NoDestination:  	return @"No Destination";  case ErrorCode.WrongUsername:  	return @"Wrong Username";  case ErrorCode.UseTLS:  	return @"Use TLS";  case ErrorCode.ServerError:  	return @"Server Error";  case ErrorCode.GlobalFailure:  	return @"Global Failure";  }  
Missing Default,Turn.Message,MessageTypeHelpers,C:\repos\vf1_turnmessage\Turn.Message\MessageType.cs,GetErrorResponseType,The following switch statement is missing a default case: switch (requestType) {  case MessageType.AllocateRequest:  	return MessageType.AllocateErrorResponse;  case MessageType.SendRequest:  	return MessageType.SendRequestErrorResponse;  case MessageType.BindingRequest:  	return MessageType.BindingErrorResponse;  case MessageType.SetActiveDestinationRequest:  	return MessageType.SetActiveDestinationErrorResponse;  case MessageType.SharedSecretRequest:  	return MessageType.SharedSecretErrorResponse;  }  
Missing Default,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,IsRfc3489,The following switch statement is missing a default case: switch (attributeType) {  case AttributeType.ChangedAddress:  case AttributeType.ChangeRequest:  case AttributeType.ResponseAddress:  case AttributeType.SourceAddress:  case AttributeType.ReflectedFrom:  case AttributeType.Password:  	return true;  }  
Missing Default,Turn.Message,TurnMessage,C:\repos\vf1_turnmessage\Turn.Message\TurnMessage.cs,GetAttributesBytes,The following switch statement is missing a default case: switch (creditalsType) {  case CreditalsType.ShortTerm:  	(attribute as MessageIntegrity).Value = ComputeShortTermMessageIntegrity (bytes' startIndex' password);  	break;  case CreditalsType.LongTerm:  	(attribute as MessageIntegrity).Value = ComputeLongTermMessageIntegrity (bytes' startIndex' password);  	break;  case CreditalsType.MsAvedgea:  	(attribute as MessageIntegrity).Value = ComputeMsAvedgeaMessageIntegrity (bytes' messageStartIndex' startIndex' key2' Realm.Value' MsUsername.Value);  	break;  }  
Missing Default,System.Text,Saslprep,C:\repos\vf1_turnmessage\Turn.Message\Tools\Saslprep.cs,IsNonAsciiSpace,The following switch statement is missing a default case: switch (c) {  case '\u00A0':  //; NO-BREAK SPACE  case '\u1680':  //; OGHAM SPACE MARK  case '\u2000':  //; EN QUAD  case '\u2001':  //; EM QUAD  case '\u2002':  //; EN SPACE  case '\u2003':  //; EM SPACE  case '\u2004':  //; THREE-PER-EM SPACE  case '\u2005':  //; FOUR-PER-EM SPACE  case '\u2006':  //; SIX-PER-EM SPACE  case '\u2007':  //; FIGURE SPACE  case '\u2008':  //; PUNCTUATION SPACE  case '\u2009':  //; THIN SPACE  case '\u200A':  //; HAIR SPACE  case '\u200B':  //; ZERO WIDTH SPACE  case '\u202F':  //; NARROW NO-BREAK SPACE  case '\u205F':  //; MEDIUM MATHEMATICAL SPACE  case '\u3000':  	//; IDEOGRAPHIC SPACE  	return true;  }  
Missing Default,System.Text,Saslprep,C:\repos\vf1_turnmessage\Turn.Message\Tools\Saslprep.cs,IsCommonlyMappedToNothing,The following switch statement is missing a default case: switch (c) {  case '\u00AD':  //; ; Map to nothing  case '\u034F':  //; ; Map to nothing  case '\u1806':  //; ; Map to nothing  case '\u180B':  //; ; Map to nothing  case '\u180C':  //; ; Map to nothing  case '\u180D':  //; ; Map to nothing  case '\u200B':  //; ; Map to nothing  case '\u200C':  //; ; Map to nothing  case '\u200D':  //; ; Map to nothing  case '\u2060':  //; ; Map to nothing  case '\uFE00':  //; ; Map to nothing  case '\uFE01':  //; ; Map to nothing  case '\uFE02':  //; ; Map to nothing  case '\uFE03':  //; ; Map to nothing  case '\uFE04':  //; ; Map to nothing  case '\uFE05':  //; ; Map to nothing  case '\uFE06':  //; ; Map to nothing  case '\uFE07':  //; ; Map to nothing  case '\uFE08':  //; ; Map to nothing  case '\uFE09':  //; ; Map to nothing  case '\uFE0A':  //; ; Map to nothing  case '\uFE0B':  //; ; Map to nothing  case '\uFE0C':  //; ; Map to nothing  case '\uFE0D':  //; ; Map to nothing  case '\uFE0E':  //; ; Map to nothing  case '\uFE0F':  //; ; Map to nothing  case '\uFEFF':  	//; ; Map to nothing  	return true;  }  
