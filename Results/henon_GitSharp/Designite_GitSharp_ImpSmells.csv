Implementation smell,Namespace,Class,File,Method,Description
Complex Method,GitSharp.Commands,AbstractCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\AbstractCommand.cs,FindGitDirectory,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Commands,CheckoutCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Stubs\CheckoutCommand.cs,Execute,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Commands,CloneCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\CloneCommand.cs,Execute,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Commands,ConfigCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Stubs\ConfigCommand.cs,Execute,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Commands,PushCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\PushCommand.cs,printPushResult,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Commands,PushCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\PushCommand.cs,printRefUpdateResult,Cyclomatic complexity of the method is 27
Complex Method,GitSharp.Commands,StatusCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\StatusCommand.cs,Execute,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Commands,StatusResults,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\StatusCommand.cs,Contains,Cyclomatic complexity of the method is 10
Complex Method,GitSharp,Branch,F:\newReposMay17\henon_GitSharp\GitSharp\Branch.cs,Reset,Cyclomatic complexity of the method is 14
Complex Method,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,Blame,Cyclomatic complexity of the method is 12
Complex Method,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,CalculateCommitDiff,Cyclomatic complexity of the method is 12
Complex Method,GitSharp,IgnoreRules,F:\newReposMay17\henon_GitSharp\GitSharp\IgnoreRules.cs,BuildRules,Cyclomatic complexity of the method is 28
Complex Method,GitSharp,Repository,F:\newReposMay17\henon_GitSharp\GitSharp\Repository.cs,Commit,Cyclomatic complexity of the method is 14
Complex Method,GitSharp,Repository,F:\newReposMay17\henon_GitSharp\GitSharp\Repository.cs,FindRepository,Cyclomatic complexity of the method is 8
Complex Method,GitSharp,RepositoryStatus,F:\newReposMay17\henon_GitSharp\GitSharp\RepositoryStatus.cs,UpdateDirectoryNotRecursive,Cyclomatic complexity of the method is 10
Complex Method,GitSharp,RepositoryStatus,F:\newReposMay17\henon_GitSharp\GitSharp\RepositoryStatus.cs,OnVisitEntry,Cyclomatic complexity of the method is 10
Long Parameter List,GitSharp.Commands,PushCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\PushCommand.cs,printUpdateLine,The method has 5 parameters.
Long Parameter List,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,Create,The method has 6 parameters.
Long Parameter List,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,Create,The method has 6 parameters.
Long Parameter List,GitSharp,RepositoryStatus,F:\newReposMay17\henon_GitSharp\GitSharp\RepositoryStatus.cs,RepositoryStatus,The method has 5 parameters.
Long Parameter List,GitSharp,StashCollection,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,WriteTree,The method has 5 parameters.
Long Statement,GitSharp.Commands,CloneCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\CloneCommand.cs,Execute,The length of the statement  "		throw new InvalidOperationException (string.Format ("destination path '{0}' already exists and is not an empty directory."' new DirectoryInfo (Directory).FullName)); " is 165.
Long Statement,GitSharp.Commands,CloneCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\CloneCommand.cs,saveRemote,The length of the statement  "	rc.AddFetchRefSpec (new RefSpec ().SetForce (true).SetSourceDestination (Constants.R_HEADS + "*"' Constants.R_REMOTES + OriginName + "/*")); " is 140.
Long Statement,GitSharp.Commands,InitCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\InitCommand.cs,Execute,The length of the statement  "			OutputStream.WriteLine (String.Format ("{0} empty Git repository in {1}"' reinit ? "Reinitialized" : "Initialized"' repo.Directory.FullName)); " is 142.
Long Statement,GitSharp.Commands,PushCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\PushCommand.cs,printRefUpdateResult,The length of the statement  "				string summary = oldRef.ObjectId.Abbreviate (Repository._internal_repo).name () + (fastForward ? ".." : "...") + rru.NewObjectId.Abbreviate (Repository._internal_repo).name (); " is 176.
Long Statement,GitSharp.Commands,PushCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\PushCommand.cs,printRefUpdateResult,The length of the statement  "		string message = "remote ref object changed - is not expected one " + rru.ExpectedOldObjectId.Abbreviate (Repository._internal_repo).name (); " is 141.
Long Statement,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,Checkout,The length of the statement  "		throw new InvalidOperationException ("Unable to checkout this commit. It was not initialized properly (i.e. the hash is not pointing to a commit object)."); " is 156.
Long Statement,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,Create,The length of the statement  "	corecommit.Author = new Core.PersonIdent (author.Name' author.EmailAddress' time.ToMillisecondsSinceEpoch ()' (int)time.Offset.TotalMinutes); " is 141.
Long Statement,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,Create,The length of the statement  "	corecommit.Committer = new Core.PersonIdent (committer.Name' committer.EmailAddress' time.ToMillisecondsSinceEpoch ()' (int)time.Offset.TotalMinutes); " is 150.
Long Statement,GitSharp,AbstractTreeNode,F:\newReposMay17\henon_GitSharp\GitSharp\AbstractTreeNode.cs,GetHistoryBefore,The length of the statement  "			if ((this is Leaf && change.Path == this.Path) || (this is Tree && change.Path.StartsWith (this.Path)))// <--- [henon] normally this is bad style but here I prefer it over polymorphism for sake of readability " is 208.
Long Statement,GitSharp,Repository,F:\newReposMay17\henon_GitSharp\GitSharp\Repository.cs,Commit,The length of the statement  "	return Commit (message' new Author (Config ["user.name"] ?? "unknown"' Config ["user.email"] ?? "unknown@(none).")' paths); " is 123.
Long Statement,GitSharp,Repository,F:\newReposMay17\henon_GitSharp\GitSharp\Repository.cs,GetDirectoryFiles,The length of the statement  "	return dir.GetFiles ().Where (f => !Index.IgnoreHandler.IsIgnored (f.FullName)).Select (f => f.FullName).Concat (dir.GetDirectories ().Where (di => !Index.IgnoreHandler.IsIgnored (di.FullName) && di.Name != GitSharp.Core.Constants.DOT_GIT).SelectMany (di => GetDirectoryFiles (di))); " is 283.
Long Statement,GitSharp,RepositoryStatus,F:\newReposMay17\henon_GitSharp\GitSharp\RepositoryStatus.cs,UpdateSingleFile,The length of the statement  "	FileInfo fileInfo = new FileInfo (Path.Combine (Repository.WorkingDirectory' file.Replace ('/'' Path.DirectorySeparatorChar))); " is 127.
Long Statement,GitSharp,RepositoryStatus,F:\newReposMay17\henon_GitSharp\GitSharp\RepositoryStatus.cs,OnVisitEntry,The length of the statement  "		if (file.Exists && indexEntry.IsModified (new DirectoryInfo (Repository.WorkingDirectory)' Options.ForceContentCheck)) { " is 120.
Complex Conditional,GitSharp.Commands,CheckoutCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Stubs\CheckoutCommand.cs,Execute,The conditional expression  "Patch && (Track || BranchCreate.Length > 0 || RefLog || Merge || Force)"  is complex.
Complex Conditional,GitSharp,Index,F:\newReposMay17\henon_GitSharp\GitSharp\Index.cs,CommitChanges,The conditional expression  "(parent == null && GitIndex.Members.Count == 0) || (parent != null && parent.Tree._id == tree_id)"  is complex.
Complex Conditional,GitSharp,AbstractTreeNode,F:\newReposMay17\henon_GitSharp\GitSharp\AbstractTreeNode.cs,GetHistoryBefore,The conditional expression  "(this is Leaf && change.Path == this.Path) || (this is Tree && change.Path.StartsWith (this.Path))"  is complex.
Magic Number,GitSharp.Commands,MergeOptions,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\MergeCommand.cs,Validate,The following statement contains a magic number: if (Commits.Count () < 2)  	throw new ArgumentException ("Need at least two commits to merge");  
Magic Number,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,CalculateCommitDiff,The following statement contains a magic number: while (walk.next ()) {  	int m0 = walk.getRawMode (0);  	if (walk.getTreeCount () == 2) {  		int m1 = walk.getRawMode (1);  		var change = new Change {  			ReferenceCommit = commits [0]'  			ComparedCommit = commits [1]'  			ReferencePermissions = walk.getFileMode (0).Bits'  			ComparedPermissions = walk.getFileMode (1).Bits'  			Name = walk.getNameString ()'  			Path = walk.getPathString ()'  		};  		if (m0 != 0 && m1 == 0) {  			change.ChangeType = ChangeType.Added;  			change.ComparedObject = Wrap (repo' walk.getObjectId (0));  		} else if (m0 == 0 && m1 != 0) {  			change.ChangeType = ChangeType.Deleted;  			change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  		} else if (m0 != m1 && walk.idEqual (0' 1)) {  			change.ChangeType = ChangeType.TypeChanged;  			change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  			change.ComparedObject = Wrap (repo' walk.getObjectId (1));  		} else {  			change.ChangeType = ChangeType.Modified;  			change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  			change.ComparedObject = Wrap (repo' walk.getObjectId (1));  		}  		yield return change;  	} else {  		var raw_modes = new int[walk.getTreeCount () - 1];  		for (int i = 0; i < walk.getTreeCount () - 1; i++)  			raw_modes [i] = walk.getRawMode (i + 1);  		var change = new Change {  			ReferenceCommit = commits [0]'  			//ComparedCommit = compared'  			Name = walk.getNameString ()'  			Path = walk.getPathString ()'  		};  		if (m0 != 0 && raw_modes.All (m1 => m1 == 0)) {  			change.ChangeType = ChangeType.Added;  			change.ComparedObject = Wrap (repo' walk.getObjectId (0));  			yield return change;  		} else if (m0 == 0 && raw_modes.Any (m1 => m1 != 0)) {  			change.ChangeType = ChangeType.Deleted;  			yield return change;  		} else if (raw_modes.Select ((m1' i) => new {  			Mode = m1'  			Index = i + 1  		}).All (x => !walk.idEqual (0' x.Index)))// TODO: not sure if this condition suffices in some special cases.  		 {  			change.ChangeType = ChangeType.Modified;  			change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  			yield return change;  		} else if (raw_modes.Select ((m1' i) => new {  			Mode = m1'  			Index = i + 1  		}).Any (x => m0 != x.Mode && walk.idEqual (0' x.Index))) {  			change.ChangeType = ChangeType.TypeChanged;  			change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  			yield return change;  		}  	}  }  
Magic Number,GitSharp,Commit,F:\newReposMay17\henon_GitSharp\GitSharp\Commit.cs,CalculateCommitDiff,The following statement contains a magic number: if (walk.getTreeCount () == 2) {  	int m1 = walk.getRawMode (1);  	var change = new Change {  		ReferenceCommit = commits [0]'  		ComparedCommit = commits [1]'  		ReferencePermissions = walk.getFileMode (0).Bits'  		ComparedPermissions = walk.getFileMode (1).Bits'  		Name = walk.getNameString ()'  		Path = walk.getPathString ()'  	};  	if (m0 != 0 && m1 == 0) {  		change.ChangeType = ChangeType.Added;  		change.ComparedObject = Wrap (repo' walk.getObjectId (0));  	} else if (m0 == 0 && m1 != 0) {  		change.ChangeType = ChangeType.Deleted;  		change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  	} else if (m0 != m1 && walk.idEqual (0' 1)) {  		change.ChangeType = ChangeType.TypeChanged;  		change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  		change.ComparedObject = Wrap (repo' walk.getObjectId (1));  	} else {  		change.ChangeType = ChangeType.Modified;  		change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  		change.ComparedObject = Wrap (repo' walk.getObjectId (1));  	}  	yield return change;  } else {  	var raw_modes = new int[walk.getTreeCount () - 1];  	for (int i = 0; i < walk.getTreeCount () - 1; i++)  		raw_modes [i] = walk.getRawMode (i + 1);  	var change = new Change {  		ReferenceCommit = commits [0]'  		//ComparedCommit = compared'  		Name = walk.getNameString ()'  		Path = walk.getPathString ()'  	};  	if (m0 != 0 && raw_modes.All (m1 => m1 == 0)) {  		change.ChangeType = ChangeType.Added;  		change.ComparedObject = Wrap (repo' walk.getObjectId (0));  		yield return change;  	} else if (m0 == 0 && raw_modes.Any (m1 => m1 != 0)) {  		change.ChangeType = ChangeType.Deleted;  		yield return change;  	} else if (raw_modes.Select ((m1' i) => new {  		Mode = m1'  		Index = i + 1  	}).All (x => !walk.idEqual (0' x.Index)))// TODO: not sure if this condition suffices in some special cases.  	 {  		change.ChangeType = ChangeType.Modified;  		change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  		yield return change;  	} else if (raw_modes.Select ((m1' i) => new {  		Mode = m1'  		Index = i + 1  	}).Any (x => m0 != x.Mode && walk.idEqual (0' x.Index))) {  		change.ChangeType = ChangeType.TypeChanged;  		change.ReferenceObject = Wrap (repo' walk.getObjectId (0));  		yield return change;  	}  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Stash,The following statement contains a magic number: sb.Append (prevStashCommitId ?? new string ('0'' 40)).Append (' ');  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: s.PrevStashCommitId = line.Substring (0' 40);  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: s.CommitId = line.Substring (41' 40);  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: s.CommitId = line.Substring (41' 40);  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: if (i != -1) {  	s.Author.Name = line.Substring (82' i - 82 - 1);  	i++;  	int i2 = line.IndexOf ('>'' i);  	if (i2 != -1)  		s.Author.EmailAddress = line.Substring (i' i2 - i);  	i2 += 2;  	i = line.IndexOf (' '' i2);  	int secs = int.Parse (line.Substring (i2' i - i2));  	string stUtcOffset = line.Substring (i + 1' 3) + ":" + line.Substring (i + 4' 2);  	if (stUtcOffset [0] == '+')  		stUtcOffset = stUtcOffset.Remove (0' 1);  	TimeSpan utcOffset = TimeSpan.Parse (stUtcOffset);  	DateTime t = new DateTime (1970' 1' 1) + TimeSpan.FromSeconds (secs) + utcOffset;  	s.DateTime = new DateTimeOffset (t' utcOffset);  	s.Comment = line.Substring (i + 7);  }  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: s.Author.Name = line.Substring (82' i - 82 - 1);  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: s.Author.Name = line.Substring (82' i - 82 - 1);  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: i2 += 2;  
Magic Number,GitSharp,Stash,F:\newReposMay17\henon_GitSharp\GitSharp\Stash.cs,Parse,The following statement contains a magic number: s.Comment = line.Substring (i + 7);  
Missing Default,GitSharp.Commands,MergeCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\MergeCommand.cs,SelectMerger,The following switch statement is missing a default case: switch (options.MergeStrategy) {  case MergeStrategy.Ours:  	return Core.Merge.MergeStrategy.Ours.NewMerger (options.Repository);  case MergeStrategy.Theirs:  	return Core.Merge.MergeStrategy.Theirs.NewMerger (options.Repository);  case MergeStrategy.Recursive:  	return Core.Merge.MergeStrategy.SimpleTwoWayInCore.NewMerger (options.Repository);  }  
Missing Default,GitSharp.Commands,PushCommand,F:\newReposMay17\henon_GitSharp\GitSharp\Commands\PushCommand.cs,printRefUpdateResult,The following switch statement is missing a default case: switch (rru.Status) {  case RemoteRefUpdate.UpdateStatus.OK: {  	if (rru.IsDelete)  		printUpdateLine ('-'' "[deleted]"' null' remoteName' null);  	else {  		GitSharp.Core.Ref oldRef = result.GetAdvertisedRef (remoteName);  		if (oldRef == null) {  			string summary = remoteName.StartsWith (Constants.R_TAGS) ? "[new tag]" : "[new branch]";  			printUpdateLine ('*'' summary' srcRef' remoteName' null);  		} else {  			bool fastForward = rru.FastForward;  			char flag = fastForward ? ' ' : '+';  			string summary = oldRef.ObjectId.Abbreviate (Repository._internal_repo).name () + (fastForward ? ".." : "...") + rru.NewObjectId.Abbreviate (Repository._internal_repo).name ();  			string message = fastForward ? null : "forced update";  			printUpdateLine (flag' summary' srcRef' remoteName' message);  		}  	}  	break;  }  case RemoteRefUpdate.UpdateStatus.NON_EXISTING:  	printUpdateLine ('X'' "[no match]"' null' remoteName' null);  	break;  case RemoteRefUpdate.UpdateStatus.REJECTED_NODELETE:  	printUpdateLine ('!'' "[rejected]"' null' remoteName' "remote side does not support deleting refs");  	break;  case RemoteRefUpdate.UpdateStatus.REJECTED_NONFASTFORWARD:  	printUpdateLine ('!'' "[rejected]"' srcRef' remoteName' "non-fast forward");  	break;  case RemoteRefUpdate.UpdateStatus.REJECTED_REMOTE_CHANGED: {  	string message = "remote ref object changed - is not expected one " + rru.ExpectedOldObjectId.Abbreviate (Repository._internal_repo).name ();  	printUpdateLine ('!'' "[rejected]"' srcRef' remoteName' message);  	break;  }  case RemoteRefUpdate.UpdateStatus.REJECTED_OTHER_REASON:  	printUpdateLine ('!'' "[rejected]"' srcRef' remoteName' rru.Message);  	break;  case RemoteRefUpdate.UpdateStatus.UP_TO_DATE:  	if (Verbose)  		printUpdateLine ('='' "[up to date]"' srcRef' remoteName' null);  	break;  case RemoteRefUpdate.UpdateStatus.NOT_ATTEMPTED:  case RemoteRefUpdate.UpdateStatus.AWAITING_REPORT:  	printUpdateLine ('?'' "[unexpected push-process behavior]"' srcRef' remoteName' rru.Message);  	break;  }  
