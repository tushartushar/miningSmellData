Implementation smell,Namespace,Class,File,Method,Description
Long Method,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The method has 214 lines of code.
Long Method,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The method has 536 lines of code.
Long Method,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The method has 118 lines of code.
Long Method,GitSharp.Core.RevWalk,RewriteTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RewriteTreeFilter.cs,include,The method has 117 lines of code.
Long Method,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The method has 121 lines of code.
Complex Method,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core,SubmoduleConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\SubmoduleConfig.cs,GetEntry,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,Cyclomatic complexity of the method is 15
Complex Method,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Decode,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FromBits,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,GitIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\GitIndex.cs,write,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core,GitIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\GitIndex.cs,checkoutEntry,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,GitIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\GitIndex.cs,writeTree,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,IndexTreeWalker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\IndexTreeWalker.cs,FinishVisitTree,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,IndexTreeWalker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\IndexTreeWalker.cs,VisitEntry,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,check,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkCommit,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,Cyclomatic complexity of the method is 20
Complex Method,GitSharp.Core,ObjectWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectWriter.cs,WriteObject,Cyclomatic complexity of the method is 17
Complex Method,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,Evict,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,Cyclomatic complexity of the method is 15
Complex Method,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,Cyclomatic complexity of the method is 96
Complex Method,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,IsValidRefName,Cyclomatic complexity of the method is 19
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,EscapeValue,Cyclomatic complexity of the method is 34
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,getLong,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,replaceStringList,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,toText,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,fromText,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,ReadValue,Cyclomatic complexity of the method is 34
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,readSectionName,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,readKeyName,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,decode,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Core,WorkDirCheckout,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WorkDirCheckout.cs,ProcessEntry,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core,RefWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefWriter.cs,writePackedRefs,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,Linux,Cyclomatic complexity of the method is 28
Complex Method,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetMandrivaPlatform,Cyclomatic complexity of the method is 79
Complex Method,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,log,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,parsePackedRefs,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,RefDirectoryRename,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectoryRename.cs,doRename,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core.Diff,DiffFormatter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,WriteRange,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,Cyclomatic complexity of the method is 19
Complex Method,GitSharp.Core.DirectoryCache,DirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEditor.cs,ApplyEdits,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,isValidPath,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,validate,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,CreateSimpleHeads,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.FnMatch,GroupHead,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,Cyclomatic complexity of the method is 18
Complex Method,GitSharp.Core.Merge,Merger,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\Merger.cs,Merge,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.RevWalk,MergeBaseGenerator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\MergeBaseGenerator.cs,next,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.RevWalk,ObjectWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\ObjectWalk.cs,nextObject,Cyclomatic complexity of the method is 29
Complex Method,GitSharp.Core.RevWalk,ObjectWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\ObjectWalk.cs,MarkTreeUninteresting,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Core.RevWalk,PendingGenerator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\PendingGenerator.cs,next,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,GetFooterLines,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RevCommitList,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommitList.cs,fillTo,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RevWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,lookupAny,Cyclomatic complexity of the method is 15
Complex Method,GitSharp.Core.RevWalk,RevWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,parseAny,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.RevWalk,RevWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,reset,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RewriteGenerator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RewriteGenerator.cs,Cleanup,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RewriteTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RewriteTreeFilter.cs,include,Cyclomatic complexity of the method is 17
Complex Method,GitSharp.Core.RevWalk,StartGenerator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\StartGenerator.cs,next,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core.Transport,FetchProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,executeImp,Cyclomatic complexity of the method is 20
Complex Method,GitSharp.Core.Transport,FetchProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,deleteTrackingRef,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,OpenSshConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,lookup,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,OpenSshConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,Cyclomatic complexity of the method is 36
Complex Method,GitSharp.Core.Transport,PushProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PushProcess.cs,PrepareRemoteUpdates,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,Process,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,ProcessTree,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadPackedObject,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,MarkLocalObjComplete,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,MarkTreeComplete,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Transport,WalkPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,Push,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Transport,WalkPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,Sendpack,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Transport,WalkRemoteObjectDatabase,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkRemoteObjectDatabase.cs,readPackedRefsImpl,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkReachable,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,EnableCapabilities,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,Cyclomatic complexity of the method is 36
Complex Method,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,BundleFetchConnection,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,verifyPrerequisites,Cyclomatic complexity of the method is 17
Complex Method,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,index,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,Cyclomatic complexity of the method is 22
Complex Method,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,Cyclomatic complexity of the method is 31
Complex Method,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,SkipInflateFromInput,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,renameAndOpenPack,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,Service,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,Cyclomatic complexity of the method is 19
Complex Method,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,Execute,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,Status,Cyclomatic complexity of the method is 22
Complex Method,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,SendStatusReport,Cyclomatic complexity of the method is 36
Complex Method,GitSharp.Core.Transport,RefSpec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,RefSpec,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,RemoteConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RemoteConfig.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,SideBandInputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,needDataPacket,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,Cyclomatic complexity of the method is 26
Complex Method,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,SendPack,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,Format,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Util,FS,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\FS.cs,globalHomeImpl,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Util,FS,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\FS.cs,systemHomeImpl,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,Hex,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Util,PathUtil,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\PathUtil.cs,RelativePath,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Util,RawSubStringPattern,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawSubstringPattern.cs,match,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Util,TemporaryBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,copy,Cyclomatic complexity of the method is 8
Complex Method,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.RevWalk.Filter,SubStringRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\SubStringRevFilter.cs,safe,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Patch,CombinedFileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\CombinedFileHeader.cs,parseGitHeaders,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Patch,CombinedHunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,parseBody,Cyclomatic complexity of the method is 30
Complex Method,GitSharp.Core.Patch,CombinedHunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,extractFileLines,Cyclomatic complexity of the method is 26
Complex Method,GitSharp.Core.Patch,CombinedHunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,extractFileLines,Cyclomatic complexity of the method is 24
Complex Method,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitHeaders,Cyclomatic complexity of the method is 18
Complex Method,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,ToEditList,Cyclomatic complexity of the method is 25
Complex Method,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,parseBody,Cyclomatic complexity of the method is 21
Complex Method,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,extractFileLines,Cyclomatic complexity of the method is 17
Complex Method,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,extractFileLines,Cyclomatic complexity of the method is 17
Complex Method,GitSharp.Core.Patch,Patch,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseFile,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Patch,Patch,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseHunks,Cyclomatic complexity of the method is 19
Complex Method,GitSharp.Core.TreeWalk,NameConflictTreeWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,FastMin,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.TreeWalk,NameConflictTreeWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,CombineDF,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.TreeWalk,TreeWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\TreeWalk.cs,next,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.RevPlot,PlotCommitList,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\PlotCommitList.cs,enter,Cyclomatic complexity of the method is 10
Long Parameter List,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,AbbreviatedObjectId,The method has 6 parameters.
Long Parameter List,GitSharp.Core,DeltaOfsPackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DeltaOfsPackedObjectLoader.cs,DeltaOfsPackedObjectLoader,The method has 5 parameters.
Long Parameter List,GitSharp.Core,DeltaRefPackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DeltaRefPackedObjectLoader.cs,DeltaRefPackedObjectLoader,The method has 5 parameters.
Long Parameter List,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,AnyObjectId,The method has 5 parameters.
Long Parameter List,GitSharp.Core,IndexTreeWalker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\IndexTreeWalker.cs,IndexTreeWalker,The method has 5 parameters.
Long Parameter List,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,pathCompare,The method has 7 parameters.
Long Parameter List,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,ObjectId,The method has 5 parameters.
Long Parameter List,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,ReadFully,The method has 5 parameters.
Long Parameter List,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,CopyToStream,The method has 5 parameters.
Long Parameter List,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The method has 5 parameters.
Long Parameter List,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,replaceStringList,The method has 5 parameters.
Long Parameter List,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,CompareNames,The method has 6 parameters.
Long Parameter List,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,BinarySearch,The method has 5 parameters.
Long Parameter List,GitSharp.Core,WholePackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WholePackedObjectLoader.cs,WholePackedObjectLoader,The method has 5 parameters.
Long Parameter List,GitSharp.Core,WindowCursor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCursor.cs,Copy,The method has 5 parameters.
Long Parameter List,GitSharp.Core,WorkDirCheckout,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WorkDirCheckout.cs,WorkDirCheckout,The method has 5 parameters.
Long Parameter List,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,GetProductInfo,The method has 5 parameters.
Long Parameter List,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,resolve,The method has 5 parameters.
Long Parameter List,GitSharp.Core.Diff,DiffFormatter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,WriteHunkHeader,The method has 5 parameters.
Long Parameter List,GitSharp.Core.Exceptions,NoClosingBracketException,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\NoClosingBracketException.cs,NoClosingBracketException,The method has 5 parameters.
Long Parameter List,GitSharp.Core.Merge,MergeFormatter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeFormatter.cs,formatMerge,The method has 6 parameters.
Long Parameter List,GitSharp.Core.RevWalk,FooterLine,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\FooterLine.cs,FooterLine,The method has 6 parameters.
Long Parameter List,GitSharp.Core.Transport,FetchProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,deleteTrackingRef,The method has 5 parameters.
Long Parameter List,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The method has 5 parameters.
Long Parameter List,GitSharp.Core.Transport,RemoteRefUpdate,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The method has 6 parameters.
Long Parameter List,GitSharp.Core.Transport,TrackingRefUpdate,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TrackingRefUpdate.cs,TrackingRefUpdate,The method has 6 parameters.
Long Parameter List,GitSharp.Core.Util,IO,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\IO.cs,ReadFully,The method has 5 parameters.
Long Parameter List,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,drawLine,The method has 6 parameters.
Long Statement,GitSharp.Core,DeltaPackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DeltaPackedObjectLoader.cs,Materialize,The length of the statement  "		throw new CorruptObjectException ("object at " + DataOffset + " in " + PackFile.File.FullName + " has bad zlib stream"' dfe); " is 125.
Long Statement,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,equals,The length of the statement  "	return firstObjectId.W2 == secondObjectId.W2 && firstObjectId.W3 == secondObjectId.W3 && firstObjectId.W4 == secondObjectId.W4 && firstObjectId.W5 == secondObjectId.W5 && firstObjectId.W1 == secondObjectId.W1; " is 209.
Long Statement,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The length of the statement  "			if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark) " is 159.
Long Statement,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The length of the statement  "			if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark) " is 239.
Long Statement,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The length of the statement  "				if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) { " is 121.
Long Statement,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Decode,The length of the statement  "		throw new CorruptObjectException (CommitId' "malformed header:" + new ASCIIEncoding ().GetString (res.Buffer ?? new byte[0])); " is 126.
Long Statement,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The length of the statement  "			if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) { " is 169.
Long Statement,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The length of the statement  "			if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) { " is 253.
Long Statement,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The length of the statement  "				if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark) " is 125.
Long Statement,GitSharp.Core,GitIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\GitIndex.cs,MakeKey,The length of the statement  "	if (!string.IsNullOrEmpty (f.DirectoryName ()) && wd.IsDirectory () && wd.Exists && !f.DirectoryName ().StartsWith (wd.DirectoryName ())) { " is 139.
Long Statement,GitSharp.Core,GitIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\GitIndex.cs,writeTree,The length of the statement  "		var ne = new FileTreeEntry (current' e.ObjectId' Constants.encode (newName [newName.Length - 1])' (e.Mode & FileMode.ExecutableFile.Bits) == FileMode.ExecutableFile.Bits); " is 171.
Long Statement,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The length of the statement  "	return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19]; " is 996.
Long Statement,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The length of the statement  "	return new ObjectId (intbuffer [offset]' intbuffer [offset + 1]' intbuffer [offset + 2]' intbuffer [offset + 3]' intbuffer [offset + 4]); " is 137.
Long Statement,GitSharp.Core,ObjectWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectWriter.cs,WriteTree,The length of the statement  "			throw new ObjectWritingException ("object at path \"" + entry.FullName + "\" does not have an id assigned.  All object ids must be assigned prior to writing a tree."); " is 167.
Long Statement,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The length of the statement  "		throw new PackMismatchException ("Pack object count mismatch:" + " pack " + packCnt + " index " + idx.ObjectCount + ": " + File.FullName); " is 138.
Long Statement,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The length of the statement  "		throw new PackMismatchException ("Pack checksum mismatch:" + " pack " + ObjectId.FromRaw (buf) + " index " + ObjectId.FromRaw (idx.PackChecksum) + ": " + File.FullName); " is 169.
Long Statement,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,StripWorkDir,The length of the statement  "	if (filePath.Length <= workDirPath.Length || filePath [workDirPath.Length] != Path.DirectorySeparatorChar || !filePath.StartsWith (workDirPath)) { " is 146.
Long Statement,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,BinarySearch,The length of the statement  "		int cmp = CompareNames (entries [mid].NameUTF8' nameUTF8' nameStart' nameEnd' GitSharp.Core.TreeEntry.LastChar (entries [mid])' nameUTF8Last); " is 142.
Long Statement,GitSharp.Core,WholePackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WholePackedObjectLoader.cs,Materialize,The length of the statement  "		throw new CorruptObjectException ("object at " + DataOffset + " in " + PackFile.File.FullName + " has bad zlib stream"' dfe); " is 125.
Long Statement,GitSharp.Core,WriteTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WriteTree.cs,VisitSymlink,The length of the statement  "		throw new SymlinksNotSupportedException ("Symlink \"" + s.FullName + "\" cannot be written as the link target" + " cannot be read from within Java."); " is 150.
Long Statement,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,writeIndex,The length of the statement  "	PackIndexWriter iw = _outputVersion <= 0 ? PackIndexWriter.CreateOldestPossible (indexStream' list) : PackIndexWriter.CreateVersion (indexStream' _outputVersion); " is 162.
Long Statement,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,SelectDeltaReuseForObject,The length of the statement  "		if ((otpBase != null || (Thin && _edgeObjects.Get (idBase) != null)) && IsBetterDeltaReuseLoader (bestLoader' loader)) { " is 120.
Long Statement,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,IsBetterDeltaReuseLoader,The length of the statement  "	return loader.RawSize == currentLoader.RawSize && loader.SupportsFastCopyRawData && !currentLoader.SupportsFastCopyRawData; " is 123.
Long Statement,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The length of the statement  "	_buf [size++] = (byte)((nextLength > 0 ? (byte)0x80 : (byte)0x00) | (byte)(objectType << 4) | (byte)(dataLength & 0x0F)); " is 121.
Long Statement,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,GetProductInfo,The length of the statement  "	GetProductInfo (info.dwOSMajorVersion' info.dwOSMinorVersion' info.dwSpMajorVersion' info.dwSpMinorVersion' out info.dwOSEdition); " is 130.
Long Statement,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The length of the statement  "				throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " is too large at " + sz + " bytes."); " is 120.
Long Statement,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,skipOptionalExtension,The length of the statement  "			throw new EndOfStreamException ("Short read of optional DIRC extension " + formatExtensionName (hdr) + "; expected another " + sz + " bytes within the section."); " is 162.
Long Statement,GitSharp.Core.Exceptions,NoClosingBracketException,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\NoClosingBracketException.cs,CreateMessage,The length of the statement  "	return string.Format ("No closing {0} found for {1} at index {2}."' closingBracket' openingBracket' Convert.ToInt32 (indexOfOpeningBracket)); " is 141.
Long Statement,GitSharp.Core.Merge,Merger,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\Merger.cs,MergeBase,The length of the statement  "		throw new IOException ("Multiple merge bases for:" + "\n  " + _sourceCommits [aIdx].Name + "\n  " + _sourceCommits [bIdx].Name + "found:" + "\n  " + base1.Name + "\n  " + base2.Name); " is 183.
Long Statement,GitSharp.Core.RevWalk,ObjectWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\ObjectWalk.cs,nextObject,The length of the statement  "			throw new CorruptObjectException ("Invalid mode " + mode + " for " + IdBuffer.Name + " '" + _treeWalk.EntryPathString + "' in " + _currentTree.Name + "."); " is 155.
Long Statement,GitSharp.Core.RevWalk,ObjectWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\ObjectWalk.cs,MarkTreeUninteresting,The length of the statement  "			throw new CorruptObjectException ("Invalid mode " + mode + " for " + IdBuffer + " " + _treeWalk.EntryPathString + " in " + tree + "."); " is 135.
Long Statement,GitSharp.Core.Transport,FetchProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,deleteTrackingRef,The length of the statement  "			throw new TransportException (_transport.Uri' "Cannot delete stale tracking ref " + name + ": " + Enum.GetName (typeof(RefUpdate.RefUpdateResult)' u.Result)); " is 158.
Long Statement,GitSharp.Core.Transport,PushProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PushProcess.cs,UpdateTrackingRefs,The length of the statement  "		if (rru.HasTrackingRefUpdate && (status == RemoteRefUpdate.UpdateStatus.UP_TO_DATE || status == RemoteRefUpdate.UpdateStatus.OK)) { " is 131.
Long Statement,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,ProcessTree,The length of the statement  "				throw new CorruptObjectException ("Invalid mode " + mode.ObjectType + " for " + _idBuffer.Name + " " + _treeWalk.getPathString () + " in " + obj.getId ().Name + "."); " is 166.
Long Statement,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,The length of the statement  "			te = failures.Count == 1 ? new TransportException ("Cannot get " + id.Name + "."' failures [0]) : new TransportException ("Cannot get " + id.Name + "."' new CompoundException (failures)); " is 187.
Long Statement,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,VerifyLooseObject,The length of the statement  "		throw new TransportException ("Incorrect hash for " + id.Name + "; computed " + _idBuffer.Name + " as a " + Constants.typeString (uol.Type) + " from " + compressed.Length + " bytes."); " is 184.
Long Statement,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,MarkTreeComplete,The length of the statement  "			throw new CorruptObjectException ("Invalid mode " + mode.ObjectType + " for " + _idBuffer.Name + " " + _treeWalk.getPathString () + " in " + tree.Name); " is 152.
Long Statement,GitSharp.Core.Transport,DaemonService,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\DaemonService.cs,Handles,The length of the statement  "	return Command.Length + 1 < commandLine.Length && commandLine [Command.Length] == ' ' && commandLine.StartsWith (Command); " is 122.
Long Statement,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteIdx,The length of the statement  "		PackIndexWriter iw = _outputVersion <= 0 ? PackIndexWriter.CreateOldestPossible (os' list) : PackIndexWriter.CreateVersion (os' _outputVersion); " is 144.
Long Statement,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The length of the statement  "		throw new IOException ("Invalid packet line header: " + (char)lenbuffer [0] + (char)lenbuffer [1] + (char)lenbuffer [2] + (char)lenbuffer [3]' e); " is 146.
Long Statement,GitSharp.Core.Transport,ReceiveCommand,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceiveCommand.cs,ToString,The length of the statement  "	return Enum.GetName (typeof(Type)' getType ()) + ": " + getOldId ().Name + " " + getNewId ().Name + " " + getRefName (); " is 120.
Long Statement,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,EnableCapabilities,The length of the statement  "		msgs = new StreamWriter (new SideBandOutputStream (SideBandOutputStream.CH_PROGRESS' SideBandOutputStream.MAX_BUF' @out)' Constants.CHARSET); " is 141.
Long Statement,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,The length of the statement  "		if (cmd.getType () == ReceiveCommand.Type.DELETE && @ref != null && !ObjectId.ZeroId.Equals (cmd.getOldId ()) && !@ref.ObjectId.Equals (cmd.getOldId ())) { " is 155.
Long Statement,GitSharp.Core.Transport,RemoteRefUpdate,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RemoteRefUpdate.cs,ToString,The length of the statement  "	return "RemoteRefUpdate[remoteName=" + RemoteName + "' " + Status + "' " + (ExpectedOldObjectId != null ? ExpectedOldObjectId.Abbreviate (_localDb).name () : "(null)") + "..." + (NewObjectId != null ? NewObjectId.Abbreviate (_localDb).name () : "(null)") + (FastForward ? "' fastForward" : string.Empty) + "' srcRef=" + SourceRef + (ForceUpdate ? "' forceUpdate" : string.Empty) + "' message=" + (Message != null ? "\"" + Message + "\"" : "null") + "' " + _localDb.Directory + "]"; " is 481.
Long Statement,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,getHumanishName,The length of the statement  "	// In order to match Java Split behavior (http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#split(java.lang.String) " is 127.
Long Statement,GitSharp.Core.Util,DateTimeExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\DateTimeExtensions.cs,ToMillisecondsSinceEpoch,The length of the statement  "	return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch (); " is 121.
Long Statement,GitSharp.Core.Util,FS,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\FS.cs,userHomeImpl,The length of the statement  "	if (platform == (int)PlatformID.Unix || platform == 6 /* (int)PlatformID.MacOSX */|| platform == (int)PlatformType.UnixMono) { " is 126.
Long Statement,GitSharp.Core.Util,FS,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\FS.cs,globalHomeImpl,The length of the statement  "		throw new ArgumentException ("GlobalHomeImpl support for '" + Environment.OSVersion.VersionString + " ' is not implemented."); " is 126.
Long Statement,GitSharp.Core.Util,FS,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\FS.cs,systemHomeImpl,The length of the statement  "		throw new ArgumentException ("SystemHomeImpl support for '" + Environment.OSVersion.VersionString + " ' is not implemented."); " is 126.
Long Statement,GitSharp.Core.Util,StringExtension,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\StringExtension.cs,Slice,The length of the statement  "		throw new ArgumentOutOfRangeException ("beginIndex"' string.Format ("beginIndex has to be less or equal than endIndex. Actual values were beginIndex={0} and endIndex={1}"' beginIndex' endIndex)); " is 195.
Long Statement,GitSharp.Core.Util,StringExtension,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\StringExtension.cs,getBytes,The length of the statement  "		throw new EncoderFallbackException (string.Format ("A problem occured while encoding '{0}' using encoder '{1}'."' plainString' encoder.WebName)' e); " is 148.
Long Statement,GitSharp.Core.Util,StringUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\StringUtils.cs,toBoolean,The length of the statement  "	if (equalsIgnoreCase ("yes"' stringValue) || equalsIgnoreCase ("true"' stringValue) || equalsIgnoreCase ("1"' stringValue) || equalsIgnoreCase ("on"' stringValue)) { " is 165.
Long Statement,GitSharp.Core.Util,StringUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\StringUtils.cs,toBoolean,The length of the statement  "	} else if (equalsIgnoreCase ("no"' stringValue) || equalsIgnoreCase ("false"' stringValue) || equalsIgnoreCase ("0"' stringValue) || equalsIgnoreCase ("off"' stringValue)) { " is 173.
Long Statement,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The length of the statement  "	throw new DecoderFallbackException (string.Format ("Unable to decode provided buffer using encoder '{0}'."' cs.WebName)); " is 121.
Long Statement,GitSharp.Core.Util,AlarmState,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,end,The length of the statement  "		//   Thread.interrupted(); // <-- Note: [henon] this code does nothing but reset an irrelevant java thread internal flag AFAIK (which is not supported by our thread implementation) " is 180.
Long Statement,GitSharp.Core.Util,RefMap,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RefMap.cs,GetEnumerator,The length of the statement  "	return new LambdaConverterIterator<Ent' KeyValuePair<string' Ref>> (entrySet ().iterator ()' ent => new KeyValuePair<string' Ref> (ent.getKey ()' ent.getValue ())); " is 164.
Long Statement,GitSharp.Core.Util.JavaHelper,AtomicReference,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\JavaHelper\AtomicReference.cs,compareAndSet,The length of the statement  "		if ((Equals (_reference' default(T)) && Equals (expected' default(T))) || (!Equals (_reference' default(T)) && _reference.Equals (expected))) { " is 143.
Long Statement,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read,The length of the statement  "		throw new ArgumentException ("Not enough space in buffer for specified number of characters starting at specified index"); " is 122.
Long Statement,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInternal,The length of the statement  "			throw new EndOfStreamException (String.Format ("End of stream reached with {0} byte{1} left to read."' size - index' size - index == 1 ? "s" : string.Empty)); " is 158.
Long Statement,GitSharp.Core.Patch,CombinedHunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,parseBody,The length of the statement  "			script.error (buf' StartOffset' "Truncated hunk' at least " + missingCnt + " lines is missing for ancestor " + (ancestor + 1)); " is 127.
Long Statement,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,parseBody,The length of the statement  "	if (last < end && LinesContext + _oldImage.LinesDeleted - 1 == _oldImage.LineCount && LinesContext + _oldImage.LinesAdded == NewLineCount && RawParseUtils.match (buf' last' Patch.SigFooter) >= 0) { " is 197.
Long Statement,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,parseBody,The length of the statement  "	} else if (LinesContext + _oldImage.LinesDeleted > _oldImage.LineCount || LinesContext + _oldImage.LinesAdded > NewLineCount) { " is 127.
Long Statement,GitSharp.Core.Patch,Patch,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseHunks,The length of the statement  "		if (fh.Hunks.isEmpty () && BinTrailer.Length < eol - c && RawParseUtils.match (buf' eol - BinTrailer.Length' BinTrailer) >= 0 && MatchAny (buf' c' BinHeaders)) { " is 161.
Complex Conditional,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The conditional expression  "typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark"  is complex.
Complex Conditional,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The conditional expression  "typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark"  is complex.
Complex Conditional,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The conditional expression  "typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark"  is complex.
Complex Conditional,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The conditional expression  "typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark"  is complex.
Complex Conditional,GitSharp.Core,GitIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\GitIndex.cs,MakeKey,The conditional expression  "!string.IsNullOrEmpty (f.DirectoryName ()) && wd.IsDirectory () && wd.Exists && !f.DirectoryName ().StartsWith (wd.DirectoryName ())"  is complex.
Complex Conditional,GitSharp.Core,IndexTreeWalker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\IndexTreeWalker.cs,Compare,The conditional expression  "(((t1 != null) && (t1.Parent == null)) && (t2 != null)) && (t2.Parent == null)"  is complex.
Complex Conditional,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,SelectDeltaReuseForObject,The conditional expression  "(otpBase != null || (Thin && _edgeObjects.Get (idBase) != null)) && IsBetterDeltaReuseLoader (bestLoader' loader)"  is complex.
Complex Conditional,GitSharp.Core.Transport,TransportLocal,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportLocal.cs,canHandle,The conditional expression  "uri.Host != null || uri.Port > 0 || uri.User != null || uri.Pass != null || uri.Path == null"  is complex.
Complex Conditional,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,The conditional expression  "cmd.getType () == ReceiveCommand.Type.DELETE && @ref != null && !ObjectId.ZeroId.Equals (cmd.getOldId ()) && !@ref.ObjectId.Equals (cmd.getOldId ())"  is complex.
Complex Conditional,GitSharp.Core.Transport,TransportBundleFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportBundleFile.cs,canHandle,The conditional expression  "uri.Host != null || uri.Port > 0 || uri.User != null || uri.Pass != null || uri.Path == null"  is complex.
Complex Conditional,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The conditional expression  "Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')"  is complex.
Complex Conditional,GitSharp.Core.Util,AtomicReferenceArray,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\AtomicReferenceArray.cs,compareAndSet,The conditional expression  "(array [slot] == null && expect == null) || (array [slot] != null && array [slot].Equals (expect))"  is complex.
Complex Conditional,GitSharp.Core.Util,StringUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\StringUtils.cs,toBoolean,The conditional expression  "equalsIgnoreCase ("yes"' stringValue) || equalsIgnoreCase ("true"' stringValue) || equalsIgnoreCase ("1"' stringValue) || equalsIgnoreCase ("on"' stringValue)"  is complex.
Complex Conditional,GitSharp.Core.Util,StringUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\StringUtils.cs,toBoolean,The conditional expression  "equalsIgnoreCase ("no"' stringValue) || equalsIgnoreCase ("false"' stringValue) || equalsIgnoreCase ("0"' stringValue) || equalsIgnoreCase ("off"' stringValue)"  is complex.
Complex Conditional,GitSharp.Core.Util.JavaHelper,AtomicReference,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\JavaHelper\AtomicReference.cs,compareAndSet,The conditional expression  "(Equals (_reference' default(T)) && Equals (expected' default(T))) || (!Equals (_reference' default(T)) && _reference.Equals (expected))"  is complex.
Complex Conditional,GitSharp.Core.Patch,HunkHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,parseBody,The conditional expression  "last < end && LinesContext + _oldImage.LinesDeleted - 1 == _oldImage.LineCount && LinesContext + _oldImage.LinesAdded == NewLineCount && RawParseUtils.match (buf' last' Patch.SigFooter) >= 0"  is complex.
Complex Conditional,GitSharp.Core.Patch,Patch,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseHunks,The conditional expression  "fh.Hunks.isEmpty () && BinTrailer.Length < eol - c && RawParseUtils.match (buf' eol - BinTrailer.Length' BinTrailer) >= 0 && MatchAny (buf' c' BinHeaders)"  is complex.
Complex Conditional,GitSharp.Core.TreeWalk,NameConflictTreeWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,FastMin,The conditional expression  "_fastMinHasMatch && IsTree (minRef) && !IsTree (t) && NameEqual (minRef' t)"  is complex.
Complex Conditional,GitSharp.Core.TreeWalk,NameConflictTreeWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,FastMin,The conditional expression  "_fastMinHasMatch && IsTree (t) && !IsTree (minRef) && NameEqual (t' minRef)"  is complex.
Virtual Method Call from Constructor,GitSharp.Core,RefRename,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "getRepository".
Virtual Method Call from Constructor,GitSharp.Core,RepositoryConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RepositoryConfig.cs,RepositoryConfig,The constructor "RepositoryConfig" calls a virtual method "openUserConfig".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getCurrentTime".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getTimezone".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getCurrentTime".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getTimezone".
Virtual Method Call from Constructor,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The constructor "Repository" calls a virtual method "openUserConfig".
Virtual Method Call from Constructor,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The constructor "Repository" calls a virtual method "load".
Virtual Method Call from Constructor,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,BlockRevQueue,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "shareFreeList".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,BlockRevQueue,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,DateRevQueue,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\DateRevQueue.cs,DateRevQueue,The constructor "DateRevQueue" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,RewriteTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RewriteTreeFilter.cs,RewriteTreeFilter,The constructor "RewriteTreeFilter" calls a virtual method "shouldBeRecursive".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,TopoSortGenerator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "shareFreeList".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,TopoSortGenerator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The constructor "URIish" calls a virtual method "getOperatingSystem".
Virtual Method Call from Constructor,GitSharp.Core.Patch,OldImage,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,OldImage,The constructor "OldImage" calls a virtual method "getOldId".
Empty Catch Block,GitSharp.Core,IgnoreHandler,F:\newReposMay17\henon_GitSharp\GitSharp.Core\IgnoreHandler.cs,IgnoreHandler,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,IgnoreHandler,F:\newReposMay17\henon_GitSharp\GitSharp.Core\IgnoreHandler.cs,IgnoreHandler,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,Lock,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,CopyCurrentContent,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,DoClose,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,read,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.RevWalk,RevCommitList,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommitList.cs,clearFlag,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,OpenSshConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,PushProcess,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PushProcess.cs,UpdateTrackingRefs,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SshConfigSessionFactory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SshConfigSessionFactory.cs,knownHosts,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SshConfigSessionFactory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SshConfigSessionFactory.cs,knownHosts,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SshConfigSessionFactory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SshConfigSessionFactory.cs,loadIdentity,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,TransportBundleStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportBundleStream.cs,close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,TransportGitAnon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportGitAnon.cs,OpenConnection,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,WalkPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,SafeDelete,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,WalkRemoteObjectDatabase,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkRemoteObjectDatabase.cs,readPackedRefs,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MaxTimeWanted,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkReachable,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkReachable,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,SendWants,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkAdvertised,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,noRepository,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,noRepository,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,verifyPrerequisites,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,Start,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,Start,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,OpenRepository,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,sendError,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,sendMessage,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Service,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,TemporaryBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,destroy,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,getScriptText,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The method has an empty catch block.
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: if (b + 8 <= nibbles) {  	// We have all of the bits required for this word.  	//  	return v;  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32 (_w2' mask (2' other.W2));  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32 (_w3' mask (3' other.W3));  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32 (_w4' mask (4' other.W4));  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: return NB.CompareUInt32 (_w5' mask (5' other.W5));  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 8) {  	return new string (b' 0' _nibbles);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray (b' 8' _w2);  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 16) {  	return new string (b' 0' _nibbles);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray (b' 16' _w3);  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 24) {  	return new string (b' 0' _nibbles);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray (b' 24' _w4);  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 32) {  	return new string (b' 0' _nibbles);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray (b' 32' _w5);  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = Hex.HexUInt32 (bs' ptr' end);  	int b = Hex.HexUInt32 (bs' ptr + 8' end);  	int c = Hex.HexUInt32 (bs' ptr + 16' end);  	int d = Hex.HexUInt32 (bs' ptr + 24' end);  	int e = Hex.HexUInt32 (bs' ptr + 32' end);  	return new AbbreviatedObjectId (end - ptr' a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' ptr' end - ptr' e);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = Hex.HexUInt32 (bs' ptr' end);  	int b = Hex.HexUInt32 (bs' ptr + 8' end);  	int c = Hex.HexUInt32 (bs' ptr + 16' end);  	int d = Hex.HexUInt32 (bs' ptr + 24' end);  	int e = Hex.HexUInt32 (bs' ptr + 32' end);  	return new AbbreviatedObjectId (end - ptr' a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' ptr' end - ptr' e);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = Hex.HexUInt32 (bs' ptr' end);  	int b = Hex.HexUInt32 (bs' ptr + 8' end);  	int c = Hex.HexUInt32 (bs' ptr + 16' end);  	int d = Hex.HexUInt32 (bs' ptr + 24' end);  	int e = Hex.HexUInt32 (bs' ptr + 32' end);  	return new AbbreviatedObjectId (end - ptr' a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' ptr' end - ptr' e);  }  
Magic Number,GitSharp.Core,AbbreviatedObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = Hex.HexUInt32 (bs' ptr' end);  	int b = Hex.HexUInt32 (bs' ptr + 8' end);  	int c = Hex.HexUInt32 (bs' ptr + 16' end);  	int d = Hex.HexUInt32 (bs' ptr + 24' end);  	int e = Hex.HexUInt32 (bs' ptr + 32' end);  	return new AbbreviatedObjectId (end - ptr' a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' ptr' end - ptr' e);  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length) {  	int num = source [currentIndex];  	switch (num) {  	case 13:  		if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  			indexModifier = 2;  		}  		break;  	case 10:  		indexModifier = 1;  		break;  	}  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length) {  	int num = source [currentIndex];  	switch (num) {  	case 13:  		if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  			indexModifier = 2;  		}  		break;  	case 10:  		indexModifier = 1;  		break;  	}  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length) {  	int num = source [currentIndex];  	switch (num) {  	case 13:  		if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  			indexModifier = 2;  		}  		break;  	case 10:  		indexModifier = 1;  		break;  	}  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length) {  	int num = source [currentIndex];  	switch (num) {  	case 13:  		if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  			indexModifier = 2;  		}  		break;  	case 10:  		indexModifier = 1;  		break;  	}  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: switch (num) {  case 13:  	if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  		indexModifier = 2;  	}  	break;  case 10:  	indexModifier = 1;  	break;  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: switch (num) {  case 13:  	if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  		indexModifier = 2;  	}  	break;  case 10:  	indexModifier = 1;  	break;  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: switch (num) {  case 13:  	if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  		indexModifier = 2;  	}  	break;  case 10:  	indexModifier = 1;  	break;  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: switch (num) {  case 13:  	if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  		indexModifier = 2;  	}  	break;  case 10:  	indexModifier = 1;  	break;  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  	indexModifier = 2;  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  	indexModifier = 2;  }  
Magic Number,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: indexModifier = 2;  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (p.Length != 50 || !p.StartsWith ("pack-") || !p.EndsWith (IndexPack.PackSuffix)) {  	throw new IOException ("Not a valid pack " + pack);  }  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (i.Length != 49 || !i.StartsWith ("pack-") || !i.EndsWith (IndexPack.IndexSuffix)) {  	throw new IOException ("Not a valid pack " + idx);  }  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (!p.Slice (0' 45).Equals (i.Slice (0' 45))) {  	throw new IOException ("Pack " + pack + "does not match index");  }  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (!p.Slice (0' 45).Equals (i.Slice (0' 45))) {  	throw new IOException ("Pack " + pack + "does not match index");  }  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: foreach (string indexName in names) {  	// Must match "pack-[0-9a-f]{40}.idx" to be an index.  	//  	if (indexName.Length != 49 || !indexName.EndsWith (".idx"))  		continue;  	string @base = indexName.Slice (0' indexName.Length - 4);  	string packName = IndexPack.GetPackFileName (@base);  	if (!names.Contains (packName)) {  		// Sometimes C Git's HTTP fetch transport leaves a  		// .idx file behind and does not download the .pack.  		// We have to skip over such useless indexes.  		//  		continue;  	}  	PackFile oldPack;  	forReuse.TryGetValue (packName' out oldPack);  	forReuse.Remove (packName);  	if (oldPack != null) {  		list.Add (oldPack);  		continue;  	}  	var packFile = new FileInfo (_packDirectory.FullName + "/" + packName);  	var idxFile = new FileInfo (_packDirectory + "/" + indexName);  	list.Add (new PackFile (idxFile' packFile));  	foundNew = true;  }  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: foreach (string indexName in names) {  	// Must match "pack-[0-9a-f]{40}.idx" to be an index.  	//  	if (indexName.Length != 49 || !indexName.EndsWith (".idx"))  		continue;  	string @base = indexName.Slice (0' indexName.Length - 4);  	string packName = IndexPack.GetPackFileName (@base);  	if (!names.Contains (packName)) {  		// Sometimes C Git's HTTP fetch transport leaves a  		// .idx file behind and does not download the .pack.  		// We have to skip over such useless indexes.  		//  		continue;  	}  	PackFile oldPack;  	forReuse.TryGetValue (packName' out oldPack);  	forReuse.Remove (packName);  	if (oldPack != null) {  		list.Add (oldPack);  		continue;  	}  	var packFile = new FileInfo (_packDirectory.FullName + "/" + packName);  	var idxFile = new FileInfo (_packDirectory + "/" + indexName);  	list.Add (new PackFile (idxFile' packFile));  	foundNew = true;  }  
Magic Number,GitSharp.Core,ObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: if (indexName.Length != 49 || !indexName.EndsWith (".idx"))  	continue;  
Magic Number,GitSharp.Core,ReflogReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ReflogReader.cs,getReverseEntries,The following statement contains a magic number: while (rs >= 0 && max-- > 0) {  	rs = RawParseUtils.prevLF (log' rs);  	Entry entry = new Entry (log' rs < 0 ? 0 : rs + 2);  	ret.Add (entry);  }  
Magic Number,GitSharp.Core,RepositoryCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RepositoryCache.cs,RepositoryCache,The following statement contains a magic number: openLocks = new Lock[4];  
Magic Number,GitSharp.Core,RepositoryCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RepositoryCache.cs,clearAll,The following statement contains a magic number: for (int stage = 0; stage < 2; stage++) {  	var keysToRemove = new List<Key> ();  	foreach (KeyValuePair<Key' WeakReference<Repository>> e in cacheMap) {  		Repository db = e.Value.get ();  		if (db != null)  			db.Dispose ();  		keysToRemove.Add (e.Key);  	}  	foreach (Key key in keysToRemove) {  		cacheMap.Remove (key);  	}  }  
Magic Number,GitSharp.Core,UnpackedObjectCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectCache.cs,Hash,The following statement contains a magic number: return (int)((uint)(((int)position) << 22) >> 22);  
Magic Number,GitSharp.Core,UnpackedObjectCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectCache.cs,Hash,The following statement contains a magic number: return (int)((uint)(((int)position) << 22) >> 22);  
Magic Number,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,UnsignedRightShift,The following statement contains a magic number: return (n >> s) + (((long)2) << ~s);  
Magic Number,GitSharp.Core,Extensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,UnsignedRightShift,The following statement contains a magic number: return (n >> s) + (2 << ~s);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 4' W2);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 8' W3);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 12' W4);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 16' W5);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: s.Write (buf' 0' 20);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 4 + off' W2);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 8 + off' W3);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 12 + off' W4);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32 (buf' 16 + off' W5);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: b [offset + 2] = W3;  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: b [offset + 3] = W4;  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: b [offset + 4] = W5;  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray (dst' 8' W2);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray (dst' 16' W3);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray (dst' 24' W4);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray (dst' 32' W5);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: return Abbreviate (repo' 8);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,GetFirstByte,The following statement contains a magic number: return (byte)(((uint)W1) >> 24);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32 (W2' NB.DecodeInt32 (bs' p + 4));  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32 (W3' NB.DecodeInt32 (bs' p + 8));  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32 (W4' NB.DecodeInt32 (bs' p + 12));  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: return NB.CompareUInt32 (W5' NB.DecodeInt32 (bs' p + 16));  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32 (W3' bs [p + 2]);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32 (W4' bs [p + 3]);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: return NB.CompareUInt32 (W5' bs [p + 4]);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray (dest' 8' W2);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray (dest' 16' W3);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray (dest' 24' W4);  
Magic Number,GitSharp.Core,AnyObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray (dest' 32' W5);  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: do {  	c = delta [deltaPtr++] & 0xff;  	baseLen |= (c & 0x7f) << shift;  	shift += 7;  } while ((c & 0x80) != 0);  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: shift += 7;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: do {  	c = delta [deltaPtr++] & 0xff;  	resLen |= (c & 0x7f) << shift;  	shift += 7;  } while ((c & 0x80) != 0);  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: shift += 7;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length) {  	int cmd = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x80) != 0) {  		// Determine the segment of the base which should  		// be copied into the output. The segment is given  		// as an offset and a Length.  		//  		int copyOffset = 0;  		if ((cmd & 0x01) != 0)  			copyOffset = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x02) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x04) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  		if ((cmd & 0x08) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  		int copySize = 0;  		if ((cmd & 0x10) != 0)  			copySize = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x20) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x40) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 16;  		if (copySize == 0)  			copySize = 0x10000;  		Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  		resultPtr += copySize;  	} else if (cmd != 0) {  		// Anything else the data is literal within the delta  		// itself.  		//  		Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  		deltaPtr += cmd;  		resultPtr += cmd;  	} else {  		// cmd == 0 has been reserved for future encoding but  		// for now its not acceptable.  		//  		throw new ArgumentException ("unsupported command 0");  	}  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length) {  	int cmd = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x80) != 0) {  		// Determine the segment of the base which should  		// be copied into the output. The segment is given  		// as an offset and a Length.  		//  		int copyOffset = 0;  		if ((cmd & 0x01) != 0)  			copyOffset = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x02) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x04) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  		if ((cmd & 0x08) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  		int copySize = 0;  		if ((cmd & 0x10) != 0)  			copySize = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x20) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x40) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 16;  		if (copySize == 0)  			copySize = 0x10000;  		Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  		resultPtr += copySize;  	} else if (cmd != 0) {  		// Anything else the data is literal within the delta  		// itself.  		//  		Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  		deltaPtr += cmd;  		resultPtr += cmd;  	} else {  		// cmd == 0 has been reserved for future encoding but  		// for now its not acceptable.  		//  		throw new ArgumentException ("unsupported command 0");  	}  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length) {  	int cmd = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x80) != 0) {  		// Determine the segment of the base which should  		// be copied into the output. The segment is given  		// as an offset and a Length.  		//  		int copyOffset = 0;  		if ((cmd & 0x01) != 0)  			copyOffset = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x02) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x04) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  		if ((cmd & 0x08) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  		int copySize = 0;  		if ((cmd & 0x10) != 0)  			copySize = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x20) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x40) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 16;  		if (copySize == 0)  			copySize = 0x10000;  		Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  		resultPtr += copySize;  	} else if (cmd != 0) {  		// Anything else the data is literal within the delta  		// itself.  		//  		Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  		deltaPtr += cmd;  		resultPtr += cmd;  	} else {  		// cmd == 0 has been reserved for future encoding but  		// for now its not acceptable.  		//  		throw new ArgumentException ("unsupported command 0");  	}  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length) {  	int cmd = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x80) != 0) {  		// Determine the segment of the base which should  		// be copied into the output. The segment is given  		// as an offset and a Length.  		//  		int copyOffset = 0;  		if ((cmd & 0x01) != 0)  			copyOffset = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x02) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x04) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  		if ((cmd & 0x08) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  		int copySize = 0;  		if ((cmd & 0x10) != 0)  			copySize = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x20) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x40) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 16;  		if (copySize == 0)  			copySize = 0x10000;  		Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  		resultPtr += copySize;  	} else if (cmd != 0) {  		// Anything else the data is literal within the delta  		// itself.  		//  		Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  		deltaPtr += cmd;  		resultPtr += cmd;  	} else {  		// cmd == 0 has been reserved for future encoding but  		// for now its not acceptable.  		//  		throw new ArgumentException ("unsupported command 0");  	}  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length) {  	int cmd = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x80) != 0) {  		// Determine the segment of the base which should  		// be copied into the output. The segment is given  		// as an offset and a Length.  		//  		int copyOffset = 0;  		if ((cmd & 0x01) != 0)  			copyOffset = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x02) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x04) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  		if ((cmd & 0x08) != 0)  			copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  		int copySize = 0;  		if ((cmd & 0x10) != 0)  			copySize = delta [deltaPtr++] & 0xff;  		if ((cmd & 0x20) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 8;  		if ((cmd & 0x40) != 0)  			copySize |= (delta [deltaPtr++] & 0xff) << 16;  		if (copySize == 0)  			copySize = 0x10000;  		Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  		resultPtr += copySize;  	} else if (cmd != 0) {  		// Anything else the data is literal within the delta  		// itself.  		//  		Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  		deltaPtr += cmd;  		resultPtr += cmd;  	} else {  		// cmd == 0 has been reserved for future encoding but  		// for now its not acceptable.  		//  		throw new ArgumentException ("unsupported command 0");  	}  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x80) != 0) {  	// Determine the segment of the base which should  	// be copied into the output. The segment is given  	// as an offset and a Length.  	//  	int copyOffset = 0;  	if ((cmd & 0x01) != 0)  		copyOffset = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x02) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x04) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  	if ((cmd & 0x08) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  	int copySize = 0;  	if ((cmd & 0x10) != 0)  		copySize = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x20) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x40) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 16;  	if (copySize == 0)  		copySize = 0x10000;  	Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  	resultPtr += copySize;  } else if (cmd != 0) {  	// Anything else the data is literal within the delta  	// itself.  	//  	Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  	deltaPtr += cmd;  	resultPtr += cmd;  } else {  	// cmd == 0 has been reserved for future encoding but  	// for now its not acceptable.  	//  	throw new ArgumentException ("unsupported command 0");  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x80) != 0) {  	// Determine the segment of the base which should  	// be copied into the output. The segment is given  	// as an offset and a Length.  	//  	int copyOffset = 0;  	if ((cmd & 0x01) != 0)  		copyOffset = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x02) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x04) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  	if ((cmd & 0x08) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  	int copySize = 0;  	if ((cmd & 0x10) != 0)  		copySize = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x20) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x40) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 16;  	if (copySize == 0)  		copySize = 0x10000;  	Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  	resultPtr += copySize;  } else if (cmd != 0) {  	// Anything else the data is literal within the delta  	// itself.  	//  	Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  	deltaPtr += cmd;  	resultPtr += cmd;  } else {  	// cmd == 0 has been reserved for future encoding but  	// for now its not acceptable.  	//  	throw new ArgumentException ("unsupported command 0");  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x80) != 0) {  	// Determine the segment of the base which should  	// be copied into the output. The segment is given  	// as an offset and a Length.  	//  	int copyOffset = 0;  	if ((cmd & 0x01) != 0)  		copyOffset = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x02) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x04) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  	if ((cmd & 0x08) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  	int copySize = 0;  	if ((cmd & 0x10) != 0)  		copySize = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x20) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x40) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 16;  	if (copySize == 0)  		copySize = 0x10000;  	Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  	resultPtr += copySize;  } else if (cmd != 0) {  	// Anything else the data is literal within the delta  	// itself.  	//  	Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  	deltaPtr += cmd;  	resultPtr += cmd;  } else {  	// cmd == 0 has been reserved for future encoding but  	// for now its not acceptable.  	//  	throw new ArgumentException ("unsupported command 0");  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x80) != 0) {  	// Determine the segment of the base which should  	// be copied into the output. The segment is given  	// as an offset and a Length.  	//  	int copyOffset = 0;  	if ((cmd & 0x01) != 0)  		copyOffset = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x02) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x04) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  	if ((cmd & 0x08) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  	int copySize = 0;  	if ((cmd & 0x10) != 0)  		copySize = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x20) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x40) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 16;  	if (copySize == 0)  		copySize = 0x10000;  	Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  	resultPtr += copySize;  } else if (cmd != 0) {  	// Anything else the data is literal within the delta  	// itself.  	//  	Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  	deltaPtr += cmd;  	resultPtr += cmd;  } else {  	// cmd == 0 has been reserved for future encoding but  	// for now its not acceptable.  	//  	throw new ArgumentException ("unsupported command 0");  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x80) != 0) {  	// Determine the segment of the base which should  	// be copied into the output. The segment is given  	// as an offset and a Length.  	//  	int copyOffset = 0;  	if ((cmd & 0x01) != 0)  		copyOffset = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x02) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x04) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  	if ((cmd & 0x08) != 0)  		copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  	int copySize = 0;  	if ((cmd & 0x10) != 0)  		copySize = delta [deltaPtr++] & 0xff;  	if ((cmd & 0x20) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 8;  	if ((cmd & 0x40) != 0)  		copySize |= (delta [deltaPtr++] & 0xff) << 16;  	if (copySize == 0)  		copySize = 0x10000;  	Array.Copy (baseData' copyOffset' result' resultPtr' copySize);  	resultPtr += copySize;  } else if (cmd != 0) {  	// Anything else the data is literal within the delta  	// itself.  	//  	Array.Copy (delta' deltaPtr' result' resultPtr' cmd);  	deltaPtr += cmd;  	resultPtr += cmd;  } else {  	// cmd == 0 has been reserved for future encoding but  	// for now its not acceptable.  	//  	throw new ArgumentException ("unsupported command 0");  }  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x02) != 0)  	copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: copyOffset |= (delta [deltaPtr++] & 0xff) << 8;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x04) != 0)  	copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: copyOffset |= (delta [deltaPtr++] & 0xff) << 16;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x08) != 0)  	copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: copyOffset |= (delta [deltaPtr++] & 0xff) << 24;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x20) != 0)  	copySize |= (delta [deltaPtr++] & 0xff) << 8;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: copySize |= (delta [deltaPtr++] & 0xff) << 8;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: if ((cmd & 0x40) != 0)  	copySize |= (delta [deltaPtr++] & 0xff) << 16;  
Magic Number,GitSharp.Core,BinaryDelta,F:\newReposMay17\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: copySize |= (delta [deltaPtr++] & 0xff) << 16;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try {  	switch (typeString [offset]) {  	case (byte)'b':  		if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  			break;  		offset += 5;  		return ObjectType.Blob;  	case (byte)'c':  		if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  			break;  		offset += 7;  		return ObjectType.Commit;  	case (byte)'t':  		switch (typeString [offset + 1]) {  		case (byte)'a':  			if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 4;  			return ObjectType.Tag;  		case (byte)'r':  			if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  				throw new CorruptObjectException (id' "invalid type");  			}  			offset += 5;  			return ObjectType.Tree;  		}  		break;  	}  } catch (IndexOutOfRangeException) {  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: offset += 5;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  	break;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: offset += 7;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: offset += 4;  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: offset += 5;  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: _treeId = ObjectId.FromString (raw' 5);  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true) {  	if (raw [rawPtr] != 'p')  		break;  	if (np == 0) {  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	} else if (np == 1) {  		ParentIds = new[] {  			ParentIds [0]'  			ObjectId.FromString (raw' rawPtr + 7)  		};  		np++;  	} else {  		if (ParentIds.Length <= np) {  			ObjectId[] old = ParentIds;  			ParentIds = new ObjectId[ParentIds.Length + 32];  			for (int i = 0; i < np; ++i) {  				ParentIds [i] = old [i];  			}  		}  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	}  	rawPtr += 48;  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true) {  	if (raw [rawPtr] != 'p')  		break;  	if (np == 0) {  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	} else if (np == 1) {  		ParentIds = new[] {  			ParentIds [0]'  			ObjectId.FromString (raw' rawPtr + 7)  		};  		np++;  	} else {  		if (ParentIds.Length <= np) {  			ObjectId[] old = ParentIds;  			ParentIds = new ObjectId[ParentIds.Length + 32];  			for (int i = 0; i < np; ++i) {  				ParentIds [i] = old [i];  			}  		}  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	}  	rawPtr += 48;  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true) {  	if (raw [rawPtr] != 'p')  		break;  	if (np == 0) {  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	} else if (np == 1) {  		ParentIds = new[] {  			ParentIds [0]'  			ObjectId.FromString (raw' rawPtr + 7)  		};  		np++;  	} else {  		if (ParentIds.Length <= np) {  			ObjectId[] old = ParentIds;  			ParentIds = new ObjectId[ParentIds.Length + 32];  			for (int i = 0; i < np; ++i) {  				ParentIds [i] = old [i];  			}  		}  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	}  	rawPtr += 48;  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true) {  	if (raw [rawPtr] != 'p')  		break;  	if (np == 0) {  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	} else if (np == 1) {  		ParentIds = new[] {  			ParentIds [0]'  			ObjectId.FromString (raw' rawPtr + 7)  		};  		np++;  	} else {  		if (ParentIds.Length <= np) {  			ObjectId[] old = ParentIds;  			ParentIds = new ObjectId[ParentIds.Length + 32];  			for (int i = 0; i < np; ++i) {  				ParentIds [i] = old [i];  			}  		}  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	}  	rawPtr += 48;  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true) {  	if (raw [rawPtr] != 'p')  		break;  	if (np == 0) {  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	} else if (np == 1) {  		ParentIds = new[] {  			ParentIds [0]'  			ObjectId.FromString (raw' rawPtr + 7)  		};  		np++;  	} else {  		if (ParentIds.Length <= np) {  			ObjectId[] old = ParentIds;  			ParentIds = new ObjectId[ParentIds.Length + 32];  			for (int i = 0; i < np; ++i) {  				ParentIds [i] = old [i];  			}  		}  		ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  	}  	rawPtr += 48;  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 0) {  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  } else if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 0) {  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  } else if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 0) {  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  } else if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 0) {  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  } else if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (np == 1) {  	ParentIds = new[] {  		ParentIds [0]'  		ObjectId.FromString (raw' rawPtr + 7)  	};  	np++;  } else {  	if (ParentIds.Length <= np) {  		ObjectId[] old = ParentIds;  		ParentIds = new ObjectId[ParentIds.Length + 32];  		for (int i = 0; i < np; ++i) {  			ParentIds [i] = old [i];  		}  	}  	ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: ParentIds = new[] {  	ParentIds [0]'  	ObjectId.FromString (raw' rawPtr + 7)  };  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: if (ParentIds.Length <= np) {  	ObjectId[] old = ParentIds;  	ParentIds = new ObjectId[ParentIds.Length + 32];  	for (int i = 0; i < np; ++i) {  		ParentIds [i] = old [i];  	}  }  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: ParentIds = new ObjectId[ParentIds.Length + 32];  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: ParentIds [np++] = ObjectId.FromString (raw' rawPtr + 7);  
Magic Number,GitSharp.Core,Commit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: rawPtr += 48;  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try {  	int position = offset.value;  	switch (typeString [position]) {  	case (byte)'b':  		if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 5;  		return OBJ_BLOB;  	case (byte)'c':  		if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset.value = position + 7;  		return OBJ_COMMIT;  	case (byte)'t':  		switch (typeString [position + 1]) {  		case (byte)'a':  			if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 4;  			return OBJ_TAG;  		case (byte)'r':  			if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  				throw new CorruptObjectException (id' "invalid type");  			offset.value = position + 5;  			return OBJ_TREE;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  } catch (IndexOutOfRangeException) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position]) {  case (byte)'b':  	if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 5;  	return OBJ_BLOB;  case (byte)'c':  	if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset.value = position + 7;  	return OBJ_COMMIT;  case (byte)'t':  	switch (typeString [position + 1]) {  	case (byte)'a':  		if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 4;  		return OBJ_TAG;  	case (byte)'r':  		if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  			throw new CorruptObjectException (id' "invalid type");  		offset.value = position + 5;  		return OBJ_TREE;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'l' || typeString [position + 2] != (byte)'o' || typeString [position + 3] != (byte)'b' || typeString [position + 4] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: offset.value = position + 5;  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 1] != (byte)'o' || typeString [position + 2] != (byte)'m' || typeString [position + 3] != (byte)'m' || typeString [position + 4] != (byte)'i' || typeString [position + 5] != (byte)'t' || typeString [position + 6] != endMark) {  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: offset.value = position + 7;  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: switch (typeString [position + 1]) {  case (byte)'a':  	if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 4;  	return OBJ_TAG;  case (byte)'r':  	if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  		throw new CorruptObjectException (id' "invalid type");  	offset.value = position + 5;  	return OBJ_TREE;  default:  	throw new CorruptObjectException (id' "invalid type");  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  	throw new CorruptObjectException (id' "invalid type");  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 2] != (byte)'g' || typeString [position + 3] != endMark)  	throw new CorruptObjectException (id' "invalid type");  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: offset.value = position + 4;  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  	throw new CorruptObjectException (id' "invalid type");  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  	throw new CorruptObjectException (id' "invalid type");  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: if (typeString [position + 2] != (byte)'e' || typeString [position + 3] != (byte)'e' || typeString [position + 4] != endMark)  	throw new CorruptObjectException (id' "invalid type");  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: offset.value = position + 5;  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,encodeASCII,The following statement contains a magic number: for (int k = r.Length - 1; k >= 0; k--) {  	char c = s [k];  	if (c > 127) {  		throw new ArgumentException ("Not ASCII string: " + s);  	}  	r [k] = (byte)c;  }  
Magic Number,GitSharp.Core,Constants,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Constants.cs,encodeASCII,The following statement contains a magic number: if (c > 127) {  	throw new ArgumentException ("Not ASCII string: " + s);  }  
Magic Number,GitSharp.Core,CoreConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CoreConfig.cs,CoreConfig,The following statement contains a magic number: packIndexVersion = rc.getInt ("pack"' "indexversion"' 2);  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0) {  	var tmp = new byte[10];  	int p = tmp.Length;  	while (mode != 0) {  		tmp [--p] = (byte)((byte)'0' + (mode & 07));  		mode >>= 3;  	}  	_octalBytes = new byte[tmp.Length - p];  	for (int k = 0; k < _octalBytes.Length; k++) {  		_octalBytes [k] = tmp [p + k];  	}  } else {  	_octalBytes = new[] {  		(byte)'0'  	};  }  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0) {  	var tmp = new byte[10];  	int p = tmp.Length;  	while (mode != 0) {  		tmp [--p] = (byte)((byte)'0' + (mode & 07));  		mode >>= 3;  	}  	_octalBytes = new byte[tmp.Length - p];  	for (int k = 0; k < _octalBytes.Length; k++) {  		_octalBytes [k] = tmp [p + k];  	}  } else {  	_octalBytes = new[] {  		(byte)'0'  	};  }  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0) {  	var tmp = new byte[10];  	int p = tmp.Length;  	while (mode != 0) {  		tmp [--p] = (byte)((byte)'0' + (mode & 07));  		mode >>= 3;  	}  	_octalBytes = new byte[tmp.Length - p];  	for (int k = 0; k < _octalBytes.Length; k++) {  		_octalBytes [k] = tmp [p + k];  	}  } else {  	_octalBytes = new[] {  		(byte)'0'  	};  }  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: while (mode != 0) {  	tmp [--p] = (byte)((byte)'0' + (mode & 07));  	mode >>= 3;  }  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: while (mode != 0) {  	tmp [--p] = (byte)((byte)'0' + (mode & 07));  	mode >>= 3;  }  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: tmp [--p] = (byte)((byte)'0' + (mode & 07));  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: mode >>= 3;  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,GetHashCode,The following statement contains a magic number: unchecked {  	return (EqualityFunction.GetHashCode () * 397) ^ ObjectType.GetHashCode ();  }  
Magic Number,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,GetHashCode,The following statement contains a magic number: return (EqualityFunction.GetHashCode () * 397) ^ ObjectType.GetHashCode ();  
Magic Number,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,CopyCurrentContent,The following statement contains a magic number: try {  	using (FileStream fis = _refFile.OpenRead ()) {  		var buf = new byte[2048];  		int r;  		while ((r = fis.Read (buf' 0' buf.Length)) >= 0)  			_os.Write (buf' 0' r);  	}  } catch (FileNotFoundException) {  	// Don't worry about a file that doesn't exist yet' it  	// conceptually has no current content to copy.  	//  } catch (Exception) {  	Unlock ();  	throw;  }  
Magic Number,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,CopyCurrentContent,The following statement contains a magic number: using (FileStream fis = _refFile.OpenRead ()) {  	var buf = new byte[2048];  	int r;  	while ((r = fis.Read (buf' 0' buf.Length)) >= 0)  		_os.Write (buf' 0' r);  }  
Magic Number,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,waitForStatChange,The following statement contains a magic number: if (_refFile.Length == _lockFile.Length) {  	long otime = _refFile.lastModified ();  	long ntime = _lockFile.lastModified ();  	while (otime == ntime) {  		Thread.Sleep (25/* milliseconds */);  		_lockFile.LastWriteTime = DateTime.Now;  		ntime = _lockFile.lastModified ();  	}  }  
Magic Number,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,waitForStatChange,The following statement contains a magic number: while (otime == ntime) {  	Thread.Sleep (25/* milliseconds */);  	_lockFile.LastWriteTime = DateTime.Now;  	ntime = _lockFile.lastModified ();  }  
Magic Number,GitSharp.Core,LockFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\LockFile.cs,waitForStatChange,The following statement contains a magic number: Thread.Sleep (25/* milliseconds */);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W2 = NB.DecodeInt32 (bs' p + 4);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W3 = NB.DecodeInt32 (bs' p + 8);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W4 = NB.DecodeInt32 (bs' p + 12);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W5 = NB.DecodeInt32 (bs' p + 16);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W3 = ints [p + 2];  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W4 = ints [p + 3];  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W5 = ints [p + 4];  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try {  	W1 = RawParseUtils.parseHexInt32 (bs' p);  	W2 = RawParseUtils.parseHexInt32 (bs' p + 8);  	W3 = RawParseUtils.parseHexInt32 (bs' p + 16);  	W4 = RawParseUtils.parseHexInt32 (bs' p + 24);  	W5 = RawParseUtils.parseHexInt32 (bs' p + 32);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try {  	W1 = RawParseUtils.parseHexInt32 (bs' p);  	W2 = RawParseUtils.parseHexInt32 (bs' p + 8);  	W3 = RawParseUtils.parseHexInt32 (bs' p + 16);  	W4 = RawParseUtils.parseHexInt32 (bs' p + 24);  	W5 = RawParseUtils.parseHexInt32 (bs' p + 32);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try {  	W1 = RawParseUtils.parseHexInt32 (bs' p);  	W2 = RawParseUtils.parseHexInt32 (bs' p + 8);  	W3 = RawParseUtils.parseHexInt32 (bs' p + 16);  	W4 = RawParseUtils.parseHexInt32 (bs' p + 24);  	W5 = RawParseUtils.parseHexInt32 (bs' p + 32);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try {  	W1 = RawParseUtils.parseHexInt32 (bs' p);  	W2 = RawParseUtils.parseHexInt32 (bs' p + 8);  	W3 = RawParseUtils.parseHexInt32 (bs' p + 16);  	W4 = RawParseUtils.parseHexInt32 (bs' p + 24);  	W5 = RawParseUtils.parseHexInt32 (bs' p + 32);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: W2 = RawParseUtils.parseHexInt32 (bs' p + 8);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: W3 = RawParseUtils.parseHexInt32 (bs' p + 16);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: W4 = RawParseUtils.parseHexInt32 (bs' p + 24);  
Magic Number,GitSharp.Core,MutableObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: W5 = RawParseUtils.parseHexInt32 (bs' p + 32);  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,duplicateName,The following statement contains a magic number: for (; ;) {  	int nextMode = 0;  	for (; ;) {  		if (nextPtr >= sz)  			return false;  		byte c = raw [nextPtr++];  		if (' ' == c)  			break;  		nextMode <<= 3;  		nextMode += (c - (byte)'0');  	}  	int nextNamePos = nextPtr;  	for (; ;) {  		if (nextPtr == sz)  			return false;  		byte c = raw [nextPtr++];  		if (c == '\0')  			break;  	}  	if (nextNamePos + 1 == nextPtr)  		return false;  	int cmp = pathCompare (raw' thisNamePos' thisNameEnd' FileMode.Tree.Bits' nextNamePos' nextPtr - 1' nextMode);  	if (cmp < 0)  		return false;  	else if (cmp == 0)  		return true;  	nextPtr += Constants.OBJECT_ID_LENGTH;  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,duplicateName,The following statement contains a magic number: for (; ;) {  	if (nextPtr >= sz)  		return false;  	byte c = raw [nextPtr++];  	if (' ' == c)  		break;  	nextMode <<= 3;  	nextMode += (c - (byte)'0');  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,duplicateName,The following statement contains a magic number: nextMode <<= 3;  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: while (ptr < sz) {  	int thisMode = 0;  	for (; ;) {  		if (ptr == sz)  			throw new CorruptObjectException ("truncated in mode");  		byte c = raw [ptr++];  		if (' ' == c)  			break;  		if (c < '0' || c > '7')  			throw new CorruptObjectException ("invalid mode character");  		if (thisMode == 0 && c == '0')  			throw new CorruptObjectException ("mode starts with '0'");  		thisMode <<= 3;  		thisMode += (c - (byte)'0');  	}  	if (FileMode.FromBits (thisMode).ObjectType == ObjectType.Bad)  		throw new CorruptObjectException ("invalid mode " + NB.DecimalToBase (thisMode' 8));  	int thisNameB = ptr;  	for (; ;) {  		if (ptr == sz)  			throw new CorruptObjectException ("truncated in name");  		byte c = raw [ptr++];  		if (c == '\0')  			break;  		if (c == '/')  			throw new CorruptObjectException ("name contains '/'");  	}  	if (thisNameB + 1 == ptr)  		throw new CorruptObjectException ("zero length name");  	if (raw [thisNameB] == '.') {  		int nameLen = (ptr - 1) - thisNameB;  		if (nameLen == 1)  			throw new CorruptObjectException ("invalid name '.'");  		if (nameLen == 2 && raw [thisNameB + 1] == '.')  			throw new CorruptObjectException ("invalid name '..'");  	}  	if (duplicateName (raw' thisNameB' ptr - 1))  		throw new CorruptObjectException ("duplicate entry names");  	if (lastNameB != 0) {  		int cmp = pathCompare (raw' lastNameB' lastNameE' lastMode' thisNameB' ptr - 1' thisMode);  		if (cmp > 0)  			throw new CorruptObjectException ("incorrectly sorted");  	}  	lastNameB = thisNameB;  	lastNameE = ptr - 1;  	lastMode = thisMode;  	ptr += Constants.OBJECT_ID_LENGTH;  	if (ptr > sz)  		throw new CorruptObjectException ("truncated in object id");  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: while (ptr < sz) {  	int thisMode = 0;  	for (; ;) {  		if (ptr == sz)  			throw new CorruptObjectException ("truncated in mode");  		byte c = raw [ptr++];  		if (' ' == c)  			break;  		if (c < '0' || c > '7')  			throw new CorruptObjectException ("invalid mode character");  		if (thisMode == 0 && c == '0')  			throw new CorruptObjectException ("mode starts with '0'");  		thisMode <<= 3;  		thisMode += (c - (byte)'0');  	}  	if (FileMode.FromBits (thisMode).ObjectType == ObjectType.Bad)  		throw new CorruptObjectException ("invalid mode " + NB.DecimalToBase (thisMode' 8));  	int thisNameB = ptr;  	for (; ;) {  		if (ptr == sz)  			throw new CorruptObjectException ("truncated in name");  		byte c = raw [ptr++];  		if (c == '\0')  			break;  		if (c == '/')  			throw new CorruptObjectException ("name contains '/'");  	}  	if (thisNameB + 1 == ptr)  		throw new CorruptObjectException ("zero length name");  	if (raw [thisNameB] == '.') {  		int nameLen = (ptr - 1) - thisNameB;  		if (nameLen == 1)  			throw new CorruptObjectException ("invalid name '.'");  		if (nameLen == 2 && raw [thisNameB + 1] == '.')  			throw new CorruptObjectException ("invalid name '..'");  	}  	if (duplicateName (raw' thisNameB' ptr - 1))  		throw new CorruptObjectException ("duplicate entry names");  	if (lastNameB != 0) {  		int cmp = pathCompare (raw' lastNameB' lastNameE' lastMode' thisNameB' ptr - 1' thisMode);  		if (cmp > 0)  			throw new CorruptObjectException ("incorrectly sorted");  	}  	lastNameB = thisNameB;  	lastNameE = ptr - 1;  	lastMode = thisMode;  	ptr += Constants.OBJECT_ID_LENGTH;  	if (ptr > sz)  		throw new CorruptObjectException ("truncated in object id");  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: while (ptr < sz) {  	int thisMode = 0;  	for (; ;) {  		if (ptr == sz)  			throw new CorruptObjectException ("truncated in mode");  		byte c = raw [ptr++];  		if (' ' == c)  			break;  		if (c < '0' || c > '7')  			throw new CorruptObjectException ("invalid mode character");  		if (thisMode == 0 && c == '0')  			throw new CorruptObjectException ("mode starts with '0'");  		thisMode <<= 3;  		thisMode += (c - (byte)'0');  	}  	if (FileMode.FromBits (thisMode).ObjectType == ObjectType.Bad)  		throw new CorruptObjectException ("invalid mode " + NB.DecimalToBase (thisMode' 8));  	int thisNameB = ptr;  	for (; ;) {  		if (ptr == sz)  			throw new CorruptObjectException ("truncated in name");  		byte c = raw [ptr++];  		if (c == '\0')  			break;  		if (c == '/')  			throw new CorruptObjectException ("name contains '/'");  	}  	if (thisNameB + 1 == ptr)  		throw new CorruptObjectException ("zero length name");  	if (raw [thisNameB] == '.') {  		int nameLen = (ptr - 1) - thisNameB;  		if (nameLen == 1)  			throw new CorruptObjectException ("invalid name '.'");  		if (nameLen == 2 && raw [thisNameB + 1] == '.')  			throw new CorruptObjectException ("invalid name '..'");  	}  	if (duplicateName (raw' thisNameB' ptr - 1))  		throw new CorruptObjectException ("duplicate entry names");  	if (lastNameB != 0) {  		int cmp = pathCompare (raw' lastNameB' lastNameE' lastMode' thisNameB' ptr - 1' thisMode);  		if (cmp > 0)  			throw new CorruptObjectException ("incorrectly sorted");  	}  	lastNameB = thisNameB;  	lastNameE = ptr - 1;  	lastMode = thisMode;  	ptr += Constants.OBJECT_ID_LENGTH;  	if (ptr > sz)  		throw new CorruptObjectException ("truncated in object id");  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: for (; ;) {  	if (ptr == sz)  		throw new CorruptObjectException ("truncated in mode");  	byte c = raw [ptr++];  	if (' ' == c)  		break;  	if (c < '0' || c > '7')  		throw new CorruptObjectException ("invalid mode character");  	if (thisMode == 0 && c == '0')  		throw new CorruptObjectException ("mode starts with '0'");  	thisMode <<= 3;  	thisMode += (c - (byte)'0');  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: thisMode <<= 3;  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: if (FileMode.FromBits (thisMode).ObjectType == ObjectType.Bad)  	throw new CorruptObjectException ("invalid mode " + NB.DecimalToBase (thisMode' 8));  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: throw new CorruptObjectException ("invalid mode " + NB.DecimalToBase (thisMode' 8));  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: if (raw [thisNameB] == '.') {  	int nameLen = (ptr - 1) - thisNameB;  	if (nameLen == 1)  		throw new CorruptObjectException ("invalid name '.'");  	if (nameLen == 2 && raw [thisNameB + 1] == '.')  		throw new CorruptObjectException ("invalid name '..'");  }  
Magic Number,GitSharp.Core,ObjectChecker,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: if (nameLen == 2 && raw [thisNameB + 1] == '.')  	throw new CorruptObjectException ("invalid name '..'");  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer [fi] == secondBuffer [si] && firstBuffer [fi + 1] == secondBuffer [si + 1] && firstBuffer [fi + 2] == secondBuffer [si + 2] && firstBuffer [fi + 3] == secondBuffer [si + 3] && firstBuffer [fi + 4] == secondBuffer [si + 4] && firstBuffer [fi + 5] == secondBuffer [si + 5] && firstBuffer [fi + 6] == secondBuffer [si + 6] && firstBuffer [fi + 7] == secondBuffer [si + 7] && firstBuffer [fi + 8] == secondBuffer [si + 8] && firstBuffer [fi + 9] == secondBuffer [si + 9] && firstBuffer [fi + 10] == secondBuffer [si + 10] && firstBuffer [fi + 11] == secondBuffer [si + 11] && firstBuffer [fi + 12] == secondBuffer [si + 12] && firstBuffer [fi + 13] == secondBuffer [si + 13] && firstBuffer [fi + 14] == secondBuffer [si + 14] && firstBuffer [fi + 15] == secondBuffer [si + 15] && firstBuffer [fi + 16] == secondBuffer [si + 16] && firstBuffer [fi + 17] == secondBuffer [si + 17] && firstBuffer [fi + 18] == secondBuffer [si + 18] && firstBuffer [fi + 19] == secondBuffer [si + 19];  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = RawParseUtils.parseHexInt32 (bs' p);  	int b = RawParseUtils.parseHexInt32 (bs' p + 8);  	int c = RawParseUtils.parseHexInt32 (bs' p + 16);  	int d = RawParseUtils.parseHexInt32 (bs' p + 24);  	int e = RawParseUtils.parseHexInt32 (bs' p + 32);  	return new ObjectId (a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = RawParseUtils.parseHexInt32 (bs' p);  	int b = RawParseUtils.parseHexInt32 (bs' p + 8);  	int c = RawParseUtils.parseHexInt32 (bs' p + 16);  	int d = RawParseUtils.parseHexInt32 (bs' p + 24);  	int e = RawParseUtils.parseHexInt32 (bs' p + 32);  	return new ObjectId (a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = RawParseUtils.parseHexInt32 (bs' p);  	int b = RawParseUtils.parseHexInt32 (bs' p + 8);  	int c = RawParseUtils.parseHexInt32 (bs' p + 16);  	int d = RawParseUtils.parseHexInt32 (bs' p + 24);  	int e = RawParseUtils.parseHexInt32 (bs' p + 32);  	return new ObjectId (a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try {  	int a = RawParseUtils.parseHexInt32 (bs' p);  	int b = RawParseUtils.parseHexInt32 (bs' p + 8);  	int c = RawParseUtils.parseHexInt32 (bs' p + 16);  	int d = RawParseUtils.parseHexInt32 (bs' p + 24);  	int e = RawParseUtils.parseHexInt32 (bs' p + 32);  	return new ObjectId (a' b' c' d' e);  } catch (IndexOutOfRangeException e) {  	throw new InvalidObjectIdException (bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  }  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: return new ObjectId (intbuffer [offset]' intbuffer [offset + 1]' intbuffer [offset + 2]' intbuffer [offset + 3]' intbuffer [offset + 4]);  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: return new ObjectId (intbuffer [offset]' intbuffer [offset + 1]' intbuffer [offset + 2]' intbuffer [offset + 3]' intbuffer [offset + 4]);  
Magic Number,GitSharp.Core,ObjectId,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: return new ObjectId (intbuffer [offset]' intbuffer [offset + 1]' intbuffer [offset + 2]' intbuffer [offset + 3]' intbuffer [offset + 4]);  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb) {  	eb = 64;  } else if (eb < 4) {  	eb = 4;  }  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb) {  	eb = 64;  } else if (eb < 4) {  	eb = 4;  }  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb) {  	eb = 64;  } else if (eb < 4) {  	eb = 4;  }  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb) {  	eb = 64;  } else if (eb < 4) {  	eb = 4;  }  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: eb = 64;  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (eb < 4) {  	eb = 4;  }  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (eb < 4) {  	eb = 4;  }  
Magic Number,GitSharp.Core,OffsetCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: eb = 4;  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,PackFile,The following statement contains a magic number: _packLastModified = (int)(packFile.lastModified () >> 10);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,PackFile,The following statement contains a magic number: _hash = GetHashCode () * 31;  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: IO.ReadFully (_fd' 0' buf' 0' 12);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (RawParseUtils.match (buf' 0' Constants.PACK_SIGNATURE) != 4) {  	throw new IOException ("Not a PACK file.");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (vers != 2 && vers != 3) {  	throw new IOException ("Unsupported pack version " + vers + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (vers != 2 && vers != 3) {  	throw new IOException ("Unsupported pack version " + vers + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: IO.ReadFully (_fd' Length - 20' buf' 0' 20);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: IO.ReadFully (_fd' Length - 20' buf' 0' 20);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: ReadFully (pos' ib' 0' 20' curs);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: while ((c & 0x80) != 0) {  	c = ib [p++] & 0xff;  	dataSize += (c & 0x7f) << shift;  	shift += 7;  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: shift += 7;  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	return new WholePackedObjectLoader (this' pos' objOffset' typeCode' (int)dataSize);  case Constants.OBJ_OFS_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	p = 0;  	c = ib [p++] & 0xff;  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ib [p++] & 0xff;  		ofs <<= 7;  		ofs += (c & 127);  	}  	return new DeltaOfsPackedObjectLoader (this' pos + p' objOffset' (int)dataSize' objOffset - ofs);  case Constants.OBJ_REF_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	return new DeltaRefPackedObjectLoader (this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw (ib));  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	return new WholePackedObjectLoader (this' pos' objOffset' typeCode' (int)dataSize);  case Constants.OBJ_OFS_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	p = 0;  	c = ib [p++] & 0xff;  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ib [p++] & 0xff;  		ofs <<= 7;  		ofs += (c & 127);  	}  	return new DeltaOfsPackedObjectLoader (this' pos + p' objOffset' (int)dataSize' objOffset - ofs);  case Constants.OBJ_REF_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	return new DeltaRefPackedObjectLoader (this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw (ib));  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	return new WholePackedObjectLoader (this' pos' objOffset' typeCode' (int)dataSize);  case Constants.OBJ_OFS_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	p = 0;  	c = ib [p++] & 0xff;  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ib [p++] & 0xff;  		ofs <<= 7;  		ofs += (c & 127);  	}  	return new DeltaOfsPackedObjectLoader (this' pos + p' objOffset' (int)dataSize' objOffset - ofs);  case Constants.OBJ_REF_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	return new DeltaRefPackedObjectLoader (this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw (ib));  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	return new WholePackedObjectLoader (this' pos' objOffset' typeCode' (int)dataSize);  case Constants.OBJ_OFS_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	p = 0;  	c = ib [p++] & 0xff;  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ib [p++] & 0xff;  		ofs <<= 7;  		ofs += (c & 127);  	}  	return new DeltaOfsPackedObjectLoader (this' pos + p' objOffset' (int)dataSize' objOffset - ofs);  case Constants.OBJ_REF_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	return new DeltaRefPackedObjectLoader (this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw (ib));  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	return new WholePackedObjectLoader (this' pos' objOffset' typeCode' (int)dataSize);  case Constants.OBJ_OFS_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	p = 0;  	c = ib [p++] & 0xff;  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ib [p++] & 0xff;  		ofs <<= 7;  		ofs += (c & 127);  	}  	return new DeltaOfsPackedObjectLoader (this' pos + p' objOffset' (int)dataSize' objOffset - ofs);  case Constants.OBJ_REF_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	return new DeltaRefPackedObjectLoader (this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw (ib));  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	return new WholePackedObjectLoader (this' pos' objOffset' typeCode' (int)dataSize);  case Constants.OBJ_OFS_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	p = 0;  	c = ib [p++] & 0xff;  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ib [p++] & 0xff;  		ofs <<= 7;  		ofs += (c & 127);  	}  	return new DeltaOfsPackedObjectLoader (this' pos + p' objOffset' (int)dataSize' objOffset - ofs);  case Constants.OBJ_REF_DELTA:  	ReadFully (pos' ib' 0' 20' curs);  	return new DeltaRefPackedObjectLoader (this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw (ib));  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: ReadFully (pos' ib' 0' 20' curs);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: while ((c & 128) != 0) {  	ofs += 1;  	c = ib [p++] & 0xff;  	ofs <<= 7;  	ofs += (c & 127);  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: while ((c & 128) != 0) {  	ofs += 1;  	c = ib [p++] & 0xff;  	ofs <<= 7;  	ofs += (c & 127);  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: while ((c & 128) != 0) {  	ofs += 1;  	c = ib [p++] & 0xff;  	ofs <<= 7;  	ofs += (c & 127);  }  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: ofs <<= 7;  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: ofs += (c & 127);  
Magic Number,GitSharp.Core,PackFile,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: ReadFully (pos' ib' 0' 20' curs);  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: try {  	using (FileStream fs = idxFile.OpenRead ()) {  		byte[] hdr = new byte[8];  		IO.ReadFully (fs' hdr' 0' hdr.Length);  		if (IsTOC (hdr)) {  			int v = NB.DecodeInt32 (hdr' 4);  			switch (v) {  			case 2:  				return new PackIndexV2 (fs);  			default:  				throw new IOException ("Unsupported pack index version " + v);  			}  		}  		return new PackIndexV1 (fs' hdr);  	}  } catch (IOException) {  	throw new IOException ("Unable to read pack index: " + idxFile.FullName);  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: try {  	using (FileStream fs = idxFile.OpenRead ()) {  		byte[] hdr = new byte[8];  		IO.ReadFully (fs' hdr' 0' hdr.Length);  		if (IsTOC (hdr)) {  			int v = NB.DecodeInt32 (hdr' 4);  			switch (v) {  			case 2:  				return new PackIndexV2 (fs);  			default:  				throw new IOException ("Unsupported pack index version " + v);  			}  		}  		return new PackIndexV1 (fs' hdr);  	}  } catch (IOException) {  	throw new IOException ("Unable to read pack index: " + idxFile.FullName);  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: try {  	using (FileStream fs = idxFile.OpenRead ()) {  		byte[] hdr = new byte[8];  		IO.ReadFully (fs' hdr' 0' hdr.Length);  		if (IsTOC (hdr)) {  			int v = NB.DecodeInt32 (hdr' 4);  			switch (v) {  			case 2:  				return new PackIndexV2 (fs);  			default:  				throw new IOException ("Unsupported pack index version " + v);  			}  		}  		return new PackIndexV1 (fs' hdr);  	}  } catch (IOException) {  	throw new IOException ("Unable to read pack index: " + idxFile.FullName);  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: using (FileStream fs = idxFile.OpenRead ()) {  	byte[] hdr = new byte[8];  	IO.ReadFully (fs' hdr' 0' hdr.Length);  	if (IsTOC (hdr)) {  		int v = NB.DecodeInt32 (hdr' 4);  		switch (v) {  		case 2:  			return new PackIndexV2 (fs);  		default:  			throw new IOException ("Unsupported pack index version " + v);  		}  	}  	return new PackIndexV1 (fs' hdr);  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: using (FileStream fs = idxFile.OpenRead ()) {  	byte[] hdr = new byte[8];  	IO.ReadFully (fs' hdr' 0' hdr.Length);  	if (IsTOC (hdr)) {  		int v = NB.DecodeInt32 (hdr' 4);  		switch (v) {  		case 2:  			return new PackIndexV2 (fs);  		default:  			throw new IOException ("Unsupported pack index version " + v);  		}  	}  	return new PackIndexV1 (fs' hdr);  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: using (FileStream fs = idxFile.OpenRead ()) {  	byte[] hdr = new byte[8];  	IO.ReadFully (fs' hdr' 0' hdr.Length);  	if (IsTOC (hdr)) {  		int v = NB.DecodeInt32 (hdr' 4);  		switch (v) {  		case 2:  			return new PackIndexV2 (fs);  		default:  			throw new IOException ("Unsupported pack index version " + v);  		}  	}  	return new PackIndexV1 (fs' hdr);  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: if (IsTOC (hdr)) {  	int v = NB.DecodeInt32 (hdr' 4);  	switch (v) {  	case 2:  		return new PackIndexV2 (fs);  	default:  		throw new IOException ("Unsupported pack index version " + v);  	}  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: if (IsTOC (hdr)) {  	int v = NB.DecodeInt32 (hdr' 4);  	switch (v) {  	case 2:  		return new PackIndexV2 (fs);  	default:  		throw new IOException ("Unsupported pack index version " + v);  	}  }  
Magic Number,GitSharp.Core,PackIndex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: switch (v) {  case 2:  	return new PackIndexV2 (fs);  default:  	throw new IOException ("Unsupported pack index version " + v);  }  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: _idxHeader = new long[256];  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: for (int k = 0; k < _idxHeader.Length; k++)  	_idxHeader [k] = NB.decodeUInt32 (fanoutTable' k * 4);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: _idxHeader [k] = NB.decodeUInt32 (fanoutTable' k * 4);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: for (int k = 0; k < _idxHeader.Length; k++) {  	uint n;  	if (k == 0)  		n = (uint)(_idxHeader [k]);  	else  		n = (uint)(_idxHeader [k] - _idxHeader [k - 1]);  	if (n > 0) {  		_idxdata [k] = new byte[n * (Constants.OBJECT_ID_LENGTH + 4)];  		IO.ReadFully (fd' _idxdata [k]' 0' _idxdata [k].Length);  	}  }  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: if (n > 0) {  	_idxdata [k] = new byte[n * (Constants.OBJECT_ID_LENGTH + 4)];  	IO.ReadFully (fd' _idxdata [k]' 0' _idxdata [k].Length);  }  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: _idxdata [k] = new byte[n * (Constants.OBJECT_ID_LENGTH + 4)];  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: ObjectCount = _idxHeader [255];  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: PackChecksum = new byte[20];  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do {  	int mid = (low + high) / 2;  	int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  	int cmp = objId.CompareTo (data' pos);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		uint b0 = data [pos - 4] & (uint)0xff;  		uint b1 = data [pos - 3] & (uint)0xff;  		uint b2 = data [pos - 2] & (uint)0xff;  		uint b3 = data [pos - 1] & (uint)0xff;  		return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  	} else  		low = mid + 1;  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp < 0) {  	high = mid;  } else if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp < 0) {  	high = mid;  } else if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp < 0) {  	high = mid;  } else if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp < 0) {  	high = mid;  } else if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp < 0) {  	high = mid;  } else if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp < 0) {  	high = mid;  } else if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: if (cmp == 0) {  	uint b0 = data [pos - 4] & (uint)0xff;  	uint b1 = data [pos - 3] & (uint)0xff;  	uint b2 = data [pos - 2] & (uint)0xff;  	uint b3 = data [pos - 1] & (uint)0xff;  	return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  } else  	low = mid + 1;  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  
Magic Number,GitSharp.Core,PackIndexV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++) {  	_fanoutTable [k] = NB.DecodeUInt32 (fanoutRaw' k * 4);  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: _fanoutTable [k] = NB.DecodeUInt32 (fanoutRaw' k * 4);  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++) {  	long bucketCnt;  	if (k == 0) {  		bucketCnt = _fanoutTable [k];  	} else {  		bucketCnt = _fanoutTable [k] - _fanoutTable [k - 1];  	}  	if (bucketCnt == 0) {  		_names [k] = NoInts;  		_offset32 [k] = NoBytes;  		_crc32 [k] = NoBytes;  		continue;  	}  	long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  	if (nameLen > int.MaxValue) {  		throw new IOException ("Index file is too large");  	}  	var intNameLen = (int)nameLen;  	var raw = new byte[intNameLen];  	var bin = new int[intNameLen >> 2];  	IO.ReadFully (fd' raw' 0' raw.Length);  	for (int i = 0; i < bin.Length; i++) {  		bin [i] = NB.DecodeInt32 (raw' i << 2);  	}  	_names [k] = bin;  	_offset32 [k] = new byte[(int)(bucketCnt * 4)];  	_crc32 [k] = new byte[(int)(bucketCnt * 4)];  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++) {  	long bucketCnt;  	if (k == 0) {  		bucketCnt = _fanoutTable [k];  	} else {  		bucketCnt = _fanoutTable [k] - _fanoutTable [k - 1];  	}  	if (bucketCnt == 0) {  		_names [k] = NoInts;  		_offset32 [k] = NoBytes;  		_crc32 [k] = NoBytes;  		continue;  	}  	long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  	if (nameLen > int.MaxValue) {  		throw new IOException ("Index file is too large");  	}  	var intNameLen = (int)nameLen;  	var raw = new byte[intNameLen];  	var bin = new int[intNameLen >> 2];  	IO.ReadFully (fd' raw' 0' raw.Length);  	for (int i = 0; i < bin.Length; i++) {  		bin [i] = NB.DecodeInt32 (raw' i << 2);  	}  	_names [k] = bin;  	_offset32 [k] = new byte[(int)(bucketCnt * 4)];  	_crc32 [k] = new byte[(int)(bucketCnt * 4)];  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++) {  	long bucketCnt;  	if (k == 0) {  		bucketCnt = _fanoutTable [k];  	} else {  		bucketCnt = _fanoutTable [k] - _fanoutTable [k - 1];  	}  	if (bucketCnt == 0) {  		_names [k] = NoInts;  		_offset32 [k] = NoBytes;  		_crc32 [k] = NoBytes;  		continue;  	}  	long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  	if (nameLen > int.MaxValue) {  		throw new IOException ("Index file is too large");  	}  	var intNameLen = (int)nameLen;  	var raw = new byte[intNameLen];  	var bin = new int[intNameLen >> 2];  	IO.ReadFully (fd' raw' 0' raw.Length);  	for (int i = 0; i < bin.Length; i++) {  		bin [i] = NB.DecodeInt32 (raw' i << 2);  	}  	_names [k] = bin;  	_offset32 [k] = new byte[(int)(bucketCnt * 4)];  	_crc32 [k] = new byte[(int)(bucketCnt * 4)];  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++) {  	long bucketCnt;  	if (k == 0) {  		bucketCnt = _fanoutTable [k];  	} else {  		bucketCnt = _fanoutTable [k] - _fanoutTable [k - 1];  	}  	if (bucketCnt == 0) {  		_names [k] = NoInts;  		_offset32 [k] = NoBytes;  		_crc32 [k] = NoBytes;  		continue;  	}  	long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  	if (nameLen > int.MaxValue) {  		throw new IOException ("Index file is too large");  	}  	var intNameLen = (int)nameLen;  	var raw = new byte[intNameLen];  	var bin = new int[intNameLen >> 2];  	IO.ReadFully (fd' raw' 0' raw.Length);  	for (int i = 0; i < bin.Length; i++) {  		bin [i] = NB.DecodeInt32 (raw' i << 2);  	}  	_names [k] = bin;  	_offset32 [k] = new byte[(int)(bucketCnt * 4)];  	_crc32 [k] = new byte[(int)(bucketCnt * 4)];  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int i = 0; i < bin.Length; i++) {  	bin [i] = NB.DecodeInt32 (raw' i << 2);  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: bin [i] = NB.DecodeInt32 (raw' i << 2);  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: _offset32 [k] = new byte[(int)(bucketCnt * 4)];  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: _crc32 [k] = new byte[(int)(bucketCnt * 4)];  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++) {  	byte[] ofs = _offset32 [k];  	IO.ReadFully (fd' ofs' 0' ofs.Length);  	for (int p = 0; p < ofs.Length; p += 4) {  		if (NB.ConvertUnsignedByteToSigned (ofs [p]) < 0) {  			o64cnt++;  		}  	}  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int p = 0; p < ofs.Length; p += 4) {  	if (NB.ConvertUnsignedByteToSigned (ofs [p]) < 0) {  		o64cnt++;  	}  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: p += 4
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: if (o64cnt > 0) {  	_offset64 = new byte[o64cnt * 8];  	IO.ReadFully (fd' _offset64' 0' _offset64.Length);  } else {  	_offset64 = NoBytes;  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: _offset64 = new byte[o64cnt * 8];  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: PackChecksum = new byte[20];  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,FindOffset,The following statement contains a magic number: if ((p & IS_O64) != 0) {  	return NB.DecodeUInt64 (_offset64' (8 * (int)(p & ~IS_O64)));  }  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,FindOffset,The following statement contains a magic number: return NB.DecodeUInt64 (_offset64' (8 * (int)(p & ~IS_O64)));  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,FindCRC32,The following statement contains a magic number: return NB.DecodeUInt32 (_crc32 [levelOne]' levelTwo << 2);  
Magic Number,GitSharp.Core,PackIndexV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,BinarySearchLevelTwo,The following statement contains a magic number: do {  	var mid = (int)((uint)(low + high) >> 1);  	int mid4 = mid << 2;  	int cmp = objId.CompareTo (data' mid4 + mid);  	if (cmp < 0) {  		high = mid;  	} else if (cmp == 0) {  		return mid;  	} else {  		low = mid + 1;  	}  } while (low < high);  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (T oe in objs) {  	switch (version) {  	case 1:  		if (PackIndexWriterV1.CanStore (oe))  			continue;  		version = 2;  		break;  	case 2:  		breakLoop = true;  		break;  	}  	if (breakLoop) {  		break;  	}  }  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (T oe in objs) {  	switch (version) {  	case 1:  		if (PackIndexWriterV1.CanStore (oe))  			continue;  		version = 2;  		break;  	case 2:  		breakLoop = true;  		break;  	}  	if (breakLoop) {  		break;  	}  }  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: switch (version) {  case 1:  	if (PackIndexWriterV1.CanStore (oe))  		continue;  	version = 2;  	break;  case 2:  	breakLoop = true;  	break;  }  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: switch (version) {  case 1:  	if (PackIndexWriterV1.CanStore (oe))  		continue;  	version = 2;  	break;  case 2:  	breakLoop = true;  	break;  }  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: version = 2;  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateVersion,The following statement contains a magic number: switch (version) {  case 1:  	return new PackIndexWriterV1 (dst);  case 2:  	return new PackIndexWriterV2 (dst);  default:  	throw new ArgumentException ("Unsupported pack index version " + version);  }  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteTOC,The following statement contains a magic number: _stream.Write (tmp' 0' 4);  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: for (int i = 1; i < 256; i++)  	fanout [i] += fanout [i - 1];  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: foreach (int n in fanout) {  	NB.encodeInt32 (tmp' 0' n);  	_stream.Write (tmp' 0' 4);  }  
Magic Number,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: _stream.Write (tmp' 0' 4);  
Magic Number,GitSharp.Core,PackIndexWriterV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV1.cs,WriteInternal,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries) {  	if (!CanStore (oe)) {  		throw new IOException ("Pack too large for index version 1");  	}  	NB.encodeInt32 (tmp' 0' (int)oe.Offset);  	oe.copyRawTo (tmp' 4);  	_stream.Write (tmp' 0' tmp.Length);  }  
Magic Number,GitSharp.Core,PackIndexWriterV1,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV1.cs,WriteInternal,The following statement contains a magic number: oe.copyRawTo (tmp' 4);  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteInternal,The following statement contains a magic number: WriteTOC (2);  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteCRCs,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries) {  	NB.encodeInt32 (tmp' 0' oe.CRC);  	_stream.BaseStream.Write (tmp' 0' 4);  }  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteCRCs,The following statement contains a magic number: _stream.BaseStream.Write (tmp' 0' 4);  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries) {  	long o = oe.Offset;  	if (o < int.MaxValue) {  		NB.encodeInt32 (tmp' 0' (int)o);  	} else {  		NB.encodeInt32 (tmp' 0' (1 << 31) | o64++);  	}  	_stream.BaseStream.Write (tmp' 0' 4);  }  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries) {  	long o = oe.Offset;  	if (o < int.MaxValue) {  		NB.encodeInt32 (tmp' 0' (int)o);  	} else {  		NB.encodeInt32 (tmp' 0' (1 << 31) | o64++);  	}  	_stream.BaseStream.Write (tmp' 0' 4);  }  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: if (o < int.MaxValue) {  	NB.encodeInt32 (tmp' 0' (int)o);  } else {  	NB.encodeInt32 (tmp' 0' (1 << 31) | o64++);  }  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: NB.encodeInt32 (tmp' 0' (1 << 31) | o64++);  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: _stream.BaseStream.Write (tmp' 0' 4);  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset64,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries) {  	long o = oe.Offset;  	if (o > int.MaxValue) {  		NB.encodeInt64 (tmp' 0' o);  		_stream.BaseStream.Write (tmp' 0' 8);  	}  }  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset64,The following statement contains a magic number: if (o > int.MaxValue) {  	NB.encodeInt64 (tmp' 0' o);  	_stream.BaseStream.Write (tmp' 0' 8);  }  
Magic Number,GitSharp.Core,PackIndexWriterV2,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset64,The following statement contains a magic number: _stream.BaseStream.Write (tmp' 0' 8);  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1) {  	When = 0;  	tzOffset = -1;  } else {  	string tzHoursStr = str.Slice (sp + 1' sp + 4).Trim ();  	int tzHours = tzHoursStr [0] == '+' ? int.Parse (tzHoursStr.Substring (1)) : int.Parse (tzHoursStr);  	int tzMins = int.Parse (str.Substring (sp + 4).Trim ());  	When = long.Parse (str.Slice (gt + 1' sp).Trim ()) * 1000;  	tzOffset = tzHours * 60 + tzMins;  }  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1) {  	When = 0;  	tzOffset = -1;  } else {  	string tzHoursStr = str.Slice (sp + 1' sp + 4).Trim ();  	int tzHours = tzHoursStr [0] == '+' ? int.Parse (tzHoursStr.Substring (1)) : int.Parse (tzHoursStr);  	int tzMins = int.Parse (str.Substring (sp + 4).Trim ());  	When = long.Parse (str.Slice (gt + 1' sp).Trim ()) * 1000;  	tzOffset = tzHours * 60 + tzMins;  }  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1) {  	When = 0;  	tzOffset = -1;  } else {  	string tzHoursStr = str.Slice (sp + 1' sp + 4).Trim ();  	int tzHours = tzHoursStr [0] == '+' ? int.Parse (tzHoursStr.Substring (1)) : int.Parse (tzHoursStr);  	int tzMins = int.Parse (str.Substring (sp + 4).Trim ());  	When = long.Parse (str.Slice (gt + 1' sp).Trim ()) * 1000;  	tzOffset = tzHours * 60 + tzMins;  }  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1) {  	When = 0;  	tzOffset = -1;  } else {  	string tzHoursStr = str.Slice (sp + 1' sp + 4).Trim ();  	int tzHours = tzHoursStr [0] == '+' ? int.Parse (tzHoursStr.Substring (1)) : int.Parse (tzHoursStr);  	int tzMins = int.Parse (str.Substring (sp + 4).Trim ());  	When = long.Parse (str.Slice (gt + 1' sp).Trim ()) * 1000;  	tzOffset = tzHours * 60 + tzMins;  }  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: When = long.Parse (str.Slice (gt + 1' sp).Trim ()) * 1000;  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: tzOffset = tzHours * 60 + tzMins;  
Magic Number,GitSharp.Core,PersonIdent,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PersonIdent.cs,ToExternalString,The following statement contains a magic number: r.Append (When / 1000);  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,MapTree,The following statement contains a magic number: switch (((ObjectType)or.Type)) {  case ObjectType.Tree:  	return new Tree (this' id' raw);  case ObjectType.Commit:  	return MapTree (ObjectId.FromString (raw' 5));  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,MapTree,The following statement contains a magic number: return MapTree (ObjectId.FromString (raw' 5));  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i) {  	switch (revision [i]) {  	case '^':  		if (refId == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  		}  		if (i + 1 < revision.Length) {  			switch (revision [i + 1]) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				int j;  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var tag = (Tag)oref;  					refId = tag.Id;  					oref = MapObject (refId' null);  				}  				Commit oCom = (oref as Commit);  				if (oCom == null) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				for (j = i + 1; j < revision.Length; ++j) {  					if (!Char.IsDigit (revision [j]))  						break;  				}  				var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  				int pnum;  				try {  					pnum = Convert.ToInt32 (parentnum);  				} catch (FormatException) {  					throw new RevisionSyntaxException (revision' "Invalid commit parent number");  				}  				if (pnum != 0) {  					ObjectId[] parents = oCom.ParentIds;  					if (pnum > parents.Length)  						refId = null;  					else  						refId = parents [pnum - 1];  				}  				i = j - 1;  				break;  			case '{':  				int k;  				string item = null;  				for (k = i + 2; k < revision.Length; ++k) {  					if (revision [k] != '}')  						continue;  					item = new string (revision.ToCharArray (i + 2' k - i - 2));  					break;  				}  				i = k;  				if (item != null) {  					if (item.Equals ("tree")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						Treeish oTree = (oref as Treeish);  						if (oTree != null) {  							refId = oTree.TreeId;  						} else {  							throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  						}  					} else if (item.Equals ("commit")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is Commit)) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (item.Equals ("blob")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is byte[])) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (string.Empty.Equals (item)) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  					} else {  						throw new RevisionSyntaxException (revision);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  				break;  			default:  				oref = MapObject (refId' null);  				Commit oComm = (oref as Commit);  				if (oComm != null) {  					ObjectId[] parents = oComm.ParentIds;  					refId = parents.Length == 0 ? null : parents [0];  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				break;  			}  		} else {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom != null) {  				ObjectId[] parents = oCom.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  			}  		}  		break;  	case '~':  		if (oref == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  			oref = MapObject (refId' null);  		}  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		if (!(oref is Commit)) {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  		int l;  		for (l = i + 1; l < revision.Length; ++l) {  			if (!Char.IsDigit (revision [l]))  				break;  		}  		var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  		int dist;  		try {  			dist = Convert.ToInt32 (distnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  		}  		while (dist > 0) {  			ObjectId[] parents = ((Commit)oref).ParentIds;  			if (parents.Length == 0) {  				refId = null;  				break;  			}  			refId = parents [0];  			oref = MapCommit (refId);  			--dist;  		}  		i = l - 1;  		break;  	case '@':  		int m;  		string time = null;  		for (m = i + 2; m < revision.Length; ++m) {  			if (revision [m] != '}')  				continue;  			time = new string (revision.ToCharArray (i + 2' m - i - 2));  			break;  		}  		if (time != null) {  			throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  		}  		i = m - 1;  		break;  	default:  		if (refId != null) {  			throw new RevisionSyntaxException (revision);  		}  		break;  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i) {  	switch (revision [i]) {  	case '^':  		if (refId == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  		}  		if (i + 1 < revision.Length) {  			switch (revision [i + 1]) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				int j;  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var tag = (Tag)oref;  					refId = tag.Id;  					oref = MapObject (refId' null);  				}  				Commit oCom = (oref as Commit);  				if (oCom == null) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				for (j = i + 1; j < revision.Length; ++j) {  					if (!Char.IsDigit (revision [j]))  						break;  				}  				var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  				int pnum;  				try {  					pnum = Convert.ToInt32 (parentnum);  				} catch (FormatException) {  					throw new RevisionSyntaxException (revision' "Invalid commit parent number");  				}  				if (pnum != 0) {  					ObjectId[] parents = oCom.ParentIds;  					if (pnum > parents.Length)  						refId = null;  					else  						refId = parents [pnum - 1];  				}  				i = j - 1;  				break;  			case '{':  				int k;  				string item = null;  				for (k = i + 2; k < revision.Length; ++k) {  					if (revision [k] != '}')  						continue;  					item = new string (revision.ToCharArray (i + 2' k - i - 2));  					break;  				}  				i = k;  				if (item != null) {  					if (item.Equals ("tree")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						Treeish oTree = (oref as Treeish);  						if (oTree != null) {  							refId = oTree.TreeId;  						} else {  							throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  						}  					} else if (item.Equals ("commit")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is Commit)) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (item.Equals ("blob")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is byte[])) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (string.Empty.Equals (item)) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  					} else {  						throw new RevisionSyntaxException (revision);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  				break;  			default:  				oref = MapObject (refId' null);  				Commit oComm = (oref as Commit);  				if (oComm != null) {  					ObjectId[] parents = oComm.ParentIds;  					refId = parents.Length == 0 ? null : parents [0];  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				break;  			}  		} else {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom != null) {  				ObjectId[] parents = oCom.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  			}  		}  		break;  	case '~':  		if (oref == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  			oref = MapObject (refId' null);  		}  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		if (!(oref is Commit)) {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  		int l;  		for (l = i + 1; l < revision.Length; ++l) {  			if (!Char.IsDigit (revision [l]))  				break;  		}  		var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  		int dist;  		try {  			dist = Convert.ToInt32 (distnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  		}  		while (dist > 0) {  			ObjectId[] parents = ((Commit)oref).ParentIds;  			if (parents.Length == 0) {  				refId = null;  				break;  			}  			refId = parents [0];  			oref = MapCommit (refId);  			--dist;  		}  		i = l - 1;  		break;  	case '@':  		int m;  		string time = null;  		for (m = i + 2; m < revision.Length; ++m) {  			if (revision [m] != '}')  				continue;  			time = new string (revision.ToCharArray (i + 2' m - i - 2));  			break;  		}  		if (time != null) {  			throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  		}  		i = m - 1;  		break;  	default:  		if (refId != null) {  			throw new RevisionSyntaxException (revision);  		}  		break;  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i) {  	switch (revision [i]) {  	case '^':  		if (refId == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  		}  		if (i + 1 < revision.Length) {  			switch (revision [i + 1]) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				int j;  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var tag = (Tag)oref;  					refId = tag.Id;  					oref = MapObject (refId' null);  				}  				Commit oCom = (oref as Commit);  				if (oCom == null) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				for (j = i + 1; j < revision.Length; ++j) {  					if (!Char.IsDigit (revision [j]))  						break;  				}  				var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  				int pnum;  				try {  					pnum = Convert.ToInt32 (parentnum);  				} catch (FormatException) {  					throw new RevisionSyntaxException (revision' "Invalid commit parent number");  				}  				if (pnum != 0) {  					ObjectId[] parents = oCom.ParentIds;  					if (pnum > parents.Length)  						refId = null;  					else  						refId = parents [pnum - 1];  				}  				i = j - 1;  				break;  			case '{':  				int k;  				string item = null;  				for (k = i + 2; k < revision.Length; ++k) {  					if (revision [k] != '}')  						continue;  					item = new string (revision.ToCharArray (i + 2' k - i - 2));  					break;  				}  				i = k;  				if (item != null) {  					if (item.Equals ("tree")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						Treeish oTree = (oref as Treeish);  						if (oTree != null) {  							refId = oTree.TreeId;  						} else {  							throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  						}  					} else if (item.Equals ("commit")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is Commit)) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (item.Equals ("blob")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is byte[])) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (string.Empty.Equals (item)) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  					} else {  						throw new RevisionSyntaxException (revision);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  				break;  			default:  				oref = MapObject (refId' null);  				Commit oComm = (oref as Commit);  				if (oComm != null) {  					ObjectId[] parents = oComm.ParentIds;  					refId = parents.Length == 0 ? null : parents [0];  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				break;  			}  		} else {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom != null) {  				ObjectId[] parents = oCom.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  			}  		}  		break;  	case '~':  		if (oref == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  			oref = MapObject (refId' null);  		}  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		if (!(oref is Commit)) {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  		int l;  		for (l = i + 1; l < revision.Length; ++l) {  			if (!Char.IsDigit (revision [l]))  				break;  		}  		var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  		int dist;  		try {  			dist = Convert.ToInt32 (distnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  		}  		while (dist > 0) {  			ObjectId[] parents = ((Commit)oref).ParentIds;  			if (parents.Length == 0) {  				refId = null;  				break;  			}  			refId = parents [0];  			oref = MapCommit (refId);  			--dist;  		}  		i = l - 1;  		break;  	case '@':  		int m;  		string time = null;  		for (m = i + 2; m < revision.Length; ++m) {  			if (revision [m] != '}')  				continue;  			time = new string (revision.ToCharArray (i + 2' m - i - 2));  			break;  		}  		if (time != null) {  			throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  		}  		i = m - 1;  		break;  	default:  		if (refId != null) {  			throw new RevisionSyntaxException (revision);  		}  		break;  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i) {  	switch (revision [i]) {  	case '^':  		if (refId == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  		}  		if (i + 1 < revision.Length) {  			switch (revision [i + 1]) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				int j;  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var tag = (Tag)oref;  					refId = tag.Id;  					oref = MapObject (refId' null);  				}  				Commit oCom = (oref as Commit);  				if (oCom == null) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				for (j = i + 1; j < revision.Length; ++j) {  					if (!Char.IsDigit (revision [j]))  						break;  				}  				var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  				int pnum;  				try {  					pnum = Convert.ToInt32 (parentnum);  				} catch (FormatException) {  					throw new RevisionSyntaxException (revision' "Invalid commit parent number");  				}  				if (pnum != 0) {  					ObjectId[] parents = oCom.ParentIds;  					if (pnum > parents.Length)  						refId = null;  					else  						refId = parents [pnum - 1];  				}  				i = j - 1;  				break;  			case '{':  				int k;  				string item = null;  				for (k = i + 2; k < revision.Length; ++k) {  					if (revision [k] != '}')  						continue;  					item = new string (revision.ToCharArray (i + 2' k - i - 2));  					break;  				}  				i = k;  				if (item != null) {  					if (item.Equals ("tree")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						Treeish oTree = (oref as Treeish);  						if (oTree != null) {  							refId = oTree.TreeId;  						} else {  							throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  						}  					} else if (item.Equals ("commit")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is Commit)) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (item.Equals ("blob")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is byte[])) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (string.Empty.Equals (item)) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  					} else {  						throw new RevisionSyntaxException (revision);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  				break;  			default:  				oref = MapObject (refId' null);  				Commit oComm = (oref as Commit);  				if (oComm != null) {  					ObjectId[] parents = oComm.ParentIds;  					refId = parents.Length == 0 ? null : parents [0];  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				break;  			}  		} else {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom != null) {  				ObjectId[] parents = oCom.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  			}  		}  		break;  	case '~':  		if (oref == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  			oref = MapObject (refId' null);  		}  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		if (!(oref is Commit)) {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  		int l;  		for (l = i + 1; l < revision.Length; ++l) {  			if (!Char.IsDigit (revision [l]))  				break;  		}  		var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  		int dist;  		try {  			dist = Convert.ToInt32 (distnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  		}  		while (dist > 0) {  			ObjectId[] parents = ((Commit)oref).ParentIds;  			if (parents.Length == 0) {  				refId = null;  				break;  			}  			refId = parents [0];  			oref = MapCommit (refId);  			--dist;  		}  		i = l - 1;  		break;  	case '@':  		int m;  		string time = null;  		for (m = i + 2; m < revision.Length; ++m) {  			if (revision [m] != '}')  				continue;  			time = new string (revision.ToCharArray (i + 2' m - i - 2));  			break;  		}  		if (time != null) {  			throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  		}  		i = m - 1;  		break;  	default:  		if (refId != null) {  			throw new RevisionSyntaxException (revision);  		}  		break;  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i) {  	switch (revision [i]) {  	case '^':  		if (refId == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  		}  		if (i + 1 < revision.Length) {  			switch (revision [i + 1]) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				int j;  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var tag = (Tag)oref;  					refId = tag.Id;  					oref = MapObject (refId' null);  				}  				Commit oCom = (oref as Commit);  				if (oCom == null) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				for (j = i + 1; j < revision.Length; ++j) {  					if (!Char.IsDigit (revision [j]))  						break;  				}  				var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  				int pnum;  				try {  					pnum = Convert.ToInt32 (parentnum);  				} catch (FormatException) {  					throw new RevisionSyntaxException (revision' "Invalid commit parent number");  				}  				if (pnum != 0) {  					ObjectId[] parents = oCom.ParentIds;  					if (pnum > parents.Length)  						refId = null;  					else  						refId = parents [pnum - 1];  				}  				i = j - 1;  				break;  			case '{':  				int k;  				string item = null;  				for (k = i + 2; k < revision.Length; ++k) {  					if (revision [k] != '}')  						continue;  					item = new string (revision.ToCharArray (i + 2' k - i - 2));  					break;  				}  				i = k;  				if (item != null) {  					if (item.Equals ("tree")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						Treeish oTree = (oref as Treeish);  						if (oTree != null) {  							refId = oTree.TreeId;  						} else {  							throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  						}  					} else if (item.Equals ("commit")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is Commit)) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (item.Equals ("blob")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is byte[])) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (string.Empty.Equals (item)) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  					} else {  						throw new RevisionSyntaxException (revision);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  				break;  			default:  				oref = MapObject (refId' null);  				Commit oComm = (oref as Commit);  				if (oComm != null) {  					ObjectId[] parents = oComm.ParentIds;  					refId = parents.Length == 0 ? null : parents [0];  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				break;  			}  		} else {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom != null) {  				ObjectId[] parents = oCom.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  			}  		}  		break;  	case '~':  		if (oref == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  			oref = MapObject (refId' null);  		}  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		if (!(oref is Commit)) {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  		int l;  		for (l = i + 1; l < revision.Length; ++l) {  			if (!Char.IsDigit (revision [l]))  				break;  		}  		var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  		int dist;  		try {  			dist = Convert.ToInt32 (distnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  		}  		while (dist > 0) {  			ObjectId[] parents = ((Commit)oref).ParentIds;  			if (parents.Length == 0) {  				refId = null;  				break;  			}  			refId = parents [0];  			oref = MapCommit (refId);  			--dist;  		}  		i = l - 1;  		break;  	case '@':  		int m;  		string time = null;  		for (m = i + 2; m < revision.Length; ++m) {  			if (revision [m] != '}')  				continue;  			time = new string (revision.ToCharArray (i + 2' m - i - 2));  			break;  		}  		if (time != null) {  			throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  		}  		i = m - 1;  		break;  	default:  		if (refId != null) {  			throw new RevisionSyntaxException (revision);  		}  		break;  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i) {  	switch (revision [i]) {  	case '^':  		if (refId == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  		}  		if (i + 1 < revision.Length) {  			switch (revision [i + 1]) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				int j;  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var tag = (Tag)oref;  					refId = tag.Id;  					oref = MapObject (refId' null);  				}  				Commit oCom = (oref as Commit);  				if (oCom == null) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				for (j = i + 1; j < revision.Length; ++j) {  					if (!Char.IsDigit (revision [j]))  						break;  				}  				var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  				int pnum;  				try {  					pnum = Convert.ToInt32 (parentnum);  				} catch (FormatException) {  					throw new RevisionSyntaxException (revision' "Invalid commit parent number");  				}  				if (pnum != 0) {  					ObjectId[] parents = oCom.ParentIds;  					if (pnum > parents.Length)  						refId = null;  					else  						refId = parents [pnum - 1];  				}  				i = j - 1;  				break;  			case '{':  				int k;  				string item = null;  				for (k = i + 2; k < revision.Length; ++k) {  					if (revision [k] != '}')  						continue;  					item = new string (revision.ToCharArray (i + 2' k - i - 2));  					break;  				}  				i = k;  				if (item != null) {  					if (item.Equals ("tree")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						Treeish oTree = (oref as Treeish);  						if (oTree != null) {  							refId = oTree.TreeId;  						} else {  							throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  						}  					} else if (item.Equals ("commit")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is Commit)) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (item.Equals ("blob")) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  						if (!(oref is byte[])) {  							throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  						}  					} else if (string.Empty.Equals (item)) {  						oref = MapObject (refId' null);  						while (oref is Tag) {  							var t = (Tag)oref;  							refId = t.Id;  							oref = MapObject (refId' null);  						}  					} else {  						throw new RevisionSyntaxException (revision);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  				break;  			default:  				oref = MapObject (refId' null);  				Commit oComm = (oref as Commit);  				if (oComm != null) {  					ObjectId[] parents = oComm.ParentIds;  					refId = parents.Length == 0 ? null : parents [0];  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  				break;  			}  		} else {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom != null) {  				ObjectId[] parents = oCom.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  			}  		}  		break;  	case '~':  		if (oref == null) {  			var refstr = new string (revision.ToCharArray (0' i));  			refId = ResolveSimple (refstr);  			if (refId == null)  				return null;  			oref = MapObject (refId' null);  		}  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		if (!(oref is Commit)) {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  		int l;  		for (l = i + 1; l < revision.Length; ++l) {  			if (!Char.IsDigit (revision [l]))  				break;  		}  		var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  		int dist;  		try {  			dist = Convert.ToInt32 (distnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  		}  		while (dist > 0) {  			ObjectId[] parents = ((Commit)oref).ParentIds;  			if (parents.Length == 0) {  				refId = null;  				break;  			}  			refId = parents [0];  			oref = MapCommit (refId);  			--dist;  		}  		i = l - 1;  		break;  	case '@':  		int m;  		string time = null;  		for (m = i + 2; m < revision.Length; ++m) {  			if (revision [m] != '}')  				continue;  			time = new string (revision.ToCharArray (i + 2' m - i - 2));  			break;  		}  		if (time != null) {  			throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  		}  		i = m - 1;  		break;  	default:  		if (refId != null) {  			throw new RevisionSyntaxException (revision);  		}  		break;  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i]) {  case '^':  	if (refId == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  	}  	if (i + 1 < revision.Length) {  		switch (revision [i + 1]) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			int j;  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom == null) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			for (j = i + 1; j < revision.Length; ++j) {  				if (!Char.IsDigit (revision [j]))  					break;  			}  			var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  			int pnum;  			try {  				pnum = Convert.ToInt32 (parentnum);  			} catch (FormatException) {  				throw new RevisionSyntaxException (revision' "Invalid commit parent number");  			}  			if (pnum != 0) {  				ObjectId[] parents = oCom.ParentIds;  				if (pnum > parents.Length)  					refId = null;  				else  					refId = parents [pnum - 1];  			}  			i = j - 1;  			break;  		case '{':  			int k;  			string item = null;  			for (k = i + 2; k < revision.Length; ++k) {  				if (revision [k] != '}')  					continue;  				item = new string (revision.ToCharArray (i + 2' k - i - 2));  				break;  			}  			i = k;  			if (item != null) {  				if (item.Equals ("tree")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					Treeish oTree = (oref as Treeish);  					if (oTree != null) {  						refId = oTree.TreeId;  					} else {  						throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  					}  				} else if (item.Equals ("commit")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is Commit)) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (item.Equals ("blob")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is byte[])) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (string.Empty.Equals (item)) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  			break;  		default:  			oref = MapObject (refId' null);  			Commit oComm = (oref as Commit);  			if (oComm != null) {  				ObjectId[] parents = oComm.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			break;  		}  	} else {  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom != null) {  			ObjectId[] parents = oCom.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  	}  	break;  case '~':  	if (oref == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  		oref = MapObject (refId' null);  	}  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	if (!(oref is Commit)) {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  	int l;  	for (l = i + 1; l < revision.Length; ++l) {  		if (!Char.IsDigit (revision [l]))  			break;  	}  	var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  	int dist;  	try {  		dist = Convert.ToInt32 (distnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  	}  	while (dist > 0) {  		ObjectId[] parents = ((Commit)oref).ParentIds;  		if (parents.Length == 0) {  			refId = null;  			break;  		}  		refId = parents [0];  		oref = MapCommit (refId);  		--dist;  	}  	i = l - 1;  	break;  case '@':  	int m;  	string time = null;  	for (m = i + 2; m < revision.Length; ++m) {  		if (revision [m] != '}')  			continue;  		time = new string (revision.ToCharArray (i + 2' m - i - 2));  		break;  	}  	if (time != null) {  		throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  	}  	i = m - 1;  	break;  default:  	if (refId != null) {  		throw new RevisionSyntaxException (revision);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i]) {  case '^':  	if (refId == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  	}  	if (i + 1 < revision.Length) {  		switch (revision [i + 1]) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			int j;  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom == null) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			for (j = i + 1; j < revision.Length; ++j) {  				if (!Char.IsDigit (revision [j]))  					break;  			}  			var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  			int pnum;  			try {  				pnum = Convert.ToInt32 (parentnum);  			} catch (FormatException) {  				throw new RevisionSyntaxException (revision' "Invalid commit parent number");  			}  			if (pnum != 0) {  				ObjectId[] parents = oCom.ParentIds;  				if (pnum > parents.Length)  					refId = null;  				else  					refId = parents [pnum - 1];  			}  			i = j - 1;  			break;  		case '{':  			int k;  			string item = null;  			for (k = i + 2; k < revision.Length; ++k) {  				if (revision [k] != '}')  					continue;  				item = new string (revision.ToCharArray (i + 2' k - i - 2));  				break;  			}  			i = k;  			if (item != null) {  				if (item.Equals ("tree")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					Treeish oTree = (oref as Treeish);  					if (oTree != null) {  						refId = oTree.TreeId;  					} else {  						throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  					}  				} else if (item.Equals ("commit")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is Commit)) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (item.Equals ("blob")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is byte[])) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (string.Empty.Equals (item)) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  			break;  		default:  			oref = MapObject (refId' null);  			Commit oComm = (oref as Commit);  			if (oComm != null) {  				ObjectId[] parents = oComm.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			break;  		}  	} else {  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom != null) {  			ObjectId[] parents = oCom.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  	}  	break;  case '~':  	if (oref == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  		oref = MapObject (refId' null);  	}  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	if (!(oref is Commit)) {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  	int l;  	for (l = i + 1; l < revision.Length; ++l) {  		if (!Char.IsDigit (revision [l]))  			break;  	}  	var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  	int dist;  	try {  		dist = Convert.ToInt32 (distnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  	}  	while (dist > 0) {  		ObjectId[] parents = ((Commit)oref).ParentIds;  		if (parents.Length == 0) {  			refId = null;  			break;  		}  		refId = parents [0];  		oref = MapCommit (refId);  		--dist;  	}  	i = l - 1;  	break;  case '@':  	int m;  	string time = null;  	for (m = i + 2; m < revision.Length; ++m) {  		if (revision [m] != '}')  			continue;  		time = new string (revision.ToCharArray (i + 2' m - i - 2));  		break;  	}  	if (time != null) {  		throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  	}  	i = m - 1;  	break;  default:  	if (refId != null) {  		throw new RevisionSyntaxException (revision);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i]) {  case '^':  	if (refId == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  	}  	if (i + 1 < revision.Length) {  		switch (revision [i + 1]) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			int j;  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom == null) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			for (j = i + 1; j < revision.Length; ++j) {  				if (!Char.IsDigit (revision [j]))  					break;  			}  			var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  			int pnum;  			try {  				pnum = Convert.ToInt32 (parentnum);  			} catch (FormatException) {  				throw new RevisionSyntaxException (revision' "Invalid commit parent number");  			}  			if (pnum != 0) {  				ObjectId[] parents = oCom.ParentIds;  				if (pnum > parents.Length)  					refId = null;  				else  					refId = parents [pnum - 1];  			}  			i = j - 1;  			break;  		case '{':  			int k;  			string item = null;  			for (k = i + 2; k < revision.Length; ++k) {  				if (revision [k] != '}')  					continue;  				item = new string (revision.ToCharArray (i + 2' k - i - 2));  				break;  			}  			i = k;  			if (item != null) {  				if (item.Equals ("tree")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					Treeish oTree = (oref as Treeish);  					if (oTree != null) {  						refId = oTree.TreeId;  					} else {  						throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  					}  				} else if (item.Equals ("commit")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is Commit)) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (item.Equals ("blob")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is byte[])) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (string.Empty.Equals (item)) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  			break;  		default:  			oref = MapObject (refId' null);  			Commit oComm = (oref as Commit);  			if (oComm != null) {  				ObjectId[] parents = oComm.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			break;  		}  	} else {  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom != null) {  			ObjectId[] parents = oCom.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  	}  	break;  case '~':  	if (oref == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  		oref = MapObject (refId' null);  	}  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	if (!(oref is Commit)) {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  	int l;  	for (l = i + 1; l < revision.Length; ++l) {  		if (!Char.IsDigit (revision [l]))  			break;  	}  	var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  	int dist;  	try {  		dist = Convert.ToInt32 (distnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  	}  	while (dist > 0) {  		ObjectId[] parents = ((Commit)oref).ParentIds;  		if (parents.Length == 0) {  			refId = null;  			break;  		}  		refId = parents [0];  		oref = MapCommit (refId);  		--dist;  	}  	i = l - 1;  	break;  case '@':  	int m;  	string time = null;  	for (m = i + 2; m < revision.Length; ++m) {  		if (revision [m] != '}')  			continue;  		time = new string (revision.ToCharArray (i + 2' m - i - 2));  		break;  	}  	if (time != null) {  		throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  	}  	i = m - 1;  	break;  default:  	if (refId != null) {  		throw new RevisionSyntaxException (revision);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i]) {  case '^':  	if (refId == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  	}  	if (i + 1 < revision.Length) {  		switch (revision [i + 1]) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			int j;  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom == null) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			for (j = i + 1; j < revision.Length; ++j) {  				if (!Char.IsDigit (revision [j]))  					break;  			}  			var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  			int pnum;  			try {  				pnum = Convert.ToInt32 (parentnum);  			} catch (FormatException) {  				throw new RevisionSyntaxException (revision' "Invalid commit parent number");  			}  			if (pnum != 0) {  				ObjectId[] parents = oCom.ParentIds;  				if (pnum > parents.Length)  					refId = null;  				else  					refId = parents [pnum - 1];  			}  			i = j - 1;  			break;  		case '{':  			int k;  			string item = null;  			for (k = i + 2; k < revision.Length; ++k) {  				if (revision [k] != '}')  					continue;  				item = new string (revision.ToCharArray (i + 2' k - i - 2));  				break;  			}  			i = k;  			if (item != null) {  				if (item.Equals ("tree")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					Treeish oTree = (oref as Treeish);  					if (oTree != null) {  						refId = oTree.TreeId;  					} else {  						throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  					}  				} else if (item.Equals ("commit")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is Commit)) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (item.Equals ("blob")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is byte[])) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (string.Empty.Equals (item)) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  			break;  		default:  			oref = MapObject (refId' null);  			Commit oComm = (oref as Commit);  			if (oComm != null) {  				ObjectId[] parents = oComm.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			break;  		}  	} else {  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom != null) {  			ObjectId[] parents = oCom.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  	}  	break;  case '~':  	if (oref == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  		oref = MapObject (refId' null);  	}  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	if (!(oref is Commit)) {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  	int l;  	for (l = i + 1; l < revision.Length; ++l) {  		if (!Char.IsDigit (revision [l]))  			break;  	}  	var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  	int dist;  	try {  		dist = Convert.ToInt32 (distnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  	}  	while (dist > 0) {  		ObjectId[] parents = ((Commit)oref).ParentIds;  		if (parents.Length == 0) {  			refId = null;  			break;  		}  		refId = parents [0];  		oref = MapCommit (refId);  		--dist;  	}  	i = l - 1;  	break;  case '@':  	int m;  	string time = null;  	for (m = i + 2; m < revision.Length; ++m) {  		if (revision [m] != '}')  			continue;  		time = new string (revision.ToCharArray (i + 2' m - i - 2));  		break;  	}  	if (time != null) {  		throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  	}  	i = m - 1;  	break;  default:  	if (refId != null) {  		throw new RevisionSyntaxException (revision);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i]) {  case '^':  	if (refId == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  	}  	if (i + 1 < revision.Length) {  		switch (revision [i + 1]) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			int j;  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom == null) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			for (j = i + 1; j < revision.Length; ++j) {  				if (!Char.IsDigit (revision [j]))  					break;  			}  			var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  			int pnum;  			try {  				pnum = Convert.ToInt32 (parentnum);  			} catch (FormatException) {  				throw new RevisionSyntaxException (revision' "Invalid commit parent number");  			}  			if (pnum != 0) {  				ObjectId[] parents = oCom.ParentIds;  				if (pnum > parents.Length)  					refId = null;  				else  					refId = parents [pnum - 1];  			}  			i = j - 1;  			break;  		case '{':  			int k;  			string item = null;  			for (k = i + 2; k < revision.Length; ++k) {  				if (revision [k] != '}')  					continue;  				item = new string (revision.ToCharArray (i + 2' k - i - 2));  				break;  			}  			i = k;  			if (item != null) {  				if (item.Equals ("tree")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					Treeish oTree = (oref as Treeish);  					if (oTree != null) {  						refId = oTree.TreeId;  					} else {  						throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  					}  				} else if (item.Equals ("commit")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is Commit)) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (item.Equals ("blob")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is byte[])) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (string.Empty.Equals (item)) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  			break;  		default:  			oref = MapObject (refId' null);  			Commit oComm = (oref as Commit);  			if (oComm != null) {  				ObjectId[] parents = oComm.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			break;  		}  	} else {  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom != null) {  			ObjectId[] parents = oCom.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  	}  	break;  case '~':  	if (oref == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  		oref = MapObject (refId' null);  	}  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	if (!(oref is Commit)) {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  	int l;  	for (l = i + 1; l < revision.Length; ++l) {  		if (!Char.IsDigit (revision [l]))  			break;  	}  	var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  	int dist;  	try {  		dist = Convert.ToInt32 (distnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  	}  	while (dist > 0) {  		ObjectId[] parents = ((Commit)oref).ParentIds;  		if (parents.Length == 0) {  			refId = null;  			break;  		}  		refId = parents [0];  		oref = MapCommit (refId);  		--dist;  	}  	i = l - 1;  	break;  case '@':  	int m;  	string time = null;  	for (m = i + 2; m < revision.Length; ++m) {  		if (revision [m] != '}')  			continue;  		time = new string (revision.ToCharArray (i + 2' m - i - 2));  		break;  	}  	if (time != null) {  		throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  	}  	i = m - 1;  	break;  default:  	if (refId != null) {  		throw new RevisionSyntaxException (revision);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i]) {  case '^':  	if (refId == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  	}  	if (i + 1 < revision.Length) {  		switch (revision [i + 1]) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			int j;  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var tag = (Tag)oref;  				refId = tag.Id;  				oref = MapObject (refId' null);  			}  			Commit oCom = (oref as Commit);  			if (oCom == null) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			for (j = i + 1; j < revision.Length; ++j) {  				if (!Char.IsDigit (revision [j]))  					break;  			}  			var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  			int pnum;  			try {  				pnum = Convert.ToInt32 (parentnum);  			} catch (FormatException) {  				throw new RevisionSyntaxException (revision' "Invalid commit parent number");  			}  			if (pnum != 0) {  				ObjectId[] parents = oCom.ParentIds;  				if (pnum > parents.Length)  					refId = null;  				else  					refId = parents [pnum - 1];  			}  			i = j - 1;  			break;  		case '{':  			int k;  			string item = null;  			for (k = i + 2; k < revision.Length; ++k) {  				if (revision [k] != '}')  					continue;  				item = new string (revision.ToCharArray (i + 2' k - i - 2));  				break;  			}  			i = k;  			if (item != null) {  				if (item.Equals ("tree")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					Treeish oTree = (oref as Treeish);  					if (oTree != null) {  						refId = oTree.TreeId;  					} else {  						throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  					}  				} else if (item.Equals ("commit")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is Commit)) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (item.Equals ("blob")) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  					if (!(oref is byte[])) {  						throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  					}  				} else if (string.Empty.Equals (item)) {  					oref = MapObject (refId' null);  					while (oref is Tag) {  						var t = (Tag)oref;  						refId = t.Id;  						oref = MapObject (refId' null);  					}  				} else {  					throw new RevisionSyntaxException (revision);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  			break;  		default:  			oref = MapObject (refId' null);  			Commit oComm = (oref as Commit);  			if (oComm != null) {  				ObjectId[] parents = oComm.ParentIds;  				refId = parents.Length == 0 ? null : parents [0];  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  			break;  		}  	} else {  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom != null) {  			ObjectId[] parents = oCom.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  		}  	}  	break;  case '~':  	if (oref == null) {  		var refstr = new string (revision.ToCharArray (0' i));  		refId = ResolveSimple (refstr);  		if (refId == null)  			return null;  		oref = MapObject (refId' null);  	}  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	if (!(oref is Commit)) {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  	int l;  	for (l = i + 1; l < revision.Length; ++l) {  		if (!Char.IsDigit (revision [l]))  			break;  	}  	var distnum = new string (revision.ToCharArray (i + 1' l - i - 1));  	int dist;  	try {  		dist = Convert.ToInt32 (distnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException ("Invalid ancestry length"' revision);  	}  	while (dist > 0) {  		ObjectId[] parents = ((Commit)oref).ParentIds;  		if (parents.Length == 0) {  			refId = null;  			break;  		}  		refId = parents [0];  		oref = MapCommit (refId);  		--dist;  	}  	i = l - 1;  	break;  case '@':  	int m;  	string time = null;  	for (m = i + 2; m < revision.Length; ++m) {  		if (revision [m] != '}')  			continue;  		time = new string (revision.ToCharArray (i + 2' m - i - 2));  		break;  	}  	if (time != null) {  		throw new RevisionSyntaxException ("reflogs not yet supported by revision parser yet"' revision);  	}  	i = m - 1;  	break;  default:  	if (refId != null) {  		throw new RevisionSyntaxException (revision);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: if (i + 1 < revision.Length) {  	switch (revision [i + 1]) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		int j;  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom == null) {  			throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  		}  		for (j = i + 1; j < revision.Length; ++j) {  			if (!Char.IsDigit (revision [j]))  				break;  		}  		var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  		int pnum;  		try {  			pnum = Convert.ToInt32 (parentnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException (revision' "Invalid commit parent number");  		}  		if (pnum != 0) {  			ObjectId[] parents = oCom.ParentIds;  			if (pnum > parents.Length)  				refId = null;  			else  				refId = parents [pnum - 1];  		}  		i = j - 1;  		break;  	case '{':  		int k;  		string item = null;  		for (k = i + 2; k < revision.Length; ++k) {  			if (revision [k] != '}')  				continue;  			item = new string (revision.ToCharArray (i + 2' k - i - 2));  			break;  		}  		i = k;  		if (item != null) {  			if (item.Equals ("tree")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				Treeish oTree = (oref as Treeish);  				if (oTree != null) {  					refId = oTree.TreeId;  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  				}  			} else if (item.Equals ("commit")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				if (!(oref is Commit)) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  			} else if (item.Equals ("blob")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				if (!(oref is byte[])) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  			} else if (string.Empty.Equals (item)) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  		} else {  			throw new RevisionSyntaxException (revision);  		}  		break;  	default:  		oref = MapObject (refId' null);  		Commit oComm = (oref as Commit);  		if (oComm != null) {  			ObjectId[] parents = oComm.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  		}  		break;  	}  } else {  	oref = MapObject (refId' null);  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	Commit oCom = (oref as Commit);  	if (oCom != null) {  		ObjectId[] parents = oCom.ParentIds;  		refId = parents.Length == 0 ? null : parents [0];  	} else {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: if (i + 1 < revision.Length) {  	switch (revision [i + 1]) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		int j;  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom == null) {  			throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  		}  		for (j = i + 1; j < revision.Length; ++j) {  			if (!Char.IsDigit (revision [j]))  				break;  		}  		var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  		int pnum;  		try {  			pnum = Convert.ToInt32 (parentnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException (revision' "Invalid commit parent number");  		}  		if (pnum != 0) {  			ObjectId[] parents = oCom.ParentIds;  			if (pnum > parents.Length)  				refId = null;  			else  				refId = parents [pnum - 1];  		}  		i = j - 1;  		break;  	case '{':  		int k;  		string item = null;  		for (k = i + 2; k < revision.Length; ++k) {  			if (revision [k] != '}')  				continue;  			item = new string (revision.ToCharArray (i + 2' k - i - 2));  			break;  		}  		i = k;  		if (item != null) {  			if (item.Equals ("tree")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				Treeish oTree = (oref as Treeish);  				if (oTree != null) {  					refId = oTree.TreeId;  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  				}  			} else if (item.Equals ("commit")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				if (!(oref is Commit)) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  			} else if (item.Equals ("blob")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				if (!(oref is byte[])) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  			} else if (string.Empty.Equals (item)) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  		} else {  			throw new RevisionSyntaxException (revision);  		}  		break;  	default:  		oref = MapObject (refId' null);  		Commit oComm = (oref as Commit);  		if (oComm != null) {  			ObjectId[] parents = oComm.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  		}  		break;  	}  } else {  	oref = MapObject (refId' null);  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	Commit oCom = (oref as Commit);  	if (oCom != null) {  		ObjectId[] parents = oCom.ParentIds;  		refId = parents.Length == 0 ? null : parents [0];  	} else {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: if (i + 1 < revision.Length) {  	switch (revision [i + 1]) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		int j;  		oref = MapObject (refId' null);  		while (oref is Tag) {  			var tag = (Tag)oref;  			refId = tag.Id;  			oref = MapObject (refId' null);  		}  		Commit oCom = (oref as Commit);  		if (oCom == null) {  			throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  		}  		for (j = i + 1; j < revision.Length; ++j) {  			if (!Char.IsDigit (revision [j]))  				break;  		}  		var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  		int pnum;  		try {  			pnum = Convert.ToInt32 (parentnum);  		} catch (FormatException) {  			throw new RevisionSyntaxException (revision' "Invalid commit parent number");  		}  		if (pnum != 0) {  			ObjectId[] parents = oCom.ParentIds;  			if (pnum > parents.Length)  				refId = null;  			else  				refId = parents [pnum - 1];  		}  		i = j - 1;  		break;  	case '{':  		int k;  		string item = null;  		for (k = i + 2; k < revision.Length; ++k) {  			if (revision [k] != '}')  				continue;  			item = new string (revision.ToCharArray (i + 2' k - i - 2));  			break;  		}  		i = k;  		if (item != null) {  			if (item.Equals ("tree")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				Treeish oTree = (oref as Treeish);  				if (oTree != null) {  					refId = oTree.TreeId;  				} else {  					throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  				}  			} else if (item.Equals ("commit")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				if (!(oref is Commit)) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  			} else if (item.Equals ("blob")) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  				if (!(oref is byte[])) {  					throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  				}  			} else if (string.Empty.Equals (item)) {  				oref = MapObject (refId' null);  				while (oref is Tag) {  					var t = (Tag)oref;  					refId = t.Id;  					oref = MapObject (refId' null);  				}  			} else {  				throw new RevisionSyntaxException (revision);  			}  		} else {  			throw new RevisionSyntaxException (revision);  		}  		break;  	default:  		oref = MapObject (refId' null);  		Commit oComm = (oref as Commit);  		if (oComm != null) {  			ObjectId[] parents = oComm.ParentIds;  			refId = parents.Length == 0 ? null : parents [0];  		} else {  			throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  		}  		break;  	}  } else {  	oref = MapObject (refId' null);  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	Commit oCom = (oref as Commit);  	if (oCom != null) {  		ObjectId[] parents = oCom.ParentIds;  		refId = parents.Length == 0 ? null : parents [0];  	} else {  		throw new IncorrectObjectTypeException (refId' Constants.TYPE_COMMIT);  	}  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i + 1]) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	int j;  	oref = MapObject (refId' null);  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	Commit oCom = (oref as Commit);  	if (oCom == null) {  		throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  	}  	for (j = i + 1; j < revision.Length; ++j) {  		if (!Char.IsDigit (revision [j]))  			break;  	}  	var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  	int pnum;  	try {  		pnum = Convert.ToInt32 (parentnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException (revision' "Invalid commit parent number");  	}  	if (pnum != 0) {  		ObjectId[] parents = oCom.ParentIds;  		if (pnum > parents.Length)  			refId = null;  		else  			refId = parents [pnum - 1];  	}  	i = j - 1;  	break;  case '{':  	int k;  	string item = null;  	for (k = i + 2; k < revision.Length; ++k) {  		if (revision [k] != '}')  			continue;  		item = new string (revision.ToCharArray (i + 2' k - i - 2));  		break;  	}  	i = k;  	if (item != null) {  		if (item.Equals ("tree")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			Treeish oTree = (oref as Treeish);  			if (oTree != null) {  				refId = oTree.TreeId;  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  			}  		} else if (item.Equals ("commit")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			if (!(oref is Commit)) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  		} else if (item.Equals ("blob")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			if (!(oref is byte[])) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  		} else if (string.Empty.Equals (item)) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  		} else {  			throw new RevisionSyntaxException (revision);  		}  	} else {  		throw new RevisionSyntaxException (revision);  	}  	break;  default:  	oref = MapObject (refId' null);  	Commit oComm = (oref as Commit);  	if (oComm != null) {  		ObjectId[] parents = oComm.ParentIds;  		refId = parents.Length == 0 ? null : parents [0];  	} else {  		throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i + 1]) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	int j;  	oref = MapObject (refId' null);  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	Commit oCom = (oref as Commit);  	if (oCom == null) {  		throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  	}  	for (j = i + 1; j < revision.Length; ++j) {  		if (!Char.IsDigit (revision [j]))  			break;  	}  	var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  	int pnum;  	try {  		pnum = Convert.ToInt32 (parentnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException (revision' "Invalid commit parent number");  	}  	if (pnum != 0) {  		ObjectId[] parents = oCom.ParentIds;  		if (pnum > parents.Length)  			refId = null;  		else  			refId = parents [pnum - 1];  	}  	i = j - 1;  	break;  case '{':  	int k;  	string item = null;  	for (k = i + 2; k < revision.Length; ++k) {  		if (revision [k] != '}')  			continue;  		item = new string (revision.ToCharArray (i + 2' k - i - 2));  		break;  	}  	i = k;  	if (item != null) {  		if (item.Equals ("tree")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			Treeish oTree = (oref as Treeish);  			if (oTree != null) {  				refId = oTree.TreeId;  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  			}  		} else if (item.Equals ("commit")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			if (!(oref is Commit)) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  		} else if (item.Equals ("blob")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			if (!(oref is byte[])) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  		} else if (string.Empty.Equals (item)) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  		} else {  			throw new RevisionSyntaxException (revision);  		}  	} else {  		throw new RevisionSyntaxException (revision);  	}  	break;  default:  	oref = MapObject (refId' null);  	Commit oComm = (oref as Commit);  	if (oComm != null) {  		ObjectId[] parents = oComm.ParentIds;  		refId = parents.Length == 0 ? null : parents [0];  	} else {  		throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: switch (revision [i + 1]) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	int j;  	oref = MapObject (refId' null);  	while (oref is Tag) {  		var tag = (Tag)oref;  		refId = tag.Id;  		oref = MapObject (refId' null);  	}  	Commit oCom = (oref as Commit);  	if (oCom == null) {  		throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  	}  	for (j = i + 1; j < revision.Length; ++j) {  		if (!Char.IsDigit (revision [j]))  			break;  	}  	var parentnum = new string (revision.ToCharArray (i + 1' j - i - 1));  	int pnum;  	try {  		pnum = Convert.ToInt32 (parentnum);  	} catch (FormatException) {  		throw new RevisionSyntaxException (revision' "Invalid commit parent number");  	}  	if (pnum != 0) {  		ObjectId[] parents = oCom.ParentIds;  		if (pnum > parents.Length)  			refId = null;  		else  			refId = parents [pnum - 1];  	}  	i = j - 1;  	break;  case '{':  	int k;  	string item = null;  	for (k = i + 2; k < revision.Length; ++k) {  		if (revision [k] != '}')  			continue;  		item = new string (revision.ToCharArray (i + 2' k - i - 2));  		break;  	}  	i = k;  	if (item != null) {  		if (item.Equals ("tree")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			Treeish oTree = (oref as Treeish);  			if (oTree != null) {  				refId = oTree.TreeId;  			} else {  				throw new IncorrectObjectTypeException (refId' ObjectType.Tree);  			}  		} else if (item.Equals ("commit")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			if (!(oref is Commit)) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  		} else if (item.Equals ("blob")) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  			if (!(oref is byte[])) {  				throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  			}  		} else if (string.Empty.Equals (item)) {  			oref = MapObject (refId' null);  			while (oref is Tag) {  				var t = (Tag)oref;  				refId = t.Id;  				oref = MapObject (refId' null);  			}  		} else {  			throw new RevisionSyntaxException (revision);  		}  	} else {  		throw new RevisionSyntaxException (revision);  	}  	break;  default:  	oref = MapObject (refId' null);  	Commit oComm = (oref as Commit);  	if (oComm != null) {  		ObjectId[] parents = oComm.ParentIds;  		refId = parents.Length == 0 ? null : parents [0];  	} else {  		throw new IncorrectObjectTypeException (refId' ObjectType.Commit);  	}  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (k = i + 2; k < revision.Length; ++k) {  	if (revision [k] != '}')  		continue;  	item = new string (revision.ToCharArray (i + 2' k - i - 2));  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (k = i + 2; k < revision.Length; ++k) {  	if (revision [k] != '}')  		continue;  	item = new string (revision.ToCharArray (i + 2' k - i - 2));  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (k = i + 2; k < revision.Length; ++k) {  	if (revision [k] != '}')  		continue;  	item = new string (revision.ToCharArray (i + 2' k - i - 2));  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: k = i + 2
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: item = new string (revision.ToCharArray (i + 2' k - i - 2));  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: item = new string (revision.ToCharArray (i + 2' k - i - 2));  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (m = i + 2; m < revision.Length; ++m) {  	if (revision [m] != '}')  		continue;  	time = new string (revision.ToCharArray (i + 2' m - i - 2));  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (m = i + 2; m < revision.Length; ++m) {  	if (revision [m] != '}')  		continue;  	time = new string (revision.ToCharArray (i + 2' m - i - 2));  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (m = i + 2; m < revision.Length; ++m) {  	if (revision [m] != '}')  		continue;  	time = new string (revision.ToCharArray (i + 2' m - i - 2));  	break;  }  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: m = i + 2
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: time = new string (revision.ToCharArray (i + 2' m - i - 2));  
Magic Number,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: time = new string (revision.ToCharArray (i + 2' m - i - 2));  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,Tag,The following statement contains a magic number: if (raw != null) {  	TagId = id;  	Id = ObjectId.FromString (raw' 7);  } else  	Id = id;  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,Tag,The following statement contains a magic number: Id = ObjectId.FromString (raw' 7);  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,Tag,The following statement contains a magic number: if (refName != null && refName.StartsWith ("refs/tags/"))  	refName = refName.Substring (10);  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,Tag,The following statement contains a magic number: refName = refName.Substring (10);  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,decode,The following statement contains a magic number: using (var br = new StreamReader (new MemoryStream (raw))) {  	string n = br.ReadLine ();  	if (n == null || !n.StartsWith ("object ")) {  		throw new CorruptObjectException (TagId' "no object");  	}  	Id = ObjectId.FromString (n.Substring (7));  	n = br.ReadLine ();  	if (n == null || !n.StartsWith ("type ")) {  		throw new CorruptObjectException (TagId' "no type");  	}  	TagType = n.Substring ("type ".Length);  	n = br.ReadLine ();  	if (n == null || !n.StartsWith ("tag ")) {  		throw new CorruptObjectException (TagId' "no tag name");  	}  	TagName = n.Substring ("tag ".Length);  	n = br.ReadLine ();  	// We should see a "tagger" header here' but some repos have tags  	// without it.  	if (n == null)  		throw new CorruptObjectException (TagId' "no tagger header");  	if (n.Length > 0)  		if (n.StartsWith ("tagger "))  			Tagger = new PersonIdent (n.Substring ("tagger ".Length));  		else  			throw new CorruptObjectException (TagId' "no tagger/bad header");  	// Message should start with an empty line' but  	StringBuilder tempMessage = new StringBuilder ();  	char[] readBuf = new char[2048];  	int readLen;  	int readIndex = 0;  	while ((readLen = br.Read (readBuf' readIndex' readBuf.Length)) > 0) {  		//readIndex += readLen;  		tempMessage.Append (readBuf' 0' readLen);  	}  	message = tempMessage.ToString ();  	if (message.StartsWith ("\n"))  		message = message.Substring (1);  }  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,decode,The following statement contains a magic number: using (var br = new StreamReader (new MemoryStream (raw))) {  	string n = br.ReadLine ();  	if (n == null || !n.StartsWith ("object ")) {  		throw new CorruptObjectException (TagId' "no object");  	}  	Id = ObjectId.FromString (n.Substring (7));  	n = br.ReadLine ();  	if (n == null || !n.StartsWith ("type ")) {  		throw new CorruptObjectException (TagId' "no type");  	}  	TagType = n.Substring ("type ".Length);  	n = br.ReadLine ();  	if (n == null || !n.StartsWith ("tag ")) {  		throw new CorruptObjectException (TagId' "no tag name");  	}  	TagName = n.Substring ("tag ".Length);  	n = br.ReadLine ();  	// We should see a "tagger" header here' but some repos have tags  	// without it.  	if (n == null)  		throw new CorruptObjectException (TagId' "no tagger header");  	if (n.Length > 0)  		if (n.StartsWith ("tagger "))  			Tagger = new PersonIdent (n.Substring ("tagger ".Length));  		else  			throw new CorruptObjectException (TagId' "no tagger/bad header");  	// Message should start with an empty line' but  	StringBuilder tempMessage = new StringBuilder ();  	char[] readBuf = new char[2048];  	int readLen;  	int readIndex = 0;  	while ((readLen = br.Read (readBuf' readIndex' readBuf.Length)) > 0) {  		//readIndex += readLen;  		tempMessage.Append (readBuf' 0' readLen);  	}  	message = tempMessage.ToString ();  	if (message.StartsWith ("\n"))  		message = message.Substring (1);  }  
Magic Number,GitSharp.Core,Tag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tag.cs,decode,The following statement contains a magic number: Id = ObjectId.FromString (n.Substring (7));  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if (!_output && ((DateTime.Now - _taskBeganAt).TotalMilliseconds < 500))  	return;  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	Display (cmp);  	_writer.Flush ();  } else if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork) {  	Display (cmp);  	_writer.Flush ();  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	Display (cmp);  	_writer.Flush ();  } else if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork) {  	Display (cmp);  	_writer.Flush ();  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork) {  	Display (cmp);  	_writer.Flush ();  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork) {  	Display (cmp);  	_writer.Flush ();  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: while (m.Length < 25) {  	m.Append (' ');  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	m.Append (cmp);  } else {  	string twstr = _totalWork.ToString ();  	string cmpstr = cmp.ToString ();  	while (cmpstr.Length < twstr.Length) {  		cmpstr = " " + cmpstr;  	}  	int pcnt = (cmp * 100 / _totalWork);  	if (pcnt < 100) {  		m.Append (' ');  	}  	if (pcnt < 10) {  		m.Append (' ');  	}  	m.Append (pcnt);  	m.Append ("% (");  	m.Append (cmpstr);  	m.Append ("/");  	m.Append (twstr);  	m.Append (")");  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	m.Append (cmp);  } else {  	string twstr = _totalWork.ToString ();  	string cmpstr = cmp.ToString ();  	while (cmpstr.Length < twstr.Length) {  		cmpstr = " " + cmpstr;  	}  	int pcnt = (cmp * 100 / _totalWork);  	if (pcnt < 100) {  		m.Append (' ');  	}  	if (pcnt < 10) {  		m.Append (' ');  	}  	m.Append (pcnt);  	m.Append ("% (");  	m.Append (cmpstr);  	m.Append ("/");  	m.Append (twstr);  	m.Append (")");  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	m.Append (cmp);  } else {  	string twstr = _totalWork.ToString ();  	string cmpstr = cmp.ToString ();  	while (cmpstr.Length < twstr.Length) {  		cmpstr = " " + cmpstr;  	}  	int pcnt = (cmp * 100 / _totalWork);  	if (pcnt < 100) {  		m.Append (' ');  	}  	if (pcnt < 10) {  		m.Append (' ');  	}  	m.Append (pcnt);  	m.Append ("% (");  	m.Append (cmpstr);  	m.Append ("/");  	m.Append (twstr);  	m.Append (")");  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (pcnt < 100) {  	m.Append (' ');  }  
Magic Number,GitSharp.Core,TextProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (pcnt < 10) {  	m.Append (' ');  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: while (rawPtr < rawSize) {  	int c = raw [rawPtr++];  	if (c < '0' || c > '7') {  		throw new CorruptObjectException (Id' "invalid entry mode");  	}  	int mode = c - '0';  	while (true) {  		c = raw [rawPtr++];  		if (' ' == c)  			break;  		if (c < '0' || c > '7') {  			throw new CorruptObjectException (Id' "invalid mode");  		}  		mode <<= 3;  		mode += c - '0';  	}  	int nameLen = 0;  	while (raw [rawPtr + nameLen] != 0) {  		nameLen++;  	}  	var name = new byte[nameLen];  	Array.Copy (raw' rawPtr' name' 0' nameLen);  	rawPtr += nameLen + 1;  	ObjectId id = ObjectId.FromRaw (raw' rawPtr);  	rawPtr += Constants.OBJECT_ID_LENGTH;  	TreeEntry ent;  	if (FileMode.RegularFile.Equals (mode)) {  		ent = new FileTreeEntry (this' id' name' false);  	} else if (FileMode.ExecutableFile.Equals (mode)) {  		ent = new FileTreeEntry (this' id' name' true);  	} else if (FileMode.Tree.Equals (mode)) {  		ent = new Tree (this' id' name);  	} else if (FileMode.Symlink.Equals (mode)) {  		ent = new SymlinkTreeEntry (this' id' name);  	} else if (FileMode.GitLink.Equals (mode)) {  		ent = new GitLinkTreeEntry (this' id' name);  	} else {  		throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  	}  	temp [nextIndex++] = ent;  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: while (rawPtr < rawSize) {  	int c = raw [rawPtr++];  	if (c < '0' || c > '7') {  		throw new CorruptObjectException (Id' "invalid entry mode");  	}  	int mode = c - '0';  	while (true) {  		c = raw [rawPtr++];  		if (' ' == c)  			break;  		if (c < '0' || c > '7') {  			throw new CorruptObjectException (Id' "invalid mode");  		}  		mode <<= 3;  		mode += c - '0';  	}  	int nameLen = 0;  	while (raw [rawPtr + nameLen] != 0) {  		nameLen++;  	}  	var name = new byte[nameLen];  	Array.Copy (raw' rawPtr' name' 0' nameLen);  	rawPtr += nameLen + 1;  	ObjectId id = ObjectId.FromRaw (raw' rawPtr);  	rawPtr += Constants.OBJECT_ID_LENGTH;  	TreeEntry ent;  	if (FileMode.RegularFile.Equals (mode)) {  		ent = new FileTreeEntry (this' id' name' false);  	} else if (FileMode.ExecutableFile.Equals (mode)) {  		ent = new FileTreeEntry (this' id' name' true);  	} else if (FileMode.Tree.Equals (mode)) {  		ent = new Tree (this' id' name);  	} else if (FileMode.Symlink.Equals (mode)) {  		ent = new SymlinkTreeEntry (this' id' name);  	} else if (FileMode.GitLink.Equals (mode)) {  		ent = new GitLinkTreeEntry (this' id' name);  	} else {  		throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  	}  	temp [nextIndex++] = ent;  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: while (true) {  	c = raw [rawPtr++];  	if (' ' == c)  		break;  	if (c < '0' || c > '7') {  		throw new CorruptObjectException (Id' "invalid mode");  	}  	mode <<= 3;  	mode += c - '0';  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: mode <<= 3;  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: if (FileMode.RegularFile.Equals (mode)) {  	ent = new FileTreeEntry (this' id' name' false);  } else if (FileMode.ExecutableFile.Equals (mode)) {  	ent = new FileTreeEntry (this' id' name' true);  } else if (FileMode.Tree.Equals (mode)) {  	ent = new Tree (this' id' name);  } else if (FileMode.Symlink.Equals (mode)) {  	ent = new SymlinkTreeEntry (this' id' name);  } else if (FileMode.GitLink.Equals (mode)) {  	ent = new GitLinkTreeEntry (this' id' name);  } else {  	throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: if (FileMode.ExecutableFile.Equals (mode)) {  	ent = new FileTreeEntry (this' id' name' true);  } else if (FileMode.Tree.Equals (mode)) {  	ent = new Tree (this' id' name);  } else if (FileMode.Symlink.Equals (mode)) {  	ent = new SymlinkTreeEntry (this' id' name);  } else if (FileMode.GitLink.Equals (mode)) {  	ent = new GitLinkTreeEntry (this' id' name);  } else {  	throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: if (FileMode.Tree.Equals (mode)) {  	ent = new Tree (this' id' name);  } else if (FileMode.Symlink.Equals (mode)) {  	ent = new SymlinkTreeEntry (this' id' name);  } else if (FileMode.GitLink.Equals (mode)) {  	ent = new GitLinkTreeEntry (this' id' name);  } else {  	throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: if (FileMode.Symlink.Equals (mode)) {  	ent = new SymlinkTreeEntry (this' id' name);  } else if (FileMode.GitLink.Equals (mode)) {  	ent = new GitLinkTreeEntry (this' id' name);  } else {  	throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: if (FileMode.GitLink.Equals (mode)) {  	ent = new GitLinkTreeEntry (this' id' name);  } else {  	throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  }  
Magic Number,GitSharp.Core,Tree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: throw new CorruptObjectException (Id' "Invalid mode: " + Convert.ToString (mode' 8));  
Magic Number,GitSharp.Core,TreeVisitorWithCurrentDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeVisitorWithCurrentDirectory.cs,TreeVisitorWithCurrentDirectory,The following statement contains a magic number: stack = new Stack<DirectoryInfo> (16);  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try {  	int fb = compressed [0] & 0xff;  	if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  		inflater.SetInput (compressed);  		var hdr = new byte[64];  		int avail = 0;  		while (!inflater.IsFinished && avail < hdr.Length) {  			try {  				avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  			} catch (IOException dfe) {  				var coe = new CorruptObjectException (id' "bad stream"' dfe);  				//inflater.end();  				throw coe;  			}  		}  		if (avail < 5) {  			throw new CorruptObjectException (id' "no header");  		}  		var p = new MutableInteger ();  		_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  		_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  		if (_objectSize < 0) {  			throw new CorruptObjectException (id' "negative size");  		}  		if (hdr [p.value++] != 0) {  			throw new CorruptObjectException (id' "garbage after size");  		}  		_bytes = new byte[_objectSize];  		if (p.value < avail) {  			Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  		}  		Decompress (id' inflater' avail - p.value);  	} else {  		int p = 0;  		int c = compressed [p++] & 0xff;  		int typeCode = (c >> 4) & 7;  		int size = c & 15;  		int shift = 4;  		while ((c & 0x80) != 0) {  			c = compressed [p++] & 0xff;  			size += (c & 0x7f) << shift;  			shift += 7;  		}  		switch (typeCode) {  		case Constants.OBJ_COMMIT:  		case Constants.OBJ_TREE:  		case Constants.OBJ_BLOB:  		case Constants.OBJ_TAG:  			_objectType = typeCode;  			break;  		default:  			throw new CorruptObjectException (id' "invalid type");  		}  		_objectSize = size;  		_bytes = new byte[_objectSize];  		inflater.SetInput (compressed' p' compressed.Length - p);  		Decompress (id' inflater' 0);  	}  } finally {  	InflaterCache.Instance.release (inflater);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (fb == 0x78 && (((fb << 8) | compressed [1] & 0xff) % 31) == 0) {  	inflater.SetInput (compressed);  	var hdr = new byte[64];  	int avail = 0;  	while (!inflater.IsFinished && avail < hdr.Length) {  		try {  			avail += inflater.Inflate (hdr' avail' hdr.Length - avail);  		} catch (IOException dfe) {  			var coe = new CorruptObjectException (id' "bad stream"' dfe);  			//inflater.end();  			throw coe;  		}  	}  	if (avail < 5) {  		throw new CorruptObjectException (id' "no header");  	}  	var p = new MutableInteger ();  	_objectType = Constants.decodeTypeString (id' hdr' (byte)' '' p);  	_objectSize = RawParseUtils.parseBase10 (hdr' p.value' p);  	if (_objectSize < 0) {  		throw new CorruptObjectException (id' "negative size");  	}  	if (hdr [p.value++] != 0) {  		throw new CorruptObjectException (id' "garbage after size");  	}  	_bytes = new byte[_objectSize];  	if (p.value < avail) {  		Array.Copy (hdr' p.value' _bytes' 0' avail - p.value);  	}  	Decompress (id' inflater' avail - p.value);  } else {  	int p = 0;  	int c = compressed [p++] & 0xff;  	int typeCode = (c >> 4) & 7;  	int size = c & 15;  	int shift = 4;  	while ((c & 0x80) != 0) {  		c = compressed [p++] & 0xff;  		size += (c & 0x7f) << shift;  		shift += 7;  	}  	switch (typeCode) {  	case Constants.OBJ_COMMIT:  	case Constants.OBJ_TREE:  	case Constants.OBJ_BLOB:  	case Constants.OBJ_TAG:  		_objectType = typeCode;  		break;  	default:  		throw new CorruptObjectException (id' "invalid type");  	}  	_objectSize = size;  	_bytes = new byte[_objectSize];  	inflater.SetInput (compressed' p' compressed.Length - p);  	Decompress (id' inflater' 0);  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: if (avail < 5) {  	throw new CorruptObjectException (id' "no header");  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: while ((c & 0x80) != 0) {  	c = compressed [p++] & 0xff;  	size += (c & 0x7f) << shift;  	shift += 7;  }  
Magic Number,GitSharp.Core,UnpackedObjectLoader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: shift += 7;  
Magic Number,GitSharp.Core,WindowCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCache.cs,Bits,The following statement contains a magic number: if (newSize < 4096) {  	throw new ArgumentException ("Invalid window size");  }  
Magic Number,GitSharp.Core,WindowCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCache.cs,TableSize,The following statement contains a magic number: return (int)Math.Min (5 * (limit / wsz) / 2' 2000000000);  
Magic Number,GitSharp.Core,WindowCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCache.cs,TableSize,The following statement contains a magic number: return (int)Math.Min (5 * (limit / wsz) / 2' 2000000000);  
Magic Number,GitSharp.Core,WindowCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCache.cs,TableSize,The following statement contains a magic number: return (int)Math.Min (5 * (limit / wsz) / 2' 2000000000);  
Magic Number,GitSharp.Core,WindowCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCache.cs,LockCount,The following statement contains a magic number: return Math.Max (cfg.PackedGitOpenFiles' 32);  
Magic Number,GitSharp.Core,WindowCacheConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: PackedGitOpenFiles = 128;  
Magic Number,GitSharp.Core,WindowCacheConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: PackedGitLimit = 10 * Mb;  
Magic Number,GitSharp.Core,WindowCacheConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: PackedGitWindowSize = 8 * Kb;  
Magic Number,GitSharp.Core,WindowCacheConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: DeltaBaseCacheLimit = 10 * Mb;  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,PackWriter,The following statement contains a magic number: _buf = new byte[16384];  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: Array.Copy (Constants.PACK_SIGNATURE' 0' _buf' 0' 4);  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: NB.encodeInt32 (_buf' 4' PackVersionGenerated);  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: NB.encodeInt32 (_buf' 8' getObjectsNumber ());  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: _pos.Write (_buf' 0' 12);  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteDeltaObjectReuse,The following statement contains a magic number: if (DeltaBaseAsOffset && otp.DeltaBase != null) {  	WriteObjectHeader (Constants.OBJ_OFS_DELTA' reuse.RawSize);  	ObjectToPack deltaBase = otp.DeltaBase;  	long offsetDiff = otp.Offset - deltaBase.Offset;  	int localPos = _buf.Length - 1;  	_buf [localPos] = (byte)(offsetDiff & 0x7F);  	while ((offsetDiff >>= 7) > 0) {  		_buf [--localPos] = (byte)(0x80 | (--offsetDiff & 0x7F));  	}  	_pos.Write (_buf' localPos' _buf.Length - localPos);  } else {  	WriteObjectHeader (Constants.OBJ_REF_DELTA' reuse.RawSize);  	otp.DeltaBaseId.copyRawTo (_buf' 0);  	_pos.Write (_buf' 0' Constants.OBJECT_ID_LENGTH);  }  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteDeltaObjectReuse,The following statement contains a magic number: while ((offsetDiff >>= 7) > 0) {  	_buf [--localPos] = (byte)(0x80 | (--offsetDiff & 0x7F));  }  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The following statement contains a magic number: _buf [size++] = (byte)((nextLength > 0 ? (byte)0x80 : (byte)0x00) | (byte)(objectType << 4) | (byte)(dataLength & 0x0F));  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The following statement contains a magic number: while (dataLength > 0) {  	nextLength = (long)(((ulong)nextLength) >> 7);  	_buf [size++] = (byte)((nextLength > 0 ? (byte)0x80 : (byte)0x00) | (byte)(dataLength & 0x7F));  	dataLength = nextLength;  }  
Magic Number,GitSharp.Core,PackWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The following statement contains a magic number: nextLength = (long)(((ulong)nextLength) >> 7);  
Magic Number,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string d in fanout) {  	if (d.Length != 2)  		continue;  	string[] entries = PathUtil.CombineDirectoryPath (objects' d).GetFiles ().Select (x => x.FullName).ToArray ();  	if (entries == null)  		continue;  	foreach (string e in entries) {  		if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  			continue;  		try {  			_unpackedObjects.Add (ObjectId.FromString (d + e));  		} catch (ArgumentException) {  			// ignoring the file that does not represent loose object  		}  	}  }  
Magic Number,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string d in fanout) {  	if (d.Length != 2)  		continue;  	string[] entries = PathUtil.CombineDirectoryPath (objects' d).GetFiles ().Select (x => x.FullName).ToArray ();  	if (entries == null)  		continue;  	foreach (string e in entries) {  		if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  			continue;  		try {  			_unpackedObjects.Add (ObjectId.FromString (d + e));  		} catch (ArgumentException) {  			// ignoring the file that does not represent loose object  		}  	}  }  
Magic Number,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: if (d.Length != 2)  	continue;  
Magic Number,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string e in entries) {  	if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  		continue;  	try {  		_unpackedObjects.Add (ObjectId.FromString (d + e));  	} catch (ArgumentException) {  		// ignoring the file that does not represent loose object  	}  }  
Magic Number,GitSharp.Core,CachedObjectDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)  	continue;  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,Linux,The following statement contains a magic number: if (release.Length > 0) {  	string str = release [0].ToString ();  	string platformType = str.Substring (5' str.Length - 13);  	VersionFile = str;  	switch (platformType) {  	case "arch":  		GetArchPlatform (this' null);  		break;  	case "fedora":  		GetFedoraPlatform (this' null);  		break;  	case "gentoo":  		GetGentooPlatform (this' null);  		break;  	case "mandriva":  		GetMandrivaPlatform (this' null);  		break;  	case "redhat":  		//RedHat variants  		GetRedHatPlatform (this' null);  		break;  	case "suse":  		GetSusePlatform (this' null);  		break;  	case "lsb":  		//Ubuntu variants  		GetUbuntuPlatform (this' null);  		break;  	default:  		GetDefaultLinuxPlatform (this' null);  		break;  	}  } else if (slackware.Length > 0) {  	VersionFile = "/etc/" + slackware [0].ToString ();  	GetSlackwarePlatform (this' null);  } else if (debian.Length > 0) {  	VersionFile = "/etc/" + debian [0].ToString ();  	GetDebianPlatform (this' null);  } else {  	GetDefaultLinuxPlatform (this' null);  }  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,Linux,The following statement contains a magic number: if (release.Length > 0) {  	string str = release [0].ToString ();  	string platformType = str.Substring (5' str.Length - 13);  	VersionFile = str;  	switch (platformType) {  	case "arch":  		GetArchPlatform (this' null);  		break;  	case "fedora":  		GetFedoraPlatform (this' null);  		break;  	case "gentoo":  		GetGentooPlatform (this' null);  		break;  	case "mandriva":  		GetMandrivaPlatform (this' null);  		break;  	case "redhat":  		//RedHat variants  		GetRedHatPlatform (this' null);  		break;  	case "suse":  		GetSusePlatform (this' null);  		break;  	case "lsb":  		//Ubuntu variants  		GetUbuntuPlatform (this' null);  		break;  	default:  		GetDefaultLinuxPlatform (this' null);  		break;  	}  } else if (slackware.Length > 0) {  	VersionFile = "/etc/" + slackware [0].ToString ();  	GetSlackwarePlatform (this' null);  } else if (debian.Length > 0) {  	VersionFile = "/etc/" + debian [0].ToString ();  	GetDebianPlatform (this' null);  } else {  	GetDefaultLinuxPlatform (this' null);  }  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetFedoraPlatform,The following statement contains a magic number: obj.Version = lines [0].Substring (pt + 8' pt2 - 1).Trim ();  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetMandrivaPlatform,The following statement contains a magic number: obj.Version = lines [0].Substring (pt + 8' pt2 - 1).Trim ();  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetRedHatPlatform,The following statement contains a magic number: obj.Version = lines [0].Substring (pt + 8' pt2 - 1 - pt + 8).Trim ();  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetRedHatPlatform,The following statement contains a magic number: obj.Version = lines [0].Substring (pt + 8' pt2 - 1 - pt + 8).Trim ();  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetSusePlatform,The following statement contains a magic number: obj.Version = lines [1].Substring (11' lines [1].Length - 11);  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetSusePlatform,The following statement contains a magic number: obj.Version = lines [1].Substring (11' lines [1].Length - 11);  
Magic Number,GitSharp.Core,Linux,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetUbuntuPlatform,The following statement contains a magic number: obj.Edition = lines [2].Substring (pt1 + 1).Trim ();  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform) {  case PlatformID.Win32Windows:  	switch (os.Version.Major) {  	case 4:  		switch (os.Version.Minor) {  		case 0:  			if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "OSR2";  			} else {  				ClassName = "Windows.v95";  				PlatformSubType = "95";  				Edition = "";  			}  			break;  		case 10:  			if (osvi.szCSDVersion == "A") {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "SE";  			} else {  				ClassName = "Windows.v98";  				PlatformSubType = "98";  				Edition = "";  			}  			break;  		case 90:  			ClassName = "Windows.ME";  			PlatformSubType = "ME";  			Edition = "";  			break;  		}  		break;  	}  	break;  case PlatformID.Win32NT:  	switch (os.Version.Major) {  	case 3:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "3.51";  		break;  	case 4:  		switch (osvi.wProductType) {  		case 1:  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Workstation";  			break;  		case 3:  			if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Enterprise";  			} else {  				ClassName = "Windows.NT";  				PlatformSubType = "NT";  				Edition = "4.0 Server Standard";  			}  			break;  		}  		break;  	case 5:  		switch (os.Version.Minor) {  		case 0:  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Data Center";  				break;  			case SuiteVersion.Enterprise:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Advanced";  				break;  			default:  				ClassName = "Windows.v2000";  				PlatformSubType = "2000";  				Edition = "Standard";  				break;  			}  			break;  		case 1:  			if (osvi.wSuiteMask == SuiteVersion.Personal) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional";  			} else {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Home";  			}  			break;  		case 2:  			if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  				ClassName = "Windows.XP";  				PlatformSubType = "XP";  				Edition = "Professional x64";  			} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Enterprise";  			} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 R2";  			} else {  				switch (osvi.wSuiteMask) {  				case SuiteVersion.DataCenter:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Data Center";  					break;  				case SuiteVersion.Blade:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Web Edition";  					break;  				case SuiteVersion.WHServer:  					ClassName = "Windows.v2003";  					PlatformSubType = "2003";  					Edition = "Home Server";  					break;  				default:  					ClassName = "Windows.v2003";  					PlatformSubType = "Server";  					Edition = "2003 Standard";  					break;  				}  			}  			break;  		}  		break;  	case 6:  		Win32ProductInfo ospi = new Win32ProductInfo ();  		ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  		ospi.dwOSMajorVersion = os.Version.Major;  		ospi.dwOSMinorVersion = os.Version.Minor;  		ospi.dwSpMajorVersion = 0;  		ospi.dwSpMinorVersion = 0;  		GetProductInfo (ospi);  		Version = Version + "." + ospi.dwOSEdition;  		switch (os.Version.Minor) {  		case 0:  			if (osvi.wProductType == NTVersion.Workstation) {  				// Vista Detection  				switch (ospi.dwOSEdition) {  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				case ProductType.Ultimate:  					//    1  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate Edition";  					break;  				case ProductType.HomeBasic:  					// 2  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic Edition";  					break;  				case ProductType.HomePremium:  					// 3  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium Edition";  					break;  				case ProductType.Enterprise:  					// 4  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise Edition";  					break;  				case ProductType.HomeBasicN:  					// 5  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Basic N Edition (EU Only)";  					break;  				case ProductType.Business:  					// 6  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business Edition";  					break;  				case ProductType.Starter:  					// B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Starter Edition";  					break;  				case ProductType.BusinessN:  					// 10  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Business N Edition (EU Only)";  					break;  				case ProductType.HomePremiumN:  					// 1A  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Home Premium N Edition (EU Only)";  					break;  				case ProductType.EnterpriseN:  					// 1B  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Enterprise N Edition (EU Only)";  					break;  				case ProductType.UltimateN:  					// 1C  					ClassName = "Windows.Vista";  					PlatformSubType = "Vista";  					Edition = "Ultimate N Edition (EU Only)";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "Vista";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "Vista";  					Edition = "is not defined!";  					break;  				}  			} else {  				switch (ospi.dwOSEdition) {  				//Windows 2008 Detection  				case ProductType.Undefined:  					ClassName = "Windows.Undefined";  					PlatformSubType = "2008";  					Edition = "is not defined!";  					break;  				case ProductType.StandardServer:  					// 7  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server";  					break;  				case ProductType.DataCenterServer:  					//8  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server";  					break;  				case ProductType.SmallBusinessServer:  					//9  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server";  					break;  				case ProductType.EnterpriseServer:  					// A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server";  					break;  				case ProductType.DataCenterServerCore:  					// C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core";  					break;  				case ProductType.StandardServerCore:  					// D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core";  					break;  				case ProductType.EnterpriseServerCore:  					// E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core";  					break;  				case ProductType.EnterpriseServerIA64:  					// F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server IA64";  					break;  				case ProductType.WebServer:  					// 11  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server";  					break;  				case ProductType.ClusterServer:  					// 12  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Cluster Server";  					break;  				case ProductType.HomeServer:  					// 13  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Server";  					break;  				case ProductType.StorageExpressServer:  					// 14  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server";  					break;  				case ProductType.StorageStandardServer:  					// 15  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server";  					break;  				case ProductType.StorageWorkgroupServer:  					// 16  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server";  					break;  				case ProductType.StorageEnterpriseServer:  					// 17  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server";  					break;  				case ProductType.ServerForSmallBusiness:  					// 18  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Businesses";  					break;  				case ProductType.SmallBusinessServerPremium:  					// 19  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Premium";  					break;  				case ProductType.WebServerCore:  					// 1D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Web Server Core";  					break;  				case ProductType.MediumBusinessServerManagement:  					// 1E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Management";  					break;  				case ProductType.MediumBusinessServerSecurity:  					// 1F  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Security";  					break;  				case ProductType.MediumBusinessServerMessaging:  					// 20  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Medium Business Server Messaging";  					break;  				case ProductType.SmallBusinessServerPrime:  					// 21  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Small Business Server Prime";  					break;  				case ProductType.HomePremiumServer:  					// 22  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Home Premium Server";  					break;  				case ProductType.ServerForSmallBusinessV:  					// 23  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Server for Small Business (Hyper-V)";  					break;  				case ProductType.StandardServerV:  					// 24  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerV:  					// 25  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server (Hyper-V)";  					break;  				case ProductType.EnterpriseServerV:  					// 26  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server (Hyper-V)";  					break;  				case ProductType.DataCenterServerCoreV:  					// 27  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Data Center Server Core (Hyper-V)";  					break;  				case ProductType.StandardServerCoreV:  					// 28  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Standard Server Core (Hyper-V)";  					break;  				case ProductType.EnterpriseServerCoreV:  					// 29  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Enterprise Server Core (Hyper-V)";  					break;  				case ProductType.HyperV:  					// 2A  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "(Hyper-V)";  					break;  				case ProductType.StorageExpressServerCore:  					// 2B  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Express Server Core";  					break;  				case ProductType.StorageStandardServerCore:  					// 2C  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Standard Server Core";  					break;  				case ProductType.StorageWorkgroupServerCore:  					// 2D  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Workgroup Server Core";  					break;  				case ProductType.StorageEnterpriseServerCore:  					// 2E  					ClassName = "Windows.v2008";  					PlatformSubType = "2008";  					Edition = "Storage Enterprise Server Core";  					break;  				case ProductType.Unlicensed:  					// 0xABCDABCD  					ClassName = "Windows.Unlicensed";  					PlatformSubType = "2008";  					Edition = "Unlicensed";  					break;  				default:  					ClassName = "Windows.Unknown";  					PlatformSubType = "2008";  					Edition = "is unknown!";  					break;  				}  			}  			break;  		case 1:  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "7";  				Edition = "is undefined";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Home Basic N Edition (EU only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.v7";  				PlatformSubType = "7";  				Edition = "Business N Edition (EU only)";  				break;  			}  			break;  		}  		//End os.Version.Minor  		break;  	}  	// End os.Version.Major  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 4:  	switch (os.Version.Minor) {  	case 0:  		if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "OSR2";  		} else {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "";  		}  		break;  	case 10:  		if (osvi.szCSDVersion == "A") {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "SE";  		} else {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "";  		}  		break;  	case 90:  		ClassName = "Windows.ME";  		PlatformSubType = "ME";  		Edition = "";  		break;  	}  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 4:  	switch (os.Version.Minor) {  	case 0:  		if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "OSR2";  		} else {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "";  		}  		break;  	case 10:  		if (osvi.szCSDVersion == "A") {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "SE";  		} else {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "";  		}  		break;  	case 90:  		ClassName = "Windows.ME";  		PlatformSubType = "ME";  		Edition = "";  		break;  	}  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 4:  	switch (os.Version.Minor) {  	case 0:  		if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "OSR2";  		} else {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "";  		}  		break;  	case 10:  		if (osvi.szCSDVersion == "A") {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "SE";  		} else {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "";  		}  		break;  	case 90:  		ClassName = "Windows.ME";  		PlatformSubType = "ME";  		Edition = "";  		break;  	}  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Minor) {  case 0:  	if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  		ClassName = "Windows.v95";  		PlatformSubType = "95";  		Edition = "OSR2";  	} else {  		ClassName = "Windows.v95";  		PlatformSubType = "95";  		Edition = "";  	}  	break;  case 10:  	if (osvi.szCSDVersion == "A") {  		ClassName = "Windows.v98";  		PlatformSubType = "98";  		Edition = "SE";  	} else {  		ClassName = "Windows.v98";  		PlatformSubType = "98";  		Edition = "";  	}  	break;  case 90:  	ClassName = "Windows.ME";  	PlatformSubType = "ME";  	Edition = "";  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Minor) {  case 0:  	if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  		ClassName = "Windows.v95";  		PlatformSubType = "95";  		Edition = "OSR2";  	} else {  		ClassName = "Windows.v95";  		PlatformSubType = "95";  		Edition = "";  	}  	break;  case 10:  	if (osvi.szCSDVersion == "A") {  		ClassName = "Windows.v98";  		PlatformSubType = "98";  		Edition = "SE";  	} else {  		ClassName = "Windows.v98";  		PlatformSubType = "98";  		Edition = "";  	}  	break;  case 90:  	ClassName = "Windows.ME";  	PlatformSubType = "ME";  	Edition = "";  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 3:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "3.51";  	break;  case 4:  	switch (osvi.wProductType) {  	case 1:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Workstation";  		break;  	case 3:  		if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Enterprise";  		} else {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Standard";  		}  		break;  	}  	break;  case 5:  	switch (os.Version.Minor) {  	case 0:  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Data Center";  			break;  		case SuiteVersion.Enterprise:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Advanced";  			break;  		default:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Standard";  			break;  		}  		break;  	case 1:  		if (osvi.wSuiteMask == SuiteVersion.Personal) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional";  		} else {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Home";  		}  		break;  	case 2:  		if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional x64";  		} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Enterprise";  		} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 R2";  		} else {  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Data Center";  				break;  			case SuiteVersion.Blade:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Web Edition";  				break;  			case SuiteVersion.WHServer:  				ClassName = "Windows.v2003";  				PlatformSubType = "2003";  				Edition = "Home Server";  				break;  			default:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Standard";  				break;  			}  		}  		break;  	}  	break;  case 6:  	Win32ProductInfo ospi = new Win32ProductInfo ();  	ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  	ospi.dwOSMajorVersion = os.Version.Major;  	ospi.dwOSMinorVersion = os.Version.Minor;  	ospi.dwSpMajorVersion = 0;  	ospi.dwSpMinorVersion = 0;  	GetProductInfo (ospi);  	Version = Version + "." + ospi.dwOSEdition;  	switch (os.Version.Minor) {  	case 0:  		if (osvi.wProductType == NTVersion.Workstation) {  			// Vista Detection  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic N Edition (EU Only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business Edition";  				break;  			case ProductType.Starter:  				// B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Starter Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business N Edition (EU Only)";  				break;  			case ProductType.HomePremiumN:  				// 1A  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium N Edition (EU Only)";  				break;  			case ProductType.EnterpriseN:  				// 1B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise N Edition (EU Only)";  				break;  			case ProductType.UltimateN:  				// 1C  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate N Edition (EU Only)";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "Vista";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			}  		} else {  			switch (ospi.dwOSEdition) {  			//Windows 2008 Detection  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "2008";  				Edition = "is not defined!";  				break;  			case ProductType.StandardServer:  				// 7  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server";  				break;  			case ProductType.DataCenterServer:  				//8  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server";  				break;  			case ProductType.SmallBusinessServer:  				//9  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server";  				break;  			case ProductType.EnterpriseServer:  				// A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server";  				break;  			case ProductType.DataCenterServerCore:  				// C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core";  				break;  			case ProductType.StandardServerCore:  				// D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core";  				break;  			case ProductType.EnterpriseServerCore:  				// E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core";  				break;  			case ProductType.EnterpriseServerIA64:  				// F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server IA64";  				break;  			case ProductType.WebServer:  				// 11  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server";  				break;  			case ProductType.ClusterServer:  				// 12  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Cluster Server";  				break;  			case ProductType.HomeServer:  				// 13  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Server";  				break;  			case ProductType.StorageExpressServer:  				// 14  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server";  				break;  			case ProductType.StorageStandardServer:  				// 15  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server";  				break;  			case ProductType.StorageWorkgroupServer:  				// 16  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server";  				break;  			case ProductType.StorageEnterpriseServer:  				// 17  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server";  				break;  			case ProductType.ServerForSmallBusiness:  				// 18  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Businesses";  				break;  			case ProductType.SmallBusinessServerPremium:  				// 19  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Premium";  				break;  			case ProductType.WebServerCore:  				// 1D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server Core";  				break;  			case ProductType.MediumBusinessServerManagement:  				// 1E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Management";  				break;  			case ProductType.MediumBusinessServerSecurity:  				// 1F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Security";  				break;  			case ProductType.MediumBusinessServerMessaging:  				// 20  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Messaging";  				break;  			case ProductType.SmallBusinessServerPrime:  				// 21  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Prime";  				break;  			case ProductType.HomePremiumServer:  				// 22  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Premium Server";  				break;  			case ProductType.ServerForSmallBusinessV:  				// 23  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Business (Hyper-V)";  				break;  			case ProductType.StandardServerV:  				// 24  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerV:  				// 25  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server (Hyper-V)";  				break;  			case ProductType.EnterpriseServerV:  				// 26  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerCoreV:  				// 27  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core (Hyper-V)";  				break;  			case ProductType.StandardServerCoreV:  				// 28  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core (Hyper-V)";  				break;  			case ProductType.EnterpriseServerCoreV:  				// 29  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core (Hyper-V)";  				break;  			case ProductType.HyperV:  				// 2A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "(Hyper-V)";  				break;  			case ProductType.StorageExpressServerCore:  				// 2B  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server Core";  				break;  			case ProductType.StorageStandardServerCore:  				// 2C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server Core";  				break;  			case ProductType.StorageWorkgroupServerCore:  				// 2D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server Core";  				break;  			case ProductType.StorageEnterpriseServerCore:  				// 2E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server Core";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "2008";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "2008";  				Edition = "is unknown!";  				break;  			}  		}  		break;  	case 1:  		switch (ospi.dwOSEdition) {  		case ProductType.Undefined:  			ClassName = "Windows.Undefined";  			PlatformSubType = "7";  			Edition = "is undefined";  			break;  		case ProductType.Ultimate:  			//    1  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Ultimate Edition";  			break;  		case ProductType.HomeBasic:  			// 2  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic Edition";  			break;  		case ProductType.HomePremium:  			// 3  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Premium Edition";  			break;  		case ProductType.Enterprise:  			// 4  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Enterprise Edition";  			break;  		case ProductType.HomeBasicN:  			// 5  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic N Edition (EU only)";  			break;  		case ProductType.Business:  			// 6  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business Edition";  			break;  		case ProductType.BusinessN:  			// 10  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business N Edition (EU only)";  			break;  		}  		break;  	}  	//End os.Version.Minor  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 3:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "3.51";  	break;  case 4:  	switch (osvi.wProductType) {  	case 1:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Workstation";  		break;  	case 3:  		if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Enterprise";  		} else {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Standard";  		}  		break;  	}  	break;  case 5:  	switch (os.Version.Minor) {  	case 0:  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Data Center";  			break;  		case SuiteVersion.Enterprise:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Advanced";  			break;  		default:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Standard";  			break;  		}  		break;  	case 1:  		if (osvi.wSuiteMask == SuiteVersion.Personal) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional";  		} else {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Home";  		}  		break;  	case 2:  		if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional x64";  		} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Enterprise";  		} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 R2";  		} else {  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Data Center";  				break;  			case SuiteVersion.Blade:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Web Edition";  				break;  			case SuiteVersion.WHServer:  				ClassName = "Windows.v2003";  				PlatformSubType = "2003";  				Edition = "Home Server";  				break;  			default:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Standard";  				break;  			}  		}  		break;  	}  	break;  case 6:  	Win32ProductInfo ospi = new Win32ProductInfo ();  	ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  	ospi.dwOSMajorVersion = os.Version.Major;  	ospi.dwOSMinorVersion = os.Version.Minor;  	ospi.dwSpMajorVersion = 0;  	ospi.dwSpMinorVersion = 0;  	GetProductInfo (ospi);  	Version = Version + "." + ospi.dwOSEdition;  	switch (os.Version.Minor) {  	case 0:  		if (osvi.wProductType == NTVersion.Workstation) {  			// Vista Detection  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic N Edition (EU Only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business Edition";  				break;  			case ProductType.Starter:  				// B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Starter Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business N Edition (EU Only)";  				break;  			case ProductType.HomePremiumN:  				// 1A  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium N Edition (EU Only)";  				break;  			case ProductType.EnterpriseN:  				// 1B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise N Edition (EU Only)";  				break;  			case ProductType.UltimateN:  				// 1C  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate N Edition (EU Only)";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "Vista";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			}  		} else {  			switch (ospi.dwOSEdition) {  			//Windows 2008 Detection  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "2008";  				Edition = "is not defined!";  				break;  			case ProductType.StandardServer:  				// 7  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server";  				break;  			case ProductType.DataCenterServer:  				//8  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server";  				break;  			case ProductType.SmallBusinessServer:  				//9  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server";  				break;  			case ProductType.EnterpriseServer:  				// A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server";  				break;  			case ProductType.DataCenterServerCore:  				// C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core";  				break;  			case ProductType.StandardServerCore:  				// D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core";  				break;  			case ProductType.EnterpriseServerCore:  				// E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core";  				break;  			case ProductType.EnterpriseServerIA64:  				// F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server IA64";  				break;  			case ProductType.WebServer:  				// 11  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server";  				break;  			case ProductType.ClusterServer:  				// 12  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Cluster Server";  				break;  			case ProductType.HomeServer:  				// 13  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Server";  				break;  			case ProductType.StorageExpressServer:  				// 14  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server";  				break;  			case ProductType.StorageStandardServer:  				// 15  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server";  				break;  			case ProductType.StorageWorkgroupServer:  				// 16  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server";  				break;  			case ProductType.StorageEnterpriseServer:  				// 17  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server";  				break;  			case ProductType.ServerForSmallBusiness:  				// 18  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Businesses";  				break;  			case ProductType.SmallBusinessServerPremium:  				// 19  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Premium";  				break;  			case ProductType.WebServerCore:  				// 1D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server Core";  				break;  			case ProductType.MediumBusinessServerManagement:  				// 1E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Management";  				break;  			case ProductType.MediumBusinessServerSecurity:  				// 1F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Security";  				break;  			case ProductType.MediumBusinessServerMessaging:  				// 20  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Messaging";  				break;  			case ProductType.SmallBusinessServerPrime:  				// 21  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Prime";  				break;  			case ProductType.HomePremiumServer:  				// 22  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Premium Server";  				break;  			case ProductType.ServerForSmallBusinessV:  				// 23  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Business (Hyper-V)";  				break;  			case ProductType.StandardServerV:  				// 24  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerV:  				// 25  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server (Hyper-V)";  				break;  			case ProductType.EnterpriseServerV:  				// 26  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerCoreV:  				// 27  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core (Hyper-V)";  				break;  			case ProductType.StandardServerCoreV:  				// 28  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core (Hyper-V)";  				break;  			case ProductType.EnterpriseServerCoreV:  				// 29  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core (Hyper-V)";  				break;  			case ProductType.HyperV:  				// 2A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "(Hyper-V)";  				break;  			case ProductType.StorageExpressServerCore:  				// 2B  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server Core";  				break;  			case ProductType.StorageStandardServerCore:  				// 2C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server Core";  				break;  			case ProductType.StorageWorkgroupServerCore:  				// 2D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server Core";  				break;  			case ProductType.StorageEnterpriseServerCore:  				// 2E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server Core";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "2008";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "2008";  				Edition = "is unknown!";  				break;  			}  		}  		break;  	case 1:  		switch (ospi.dwOSEdition) {  		case ProductType.Undefined:  			ClassName = "Windows.Undefined";  			PlatformSubType = "7";  			Edition = "is undefined";  			break;  		case ProductType.Ultimate:  			//    1  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Ultimate Edition";  			break;  		case ProductType.HomeBasic:  			// 2  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic Edition";  			break;  		case ProductType.HomePremium:  			// 3  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Premium Edition";  			break;  		case ProductType.Enterprise:  			// 4  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Enterprise Edition";  			break;  		case ProductType.HomeBasicN:  			// 5  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic N Edition (EU only)";  			break;  		case ProductType.Business:  			// 6  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business Edition";  			break;  		case ProductType.BusinessN:  			// 10  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business N Edition (EU only)";  			break;  		}  		break;  	}  	//End os.Version.Minor  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 3:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "3.51";  	break;  case 4:  	switch (osvi.wProductType) {  	case 1:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Workstation";  		break;  	case 3:  		if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Enterprise";  		} else {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Standard";  		}  		break;  	}  	break;  case 5:  	switch (os.Version.Minor) {  	case 0:  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Data Center";  			break;  		case SuiteVersion.Enterprise:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Advanced";  			break;  		default:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Standard";  			break;  		}  		break;  	case 1:  		if (osvi.wSuiteMask == SuiteVersion.Personal) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional";  		} else {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Home";  		}  		break;  	case 2:  		if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional x64";  		} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Enterprise";  		} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 R2";  		} else {  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Data Center";  				break;  			case SuiteVersion.Blade:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Web Edition";  				break;  			case SuiteVersion.WHServer:  				ClassName = "Windows.v2003";  				PlatformSubType = "2003";  				Edition = "Home Server";  				break;  			default:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Standard";  				break;  			}  		}  		break;  	}  	break;  case 6:  	Win32ProductInfo ospi = new Win32ProductInfo ();  	ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  	ospi.dwOSMajorVersion = os.Version.Major;  	ospi.dwOSMinorVersion = os.Version.Minor;  	ospi.dwSpMajorVersion = 0;  	ospi.dwSpMinorVersion = 0;  	GetProductInfo (ospi);  	Version = Version + "." + ospi.dwOSEdition;  	switch (os.Version.Minor) {  	case 0:  		if (osvi.wProductType == NTVersion.Workstation) {  			// Vista Detection  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic N Edition (EU Only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business Edition";  				break;  			case ProductType.Starter:  				// B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Starter Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business N Edition (EU Only)";  				break;  			case ProductType.HomePremiumN:  				// 1A  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium N Edition (EU Only)";  				break;  			case ProductType.EnterpriseN:  				// 1B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise N Edition (EU Only)";  				break;  			case ProductType.UltimateN:  				// 1C  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate N Edition (EU Only)";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "Vista";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			}  		} else {  			switch (ospi.dwOSEdition) {  			//Windows 2008 Detection  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "2008";  				Edition = "is not defined!";  				break;  			case ProductType.StandardServer:  				// 7  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server";  				break;  			case ProductType.DataCenterServer:  				//8  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server";  				break;  			case ProductType.SmallBusinessServer:  				//9  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server";  				break;  			case ProductType.EnterpriseServer:  				// A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server";  				break;  			case ProductType.DataCenterServerCore:  				// C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core";  				break;  			case ProductType.StandardServerCore:  				// D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core";  				break;  			case ProductType.EnterpriseServerCore:  				// E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core";  				break;  			case ProductType.EnterpriseServerIA64:  				// F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server IA64";  				break;  			case ProductType.WebServer:  				// 11  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server";  				break;  			case ProductType.ClusterServer:  				// 12  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Cluster Server";  				break;  			case ProductType.HomeServer:  				// 13  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Server";  				break;  			case ProductType.StorageExpressServer:  				// 14  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server";  				break;  			case ProductType.StorageStandardServer:  				// 15  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server";  				break;  			case ProductType.StorageWorkgroupServer:  				// 16  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server";  				break;  			case ProductType.StorageEnterpriseServer:  				// 17  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server";  				break;  			case ProductType.ServerForSmallBusiness:  				// 18  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Businesses";  				break;  			case ProductType.SmallBusinessServerPremium:  				// 19  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Premium";  				break;  			case ProductType.WebServerCore:  				// 1D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server Core";  				break;  			case ProductType.MediumBusinessServerManagement:  				// 1E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Management";  				break;  			case ProductType.MediumBusinessServerSecurity:  				// 1F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Security";  				break;  			case ProductType.MediumBusinessServerMessaging:  				// 20  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Messaging";  				break;  			case ProductType.SmallBusinessServerPrime:  				// 21  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Prime";  				break;  			case ProductType.HomePremiumServer:  				// 22  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Premium Server";  				break;  			case ProductType.ServerForSmallBusinessV:  				// 23  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Business (Hyper-V)";  				break;  			case ProductType.StandardServerV:  				// 24  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerV:  				// 25  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server (Hyper-V)";  				break;  			case ProductType.EnterpriseServerV:  				// 26  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerCoreV:  				// 27  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core (Hyper-V)";  				break;  			case ProductType.StandardServerCoreV:  				// 28  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core (Hyper-V)";  				break;  			case ProductType.EnterpriseServerCoreV:  				// 29  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core (Hyper-V)";  				break;  			case ProductType.HyperV:  				// 2A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "(Hyper-V)";  				break;  			case ProductType.StorageExpressServerCore:  				// 2B  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server Core";  				break;  			case ProductType.StorageStandardServerCore:  				// 2C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server Core";  				break;  			case ProductType.StorageWorkgroupServerCore:  				// 2D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server Core";  				break;  			case ProductType.StorageEnterpriseServerCore:  				// 2E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server Core";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "2008";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "2008";  				Edition = "is unknown!";  				break;  			}  		}  		break;  	case 1:  		switch (ospi.dwOSEdition) {  		case ProductType.Undefined:  			ClassName = "Windows.Undefined";  			PlatformSubType = "7";  			Edition = "is undefined";  			break;  		case ProductType.Ultimate:  			//    1  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Ultimate Edition";  			break;  		case ProductType.HomeBasic:  			// 2  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic Edition";  			break;  		case ProductType.HomePremium:  			// 3  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Premium Edition";  			break;  		case ProductType.Enterprise:  			// 4  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Enterprise Edition";  			break;  		case ProductType.HomeBasicN:  			// 5  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic N Edition (EU only)";  			break;  		case ProductType.Business:  			// 6  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business Edition";  			break;  		case ProductType.BusinessN:  			// 10  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business N Edition (EU only)";  			break;  		}  		break;  	}  	//End os.Version.Minor  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 3:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "3.51";  	break;  case 4:  	switch (osvi.wProductType) {  	case 1:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Workstation";  		break;  	case 3:  		if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Enterprise";  		} else {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Standard";  		}  		break;  	}  	break;  case 5:  	switch (os.Version.Minor) {  	case 0:  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Data Center";  			break;  		case SuiteVersion.Enterprise:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Advanced";  			break;  		default:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Standard";  			break;  		}  		break;  	case 1:  		if (osvi.wSuiteMask == SuiteVersion.Personal) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional";  		} else {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Home";  		}  		break;  	case 2:  		if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional x64";  		} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Enterprise";  		} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 R2";  		} else {  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Data Center";  				break;  			case SuiteVersion.Blade:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Web Edition";  				break;  			case SuiteVersion.WHServer:  				ClassName = "Windows.v2003";  				PlatformSubType = "2003";  				Edition = "Home Server";  				break;  			default:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Standard";  				break;  			}  		}  		break;  	}  	break;  case 6:  	Win32ProductInfo ospi = new Win32ProductInfo ();  	ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  	ospi.dwOSMajorVersion = os.Version.Major;  	ospi.dwOSMinorVersion = os.Version.Minor;  	ospi.dwSpMajorVersion = 0;  	ospi.dwSpMinorVersion = 0;  	GetProductInfo (ospi);  	Version = Version + "." + ospi.dwOSEdition;  	switch (os.Version.Minor) {  	case 0:  		if (osvi.wProductType == NTVersion.Workstation) {  			// Vista Detection  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic N Edition (EU Only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business Edition";  				break;  			case ProductType.Starter:  				// B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Starter Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business N Edition (EU Only)";  				break;  			case ProductType.HomePremiumN:  				// 1A  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium N Edition (EU Only)";  				break;  			case ProductType.EnterpriseN:  				// 1B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise N Edition (EU Only)";  				break;  			case ProductType.UltimateN:  				// 1C  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate N Edition (EU Only)";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "Vista";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			}  		} else {  			switch (ospi.dwOSEdition) {  			//Windows 2008 Detection  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "2008";  				Edition = "is not defined!";  				break;  			case ProductType.StandardServer:  				// 7  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server";  				break;  			case ProductType.DataCenterServer:  				//8  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server";  				break;  			case ProductType.SmallBusinessServer:  				//9  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server";  				break;  			case ProductType.EnterpriseServer:  				// A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server";  				break;  			case ProductType.DataCenterServerCore:  				// C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core";  				break;  			case ProductType.StandardServerCore:  				// D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core";  				break;  			case ProductType.EnterpriseServerCore:  				// E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core";  				break;  			case ProductType.EnterpriseServerIA64:  				// F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server IA64";  				break;  			case ProductType.WebServer:  				// 11  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server";  				break;  			case ProductType.ClusterServer:  				// 12  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Cluster Server";  				break;  			case ProductType.HomeServer:  				// 13  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Server";  				break;  			case ProductType.StorageExpressServer:  				// 14  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server";  				break;  			case ProductType.StorageStandardServer:  				// 15  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server";  				break;  			case ProductType.StorageWorkgroupServer:  				// 16  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server";  				break;  			case ProductType.StorageEnterpriseServer:  				// 17  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server";  				break;  			case ProductType.ServerForSmallBusiness:  				// 18  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Businesses";  				break;  			case ProductType.SmallBusinessServerPremium:  				// 19  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Premium";  				break;  			case ProductType.WebServerCore:  				// 1D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server Core";  				break;  			case ProductType.MediumBusinessServerManagement:  				// 1E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Management";  				break;  			case ProductType.MediumBusinessServerSecurity:  				// 1F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Security";  				break;  			case ProductType.MediumBusinessServerMessaging:  				// 20  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Messaging";  				break;  			case ProductType.SmallBusinessServerPrime:  				// 21  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Prime";  				break;  			case ProductType.HomePremiumServer:  				// 22  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Premium Server";  				break;  			case ProductType.ServerForSmallBusinessV:  				// 23  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Business (Hyper-V)";  				break;  			case ProductType.StandardServerV:  				// 24  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerV:  				// 25  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server (Hyper-V)";  				break;  			case ProductType.EnterpriseServerV:  				// 26  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerCoreV:  				// 27  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core (Hyper-V)";  				break;  			case ProductType.StandardServerCoreV:  				// 28  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core (Hyper-V)";  				break;  			case ProductType.EnterpriseServerCoreV:  				// 29  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core (Hyper-V)";  				break;  			case ProductType.HyperV:  				// 2A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "(Hyper-V)";  				break;  			case ProductType.StorageExpressServerCore:  				// 2B  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server Core";  				break;  			case ProductType.StorageStandardServerCore:  				// 2C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server Core";  				break;  			case ProductType.StorageWorkgroupServerCore:  				// 2D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server Core";  				break;  			case ProductType.StorageEnterpriseServerCore:  				// 2E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server Core";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "2008";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "2008";  				Edition = "is unknown!";  				break;  			}  		}  		break;  	case 1:  		switch (ospi.dwOSEdition) {  		case ProductType.Undefined:  			ClassName = "Windows.Undefined";  			PlatformSubType = "7";  			Edition = "is undefined";  			break;  		case ProductType.Ultimate:  			//    1  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Ultimate Edition";  			break;  		case ProductType.HomeBasic:  			// 2  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic Edition";  			break;  		case ProductType.HomePremium:  			// 3  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Premium Edition";  			break;  		case ProductType.Enterprise:  			// 4  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Enterprise Edition";  			break;  		case ProductType.HomeBasicN:  			// 5  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic N Edition (EU only)";  			break;  		case ProductType.Business:  			// 6  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business Edition";  			break;  		case ProductType.BusinessN:  			// 10  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business N Edition (EU only)";  			break;  		}  		break;  	}  	//End os.Version.Minor  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 3:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "3.51";  	break;  case 4:  	switch (osvi.wProductType) {  	case 1:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Workstation";  		break;  	case 3:  		if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Enterprise";  		} else {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Standard";  		}  		break;  	}  	break;  case 5:  	switch (os.Version.Minor) {  	case 0:  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Data Center";  			break;  		case SuiteVersion.Enterprise:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Advanced";  			break;  		default:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Standard";  			break;  		}  		break;  	case 1:  		if (osvi.wSuiteMask == SuiteVersion.Personal) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional";  		} else {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Home";  		}  		break;  	case 2:  		if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional x64";  		} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Enterprise";  		} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 R2";  		} else {  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Data Center";  				break;  			case SuiteVersion.Blade:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Web Edition";  				break;  			case SuiteVersion.WHServer:  				ClassName = "Windows.v2003";  				PlatformSubType = "2003";  				Edition = "Home Server";  				break;  			default:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Standard";  				break;  			}  		}  		break;  	}  	break;  case 6:  	Win32ProductInfo ospi = new Win32ProductInfo ();  	ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  	ospi.dwOSMajorVersion = os.Version.Major;  	ospi.dwOSMinorVersion = os.Version.Minor;  	ospi.dwSpMajorVersion = 0;  	ospi.dwSpMinorVersion = 0;  	GetProductInfo (ospi);  	Version = Version + "." + ospi.dwOSEdition;  	switch (os.Version.Minor) {  	case 0:  		if (osvi.wProductType == NTVersion.Workstation) {  			// Vista Detection  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic N Edition (EU Only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business Edition";  				break;  			case ProductType.Starter:  				// B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Starter Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business N Edition (EU Only)";  				break;  			case ProductType.HomePremiumN:  				// 1A  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium N Edition (EU Only)";  				break;  			case ProductType.EnterpriseN:  				// 1B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise N Edition (EU Only)";  				break;  			case ProductType.UltimateN:  				// 1C  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate N Edition (EU Only)";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "Vista";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			}  		} else {  			switch (ospi.dwOSEdition) {  			//Windows 2008 Detection  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "2008";  				Edition = "is not defined!";  				break;  			case ProductType.StandardServer:  				// 7  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server";  				break;  			case ProductType.DataCenterServer:  				//8  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server";  				break;  			case ProductType.SmallBusinessServer:  				//9  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server";  				break;  			case ProductType.EnterpriseServer:  				// A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server";  				break;  			case ProductType.DataCenterServerCore:  				// C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core";  				break;  			case ProductType.StandardServerCore:  				// D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core";  				break;  			case ProductType.EnterpriseServerCore:  				// E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core";  				break;  			case ProductType.EnterpriseServerIA64:  				// F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server IA64";  				break;  			case ProductType.WebServer:  				// 11  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server";  				break;  			case ProductType.ClusterServer:  				// 12  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Cluster Server";  				break;  			case ProductType.HomeServer:  				// 13  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Server";  				break;  			case ProductType.StorageExpressServer:  				// 14  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server";  				break;  			case ProductType.StorageStandardServer:  				// 15  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server";  				break;  			case ProductType.StorageWorkgroupServer:  				// 16  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server";  				break;  			case ProductType.StorageEnterpriseServer:  				// 17  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server";  				break;  			case ProductType.ServerForSmallBusiness:  				// 18  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Businesses";  				break;  			case ProductType.SmallBusinessServerPremium:  				// 19  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Premium";  				break;  			case ProductType.WebServerCore:  				// 1D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server Core";  				break;  			case ProductType.MediumBusinessServerManagement:  				// 1E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Management";  				break;  			case ProductType.MediumBusinessServerSecurity:  				// 1F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Security";  				break;  			case ProductType.MediumBusinessServerMessaging:  				// 20  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Messaging";  				break;  			case ProductType.SmallBusinessServerPrime:  				// 21  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Prime";  				break;  			case ProductType.HomePremiumServer:  				// 22  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Premium Server";  				break;  			case ProductType.ServerForSmallBusinessV:  				// 23  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Business (Hyper-V)";  				break;  			case ProductType.StandardServerV:  				// 24  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerV:  				// 25  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server (Hyper-V)";  				break;  			case ProductType.EnterpriseServerV:  				// 26  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerCoreV:  				// 27  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core (Hyper-V)";  				break;  			case ProductType.StandardServerCoreV:  				// 28  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core (Hyper-V)";  				break;  			case ProductType.EnterpriseServerCoreV:  				// 29  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core (Hyper-V)";  				break;  			case ProductType.HyperV:  				// 2A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "(Hyper-V)";  				break;  			case ProductType.StorageExpressServerCore:  				// 2B  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server Core";  				break;  			case ProductType.StorageStandardServerCore:  				// 2C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server Core";  				break;  			case ProductType.StorageWorkgroupServerCore:  				// 2D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server Core";  				break;  			case ProductType.StorageEnterpriseServerCore:  				// 2E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server Core";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "2008";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "2008";  				Edition = "is unknown!";  				break;  			}  		}  		break;  	case 1:  		switch (ospi.dwOSEdition) {  		case ProductType.Undefined:  			ClassName = "Windows.Undefined";  			PlatformSubType = "7";  			Edition = "is undefined";  			break;  		case ProductType.Ultimate:  			//    1  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Ultimate Edition";  			break;  		case ProductType.HomeBasic:  			// 2  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic Edition";  			break;  		case ProductType.HomePremium:  			// 3  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Premium Edition";  			break;  		case ProductType.Enterprise:  			// 4  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Enterprise Edition";  			break;  		case ProductType.HomeBasicN:  			// 5  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic N Edition (EU only)";  			break;  		case ProductType.Business:  			// 6  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business Edition";  			break;  		case ProductType.BusinessN:  			// 10  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business N Edition (EU only)";  			break;  		}  		break;  	}  	//End os.Version.Minor  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Major) {  case 3:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "3.51";  	break;  case 4:  	switch (osvi.wProductType) {  	case 1:  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Workstation";  		break;  	case 3:  		if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Enterprise";  		} else {  			ClassName = "Windows.NT";  			PlatformSubType = "NT";  			Edition = "4.0 Server Standard";  		}  		break;  	}  	break;  case 5:  	switch (os.Version.Minor) {  	case 0:  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Data Center";  			break;  		case SuiteVersion.Enterprise:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Advanced";  			break;  		default:  			ClassName = "Windows.v2000";  			PlatformSubType = "2000";  			Edition = "Standard";  			break;  		}  		break;  	case 1:  		if (osvi.wSuiteMask == SuiteVersion.Personal) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional";  		} else {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Home";  		}  		break;  	case 2:  		if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  			ClassName = "Windows.XP";  			PlatformSubType = "XP";  			Edition = "Professional x64";  		} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Enterprise";  		} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 R2";  		} else {  			switch (osvi.wSuiteMask) {  			case SuiteVersion.DataCenter:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Data Center";  				break;  			case SuiteVersion.Blade:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Web Edition";  				break;  			case SuiteVersion.WHServer:  				ClassName = "Windows.v2003";  				PlatformSubType = "2003";  				Edition = "Home Server";  				break;  			default:  				ClassName = "Windows.v2003";  				PlatformSubType = "Server";  				Edition = "2003 Standard";  				break;  			}  		}  		break;  	}  	break;  case 6:  	Win32ProductInfo ospi = new Win32ProductInfo ();  	ospi.dwOSProductInfoSize = Marshal.SizeOf (ospi);  	ospi.dwOSMajorVersion = os.Version.Major;  	ospi.dwOSMinorVersion = os.Version.Minor;  	ospi.dwSpMajorVersion = 0;  	ospi.dwSpMinorVersion = 0;  	GetProductInfo (ospi);  	Version = Version + "." + ospi.dwOSEdition;  	switch (os.Version.Minor) {  	case 0:  		if (osvi.wProductType == NTVersion.Workstation) {  			// Vista Detection  			switch (ospi.dwOSEdition) {  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			case ProductType.Ultimate:  				//    1  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate Edition";  				break;  			case ProductType.HomeBasic:  				// 2  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic Edition";  				break;  			case ProductType.HomePremium:  				// 3  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium Edition";  				break;  			case ProductType.Enterprise:  				// 4  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise Edition";  				break;  			case ProductType.HomeBasicN:  				// 5  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Basic N Edition (EU Only)";  				break;  			case ProductType.Business:  				// 6  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business Edition";  				break;  			case ProductType.Starter:  				// B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Starter Edition";  				break;  			case ProductType.BusinessN:  				// 10  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Business N Edition (EU Only)";  				break;  			case ProductType.HomePremiumN:  				// 1A  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Home Premium N Edition (EU Only)";  				break;  			case ProductType.EnterpriseN:  				// 1B  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Enterprise N Edition (EU Only)";  				break;  			case ProductType.UltimateN:  				// 1C  				ClassName = "Windows.Vista";  				PlatformSubType = "Vista";  				Edition = "Ultimate N Edition (EU Only)";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "Vista";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "Vista";  				Edition = "is not defined!";  				break;  			}  		} else {  			switch (ospi.dwOSEdition) {  			//Windows 2008 Detection  			case ProductType.Undefined:  				ClassName = "Windows.Undefined";  				PlatformSubType = "2008";  				Edition = "is not defined!";  				break;  			case ProductType.StandardServer:  				// 7  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server";  				break;  			case ProductType.DataCenterServer:  				//8  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server";  				break;  			case ProductType.SmallBusinessServer:  				//9  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server";  				break;  			case ProductType.EnterpriseServer:  				// A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server";  				break;  			case ProductType.DataCenterServerCore:  				// C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core";  				break;  			case ProductType.StandardServerCore:  				// D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core";  				break;  			case ProductType.EnterpriseServerCore:  				// E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core";  				break;  			case ProductType.EnterpriseServerIA64:  				// F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server IA64";  				break;  			case ProductType.WebServer:  				// 11  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server";  				break;  			case ProductType.ClusterServer:  				// 12  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Cluster Server";  				break;  			case ProductType.HomeServer:  				// 13  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Server";  				break;  			case ProductType.StorageExpressServer:  				// 14  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server";  				break;  			case ProductType.StorageStandardServer:  				// 15  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server";  				break;  			case ProductType.StorageWorkgroupServer:  				// 16  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server";  				break;  			case ProductType.StorageEnterpriseServer:  				// 17  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server";  				break;  			case ProductType.ServerForSmallBusiness:  				// 18  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Businesses";  				break;  			case ProductType.SmallBusinessServerPremium:  				// 19  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Premium";  				break;  			case ProductType.WebServerCore:  				// 1D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Web Server Core";  				break;  			case ProductType.MediumBusinessServerManagement:  				// 1E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Management";  				break;  			case ProductType.MediumBusinessServerSecurity:  				// 1F  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Security";  				break;  			case ProductType.MediumBusinessServerMessaging:  				// 20  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Medium Business Server Messaging";  				break;  			case ProductType.SmallBusinessServerPrime:  				// 21  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Small Business Server Prime";  				break;  			case ProductType.HomePremiumServer:  				// 22  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Home Premium Server";  				break;  			case ProductType.ServerForSmallBusinessV:  				// 23  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Server for Small Business (Hyper-V)";  				break;  			case ProductType.StandardServerV:  				// 24  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerV:  				// 25  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server (Hyper-V)";  				break;  			case ProductType.EnterpriseServerV:  				// 26  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server (Hyper-V)";  				break;  			case ProductType.DataCenterServerCoreV:  				// 27  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Data Center Server Core (Hyper-V)";  				break;  			case ProductType.StandardServerCoreV:  				// 28  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Standard Server Core (Hyper-V)";  				break;  			case ProductType.EnterpriseServerCoreV:  				// 29  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Enterprise Server Core (Hyper-V)";  				break;  			case ProductType.HyperV:  				// 2A  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "(Hyper-V)";  				break;  			case ProductType.StorageExpressServerCore:  				// 2B  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Express Server Core";  				break;  			case ProductType.StorageStandardServerCore:  				// 2C  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Standard Server Core";  				break;  			case ProductType.StorageWorkgroupServerCore:  				// 2D  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Workgroup Server Core";  				break;  			case ProductType.StorageEnterpriseServerCore:  				// 2E  				ClassName = "Windows.v2008";  				PlatformSubType = "2008";  				Edition = "Storage Enterprise Server Core";  				break;  			case ProductType.Unlicensed:  				// 0xABCDABCD  				ClassName = "Windows.Unlicensed";  				PlatformSubType = "2008";  				Edition = "Unlicensed";  				break;  			default:  				ClassName = "Windows.Unknown";  				PlatformSubType = "2008";  				Edition = "is unknown!";  				break;  			}  		}  		break;  	case 1:  		switch (ospi.dwOSEdition) {  		case ProductType.Undefined:  			ClassName = "Windows.Undefined";  			PlatformSubType = "7";  			Edition = "is undefined";  			break;  		case ProductType.Ultimate:  			//    1  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Ultimate Edition";  			break;  		case ProductType.HomeBasic:  			// 2  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic Edition";  			break;  		case ProductType.HomePremium:  			// 3  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Premium Edition";  			break;  		case ProductType.Enterprise:  			// 4  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Enterprise Edition";  			break;  		case ProductType.HomeBasicN:  			// 5  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Home Basic N Edition (EU only)";  			break;  		case ProductType.Business:  			// 6  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business Edition";  			break;  		case ProductType.BusinessN:  			// 10  			ClassName = "Windows.v7";  			PlatformSubType = "7";  			Edition = "Business N Edition (EU only)";  			break;  		}  		break;  	}  	//End os.Version.Minor  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (osvi.wProductType) {  case 1:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "4.0 Workstation";  	break;  case 3:  	if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Server Enterprise";  	} else {  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Server Standard";  	}  	break;  }  
Magic Number,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Version.Minor) {  case 0:  	switch (osvi.wSuiteMask) {  	case SuiteVersion.DataCenter:  		ClassName = "Windows.v2000";  		PlatformSubType = "2000";  		Edition = "Data Center";  		break;  	case SuiteVersion.Enterprise:  		ClassName = "Windows.v2000";  		PlatformSubType = "2000";  		Edition = "Advanced";  		break;  	default:  		ClassName = "Windows.v2000";  		PlatformSubType = "2000";  		Edition = "Standard";  		break;  	}  	break;  case 1:  	if (osvi.wSuiteMask == SuiteVersion.Personal) {  		ClassName = "Windows.XP";  		PlatformSubType = "XP";  		Edition = "Professional";  	} else {  		ClassName = "Windows.XP";  		PlatformSubType = "XP";  		Edition = "Home";  	}  	break;  case 2:  	if ((osvi.wProductType == NTVersion.Workstation) && (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64)) {  		ClassName = "Windows.XP";  		PlatformSubType = "XP";  		Edition = "Professional x64";  	} else if ((osvi.wProductType == NTVersion.Server) && (GetSystemMetrics (SystemMetrics.ServerR2) == 0) && (osvi.wSuiteMask == SuiteVersion.Enterprise)) {  		ClassName = "Windows.v2003";  		PlatformSubType = "Server";  		Edition = "2003 Enterprise";  	} else if ((osvi.wProductType == NTVersion.Server) && GetSystemMetrics (SystemMetrics.ServerR2) != 0) {  		ClassName = "Windows.v2003";  		PlatformSubType = "Server";  		Edition = "2003 R2";  	} else {  		switch (osvi.wSuiteMask) {  		case SuiteVersion.DataCenter:  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Data Center";  			break;  		case SuiteVersion.Blade:  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Web Edition";  			break;  		case SuiteVersion.WHServer:  			ClassName = "Windows.v2003";  			PlatformSubType = "2003";  			Edition = "Home Server";  			break;  		default:  			ClassName = "Windows.v2003";  			PlatformSubType = "Server";  			Edition = "2003 Standard";  			break;  		}  	}  	break;  }  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: try {  	buf = IO.ReadFully (path' 4096);  } catch (FileNotFoundException) {  	return null;  	// doesn't exist; not a reference.  } catch (DirectoryNotFoundException) {  	return null;  	// doesn't exist; not a reference.  }  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: buf = IO.ReadFully (path' 4096);  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: if (isSymRef (buf' n)) {  	// trim trailing whitespace  	while (0 < n && Char.IsWhiteSpace ((char)buf [n - 1]))  		n--;  	if (n < 6) {  		string content = RawParseUtils.decode (buf' 0' n);  		throw new IOException ("Not a ref: " + name + ": " + content);  	}  	string target = RawParseUtils.decode (buf' 5' n);  	return newSymbolicRef (modified' name' target);  }  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: if (isSymRef (buf' n)) {  	// trim trailing whitespace  	while (0 < n && Char.IsWhiteSpace ((char)buf [n - 1]))  		n--;  	if (n < 6) {  		string content = RawParseUtils.decode (buf' 0' n);  		throw new IOException ("Not a ref: " + name + ": " + content);  	}  	string target = RawParseUtils.decode (buf' 5' n);  	return newSymbolicRef (modified' name' target);  }  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: if (n < 6) {  	string content = RawParseUtils.decode (buf' 0' n);  	throw new IOException ("Not a ref: " + name + ": " + content);  }  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: if (n < 6)  	return false;  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: return buf [0] == 'r' //  && buf [1] == 'e' //  && buf [2] == 'f' //  && buf [3] == ':' //  && buf [4] == ' ';  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: return buf [0] == 'r' //  && buf [1] == 'e' //  && buf [2] == 'f' //  && buf [3] == ':' //  && buf [4] == ' ';  
Magic Number,GitSharp.Core,RefDirectory,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: return buf [0] == 'r' //  && buf [1] == 'e' //  && buf [2] == 'f' //  && buf [3] == ':' //  && buf [4] == ' ';  
Magic Number,GitSharp.Core,RefDirectoryRename,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RefDirectoryRename.cs,renameLog,The following statement contains a magic number: try {  	int levels = RefDirectory.levelsIn (src.getName ()) - 2;  	RefDirectory.delete (srcLog' levels);  	return true;  } catch (IOException) {  	rename (dstLog.FullName' srcLog.FullName);  	return false;  }  
Magic Number,GitSharp.Core.Diff,DiffFormatter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,DiffFormatter,The following statement contains a magic number: setContext (3);  
Magic Number,GitSharp.Core.Diff,DiffFormatter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,CombineA,The following statement contains a magic number: return e [i].BeginA - e [i - 1].EndA <= 2 * _context;  
Magic Number,GitSharp.Core.Diff,DiffFormatter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,CombineB,The following statement contains a magic number: return e [i].BeginB - e [i - 1].EndB <= 2 * _context;  
Magic Number,GitSharp.Core.Diff,RawText,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,size,The following statement contains a magic number: return lines.size () - 2;  
Magic Number,GitSharp.Core.Diff,RawText,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,HashLine,The following statement contains a magic number: for (; ptr < end; ptr++) {  	hash = (hash << 5) ^ (raw [ptr] & 0xff);  }  
Magic Number,GitSharp.Core.Diff,RawText,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,HashLine,The following statement contains a magic number: hash = (hash << 5) ^ (raw [ptr] & 0xff);  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (_entries.Length == _entryCnt) {  	var n = new DirCacheEntry[(_entryCnt + 16) * 3 / 2];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (_entries.Length == _entryCnt) {  	var n = new DirCacheEntry[(_entryCnt + 16) * 3 / 2];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (_entries.Length == _entryCnt) {  	var n = new DirCacheEntry[(_entryCnt + 16) * 3 / 2];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (_entryCnt + cnt > _entries.Length) {  	int m1 = (_entryCnt + 16) * 3 / 2;  	int m2 = _entryCnt + cnt;  	var n = new DirCacheEntry[Math.Max (m1' m2)];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (_entryCnt + cnt > _entries.Length) {  	int m1 = (_entryCnt + 16) * 3 / 2;  	int m2 = _entryCnt + cnt;  	var n = new DirCacheEntry[Math.Max (m1' m2)];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (_entryCnt + cnt > _entries.Length) {  	int m1 = (_entryCnt + 16) * 3 / 2;  	int m2 = _entryCnt + cnt;  	var n = new DirCacheEntry[Math.Max (m1' m2)];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,Replace,The following statement contains a magic number: if (_entryCnt < _entries.Length / 2) {  	var n = new DirCacheEntry[_entryCnt];  	Array.Copy (_entries' 0' n' 0' _entryCnt);  	_entries = n;  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,builder,The following statement contains a magic number: return new DirCacheBuilder (this' _entryCnt + 16);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,editor,The following statement contains a magic number: return new DirCacheEditor (this' _entryCnt + 16);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: IO.ReadFully (inStream' hdr' 0' 12);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: md.Update (hdr' 0' 12);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: if (ver != 2) {  	throw new CorruptObjectException ("Unknown DIRC version " + ver);  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: _entryCnt = NB.DecodeInt32 (hdr' 8);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true) {  	var pos = inStream.Position;  	IO.ReadFully (inStream' hdr' 0' 20);  	if (inStream.ReadByte () < 0) {  		// No extensions present; the file ended where we expected.  		//  		break;  	}  	inStream.Seek (pos' SeekOrigin.Begin);  	md.Update (hdr' 0' 8);  	IO.skipFully (inStream' 8);  	long sz = NB.decodeUInt32 (hdr' 4);  	switch (NB.DecodeInt32 (hdr' 0)) {  	case ExtTree:  		if (int.MaxValue < sz) {  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " is too large at " + sz + " bytes.");  		}  		byte[] raw = new byte[(int)sz];  		IO.ReadFully (inStream' raw' 0' raw.Length);  		md.Update (raw' 0' raw.Length);  		_cacheTree = new DirCacheTree (raw' new MutableInteger ()' null);  		break;  	default:  		if (hdr [0] >= (byte)'A' && hdr [0] <= (byte)'Z') {  			// The extension is optional and is here only as  			// a performance optimization. Since we do not  			// understand it' we can safely skip past it' after  			// we include its data in our checksum.  			//  			skipOptionalExtension (inStream' md' hdr' sz);  		} else {  			// The extension is not an optimization and is  			// _required_ to understand this index format.  			// Since we did not trap it above we must abort.  			//  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " not supported by this version.");  		}  		break;  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true) {  	var pos = inStream.Position;  	IO.ReadFully (inStream' hdr' 0' 20);  	if (inStream.ReadByte () < 0) {  		// No extensions present; the file ended where we expected.  		//  		break;  	}  	inStream.Seek (pos' SeekOrigin.Begin);  	md.Update (hdr' 0' 8);  	IO.skipFully (inStream' 8);  	long sz = NB.decodeUInt32 (hdr' 4);  	switch (NB.DecodeInt32 (hdr' 0)) {  	case ExtTree:  		if (int.MaxValue < sz) {  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " is too large at " + sz + " bytes.");  		}  		byte[] raw = new byte[(int)sz];  		IO.ReadFully (inStream' raw' 0' raw.Length);  		md.Update (raw' 0' raw.Length);  		_cacheTree = new DirCacheTree (raw' new MutableInteger ()' null);  		break;  	default:  		if (hdr [0] >= (byte)'A' && hdr [0] <= (byte)'Z') {  			// The extension is optional and is here only as  			// a performance optimization. Since we do not  			// understand it' we can safely skip past it' after  			// we include its data in our checksum.  			//  			skipOptionalExtension (inStream' md' hdr' sz);  		} else {  			// The extension is not an optimization and is  			// _required_ to understand this index format.  			// Since we did not trap it above we must abort.  			//  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " not supported by this version.");  		}  		break;  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true) {  	var pos = inStream.Position;  	IO.ReadFully (inStream' hdr' 0' 20);  	if (inStream.ReadByte () < 0) {  		// No extensions present; the file ended where we expected.  		//  		break;  	}  	inStream.Seek (pos' SeekOrigin.Begin);  	md.Update (hdr' 0' 8);  	IO.skipFully (inStream' 8);  	long sz = NB.decodeUInt32 (hdr' 4);  	switch (NB.DecodeInt32 (hdr' 0)) {  	case ExtTree:  		if (int.MaxValue < sz) {  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " is too large at " + sz + " bytes.");  		}  		byte[] raw = new byte[(int)sz];  		IO.ReadFully (inStream' raw' 0' raw.Length);  		md.Update (raw' 0' raw.Length);  		_cacheTree = new DirCacheTree (raw' new MutableInteger ()' null);  		break;  	default:  		if (hdr [0] >= (byte)'A' && hdr [0] <= (byte)'Z') {  			// The extension is optional and is here only as  			// a performance optimization. Since we do not  			// understand it' we can safely skip past it' after  			// we include its data in our checksum.  			//  			skipOptionalExtension (inStream' md' hdr' sz);  		} else {  			// The extension is not an optimization and is  			// _required_ to understand this index format.  			// Since we did not trap it above we must abort.  			//  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " not supported by this version.");  		}  		break;  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true) {  	var pos = inStream.Position;  	IO.ReadFully (inStream' hdr' 0' 20);  	if (inStream.ReadByte () < 0) {  		// No extensions present; the file ended where we expected.  		//  		break;  	}  	inStream.Seek (pos' SeekOrigin.Begin);  	md.Update (hdr' 0' 8);  	IO.skipFully (inStream' 8);  	long sz = NB.decodeUInt32 (hdr' 4);  	switch (NB.DecodeInt32 (hdr' 0)) {  	case ExtTree:  		if (int.MaxValue < sz) {  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " is too large at " + sz + " bytes.");  		}  		byte[] raw = new byte[(int)sz];  		IO.ReadFully (inStream' raw' 0' raw.Length);  		md.Update (raw' 0' raw.Length);  		_cacheTree = new DirCacheTree (raw' new MutableInteger ()' null);  		break;  	default:  		if (hdr [0] >= (byte)'A' && hdr [0] <= (byte)'Z') {  			// The extension is optional and is here only as  			// a performance optimization. Since we do not  			// understand it' we can safely skip past it' after  			// we include its data in our checksum.  			//  			skipOptionalExtension (inStream' md' hdr' sz);  		} else {  			// The extension is not an optimization and is  			// _required_ to understand this index format.  			// Since we did not trap it above we must abort.  			//  			throw new CorruptObjectException ("DIRC extension " + formatExtensionName (hdr) + " not supported by this version.");  		}  		break;  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: IO.ReadFully (inStream' hdr' 0' 20);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: md.Update (hdr' 0' 8);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: IO.skipFully (inStream' 8);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,formatExtensionName,The following statement contains a magic number: return "'" + Charset.forName ("ISO-8859-1").GetString (hdr' 0' 4) + "'";  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32 (tmp' 4' /* version */2);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32 (tmp' 4' /* version */2);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32 (tmp' 8' _entryCnt);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: dos.Write (tmp' 0' 12);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_lastModified <= 0) {  	// Write a new index' as no entries require smudging.  	//  	for (int i = 0; i < _entryCnt; i++) {  		_sortedEntries [i].write (dos);  	}  } else {  	int smudge_s = (int)(_lastModified / 1000);  	int smudge_ns = ((int)(_lastModified % 1000)) * 1000000;  	for (int i = 0; i < _entryCnt; i++) {  		DirCacheEntry e = _sortedEntries [i];  		if (e.mightBeRacilyClean (smudge_s' smudge_ns))  			e.smudgeRacilyClean ();  		e.write (dos);  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_lastModified <= 0) {  	// Write a new index' as no entries require smudging.  	//  	for (int i = 0; i < _entryCnt; i++) {  		_sortedEntries [i].write (dos);  	}  } else {  	int smudge_s = (int)(_lastModified / 1000);  	int smudge_ns = ((int)(_lastModified % 1000)) * 1000000;  	for (int i = 0; i < _entryCnt; i++) {  		DirCacheEntry e = _sortedEntries [i];  		if (e.mightBeRacilyClean (smudge_s' smudge_ns))  			e.smudgeRacilyClean ();  		e.write (dos);  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_lastModified <= 0) {  	// Write a new index' as no entries require smudging.  	//  	for (int i = 0; i < _entryCnt; i++) {  		_sortedEntries [i].write (dos);  	}  } else {  	int smudge_s = (int)(_lastModified / 1000);  	int smudge_ns = ((int)(_lastModified % 1000)) * 1000000;  	for (int i = 0; i < _entryCnt; i++) {  		DirCacheEntry e = _sortedEntries [i];  		if (e.mightBeRacilyClean (smudge_s' smudge_ns))  			e.smudgeRacilyClean ();  		e.write (dos);  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_cacheTree != null) {  	var bb = new LocalFileBuffer ();  	_cacheTree.write (tmp' bb);  	bb.close ();  	NB.encodeInt32 (tmp' 0' ExtTree);  	NB.encodeInt32 (tmp' 4' (int)bb.Length);  	dos.Write (tmp' 0' 8);  	bb.writeTo (dos' null);  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_cacheTree != null) {  	var bb = new LocalFileBuffer ();  	_cacheTree.write (tmp' bb);  	bb.close ();  	NB.encodeInt32 (tmp' 0' ExtTree);  	NB.encodeInt32 (tmp' 4' (int)bb.Length);  	dos.Write (tmp' 0' 8);  	bb.writeTo (dos' null);  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32 (tmp' 4' (int)bb.Length);  
Magic Number,GitSharp.Core.DirectoryCache,DirCache,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: dos.Write (tmp' 0' 8);  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: if (stage < 0 || 3 < stage)  	throw new ArgumentException ("Invalid stage " + stage + " for path " + toString (newPath));  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,mightBeRacilyClean,The following statement contains a magic number: if (smudge_s == mtime)  	return smudge_ns <= NB.DecodeInt32 (_info' @base + 4) / 1000000;  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,mightBeRacilyClean,The following statement contains a magic number: if (smudge_s == mtime)  	return smudge_ns <= NB.DecodeInt32 (_info' @base + 4) / 1000000;  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,mightBeRacilyClean,The following statement contains a magic number: return smudge_ns <= NB.DecodeInt32 (_info' @base + 4) / 1000000;  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,mightBeRacilyClean,The following statement contains a magic number: return smudge_ns <= NB.DecodeInt32 (_info' @base + 4) / 1000000;  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,smudgeRacilyClean,The following statement contains a magic number: _info.Fill (@base' @base + 8' (byte)127);  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,smudgeRacilyClean,The following statement contains a magic number: _info.Fill (@base' @base + 8' (byte)127);  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,getStage,The following statement contains a magic number: return (int)((uint)(_info [_infoOffset + PFlags]) >> 4) & 0x3;  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32 (_info' @base' (int)(when / 1000));  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32 (_info' @base + 4' ((int)(when % 1000)) * 1000000);  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32 (_info' @base + 4' ((int)(when % 1000)) * 1000000);  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32 (_info' @base + 4' ((int)(when % 1000)) * 1000000);  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: while (entryIdx < endIdx) {  	DirCacheEntry e = cache [entryIdx];  	if (e.getStage () != 0) {  		throw new UnmergedPathException (e);  	}  	byte[] ep = e.Path;  	if (childIdx < _childCount) {  		DirCacheTree st = _children [childIdx];  		if (st.contains (ep' pathOffset' ep.Length)) {  			int stOffset = pathOffset + st.nameLength () + 1;  			st.writeTree (cache' entryIdx' stOffset' ow);  			size += FileMode.Tree.copyToLength ();  			size += st.nameLength ();  			size += Constants.OBJECT_ID_LENGTH + 2;  			entryIdx += st._entrySpan;  			childIdx++;  			continue;  		}  	}  	FileMode mode = e.getFileMode ();  	size += mode.copyToLength ();  	size += ep.Length - pathOffset;  	size += Constants.OBJECT_ID_LENGTH + 2;  	entryIdx++;  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: while (entryIdx < endIdx) {  	DirCacheEntry e = cache [entryIdx];  	if (e.getStage () != 0) {  		throw new UnmergedPathException (e);  	}  	byte[] ep = e.Path;  	if (childIdx < _childCount) {  		DirCacheTree st = _children [childIdx];  		if (st.contains (ep' pathOffset' ep.Length)) {  			int stOffset = pathOffset + st.nameLength () + 1;  			st.writeTree (cache' entryIdx' stOffset' ow);  			size += FileMode.Tree.copyToLength ();  			size += st.nameLength ();  			size += Constants.OBJECT_ID_LENGTH + 2;  			entryIdx += st._entrySpan;  			childIdx++;  			continue;  		}  	}  	FileMode mode = e.getFileMode ();  	size += mode.copyToLength ();  	size += ep.Length - pathOffset;  	size += Constants.OBJECT_ID_LENGTH + 2;  	entryIdx++;  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: if (childIdx < _childCount) {  	DirCacheTree st = _children [childIdx];  	if (st.contains (ep' pathOffset' ep.Length)) {  		int stOffset = pathOffset + st.nameLength () + 1;  		st.writeTree (cache' entryIdx' stOffset' ow);  		size += FileMode.Tree.copyToLength ();  		size += st.nameLength ();  		size += Constants.OBJECT_ID_LENGTH + 2;  		entryIdx += st._entrySpan;  		childIdx++;  		continue;  	}  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: if (st.contains (ep' pathOffset' ep.Length)) {  	int stOffset = pathOffset + st.nameLength () + 1;  	st.writeTree (cache' entryIdx' stOffset' ow);  	size += FileMode.Tree.copyToLength ();  	size += st.nameLength ();  	size += Constants.OBJECT_ID_LENGTH + 2;  	entryIdx += st._entrySpan;  	childIdx++;  	continue;  }  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: size += Constants.OBJECT_ID_LENGTH + 2;  
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: size += Constants.OBJECT_ID_LENGTH + 2;  
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: sb.AppendLine (indent + new string ('-'' 80));  
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: foreach (string line in exception.StackTrace.Split (new[] {  	" at "  }' StringSplitOptions.RemoveEmptyEntries)) {  	if (string.IsNullOrEmpty (line.Trim ()))  		continue;  	string[] parts = line.Trim ().Split (new[] {  		" in "  	}' StringSplitOptions.RemoveEmptyEntries);  	string classInfo = parts [0];  	if (parts.Length == 2) {  		parts = parts [1].Trim ().Split (new[] {  			"line"  		}' StringSplitOptions.RemoveEmptyEntries);  		if (parts.Length == 2) {  			string srcFile = parts [0];  			int lineNr = int.Parse (parts [1]);  			sb.AppendFormat (indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd (':')' lineNr' classInfo);  		} else {  			sb.AppendLine (indent + "  " + classInfo);  		}  	} else {  		sb.AppendLine (indent + "  " + classInfo);  	}  }  
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: foreach (string line in exception.StackTrace.Split (new[] {  	" at "  }' StringSplitOptions.RemoveEmptyEntries)) {  	if (string.IsNullOrEmpty (line.Trim ()))  		continue;  	string[] parts = line.Trim ().Split (new[] {  		" in "  	}' StringSplitOptions.RemoveEmptyEntries);  	string classInfo = parts [0];  	if (parts.Length == 2) {  		parts = parts [1].Trim ().Split (new[] {  			"line"  		}' StringSplitOptions.RemoveEmptyEntries);  		if (parts.Length == 2) {  			string srcFile = parts [0];  			int lineNr = int.Parse (parts [1]);  			sb.AppendFormat (indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd (':')' lineNr' classInfo);  		} else {  			sb.AppendLine (indent + "  " + classInfo);  		}  	} else {  		sb.AppendLine (indent + "  " + classInfo);  	}  }  
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: if (parts.Length == 2) {  	parts = parts [1].Trim ().Split (new[] {  		"line"  	}' StringSplitOptions.RemoveEmptyEntries);  	if (parts.Length == 2) {  		string srcFile = parts [0];  		int lineNr = int.Parse (parts [1]);  		sb.AppendFormat (indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd (':')' lineNr' classInfo);  	} else {  		sb.AppendLine (indent + "  " + classInfo);  	}  } else {  	sb.AppendLine (indent + "  " + classInfo);  }  
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: if (parts.Length == 2) {  	parts = parts [1].Trim ().Split (new[] {  		"line"  	}' StringSplitOptions.RemoveEmptyEntries);  	if (parts.Length == 2) {  		string srcFile = parts [0];  		int lineNr = int.Parse (parts [1]);  		sb.AppendFormat (indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd (':')' lineNr' classInfo);  	} else {  		sb.AppendLine (indent + "  " + classInfo);  	}  } else {  	sb.AppendLine (indent + "  " + classInfo);  }  
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: if (parts.Length == 2) {  	string srcFile = parts [0];  	int lineNr = int.Parse (parts [1]);  	sb.AppendFormat (indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd (':')' lineNr' classInfo);  } else {  	sb.AppendLine (indent + "  " + classInfo);  }  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: for (int i = allHeads.Count - 1; i >= 0; i--) {  	AbstractHead head = allHeads [i];  	// explanation:  	// a and * of the pattern "a*b"  	// need *b as newHeads  	// that's why * extends the list for it self and it's left neighbor.  	if (head.IsStar) {  		nextHeadsSuggestion.Add (head);  		head.setNewHeads (nextHeadsSuggestion);  	} else {  		head.setNewHeads (nextHeadsSuggestion);  		nextHeadsSuggestion = new List<IHead> (2) {  			head  		};  	}  }  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: if (head.IsStar) {  	nextHeadsSuggestion.Add (head);  	head.setNewHeads (nextHeadsSuggestion);  } else {  	head.setNewHeads (nextHeadsSuggestion);  	nextHeadsSuggestion = new List<IHead> (2) {  		head  	};  }  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: nextHeadsSuggestion = new List<IHead> (2) {  	head  };  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: do {  	int possibleGroupEnd = pattern.IndexOf (']'' firstValidEndBracketIndex);  	if (possibleGroupEnd == -1) {  		throw new NoClosingBracketException (indexOfStartBracket' "["' "]"' pattern);  	}  	Match charClassStartMatch = Regex.Match (pattern.Substring (firstValidCharClassIndex)' CharacterClassStartPattern);  	bool foundCharClass = charClassStartMatch.Success;  	int charClassStartMatchIndex = charClassStartMatch.Index + firstValidCharClassIndex;  	if (foundCharClass && charClassStartMatchIndex < possibleGroupEnd) {  		string classStart = charClassStartMatch.Groups [0].Value;  		string classEnd = classStart [1] + "]";  		int classStartIndex = charClassStartMatchIndex;  		int classEndIndex = pattern.IndexOf (classEnd' classStartIndex + 2);  		if (classEndIndex == -1) {  			throw new NoClosingBracketException (classStartIndex' classStart' classEnd' pattern);  		}  		firstValidCharClassIndex = classEndIndex + 2;  		firstValidEndBracketIndex = firstValidCharClassIndex;  	} else {  		groupEnd = possibleGroupEnd;  	}  } while (groupEnd == -1);  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: do {  	int possibleGroupEnd = pattern.IndexOf (']'' firstValidEndBracketIndex);  	if (possibleGroupEnd == -1) {  		throw new NoClosingBracketException (indexOfStartBracket' "["' "]"' pattern);  	}  	Match charClassStartMatch = Regex.Match (pattern.Substring (firstValidCharClassIndex)' CharacterClassStartPattern);  	bool foundCharClass = charClassStartMatch.Success;  	int charClassStartMatchIndex = charClassStartMatch.Index + firstValidCharClassIndex;  	if (foundCharClass && charClassStartMatchIndex < possibleGroupEnd) {  		string classStart = charClassStartMatch.Groups [0].Value;  		string classEnd = classStart [1] + "]";  		int classStartIndex = charClassStartMatchIndex;  		int classEndIndex = pattern.IndexOf (classEnd' classStartIndex + 2);  		if (classEndIndex == -1) {  			throw new NoClosingBracketException (classStartIndex' classStart' classEnd' pattern);  		}  		firstValidCharClassIndex = classEndIndex + 2;  		firstValidEndBracketIndex = firstValidCharClassIndex;  	} else {  		groupEnd = possibleGroupEnd;  	}  } while (groupEnd == -1);  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: if (foundCharClass && charClassStartMatchIndex < possibleGroupEnd) {  	string classStart = charClassStartMatch.Groups [0].Value;  	string classEnd = classStart [1] + "]";  	int classStartIndex = charClassStartMatchIndex;  	int classEndIndex = pattern.IndexOf (classEnd' classStartIndex + 2);  	if (classEndIndex == -1) {  		throw new NoClosingBracketException (classStartIndex' classStart' classEnd' pattern);  	}  	firstValidCharClassIndex = classEndIndex + 2;  	firstValidEndBracketIndex = firstValidCharClassIndex;  } else {  	groupEnd = possibleGroupEnd;  }  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: if (foundCharClass && charClassStartMatchIndex < possibleGroupEnd) {  	string classStart = charClassStartMatch.Groups [0].Value;  	string classEnd = classStart [1] + "]";  	int classStartIndex = charClassStartMatchIndex;  	int classEndIndex = pattern.IndexOf (classEnd' classStartIndex + 2);  	if (classEndIndex == -1) {  		throw new NoClosingBracketException (classStartIndex' classStart' classEnd' pattern);  	}  	firstValidCharClassIndex = classEndIndex + 2;  	firstValidEndBracketIndex = firstValidCharClassIndex;  } else {  	groupEnd = possibleGroupEnd;  }  
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: firstValidCharClassIndex = classEndIndex + 2;  
Magic Number,GitSharp.Core.FnMatch,GroupHead,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,The following statement contains a magic number: while (match.Success) {  	string characterClass = match.Groups [0].Value;  	if (characterClass.Length == 3 && characterClass [1] == '-') {  		char start = characterClass [0];  		char end = characterClass [2];  		_characterClasses.Add (new CharacterRange (start' end));  	} else if (characterClass.Equals ("[:alnum:]")) {  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:alpha:]")) {  		_characterClasses.Add (LetterPattern.Instance);  	} else if (characterClass.Equals ("[:blank:]")) {  		_characterClasses.Add (new OneCharacterPattern (' '));  		_characterClasses.Add (new OneCharacterPattern ('\t'));  	} else if (characterClass.Equals ("[:cntrl:]")) {  		_characterClasses.Add (new CharacterRange ('\u0000'' '\u001F'));  		_characterClasses.Add (new OneCharacterPattern ('\u007F'));  	} else if (characterClass.Equals ("[:digit:]")) {  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:graph:]")) {  		_characterClasses.Add (new CharacterRange ('\u0021'' '\u007E'));  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:lower:]")) {  		_characterClasses.Add (LowerPattern.Instance);  	} else if (characterClass.Equals ("[:print:]")) {  		_characterClasses.Add (new CharacterRange ('\u0020'' '\u007E'));  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:punct:]")) {  		_characterClasses.Add (PunctPattern.Instance);  	} else if (characterClass.Equals ("[:space:]")) {  		_characterClasses.Add (WhitespacePattern.Instance);  	} else if (characterClass.Equals ("[:upper:]")) {  		_characterClasses.Add (UpperPattern.Instance);  	} else if (characterClass.Equals ("[:xdigit:]")) {  		_characterClasses.Add (new CharacterRange ('0'' '9'));  		_characterClasses.Add (new CharacterRange ('a'' 'f'));  		_characterClasses.Add (new CharacterRange ('A'' 'F'));  	} else if (characterClass.Equals ("[:word:]")) {  		_characterClasses.Add (new OneCharacterPattern ('_'));  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else {  		string message = string.Format ("The character class \"{0}\" is not supported."' characterClass);  		throw new InvalidPatternException (message' wholePattern);  	}  	pattern = pattern.Replace (characterClass' string.Empty);  	match = RegexPattern.Match (pattern);  }  
Magic Number,GitSharp.Core.FnMatch,GroupHead,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,The following statement contains a magic number: while (match.Success) {  	string characterClass = match.Groups [0].Value;  	if (characterClass.Length == 3 && characterClass [1] == '-') {  		char start = characterClass [0];  		char end = characterClass [2];  		_characterClasses.Add (new CharacterRange (start' end));  	} else if (characterClass.Equals ("[:alnum:]")) {  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:alpha:]")) {  		_characterClasses.Add (LetterPattern.Instance);  	} else if (characterClass.Equals ("[:blank:]")) {  		_characterClasses.Add (new OneCharacterPattern (' '));  		_characterClasses.Add (new OneCharacterPattern ('\t'));  	} else if (characterClass.Equals ("[:cntrl:]")) {  		_characterClasses.Add (new CharacterRange ('\u0000'' '\u001F'));  		_characterClasses.Add (new OneCharacterPattern ('\u007F'));  	} else if (characterClass.Equals ("[:digit:]")) {  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:graph:]")) {  		_characterClasses.Add (new CharacterRange ('\u0021'' '\u007E'));  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:lower:]")) {  		_characterClasses.Add (LowerPattern.Instance);  	} else if (characterClass.Equals ("[:print:]")) {  		_characterClasses.Add (new CharacterRange ('\u0020'' '\u007E'));  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else if (characterClass.Equals ("[:punct:]")) {  		_characterClasses.Add (PunctPattern.Instance);  	} else if (characterClass.Equals ("[:space:]")) {  		_characterClasses.Add (WhitespacePattern.Instance);  	} else if (characterClass.Equals ("[:upper:]")) {  		_characterClasses.Add (UpperPattern.Instance);  	} else if (characterClass.Equals ("[:xdigit:]")) {  		_characterClasses.Add (new CharacterRange ('0'' '9'));  		_characterClasses.Add (new CharacterRange ('a'' 'f'));  		_characterClasses.Add (new CharacterRange ('A'' 'F'));  	} else if (characterClass.Equals ("[:word:]")) {  		_characterClasses.Add (new OneCharacterPattern ('_'));  		_characterClasses.Add (LetterPattern.Instance);  		_characterClasses.Add (DigitPattern.Instance);  	} else {  		string message = string.Format ("The character class \"{0}\" is not supported."' characterClass);  		throw new InvalidPatternException (message' wholePattern);  	}  	pattern = pattern.Replace (characterClass' string.Empty);  	match = RegexPattern.Match (pattern);  }  
Magic Number,GitSharp.Core.FnMatch,GroupHead,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,The following statement contains a magic number: if (characterClass.Length == 3 && characterClass [1] == '-') {  	char start = characterClass [0];  	char end = characterClass [2];  	_characterClasses.Add (new CharacterRange (start' end));  } else if (characterClass.Equals ("[:alnum:]")) {  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:alpha:]")) {  	_characterClasses.Add (LetterPattern.Instance);  } else if (characterClass.Equals ("[:blank:]")) {  	_characterClasses.Add (new OneCharacterPattern (' '));  	_characterClasses.Add (new OneCharacterPattern ('\t'));  } else if (characterClass.Equals ("[:cntrl:]")) {  	_characterClasses.Add (new CharacterRange ('\u0000'' '\u001F'));  	_characterClasses.Add (new OneCharacterPattern ('\u007F'));  } else if (characterClass.Equals ("[:digit:]")) {  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:graph:]")) {  	_characterClasses.Add (new CharacterRange ('\u0021'' '\u007E'));  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:lower:]")) {  	_characterClasses.Add (LowerPattern.Instance);  } else if (characterClass.Equals ("[:print:]")) {  	_characterClasses.Add (new CharacterRange ('\u0020'' '\u007E'));  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:punct:]")) {  	_characterClasses.Add (PunctPattern.Instance);  } else if (characterClass.Equals ("[:space:]")) {  	_characterClasses.Add (WhitespacePattern.Instance);  } else if (characterClass.Equals ("[:upper:]")) {  	_characterClasses.Add (UpperPattern.Instance);  } else if (characterClass.Equals ("[:xdigit:]")) {  	_characterClasses.Add (new CharacterRange ('0'' '9'));  	_characterClasses.Add (new CharacterRange ('a'' 'f'));  	_characterClasses.Add (new CharacterRange ('A'' 'F'));  } else if (characterClass.Equals ("[:word:]")) {  	_characterClasses.Add (new OneCharacterPattern ('_'));  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else {  	string message = string.Format ("The character class \"{0}\" is not supported."' characterClass);  	throw new InvalidPatternException (message' wholePattern);  }  
Magic Number,GitSharp.Core.FnMatch,GroupHead,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,The following statement contains a magic number: if (characterClass.Length == 3 && characterClass [1] == '-') {  	char start = characterClass [0];  	char end = characterClass [2];  	_characterClasses.Add (new CharacterRange (start' end));  } else if (characterClass.Equals ("[:alnum:]")) {  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:alpha:]")) {  	_characterClasses.Add (LetterPattern.Instance);  } else if (characterClass.Equals ("[:blank:]")) {  	_characterClasses.Add (new OneCharacterPattern (' '));  	_characterClasses.Add (new OneCharacterPattern ('\t'));  } else if (characterClass.Equals ("[:cntrl:]")) {  	_characterClasses.Add (new CharacterRange ('\u0000'' '\u001F'));  	_characterClasses.Add (new OneCharacterPattern ('\u007F'));  } else if (characterClass.Equals ("[:digit:]")) {  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:graph:]")) {  	_characterClasses.Add (new CharacterRange ('\u0021'' '\u007E'));  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:lower:]")) {  	_characterClasses.Add (LowerPattern.Instance);  } else if (characterClass.Equals ("[:print:]")) {  	_characterClasses.Add (new CharacterRange ('\u0020'' '\u007E'));  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else if (characterClass.Equals ("[:punct:]")) {  	_characterClasses.Add (PunctPattern.Instance);  } else if (characterClass.Equals ("[:space:]")) {  	_characterClasses.Add (WhitespacePattern.Instance);  } else if (characterClass.Equals ("[:upper:]")) {  	_characterClasses.Add (UpperPattern.Instance);  } else if (characterClass.Equals ("[:xdigit:]")) {  	_characterClasses.Add (new CharacterRange ('0'' '9'));  	_characterClasses.Add (new CharacterRange ('a'' 'f'));  	_characterClasses.Add (new CharacterRange ('A'' 'F'));  } else if (characterClass.Equals ("[:word:]")) {  	_characterClasses.Add (new OneCharacterPattern ('_'));  	_characterClasses.Add (LetterPattern.Instance);  	_characterClasses.Add (DigitPattern.Instance);  } else {  	string message = string.Format ("The character class \"{0}\" is not supported."' characterClass);  	throw new InvalidPatternException (message' wholePattern);  }  
Magic Number,GitSharp.Core.Merge,ThreeWayMerger,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\ThreeWayMerger.cs,Merge,The following statement contains a magic number: return tips.Length != 2 ? false : base.Merge (tips);  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: while (theirsEdit != END_EDIT || oursEdit != END_EDIT) {  	if (oursEdit.EndA <= theirsEdit.BeginA) {  		// something was changed in ours not overlapping with any change  		// from theirs. First add the common part in front of the edit  		// then the edit.  		if (current != oursEdit.BeginA) {  			result.add (0' current' oursEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  		}  		result.add (1' oursEdit.BeginB' oursEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  		current = oursEdit.EndA;  		oursEdit = nextEdit (baseToOurs);  	} else if (theirsEdit.EndA <= oursEdit.BeginA) {  		// something was changed in theirs not overlapping with any  		// from ours. First add the common part in front of the edit  		// then the edit.  		if (current != theirsEdit.BeginA) {  			result.add (0' current' theirsEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  		}  		result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  		current = theirsEdit.EndA;  		theirsEdit = nextEdit (baseToTheirs);  	} else {  		// here we found a real overlapping modification  		// if there is a common part in front of the conflict add it  		if (oursEdit.BeginA != current && theirsEdit.BeginA != current) {  			result.add (0' current' Math.Min (oursEdit.BeginA' theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);  		}  		// set some initial values for the ranges in A and B which we  		// want to handle  		int oursBeginB = oursEdit.BeginB;  		int theirsBeginB = theirsEdit.BeginB;  		// harmonize the start of the ranges in A and B  		if (oursEdit.BeginA < theirsEdit.BeginA) {  			theirsBeginB -= theirsEdit.BeginA - oursEdit.BeginA;  		} else {  			oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;  		}  		// combine edits:  		// Maybe an Edit on one side corresponds to multiple Edits on  		// the other side. Then we have to combine the Edits of the  		// other side - so in the end we can merge together two single  		// edits.  		//  		// It is important to notice that this combining will extend the  		// ranges of our conflict always downwards (towards the end of  		// the content). The starts of the conflicting ranges in ours  		// and theirs are not touched here.  		//  		// This combining is an iterative process: after we have  		// combined some edits we have to do the check again. The  		// combined edits could now correspond to multiple edits on the  		// other side.  		//  		// Example: when this combining algorithm works on the following  		// edits  		// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  		// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  		// it will merge them into  		// oursEdits=((0-8'0-8)'(10-11'10-11)) and  		// theirsEdits=((0-7'0-7))  		//  		// Since the only interesting thing to us is how in ours and  		// theirs the end of the conflicting range is changing we let  		// oursEdit and theirsEdit point to the last conflicting edit  		Edit nextOursEdit = nextEdit (baseToOurs);  		Edit nextTheirsEdit = nextEdit (baseToTheirs);  		for (; ;) {  			if (oursEdit.EndA > nextTheirsEdit.BeginA) {  				theirsEdit = nextTheirsEdit;  				nextTheirsEdit = nextEdit (baseToTheirs);  			} else if (theirsEdit.EndA > nextOursEdit.BeginA) {  				oursEdit = nextOursEdit;  				nextOursEdit = nextEdit (baseToOurs);  			} else {  				break;  			}  		}  		// harmonize the end of the ranges in A and B  		int oursEndB = oursEdit.EndB;  		int theirsEndB = theirsEdit.EndB;  		if (oursEdit.EndA < theirsEdit.EndA) {  			oursEndB += theirsEdit.EndA - oursEdit.EndA;  		} else {  			theirsEndB += oursEdit.EndA - theirsEdit.EndA;  		}  		// Add the conflict  		result.add (1' oursBeginB' oursEndB' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  		result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  		current = Math.Max (oursEdit.EndA' theirsEdit.EndA);  		oursEdit = nextOursEdit;  		theirsEdit = nextTheirsEdit;  	}  }  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: while (theirsEdit != END_EDIT || oursEdit != END_EDIT) {  	if (oursEdit.EndA <= theirsEdit.BeginA) {  		// something was changed in ours not overlapping with any change  		// from theirs. First add the common part in front of the edit  		// then the edit.  		if (current != oursEdit.BeginA) {  			result.add (0' current' oursEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  		}  		result.add (1' oursEdit.BeginB' oursEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  		current = oursEdit.EndA;  		oursEdit = nextEdit (baseToOurs);  	} else if (theirsEdit.EndA <= oursEdit.BeginA) {  		// something was changed in theirs not overlapping with any  		// from ours. First add the common part in front of the edit  		// then the edit.  		if (current != theirsEdit.BeginA) {  			result.add (0' current' theirsEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  		}  		result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  		current = theirsEdit.EndA;  		theirsEdit = nextEdit (baseToTheirs);  	} else {  		// here we found a real overlapping modification  		// if there is a common part in front of the conflict add it  		if (oursEdit.BeginA != current && theirsEdit.BeginA != current) {  			result.add (0' current' Math.Min (oursEdit.BeginA' theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);  		}  		// set some initial values for the ranges in A and B which we  		// want to handle  		int oursBeginB = oursEdit.BeginB;  		int theirsBeginB = theirsEdit.BeginB;  		// harmonize the start of the ranges in A and B  		if (oursEdit.BeginA < theirsEdit.BeginA) {  			theirsBeginB -= theirsEdit.BeginA - oursEdit.BeginA;  		} else {  			oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;  		}  		// combine edits:  		// Maybe an Edit on one side corresponds to multiple Edits on  		// the other side. Then we have to combine the Edits of the  		// other side - so in the end we can merge together two single  		// edits.  		//  		// It is important to notice that this combining will extend the  		// ranges of our conflict always downwards (towards the end of  		// the content). The starts of the conflicting ranges in ours  		// and theirs are not touched here.  		//  		// This combining is an iterative process: after we have  		// combined some edits we have to do the check again. The  		// combined edits could now correspond to multiple edits on the  		// other side.  		//  		// Example: when this combining algorithm works on the following  		// edits  		// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  		// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  		// it will merge them into  		// oursEdits=((0-8'0-8)'(10-11'10-11)) and  		// theirsEdits=((0-7'0-7))  		//  		// Since the only interesting thing to us is how in ours and  		// theirs the end of the conflicting range is changing we let  		// oursEdit and theirsEdit point to the last conflicting edit  		Edit nextOursEdit = nextEdit (baseToOurs);  		Edit nextTheirsEdit = nextEdit (baseToTheirs);  		for (; ;) {  			if (oursEdit.EndA > nextTheirsEdit.BeginA) {  				theirsEdit = nextTheirsEdit;  				nextTheirsEdit = nextEdit (baseToTheirs);  			} else if (theirsEdit.EndA > nextOursEdit.BeginA) {  				oursEdit = nextOursEdit;  				nextOursEdit = nextEdit (baseToOurs);  			} else {  				break;  			}  		}  		// harmonize the end of the ranges in A and B  		int oursEndB = oursEdit.EndB;  		int theirsEndB = theirsEdit.EndB;  		if (oursEdit.EndA < theirsEdit.EndA) {  			oursEndB += theirsEdit.EndA - oursEdit.EndA;  		} else {  			theirsEndB += oursEdit.EndA - theirsEdit.EndA;  		}  		// Add the conflict  		result.add (1' oursBeginB' oursEndB' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  		result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  		current = Math.Max (oursEdit.EndA' theirsEdit.EndA);  		oursEdit = nextOursEdit;  		theirsEdit = nextTheirsEdit;  	}  }  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: if (oursEdit.EndA <= theirsEdit.BeginA) {  	// something was changed in ours not overlapping with any change  	// from theirs. First add the common part in front of the edit  	// then the edit.  	if (current != oursEdit.BeginA) {  		result.add (0' current' oursEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  	}  	result.add (1' oursEdit.BeginB' oursEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  	current = oursEdit.EndA;  	oursEdit = nextEdit (baseToOurs);  } else if (theirsEdit.EndA <= oursEdit.BeginA) {  	// something was changed in theirs not overlapping with any  	// from ours. First add the common part in front of the edit  	// then the edit.  	if (current != theirsEdit.BeginA) {  		result.add (0' current' theirsEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  	}  	result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  	current = theirsEdit.EndA;  	theirsEdit = nextEdit (baseToTheirs);  } else {  	// here we found a real overlapping modification  	// if there is a common part in front of the conflict add it  	if (oursEdit.BeginA != current && theirsEdit.BeginA != current) {  		result.add (0' current' Math.Min (oursEdit.BeginA' theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);  	}  	// set some initial values for the ranges in A and B which we  	// want to handle  	int oursBeginB = oursEdit.BeginB;  	int theirsBeginB = theirsEdit.BeginB;  	// harmonize the start of the ranges in A and B  	if (oursEdit.BeginA < theirsEdit.BeginA) {  		theirsBeginB -= theirsEdit.BeginA - oursEdit.BeginA;  	} else {  		oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;  	}  	// combine edits:  	// Maybe an Edit on one side corresponds to multiple Edits on  	// the other side. Then we have to combine the Edits of the  	// other side - so in the end we can merge together two single  	// edits.  	//  	// It is important to notice that this combining will extend the  	// ranges of our conflict always downwards (towards the end of  	// the content). The starts of the conflicting ranges in ours  	// and theirs are not touched here.  	//  	// This combining is an iterative process: after we have  	// combined some edits we have to do the check again. The  	// combined edits could now correspond to multiple edits on the  	// other side.  	//  	// Example: when this combining algorithm works on the following  	// edits  	// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  	// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  	// it will merge them into  	// oursEdits=((0-8'0-8)'(10-11'10-11)) and  	// theirsEdits=((0-7'0-7))  	//  	// Since the only interesting thing to us is how in ours and  	// theirs the end of the conflicting range is changing we let  	// oursEdit and theirsEdit point to the last conflicting edit  	Edit nextOursEdit = nextEdit (baseToOurs);  	Edit nextTheirsEdit = nextEdit (baseToTheirs);  	for (; ;) {  		if (oursEdit.EndA > nextTheirsEdit.BeginA) {  			theirsEdit = nextTheirsEdit;  			nextTheirsEdit = nextEdit (baseToTheirs);  		} else if (theirsEdit.EndA > nextOursEdit.BeginA) {  			oursEdit = nextOursEdit;  			nextOursEdit = nextEdit (baseToOurs);  		} else {  			break;  		}  	}  	// harmonize the end of the ranges in A and B  	int oursEndB = oursEdit.EndB;  	int theirsEndB = theirsEdit.EndB;  	if (oursEdit.EndA < theirsEdit.EndA) {  		oursEndB += theirsEdit.EndA - oursEdit.EndA;  	} else {  		theirsEndB += oursEdit.EndA - theirsEdit.EndA;  	}  	// Add the conflict  	result.add (1' oursBeginB' oursEndB' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  	result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  	current = Math.Max (oursEdit.EndA' theirsEdit.EndA);  	oursEdit = nextOursEdit;  	theirsEdit = nextTheirsEdit;  }  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: if (oursEdit.EndA <= theirsEdit.BeginA) {  	// something was changed in ours not overlapping with any change  	// from theirs. First add the common part in front of the edit  	// then the edit.  	if (current != oursEdit.BeginA) {  		result.add (0' current' oursEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  	}  	result.add (1' oursEdit.BeginB' oursEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  	current = oursEdit.EndA;  	oursEdit = nextEdit (baseToOurs);  } else if (theirsEdit.EndA <= oursEdit.BeginA) {  	// something was changed in theirs not overlapping with any  	// from ours. First add the common part in front of the edit  	// then the edit.  	if (current != theirsEdit.BeginA) {  		result.add (0' current' theirsEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  	}  	result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  	current = theirsEdit.EndA;  	theirsEdit = nextEdit (baseToTheirs);  } else {  	// here we found a real overlapping modification  	// if there is a common part in front of the conflict add it  	if (oursEdit.BeginA != current && theirsEdit.BeginA != current) {  		result.add (0' current' Math.Min (oursEdit.BeginA' theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);  	}  	// set some initial values for the ranges in A and B which we  	// want to handle  	int oursBeginB = oursEdit.BeginB;  	int theirsBeginB = theirsEdit.BeginB;  	// harmonize the start of the ranges in A and B  	if (oursEdit.BeginA < theirsEdit.BeginA) {  		theirsBeginB -= theirsEdit.BeginA - oursEdit.BeginA;  	} else {  		oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;  	}  	// combine edits:  	// Maybe an Edit on one side corresponds to multiple Edits on  	// the other side. Then we have to combine the Edits of the  	// other side - so in the end we can merge together two single  	// edits.  	//  	// It is important to notice that this combining will extend the  	// ranges of our conflict always downwards (towards the end of  	// the content). The starts of the conflicting ranges in ours  	// and theirs are not touched here.  	//  	// This combining is an iterative process: after we have  	// combined some edits we have to do the check again. The  	// combined edits could now correspond to multiple edits on the  	// other side.  	//  	// Example: when this combining algorithm works on the following  	// edits  	// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  	// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  	// it will merge them into  	// oursEdits=((0-8'0-8)'(10-11'10-11)) and  	// theirsEdits=((0-7'0-7))  	//  	// Since the only interesting thing to us is how in ours and  	// theirs the end of the conflicting range is changing we let  	// oursEdit and theirsEdit point to the last conflicting edit  	Edit nextOursEdit = nextEdit (baseToOurs);  	Edit nextTheirsEdit = nextEdit (baseToTheirs);  	for (; ;) {  		if (oursEdit.EndA > nextTheirsEdit.BeginA) {  			theirsEdit = nextTheirsEdit;  			nextTheirsEdit = nextEdit (baseToTheirs);  		} else if (theirsEdit.EndA > nextOursEdit.BeginA) {  			oursEdit = nextOursEdit;  			nextOursEdit = nextEdit (baseToOurs);  		} else {  			break;  		}  	}  	// harmonize the end of the ranges in A and B  	int oursEndB = oursEdit.EndB;  	int theirsEndB = theirsEdit.EndB;  	if (oursEdit.EndA < theirsEdit.EndA) {  		oursEndB += theirsEdit.EndA - oursEdit.EndA;  	} else {  		theirsEndB += oursEdit.EndA - theirsEdit.EndA;  	}  	// Add the conflict  	result.add (1' oursBeginB' oursEndB' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  	result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  	current = Math.Max (oursEdit.EndA' theirsEdit.EndA);  	oursEdit = nextOursEdit;  	theirsEdit = nextTheirsEdit;  }  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: if (theirsEdit.EndA <= oursEdit.BeginA) {  	// something was changed in theirs not overlapping with any  	// from ours. First add the common part in front of the edit  	// then the edit.  	if (current != theirsEdit.BeginA) {  		result.add (0' current' theirsEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  	}  	result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  	current = theirsEdit.EndA;  	theirsEdit = nextEdit (baseToTheirs);  } else {  	// here we found a real overlapping modification  	// if there is a common part in front of the conflict add it  	if (oursEdit.BeginA != current && theirsEdit.BeginA != current) {  		result.add (0' current' Math.Min (oursEdit.BeginA' theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);  	}  	// set some initial values for the ranges in A and B which we  	// want to handle  	int oursBeginB = oursEdit.BeginB;  	int theirsBeginB = theirsEdit.BeginB;  	// harmonize the start of the ranges in A and B  	if (oursEdit.BeginA < theirsEdit.BeginA) {  		theirsBeginB -= theirsEdit.BeginA - oursEdit.BeginA;  	} else {  		oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;  	}  	// combine edits:  	// Maybe an Edit on one side corresponds to multiple Edits on  	// the other side. Then we have to combine the Edits of the  	// other side - so in the end we can merge together two single  	// edits.  	//  	// It is important to notice that this combining will extend the  	// ranges of our conflict always downwards (towards the end of  	// the content). The starts of the conflicting ranges in ours  	// and theirs are not touched here.  	//  	// This combining is an iterative process: after we have  	// combined some edits we have to do the check again. The  	// combined edits could now correspond to multiple edits on the  	// other side.  	//  	// Example: when this combining algorithm works on the following  	// edits  	// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  	// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  	// it will merge them into  	// oursEdits=((0-8'0-8)'(10-11'10-11)) and  	// theirsEdits=((0-7'0-7))  	//  	// Since the only interesting thing to us is how in ours and  	// theirs the end of the conflicting range is changing we let  	// oursEdit and theirsEdit point to the last conflicting edit  	Edit nextOursEdit = nextEdit (baseToOurs);  	Edit nextTheirsEdit = nextEdit (baseToTheirs);  	for (; ;) {  		if (oursEdit.EndA > nextTheirsEdit.BeginA) {  			theirsEdit = nextTheirsEdit;  			nextTheirsEdit = nextEdit (baseToTheirs);  		} else if (theirsEdit.EndA > nextOursEdit.BeginA) {  			oursEdit = nextOursEdit;  			nextOursEdit = nextEdit (baseToOurs);  		} else {  			break;  		}  	}  	// harmonize the end of the ranges in A and B  	int oursEndB = oursEdit.EndB;  	int theirsEndB = theirsEdit.EndB;  	if (oursEdit.EndA < theirsEdit.EndA) {  		oursEndB += theirsEdit.EndA - oursEdit.EndA;  	} else {  		theirsEndB += oursEdit.EndA - theirsEdit.EndA;  	}  	// Add the conflict  	result.add (1' oursBeginB' oursEndB' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  	result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  	current = Math.Max (oursEdit.EndA' theirsEdit.EndA);  	oursEdit = nextOursEdit;  	theirsEdit = nextTheirsEdit;  }  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: if (theirsEdit.EndA <= oursEdit.BeginA) {  	// something was changed in theirs not overlapping with any  	// from ours. First add the common part in front of the edit  	// then the edit.  	if (current != theirsEdit.BeginA) {  		result.add (0' current' theirsEdit.BeginA' MergeChunk.ConflictState.NO_CONFLICT);  	}  	result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  	current = theirsEdit.EndA;  	theirsEdit = nextEdit (baseToTheirs);  } else {  	// here we found a real overlapping modification  	// if there is a common part in front of the conflict add it  	if (oursEdit.BeginA != current && theirsEdit.BeginA != current) {  		result.add (0' current' Math.Min (oursEdit.BeginA' theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);  	}  	// set some initial values for the ranges in A and B which we  	// want to handle  	int oursBeginB = oursEdit.BeginB;  	int theirsBeginB = theirsEdit.BeginB;  	// harmonize the start of the ranges in A and B  	if (oursEdit.BeginA < theirsEdit.BeginA) {  		theirsBeginB -= theirsEdit.BeginA - oursEdit.BeginA;  	} else {  		oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;  	}  	// combine edits:  	// Maybe an Edit on one side corresponds to multiple Edits on  	// the other side. Then we have to combine the Edits of the  	// other side - so in the end we can merge together two single  	// edits.  	//  	// It is important to notice that this combining will extend the  	// ranges of our conflict always downwards (towards the end of  	// the content). The starts of the conflicting ranges in ours  	// and theirs are not touched here.  	//  	// This combining is an iterative process: after we have  	// combined some edits we have to do the check again. The  	// combined edits could now correspond to multiple edits on the  	// other side.  	//  	// Example: when this combining algorithm works on the following  	// edits  	// oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and  	// theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))  	// it will merge them into  	// oursEdits=((0-8'0-8)'(10-11'10-11)) and  	// theirsEdits=((0-7'0-7))  	//  	// Since the only interesting thing to us is how in ours and  	// theirs the end of the conflicting range is changing we let  	// oursEdit and theirsEdit point to the last conflicting edit  	Edit nextOursEdit = nextEdit (baseToOurs);  	Edit nextTheirsEdit = nextEdit (baseToTheirs);  	for (; ;) {  		if (oursEdit.EndA > nextTheirsEdit.BeginA) {  			theirsEdit = nextTheirsEdit;  			nextTheirsEdit = nextEdit (baseToTheirs);  		} else if (theirsEdit.EndA > nextOursEdit.BeginA) {  			oursEdit = nextOursEdit;  			nextOursEdit = nextEdit (baseToOurs);  		} else {  			break;  		}  	}  	// harmonize the end of the ranges in A and B  	int oursEndB = oursEdit.EndB;  	int theirsEndB = theirsEdit.EndB;  	if (oursEdit.EndA < theirsEdit.EndA) {  		oursEndB += theirsEdit.EndA - oursEdit.EndA;  	} else {  		theirsEndB += oursEdit.EndA - theirsEdit.EndA;  	}  	// Add the conflict  	result.add (1' oursBeginB' oursEndB' MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);  	result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  	current = Math.Max (oursEdit.EndA' theirsEdit.EndA);  	oursEdit = nextOursEdit;  	theirsEdit = nextTheirsEdit;  }  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: result.add (2' theirsEdit.BeginB' theirsEdit.EndB' MergeChunk.ConflictState.NO_CONFLICT);  
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: result.add (2' theirsBeginB' theirsEndB' MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: idBuffer.FromString (raw' 5);  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null) {  	var pList = new RevCommit[1];  	int nParents = 0;  	while (true) {  		if (raw [ptr] != (byte)'p')  			break;  		idBuffer.FromString (raw' ptr + 7);  		RevCommit p = walk.lookupCommit (idBuffer);  		if (nParents == 0) {  			pList [nParents++] = p;  		} else if (nParents == 1) {  			pList = new[] {  				pList [0]'  				p  			};  			nParents = 2;  		} else {  			if (pList.Length <= nParents) {  				RevCommit[] old = pList;  				pList = new RevCommit[pList.Length + 32];  				Array.Copy (old' 0' pList' 0' nParents);  			}  			pList [nParents++] = p;  		}  		ptr += 48;  	}  	if (nParents != pList.Length) {  		RevCommit[] old = pList;  		pList = new RevCommit[nParents];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	Parents = pList;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null) {  	var pList = new RevCommit[1];  	int nParents = 0;  	while (true) {  		if (raw [ptr] != (byte)'p')  			break;  		idBuffer.FromString (raw' ptr + 7);  		RevCommit p = walk.lookupCommit (idBuffer);  		if (nParents == 0) {  			pList [nParents++] = p;  		} else if (nParents == 1) {  			pList = new[] {  				pList [0]'  				p  			};  			nParents = 2;  		} else {  			if (pList.Length <= nParents) {  				RevCommit[] old = pList;  				pList = new RevCommit[pList.Length + 32];  				Array.Copy (old' 0' pList' 0' nParents);  			}  			pList [nParents++] = p;  		}  		ptr += 48;  	}  	if (nParents != pList.Length) {  		RevCommit[] old = pList;  		pList = new RevCommit[nParents];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	Parents = pList;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null) {  	var pList = new RevCommit[1];  	int nParents = 0;  	while (true) {  		if (raw [ptr] != (byte)'p')  			break;  		idBuffer.FromString (raw' ptr + 7);  		RevCommit p = walk.lookupCommit (idBuffer);  		if (nParents == 0) {  			pList [nParents++] = p;  		} else if (nParents == 1) {  			pList = new[] {  				pList [0]'  				p  			};  			nParents = 2;  		} else {  			if (pList.Length <= nParents) {  				RevCommit[] old = pList;  				pList = new RevCommit[pList.Length + 32];  				Array.Copy (old' 0' pList' 0' nParents);  			}  			pList [nParents++] = p;  		}  		ptr += 48;  	}  	if (nParents != pList.Length) {  		RevCommit[] old = pList;  		pList = new RevCommit[nParents];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	Parents = pList;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null) {  	var pList = new RevCommit[1];  	int nParents = 0;  	while (true) {  		if (raw [ptr] != (byte)'p')  			break;  		idBuffer.FromString (raw' ptr + 7);  		RevCommit p = walk.lookupCommit (idBuffer);  		if (nParents == 0) {  			pList [nParents++] = p;  		} else if (nParents == 1) {  			pList = new[] {  				pList [0]'  				p  			};  			nParents = 2;  		} else {  			if (pList.Length <= nParents) {  				RevCommit[] old = pList;  				pList = new RevCommit[pList.Length + 32];  				Array.Copy (old' 0' pList' 0' nParents);  			}  			pList [nParents++] = p;  		}  		ptr += 48;  	}  	if (nParents != pList.Length) {  		RevCommit[] old = pList;  		pList = new RevCommit[nParents];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	Parents = pList;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: while (true) {  	if (raw [ptr] != (byte)'p')  		break;  	idBuffer.FromString (raw' ptr + 7);  	RevCommit p = walk.lookupCommit (idBuffer);  	if (nParents == 0) {  		pList [nParents++] = p;  	} else if (nParents == 1) {  		pList = new[] {  			pList [0]'  			p  		};  		nParents = 2;  	} else {  		if (pList.Length <= nParents) {  			RevCommit[] old = pList;  			pList = new RevCommit[pList.Length + 32];  			Array.Copy (old' 0' pList' 0' nParents);  		}  		pList [nParents++] = p;  	}  	ptr += 48;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: while (true) {  	if (raw [ptr] != (byte)'p')  		break;  	idBuffer.FromString (raw' ptr + 7);  	RevCommit p = walk.lookupCommit (idBuffer);  	if (nParents == 0) {  		pList [nParents++] = p;  	} else if (nParents == 1) {  		pList = new[] {  			pList [0]'  			p  		};  		nParents = 2;  	} else {  		if (pList.Length <= nParents) {  			RevCommit[] old = pList;  			pList = new RevCommit[pList.Length + 32];  			Array.Copy (old' 0' pList' 0' nParents);  		}  		pList [nParents++] = p;  	}  	ptr += 48;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: while (true) {  	if (raw [ptr] != (byte)'p')  		break;  	idBuffer.FromString (raw' ptr + 7);  	RevCommit p = walk.lookupCommit (idBuffer);  	if (nParents == 0) {  		pList [nParents++] = p;  	} else if (nParents == 1) {  		pList = new[] {  			pList [0]'  			p  		};  		nParents = 2;  	} else {  		if (pList.Length <= nParents) {  			RevCommit[] old = pList;  			pList = new RevCommit[pList.Length + 32];  			Array.Copy (old' 0' pList' 0' nParents);  		}  		pList [nParents++] = p;  	}  	ptr += 48;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: while (true) {  	if (raw [ptr] != (byte)'p')  		break;  	idBuffer.FromString (raw' ptr + 7);  	RevCommit p = walk.lookupCommit (idBuffer);  	if (nParents == 0) {  		pList [nParents++] = p;  	} else if (nParents == 1) {  		pList = new[] {  			pList [0]'  			p  		};  		nParents = 2;  	} else {  		if (pList.Length <= nParents) {  			RevCommit[] old = pList;  			pList = new RevCommit[pList.Length + 32];  			Array.Copy (old' 0' pList' 0' nParents);  		}  		pList [nParents++] = p;  	}  	ptr += 48;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: idBuffer.FromString (raw' ptr + 7);  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (nParents == 0) {  	pList [nParents++] = p;  } else if (nParents == 1) {  	pList = new[] {  		pList [0]'  		p  	};  	nParents = 2;  } else {  	if (pList.Length <= nParents) {  		RevCommit[] old = pList;  		pList = new RevCommit[pList.Length + 32];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	pList [nParents++] = p;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (nParents == 0) {  	pList [nParents++] = p;  } else if (nParents == 1) {  	pList = new[] {  		pList [0]'  		p  	};  	nParents = 2;  } else {  	if (pList.Length <= nParents) {  		RevCommit[] old = pList;  		pList = new RevCommit[pList.Length + 32];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	pList [nParents++] = p;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (nParents == 1) {  	pList = new[] {  		pList [0]'  		p  	};  	nParents = 2;  } else {  	if (pList.Length <= nParents) {  		RevCommit[] old = pList;  		pList = new RevCommit[pList.Length + 32];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	pList [nParents++] = p;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (nParents == 1) {  	pList = new[] {  		pList [0]'  		p  	};  	nParents = 2;  } else {  	if (pList.Length <= nParents) {  		RevCommit[] old = pList;  		pList = new RevCommit[pList.Length + 32];  		Array.Copy (old' 0' pList' 0' nParents);  	}  	pList [nParents++] = p;  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: nParents = 2;  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (pList.Length <= nParents) {  	RevCommit[] old = pList;  	pList = new RevCommit[pList.Length + 32];  	Array.Copy (old' 0' pList' 0' nParents);  }  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: pList = new RevCommit[pList.Length + 32];  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: ptr += 48;  
Magic Number,GitSharp.Core.RevWalk,RevCommit,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,GetFooterLines,The following statement contains a magic number: while (true) {  	ptr = RawParseUtils.prevLF (raw' ptr);  	if (ptr <= msgB) {  		break;  		// Don't parse commit headers as footer lines.  	}  	int keyStart = ptr + 2;  	if (raw [keyStart] == '\n') {  		break;  		// Stop at first paragraph break' no footers above it.  	}  	int keyEnd = RawParseUtils.endOfFooterLineKey (raw' keyStart);  	if (keyEnd < 0) {  		continue;  		// Not a well formed footer line' skip it.  	}  	// Skip over the ': *' at the end of the key before the value.  	//  	int valStart = keyEnd + 1;  	while (valStart < raw.Length && raw [valStart] == ' ') {  		valStart++;  	}  	// Value ends at the LF' and does not include it.  	//  	int valEnd = RawParseUtils.nextLF (raw' valStart);  	if (raw [valEnd - 1] == '\n') {  		valEnd--;  	}  	r.Add (new FooterLine (raw' enc' keyStart' keyEnd' valStart' valEnd));  }  
Magic Number,GitSharp.Core.RevWalk,RevObjectList,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevObjectList.cs,get,The following statement contains a magic number: if (index >> s.Shift >= 1024) {  	return null;  }  
Magic Number,GitSharp.Core.RevWalk,RevTag,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevTag.cs,parseCanonical,The following statement contains a magic number: walk.IdBuffer.FromString (rawTag' 7);  
Magic Number,GitSharp.Core.RevWalk,RevWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,allocFlag,The following statement contains a magic number: if (_freeFlags == 0) {  	throw new ArgumentException (32 - ReservedFlags + " flags already created.");  }  
Magic Number,GitSharp.Core.RevWalk,RevWalk,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,allocFlag,The following statement contains a magic number: throw new ArgumentException (32 - ReservedFlags + " flags already created.");  
Magic Number,GitSharp.Core.Transport,OpenSshConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,The following statement contains a magic number: while ((line = sr.ReadLine ()) != null) {  	line = line.Trim ();  	if (line.Length == 0 || line.StartsWith ("#"))  		continue;  	var regex = new Regex ("[ \t]*[= \t]");  	string[] parts = regex.Split (line' 2);  	string keyword = parts [0].Trim ();  	string argValue = parts [1].Trim ();  	var regex2 = new Regex ("[ \t]");  	if (StringUtils.equalsIgnoreCase ("Host"' keyword)) {  		current.Clear ();  		foreach (string pattern in regex2.Split (argValue)) {  			string name = dequote (pattern);  			Host c = m.get (name);  			if (c == null) {  				c = new Host ();  				m.put (name' c);  			}  			current.Add (c);  		}  		continue;  	}  	if (current.isEmpty ()) {  		// We received an option outside of a Host block. We  		// don't know who this should match against' so skip.  		//  		continue;  	}  	if (StringUtils.equalsIgnoreCase ("HostName"' keyword)) {  		foreach (Host c in current)  			if (c.hostName == null)  				c.hostName = dequote (argValue);  	} else if (StringUtils.equalsIgnoreCase ("User"' keyword)) {  		foreach (Host c in current)  			if (c.user == null)  				c.user = dequote (argValue);  	} else if (StringUtils.equalsIgnoreCase ("Port"' keyword)) {  		try {  			int port = int.Parse (dequote (argValue));  			foreach (Host c in current)  				if (c.port == 0)  					c.port = port;  		} catch (FormatException) {  			// Bad port number. Don't set it.  		}  	} else if (StringUtils.equalsIgnoreCase ("IdentityFile"' keyword)) {  		foreach (Host c in current)  			if (c.identityFile == null)  				c.identityFile = toFile (dequote (argValue));  	} else if (StringUtils.equalsIgnoreCase ("PreferredAuthentications"' keyword)) {  		foreach (Host c in current)  			if (c.preferredAuthentications == null)  				c.preferredAuthentications = nows (dequote (argValue));  	} else if (StringUtils.equalsIgnoreCase ("BatchMode"' keyword)) {  		foreach (Host c in current)  			if (c.batchMode == null)  				c.batchMode = yesno (dequote (argValue));  	} else if (StringUtils.equalsIgnoreCase ("StrictHostKeyChecking"' keyword)) {  		string value = dequote (argValue);  		foreach (Host c in current)  			if (c.strictHostKeyChecking == null)  				c.strictHostKeyChecking = value;  	}  }  
Magic Number,GitSharp.Core.Transport,OpenSshConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,toFile,The following statement contains a magic number: if (path.StartsWith ("~/")) {  	return PathUtil.CombineFilePath (_home' path.Substring (2));  }  
Magic Number,GitSharp.Core.Transport,OpenSshConfig,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,toFile,The following statement contains a magic number: return PathUtil.CombineFilePath (_home' path.Substring (2));  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (!_output && now - _taskBeganAt < 500)  	return;  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	if (now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  } else {  	if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	if (now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  } else {  	if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	if (now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  } else {  	if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	if (now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  } else {  	if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  		display (cmp' null);  		_lastOutput = now;  	}  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (now - _lastOutput >= 500) {  	display (cmp' null);  	_lastOutput = now;  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  	display (cmp' null);  	_lastOutput = now;  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  	display (cmp' null);  	_lastOutput = now;  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500) {  	display (cmp' null);  	_lastOutput = now;  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	m.Append (cmp);  } else {  	int pcnt = (cmp * 100 / _totalWork);  	if (pcnt < 100)  		m.Append (' ');  	if (pcnt < 10)  		m.Append (' ');  	m.Append (pcnt);  	m.Append ("% (");  	m.Append (cmp);  	m.Append ("/");  	m.Append (_totalWork);  	m.Append (")");  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	m.Append (cmp);  } else {  	int pcnt = (cmp * 100 / _totalWork);  	if (pcnt < 100)  		m.Append (' ');  	if (pcnt < 10)  		m.Append (' ');  	m.Append (pcnt);  	m.Append ("% (");  	m.Append (cmp);  	m.Append ("/");  	m.Append (_totalWork);  	m.Append (")");  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (_totalWork == UNKNOWN) {  	m.Append (cmp);  } else {  	int pcnt = (cmp * 100 / _totalWork);  	if (pcnt < 100)  		m.Append (' ');  	if (pcnt < 10)  		m.Append (' ');  	m.Append (pcnt);  	m.Append ("% (");  	m.Append (cmp);  	m.Append ("/");  	m.Append (_totalWork);  	m.Append (")");  }  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (pcnt < 100)  	m.Append (' ');  
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (pcnt < 10)  	m.Append (' ');  
Magic Number,GitSharp.Core.Transport,TransportGitSsh,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,commandFor,The following statement contains a magic number: if (gitspace >= 0) {  	SqMinimal (cmd' exe.Slice (0' gitspace + 3));  	cmd.Append (' ');  	SqMinimal (cmd' exe.Substring (gitspace + 4));  } else  	SqMinimal (cmd' exe);  
Magic Number,GitSharp.Core.Transport,TransportGitSsh,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,commandFor,The following statement contains a magic number: if (gitspace >= 0) {  	SqMinimal (cmd' exe.Slice (0' gitspace + 3));  	cmd.Append (' ');  	SqMinimal (cmd' exe.Substring (gitspace + 4));  } else  	SqMinimal (cmd' exe);  
Magic Number,GitSharp.Core.Transport,TransportGitSsh,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,commandFor,The following statement contains a magic number: SqMinimal (cmd' exe.Slice (0' gitspace + 3));  
Magic Number,GitSharp.Core.Transport,TransportGitSsh,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,commandFor,The following statement contains a magic number: SqMinimal (cmd' exe.Substring (gitspace + 4));  
Magic Number,GitSharp.Core.Transport,TransportGitSsh,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,checkExecFailure,The following statement contains a magic number: if (status == 127) {  	String why = _errStream.ToString ();  	IOException cause = null;  	if (why != null && why.Length > 0)  		cause = new IOException (why);  	throw new TransportException (Uri' "cannot execute: " + commandFor (exe)' cause);  }  
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,WalkFetchConnection,The following statement contains a magic number: _packLocks = new List<PackLock> (4);  
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,The following statement contains a magic number: while (true) {  	// Try a pack file we know about' but don't have yet. Odds are  	// that if it has this object' it has others related to it so  	// getting the pack is a good bet.  	//  	if (DownloadPackedObject (pm' id))  		return;  	// Search for a loose object over all alternates' starting  	// from the one we last successfully located an object through.  	//  	string idStr = id.Name;  	string subdir = idStr.Slice (0' 2);  	string file = idStr.Substring (2);  	string looseName = subdir + "/" + file;  	for (int i = _lastRemoteIdx; i < _remotes.Count; i++) {  		if (DownloadLooseObject (id' looseName' _remotes [i])) {  			_lastRemoteIdx = i;  			return;  		}  	}  	for (int i = 0; i < _lastRemoteIdx; i++) {  		if (DownloadLooseObject (id' looseName' _remotes [i])) {  			_lastRemoteIdx = i;  			return;  		}  	}  	// Try to obtain more pack information and search those.  	//  	while (_noPacksYet.Count > 0) {  		WalkRemoteObjectDatabase wrr = _noPacksYet.First.Value;  		_noPacksYet.RemoveFirst ();  		ICollection<string> packNameList;  		try {  			pm.BeginTask ("Listing packs"' ProgressMonitor.UNKNOWN);  			packNameList = wrr.getPackNames ();  		} catch (IOException e) {  			// Try another repository.  			//  			RecordError (id' e);  			continue;  		} finally {  			pm.EndTask ();  		}  		if (packNameList == null || packNameList.Count == 0)  			continue;  		foreach (string packName in packNameList) {  			bool contains = _packsConsidered.Contains (packName);  			_packsConsidered.Add (packName);  			if (!contains) {  				_unfetchedPacks.AddLast (new RemotePack (_lockMessage' _packLocks' _objCheck' _local' wrr' packName));  			}  		}  		if (DownloadPackedObject (pm' id))  			return;  	}  	// Try to expand the first alternate we haven't expanded yet.  	//  	ICollection<WalkRemoteObjectDatabase> al = ExpandOneAlternate (id' pm);  	if (al != null && al.Count > 0) {  		foreach (WalkRemoteObjectDatabase alt in al) {  			_remotes.Add (alt);  			_noPacksYet.AddLast (alt);  			_noAlternatesYet.AddLast (alt);  		}  		continue;  	}  	// We could not obtain the object. There may be reasons why.  	//  	List<Exception> failures = _fetchErrors.get (id.Copy ());  	var te = new TransportException ("Cannot get " + id.Name + ".");  	if (failures != null && failures.Count > 0) {  		te = failures.Count == 1 ? new TransportException ("Cannot get " + id.Name + "."' failures [0]) : new TransportException ("Cannot get " + id.Name + "."' new CompoundException (failures));  	}  	throw te;  }  
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,The following statement contains a magic number: while (true) {  	// Try a pack file we know about' but don't have yet. Odds are  	// that if it has this object' it has others related to it so  	// getting the pack is a good bet.  	//  	if (DownloadPackedObject (pm' id))  		return;  	// Search for a loose object over all alternates' starting  	// from the one we last successfully located an object through.  	//  	string idStr = id.Name;  	string subdir = idStr.Slice (0' 2);  	string file = idStr.Substring (2);  	string looseName = subdir + "/" + file;  	for (int i = _lastRemoteIdx; i < _remotes.Count; i++) {  		if (DownloadLooseObject (id' looseName' _remotes [i])) {  			_lastRemoteIdx = i;  			return;  		}  	}  	for (int i = 0; i < _lastRemoteIdx; i++) {  		if (DownloadLooseObject (id' looseName' _remotes [i])) {  			_lastRemoteIdx = i;  			return;  		}  	}  	// Try to obtain more pack information and search those.  	//  	while (_noPacksYet.Count > 0) {  		WalkRemoteObjectDatabase wrr = _noPacksYet.First.Value;  		_noPacksYet.RemoveFirst ();  		ICollection<string> packNameList;  		try {  			pm.BeginTask ("Listing packs"' ProgressMonitor.UNKNOWN);  			packNameList = wrr.getPackNames ();  		} catch (IOException e) {  			// Try another repository.  			//  			RecordError (id' e);  			continue;  		} finally {  			pm.EndTask ();  		}  		if (packNameList == null || packNameList.Count == 0)  			continue;  		foreach (string packName in packNameList) {  			bool contains = _packsConsidered.Contains (packName);  			_packsConsidered.Add (packName);  			if (!contains) {  				_unfetchedPacks.AddLast (new RemotePack (_lockMessage' _packLocks' _objCheck' _local' wrr' packName));  			}  		}  		if (DownloadPackedObject (pm' id))  			return;  	}  	// Try to expand the first alternate we haven't expanded yet.  	//  	ICollection<WalkRemoteObjectDatabase> al = ExpandOneAlternate (id' pm);  	if (al != null && al.Count > 0) {  		foreach (WalkRemoteObjectDatabase alt in al) {  			_remotes.Add (alt);  			_noPacksYet.AddLast (alt);  			_noAlternatesYet.AddLast (alt);  		}  		continue;  	}  	// We could not obtain the object. There may be reasons why.  	//  	List<Exception> failures = _fetchErrors.get (id.Copy ());  	var te = new TransportException ("Cannot get " + id.Name + ".");  	if (failures != null && failures.Count > 0) {  		te = failures.Count == 1 ? new TransportException ("Cannot get " + id.Name + "."' failures [0]) : new TransportException ("Cannot get " + id.Name + "."' new CompoundException (failures));  	}  	throw te;  }  
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RecordError,The following statement contains a magic number: if (errors == null) {  	errors = new List<Exception> (2);  	_fetchErrors.put (objId' errors);  }  
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RecordError,The following statement contains a magic number: errors = new List<Exception> (2);  
Magic Number,GitSharp.Core.Transport,WalkPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,Sendpack,The following statement contains a magic number: try {  	var pw = new PackWriter (_local' monitor);  	var need = new List<ObjectId> ();  	var have = new List<ObjectId> ();  	foreach (RemoteRefUpdate r in updates) {  		need.Add (r.NewObjectId);  	}  	foreach (Ref r in Refs) {  		have.Add (r.ObjectId);  		if (r.PeeledObjectId != null) {  			have.Add (r.PeeledObjectId);  		}  	}  	pw.preparePack (need' have);  	// We don't have to continue further if the pack will  	// be an empty pack' as the remote has all objects it  	// needs to complete this change.  	//  	if (pw.getObjectsNumber () == 0)  		return;  	_packNames = new Dictionary<string' string> ();  	foreach (string n in _dest.getPackNames ()) {  		_packNames.put (n' n);  	}  	string b = "pack-" + pw.computeName ().Name;  	string packName = b + IndexPack.PackSuffix;  	pathPack = "pack/" + packName;  	pathIdx = "pack/" + b + IndexPack.IndexSuffix;  	if (_packNames.remove (packName) != null) {  		// The remote already contains this pack. We should  		// remove the index before overwriting to prevent bad  		// offsets from appearing to clients.  		//  		_dest.writeInfoPacks (_packNames.Keys);  		_dest.deleteFile (pathIdx);  	}  	// Write the pack file' then the index' as readers look the  	// other direction (index' then pack file).  	//  	string wt = "Put " + b.Slice (0' 12);  	using (Stream os = _dest.writeFile (pathPack' monitor' wt + "." + IndexPack.PackSuffix)) {  		pw.writePack (os);  	}  	using (Stream os = _dest.writeFile (pathIdx' monitor' wt + "." + IndexPack.IndexSuffix)) {  		pw.writeIndex (os);  	}  	// Record the pack at the start of the pack info list. This  	// way clients are likely to consult the newest pack first'  	// and discover the most recent objects there.  	//  	var infoPacks = new List<string> {  		packName  	};  	infoPacks.AddRange (_packNames.Keys);  	_dest.writeInfoPacks (infoPacks);  } catch (IOException err) {  	SafeDelete (pathIdx);  	SafeDelete (pathPack);  	throw new TransportException (_uri' "cannot store objects"' err);  }  
Magic Number,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (avail.Count == 0) {  			throw noRepository ();  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (avail.Count == 0) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			// The first line (if any) may contain "hidden"  			// capability values after a NUL byte.  			foreach (string c in line.Substring (nul + 1).Split (' '))  				remoteCapabilies.Add (c);  			line = line.Slice (0' nul);  		}  	}  	string name = line.Slice (41' line.Length);  	if (avail.Count == 0 && name.Equals ("capabilities^{}")) {  		// special line from git-receive-pack to show  		// capabilities when there are no refs to advertise  		continue;  	}  	ObjectId id = ObjectId.FromString (line.Slice (0' 40));  	if (name.Equals (".have"))  		additionalHaves.Add (id);  	else if (name.EndsWith ("^{}")) {  		name = name.Slice (0' name.Length - 3);  		Ref prior = avail.get (name);  		if (prior == null)  			throw new PackProtocolException (uri' "advertisement of " + name + "^{} came before " + name);  		if (prior.PeeledObjectId != null)  			throw duplicateAdvertisement (name + "^{}");  		avail.put (name' new PeeledTag (Storage.Network' name' prior.ObjectId' id));  	} else {  		Ref prior = avail.put (name' new PeeledNonTag (Storage.Network' name' id));  		if (prior != null)  			throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (avail.Count == 0) {  			throw noRepository ();  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (avail.Count == 0) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			// The first line (if any) may contain "hidden"  			// capability values after a NUL byte.  			foreach (string c in line.Substring (nul + 1).Split (' '))  				remoteCapabilies.Add (c);  			line = line.Slice (0' nul);  		}  	}  	string name = line.Slice (41' line.Length);  	if (avail.Count == 0 && name.Equals ("capabilities^{}")) {  		// special line from git-receive-pack to show  		// capabilities when there are no refs to advertise  		continue;  	}  	ObjectId id = ObjectId.FromString (line.Slice (0' 40));  	if (name.Equals (".have"))  		additionalHaves.Add (id);  	else if (name.EndsWith ("^{}")) {  		name = name.Slice (0' name.Length - 3);  		Ref prior = avail.get (name);  		if (prior == null)  			throw new PackProtocolException (uri' "advertisement of " + name + "^{} came before " + name);  		if (prior.PeeledObjectId != null)  			throw duplicateAdvertisement (name + "^{}");  		avail.put (name' new PeeledTag (Storage.Network' name' prior.ObjectId' id));  	} else {  		Ref prior = avail.put (name' new PeeledNonTag (Storage.Network' name' id));  		if (prior != null)  			throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (avail.Count == 0) {  			throw noRepository ();  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (avail.Count == 0) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			// The first line (if any) may contain "hidden"  			// capability values after a NUL byte.  			foreach (string c in line.Substring (nul + 1).Split (' '))  				remoteCapabilies.Add (c);  			line = line.Slice (0' nul);  		}  	}  	string name = line.Slice (41' line.Length);  	if (avail.Count == 0 && name.Equals ("capabilities^{}")) {  		// special line from git-receive-pack to show  		// capabilities when there are no refs to advertise  		continue;  	}  	ObjectId id = ObjectId.FromString (line.Slice (0' 40));  	if (name.Equals (".have"))  		additionalHaves.Add (id);  	else if (name.EndsWith ("^{}")) {  		name = name.Slice (0' name.Length - 3);  		Ref prior = avail.get (name);  		if (prior == null)  			throw new PackProtocolException (uri' "advertisement of " + name + "^{} came before " + name);  		if (prior.PeeledObjectId != null)  			throw duplicateAdvertisement (name + "^{}");  		avail.put (name' new PeeledTag (Storage.Network' name' prior.ObjectId' id));  	} else {  		Ref prior = avail.put (name' new PeeledNonTag (Storage.Network' name' id));  		if (prior != null)  			throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: if (name.Equals (".have"))  	additionalHaves.Add (id);  else if (name.EndsWith ("^{}")) {  	name = name.Slice (0' name.Length - 3);  	Ref prior = avail.get (name);  	if (prior == null)  		throw new PackProtocolException (uri' "advertisement of " + name + "^{} came before " + name);  	if (prior.PeeledObjectId != null)  		throw duplicateAdvertisement (name + "^{}");  	avail.put (name' new PeeledTag (Storage.Network' name' prior.ObjectId' id));  } else {  	Ref prior = avail.put (name' new PeeledNonTag (Storage.Network' name' id));  	if (prior != null)  		throw duplicateAdvertisement (name);  }  
Magic Number,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: if (name.EndsWith ("^{}")) {  	name = name.Slice (0' name.Length - 3);  	Ref prior = avail.get (name);  	if (prior == null)  		throw new PackProtocolException (uri' "advertisement of " + name + "^{} came before " + name);  	if (prior.PeeledObjectId != null)  		throw duplicateAdvertisement (name + "^{}");  	avail.put (name' new PeeledTag (Storage.Network' name' prior.ObjectId' id));  } else {  	Ref prior = avail.put (name' new PeeledNonTag (Storage.Network' name' id));  	if (prior != null)  		throw duplicateAdvertisement (name);  }  
Magic Number,GitSharp.Core.Transport,BasePackConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: name = name.Slice (0' name.Length - 3);  
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,SendWants,The following statement contains a magic number: foreach (Ref r in want) {  	try {  		if (_walk.parseAny (r.ObjectId).has (REACHABLE)) {  			// We already have this object. Asking for it is  			// not a very good idea.  			//  			continue;  		}  	} catch (IOException) {  		// Its OK' we don't have it' but we want to fix that  		// by fetching the object from the other side.  	}  	var line = new StringBuilder (46);  	line.Append ("want ");  	line.Append (r.ObjectId.Name);  	if (first) {  		line.Append (EnableCapabilities ());  		first = false;  	}  	line.Append ('\n');  	pckOut.WriteString (line.ToString ());  }  
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: for (; ;) {  	RevCommit c = _walk.next ();  	if (c == null) {  		goto END_SEND_HAVES;  	}  	pckOut.WriteString ("have " + c.getId ().Name + "\n");  	havesSent++;  	havesSinceLastContinue++;  	if ((31 & havesSent) != 0) {  		// We group the have lines into blocks of 32' each marked  		// with a flush (aka end). This one is within a block so  		// continue with another have line.  		//  		continue;  	}  	if (monitor.IsCancelled)  		throw new CancelledException ();  	pckOut.End ();  	resultsPending++;  	// Each end will cause a result to come back.  	if (havesSent == 32) {  		// On the first block we race ahead and try to send  		// more of the second block while waiting for the  		// remote to respond to our first block request.  		// This keeps us one block ahead of the peer.  		//  		continue;  	}  	for (; ;) {  		PacketLineIn.AckNackResult anr = pckIn.readACK (ackId);  		switch (anr) {  		case PacketLineIn.AckNackResult.NAK:  			// More have lines are necessary to compute the  			// pack on the remote side. Keep doing that.  			resultsPending--;  			goto END_READ_RESULT;  		case PacketLineIn.AckNackResult.ACK:  			// The remote side is happy and knows exactly what  			// to send us. There is no further negotiation and  			// we can break out immediately.  			_multiAck = MultiAck.OFF;  			resultsPending = 0;  			receivedAck = true;  			goto END_SEND_HAVES;  		case PacketLineIn.AckNackResult.ACK_CONTINUE:  		case PacketLineIn.AckNackResult.ACK_COMMON:  		case PacketLineIn.AckNackResult.ACK_READY:  			// The server knows this commit (ackId). We don't  			// need to send any further along its ancestry' but  			// we need to continue to talk about other parts of  			// our local history.  			MarkCommon (_walk.parseAny (ackId));  			receivedAck = true;  			receivedContinue = true;  			havesSinceLastContinue = 0;  			break;  		}  		if (monitor.IsCancelled)  			throw new CancelledException ();  	}  	END_READ_RESULT:  	if (receivedContinue && havesSinceLastContinue > MAX_HAVES) {  		// Our history must be really different from the remote's.  		// We just sent a whole slew of have lines' and it did not  		// recognize any of them. Avoid sending our entire history  		// to them by giving up early.  		//  		break;  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: for (; ;) {  	RevCommit c = _walk.next ();  	if (c == null) {  		goto END_SEND_HAVES;  	}  	pckOut.WriteString ("have " + c.getId ().Name + "\n");  	havesSent++;  	havesSinceLastContinue++;  	if ((31 & havesSent) != 0) {  		// We group the have lines into blocks of 32' each marked  		// with a flush (aka end). This one is within a block so  		// continue with another have line.  		//  		continue;  	}  	if (monitor.IsCancelled)  		throw new CancelledException ();  	pckOut.End ();  	resultsPending++;  	// Each end will cause a result to come back.  	if (havesSent == 32) {  		// On the first block we race ahead and try to send  		// more of the second block while waiting for the  		// remote to respond to our first block request.  		// This keeps us one block ahead of the peer.  		//  		continue;  	}  	for (; ;) {  		PacketLineIn.AckNackResult anr = pckIn.readACK (ackId);  		switch (anr) {  		case PacketLineIn.AckNackResult.NAK:  			// More have lines are necessary to compute the  			// pack on the remote side. Keep doing that.  			resultsPending--;  			goto END_READ_RESULT;  		case PacketLineIn.AckNackResult.ACK:  			// The remote side is happy and knows exactly what  			// to send us. There is no further negotiation and  			// we can break out immediately.  			_multiAck = MultiAck.OFF;  			resultsPending = 0;  			receivedAck = true;  			goto END_SEND_HAVES;  		case PacketLineIn.AckNackResult.ACK_CONTINUE:  		case PacketLineIn.AckNackResult.ACK_COMMON:  		case PacketLineIn.AckNackResult.ACK_READY:  			// The server knows this commit (ackId). We don't  			// need to send any further along its ancestry' but  			// we need to continue to talk about other parts of  			// our local history.  			MarkCommon (_walk.parseAny (ackId));  			receivedAck = true;  			receivedContinue = true;  			havesSinceLastContinue = 0;  			break;  		}  		if (monitor.IsCancelled)  			throw new CancelledException ();  	}  	END_READ_RESULT:  	if (receivedContinue && havesSinceLastContinue > MAX_HAVES) {  		// Our history must be really different from the remote's.  		// We just sent a whole slew of have lines' and it did not  		// recognize any of them. Avoid sending our entire history  		// to them by giving up early.  		//  		break;  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: if ((31 & havesSent) != 0) {  	// We group the have lines into blocks of 32' each marked  	// with a flush (aka end). This one is within a block so  	// continue with another have line.  	//  	continue;  }  
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: if (havesSent == 32) {  	// On the first block we race ahead and try to send  	// more of the second block while waiting for the  	// remote to respond to our first block request.  	// This keeps us one block ahead of the peer.  	//  	continue;  }  
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: while ((refLine = pckIn.ReadString ()) != PacketLineIn.END) {  	bool ok = false;  	int refNameEnd = -1;  	if (refLine.StartsWith ("ok ")) {  		ok = true;  		refNameEnd = refLine.Length;  	} else if (refLine.StartsWith ("ng ")) {  		refNameEnd = refLine.IndexOf (' '' 3);  	}  	if (refNameEnd == -1) {  		throw new PackProtocolException (uri + ": unexpected report line: " + refLine);  	}  	string refName = refLine.Slice (3' refNameEnd);  	string message = (ok ? null : refLine.Substring (refNameEnd + 1));  	RemoteRefUpdate rru = refUpdates.get (refName);  	if (rru == null)  		throw new PackProtocolException (uri + ": unexpected ref report: " + refName);  	if (ok) {  		rru.Status = RemoteRefUpdate.UpdateStatus.OK;  	} else {  		rru.Status = RemoteRefUpdate.UpdateStatus.REJECTED_OTHER_REASON;  		rru.Message = message;  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: while ((refLine = pckIn.ReadString ()) != PacketLineIn.END) {  	bool ok = false;  	int refNameEnd = -1;  	if (refLine.StartsWith ("ok ")) {  		ok = true;  		refNameEnd = refLine.Length;  	} else if (refLine.StartsWith ("ng ")) {  		refNameEnd = refLine.IndexOf (' '' 3);  	}  	if (refNameEnd == -1) {  		throw new PackProtocolException (uri + ": unexpected report line: " + refLine);  	}  	string refName = refLine.Slice (3' refNameEnd);  	string message = (ok ? null : refLine.Substring (refNameEnd + 1));  	RemoteRefUpdate rru = refUpdates.get (refName);  	if (rru == null)  		throw new PackProtocolException (uri + ": unexpected ref report: " + refName);  	if (ok) {  		rru.Status = RemoteRefUpdate.UpdateStatus.OK;  	} else {  		rru.Status = RemoteRefUpdate.UpdateStatus.REJECTED_OTHER_REASON;  		rru.Message = message;  	}  }  
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: if (refLine.StartsWith ("ok ")) {  	ok = true;  	refNameEnd = refLine.Length;  } else if (refLine.StartsWith ("ng ")) {  	refNameEnd = refLine.IndexOf (' '' 3);  }  
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: if (refLine.StartsWith ("ng ")) {  	refNameEnd = refLine.IndexOf (' '' 3);  }  
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: refNameEnd = refLine.IndexOf (' '' 3);  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,BundleFetchConnection,The following statement contains a magic number: try {  	switch (readSignature ()) {  	case 2:  		readBundleV2 ();  		break;  	default:  		throw new TransportException (_transport.Uri' "not a bundle");  	}  } catch (TransportException) {  	Close ();  	throw;  } catch (IOException err) {  	Close ();  	throw new TransportException (_transport.Uri' err.Message' err);  } catch (Exception err) {  	Close ();  	throw new TransportException (_transport.Uri' err.Message' err);  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,BundleFetchConnection,The following statement contains a magic number: switch (readSignature ()) {  case 2:  	readBundleV2 ();  	break;  default:  	throw new TransportException (_transport.Uri' "not a bundle");  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readSignature,The following statement contains a magic number: if (TransportBundleConstants.V2_BUNDLE_SIGNATURE.Equals (rev))  	return 2;  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readSignature,The following statement contains a magic number: return 2;  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ;) {  	string line = readLine (hdrbuf);  	if (line.Length == 0)  		break;  	if (line [0] == '-') {  		ObjectId id = ObjectId.FromString (line.Slice (1' 41));  		String shortDesc = null;  		if (line.Length > 42)  			shortDesc = line.Substring (42);  		_prereqs.put (id' shortDesc);  		continue;  	}  	string name = line.Slice (41' line.Length);  	ObjectId id2 = ObjectId.FromString (line.Slice (0' 40));  	Ref prior = avail.put (name' new Unpeeled (Storage.Network' name' id2));  	if (prior != null) {  		throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ;) {  	string line = readLine (hdrbuf);  	if (line.Length == 0)  		break;  	if (line [0] == '-') {  		ObjectId id = ObjectId.FromString (line.Slice (1' 41));  		String shortDesc = null;  		if (line.Length > 42)  			shortDesc = line.Substring (42);  		_prereqs.put (id' shortDesc);  		continue;  	}  	string name = line.Slice (41' line.Length);  	ObjectId id2 = ObjectId.FromString (line.Slice (0' 40));  	Ref prior = avail.put (name' new Unpeeled (Storage.Network' name' id2));  	if (prior != null) {  		throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ;) {  	string line = readLine (hdrbuf);  	if (line.Length == 0)  		break;  	if (line [0] == '-') {  		ObjectId id = ObjectId.FromString (line.Slice (1' 41));  		String shortDesc = null;  		if (line.Length > 42)  			shortDesc = line.Substring (42);  		_prereqs.put (id' shortDesc);  		continue;  	}  	string name = line.Slice (41' line.Length);  	ObjectId id2 = ObjectId.FromString (line.Slice (0' 40));  	Ref prior = avail.put (name' new Unpeeled (Storage.Network' name' id2));  	if (prior != null) {  		throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ;) {  	string line = readLine (hdrbuf);  	if (line.Length == 0)  		break;  	if (line [0] == '-') {  		ObjectId id = ObjectId.FromString (line.Slice (1' 41));  		String shortDesc = null;  		if (line.Length > 42)  			shortDesc = line.Substring (42);  		_prereqs.put (id' shortDesc);  		continue;  	}  	string name = line.Slice (41' line.Length);  	ObjectId id2 = ObjectId.FromString (line.Slice (0' 40));  	Ref prior = avail.put (name' new Unpeeled (Storage.Network' name' id2));  	if (prior != null) {  		throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ;) {  	string line = readLine (hdrbuf);  	if (line.Length == 0)  		break;  	if (line [0] == '-') {  		ObjectId id = ObjectId.FromString (line.Slice (1' 41));  		String shortDesc = null;  		if (line.Length > 42)  			shortDesc = line.Substring (42);  		_prereqs.put (id' shortDesc);  		continue;  	}  	string name = line.Slice (41' line.Length);  	ObjectId id2 = ObjectId.FromString (line.Slice (0' 40));  	Ref prior = avail.put (name' new Unpeeled (Storage.Network' name' id2));  	if (prior != null) {  		throw duplicateAdvertisement (name);  	}  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: if (line [0] == '-') {  	ObjectId id = ObjectId.FromString (line.Slice (1' 41));  	String shortDesc = null;  	if (line.Length > 42)  		shortDesc = line.Substring (42);  	_prereqs.put (id' shortDesc);  	continue;  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: if (line [0] == '-') {  	ObjectId id = ObjectId.FromString (line.Slice (1' 41));  	String shortDesc = null;  	if (line.Length > 42)  		shortDesc = line.Substring (42);  	_prereqs.put (id' shortDesc);  	continue;  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: if (line [0] == '-') {  	ObjectId id = ObjectId.FromString (line.Slice (1' 41));  	String shortDesc = null;  	if (line.Length > 42)  		shortDesc = line.Substring (42);  	_prereqs.put (id' shortDesc);  	continue;  }  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: if (line.Length > 42)  	shortDesc = line.Substring (42);  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: if (line.Length > 42)  	shortDesc = line.Substring (42);  
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: shortDesc = line.Substring (42);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,index,The following statement contains a magic number: progress.Start (2/* tasks */);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: while ((c & 0x80) != 0) {  	c = ReadFromFile ();  	sz += (c & 0x7f) << shift;  	shift += 7;  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: shift += 7;  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	type = typecode;  	data = InflateFromFile ((int)sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromFile () & 0xff;  	while ((c & 128) != 0) {  		c = ReadFromFile () & 0xff;  	}  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  case Constants.OBJ_REF_DELTA:  	_crc.Update (_buffer' FillFromFile (20)' 20);  	Use (20);  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  default:  	throw new IOException ("Unknown object type " + typecode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	type = typecode;  	data = InflateFromFile ((int)sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromFile () & 0xff;  	while ((c & 128) != 0) {  		c = ReadFromFile () & 0xff;  	}  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  case Constants.OBJ_REF_DELTA:  	_crc.Update (_buffer' FillFromFile (20)' 20);  	Use (20);  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  default:  	throw new IOException ("Unknown object type " + typecode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	type = typecode;  	data = InflateFromFile ((int)sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromFile () & 0xff;  	while ((c & 128) != 0) {  		c = ReadFromFile () & 0xff;  	}  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  case Constants.OBJ_REF_DELTA:  	_crc.Update (_buffer' FillFromFile (20)' 20);  	Use (20);  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  default:  	throw new IOException ("Unknown object type " + typecode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	type = typecode;  	data = InflateFromFile ((int)sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromFile () & 0xff;  	while ((c & 128) != 0) {  		c = ReadFromFile () & 0xff;  	}  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  case Constants.OBJ_REF_DELTA:  	_crc.Update (_buffer' FillFromFile (20)' 20);  	Use (20);  	data = BinaryDelta.Apply (data' InflateFromFile ((int)sz));  	break;  default:  	throw new IOException ("Unknown object type " + typecode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: while ((c & 128) != 0) {  	c = ReadFromFile () & 0xff;  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: _crc.Update (_buffer' FillFromFile (20)' 20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: _crc.Update (_buffer' FillFromFile (20)' 20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: Use (20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixThinPack,The following statement contains a magic number: _originalEof = _packOut.Length - 20;  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: _buffer [hdrlen++] = (byte)((typeCode << 4) | sz & 15);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: _buffer [hdrlen++] = (byte)((typeCode << 4) | sz & 15);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: sz = (int)(((uint)sz) >> 4);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: while (sz > 0) {  	_buffer [hdrlen - 1] |= 0x80;  	_buffer [hdrlen++] = (byte)(sz & 0x7f);  	sz = (int)(((uint)sz) >> 7);  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: sz = (int)(((uint)sz) >> 7);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,The following statement contains a magic number: FillFromFile (12);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,The following statement contains a magic number: NB.encodeInt32 (_buffer' 8' _entryCount);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,The following statement contains a magic number: _packOut.Write (_buffer' 0' 12);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: if (vers != 2 && vers != 3) {  	throw new IOException ("Unsupported pack version " + vers + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: if (vers != 2 && vers != 3) {  	throw new IOException ("Unsupported pack version " + vers + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: _objectCount = NB.decodeUInt32 (_buffer' p + 8);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: _packcsum = new byte[20];  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: Array.Copy (_buffer' c' _packcsum' 0' 20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: Use (20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: while ((c & 0x80) != 0) {  	c = ReadFromInput ();  	sz += (c & 0x7f) << shift;  	shift += 7;  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: shift += 7;  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode) {  case Constants.OBJ_COMMIT:  case Constants.OBJ_TREE:  case Constants.OBJ_BLOB:  case Constants.OBJ_TAG:  	Whole (typeCode' pos' sz);  	break;  case Constants.OBJ_OFS_DELTA:  	c = ReadFromInput ();  	long ofs = c & 127;  	while ((c & 128) != 0) {  		ofs += 1;  		c = ReadFromInput ();  		ofs <<= 7;  		ofs += (c & 127);  	}  	long pbase = pos - ofs;  	SkipInflateFromInput (sz);  	var n = new UnresolvedDelta (pos' (int)_crc.Value);  	n.Next = _baseByPos.put (pbase' n);  	_deltaCount++;  	break;  case Constants.OBJ_REF_DELTA:  	c = FillFromInput (20);  	_crc.Update (_buffer' c' 20);  	ObjectId baseId = ObjectId.FromRaw (_buffer' c);  	Use (20);  	DeltaChain r = _baseById.Get (baseId);  	if (r == null) {  		r = new DeltaChain (baseId);  		_baseById.Add (r);  	}  	SkipInflateFromInput (sz);  	r.Add (new UnresolvedDelta (pos' (int)_crc.Value));  	_deltaCount++;  	break;  default:  	throw new IOException ("Unknown object type " + typeCode + ".");  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: while ((c & 128) != 0) {  	ofs += 1;  	c = ReadFromInput ();  	ofs <<= 7;  	ofs += (c & 127);  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: while ((c & 128) != 0) {  	ofs += 1;  	c = ReadFromInput ();  	ofs <<= 7;  	ofs += (c & 127);  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: while ((c & 128) != 0) {  	ofs += 1;  	c = ReadFromInput ();  	ofs <<= 7;  	ofs += (c & 127);  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: ofs <<= 7;  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: ofs += (c & 127);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: c = FillFromInput (20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: _crc.Update (_buffer' c' 20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: Use (20);  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,SkipInflateFromInput,The following statement contains a magic number: try {  	byte[] dst = _objectData;  	int n = 0;  	int p = -1;  	while (!inf.IsFinished) {  		if (inf.IsNeedingInput) {  			if (p >= 0) {  				_crc.Update (_buffer' p' _bAvail);  				Use (_bAvail);  			}  			p = FillFromInput (1);  			inf.SetInput (_buffer' p' _bAvail);  		}  		int free = dst.Length - n;  		if (free < 8) {  			sz -= n;  			n = 0;  			free = dst.Length;  		}  		n += inf.Inflate (dst' n' free);  	}  	if (n != sz) {  		throw new IOException ("wrong decompressed length");  	}  	n = _bAvail - inf.RemainingInput;  	if (n > 0) {  		_crc.Update (_buffer' p' n);  		Use (n);  	}  } catch (IOException e) {  	throw Corrupt (e);  } finally {  	inf.Reset ();  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,SkipInflateFromInput,The following statement contains a magic number: while (!inf.IsFinished) {  	if (inf.IsNeedingInput) {  		if (p >= 0) {  			_crc.Update (_buffer' p' _bAvail);  			Use (_bAvail);  		}  		p = FillFromInput (1);  		inf.SetInput (_buffer' p' _bAvail);  	}  	int free = dst.Length - n;  	if (free < 8) {  		sz -= n;  		n = 0;  		free = dst.Length;  	}  	n += inf.Inflate (dst' n' free);  }  
Magic Number,GitSharp.Core.Transport,IndexPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,SkipInflateFromInput,The following statement contains a magic number: if (free < 8) {  	sz -= n;  	n = 0;  	free = dst.Length;  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,PacketLineIn,The following statement contains a magic number: lenbuffer = new byte[4];  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith ("ACK ")) {  	returnedId.FromString (line.Slice (4' 44));  	if (line.Length == 44)  		return AckNackResult.ACK;  	string arg = line.Substring (44);  	if (arg.Equals (" continue"))  		return AckNackResult.ACK_CONTINUE;  	else if (arg.Equals (" common"))  		return AckNackResult.ACK_COMMON;  	else if (arg.Equals (" ready"))  		return AckNackResult.ACK_READY;  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith ("ACK ")) {  	returnedId.FromString (line.Slice (4' 44));  	if (line.Length == 44)  		return AckNackResult.ACK;  	string arg = line.Substring (44);  	if (arg.Equals (" continue"))  		return AckNackResult.ACK_CONTINUE;  	else if (arg.Equals (" common"))  		return AckNackResult.ACK_COMMON;  	else if (arg.Equals (" ready"))  		return AckNackResult.ACK_READY;  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith ("ACK ")) {  	returnedId.FromString (line.Slice (4' 44));  	if (line.Length == 44)  		return AckNackResult.ACK;  	string arg = line.Substring (44);  	if (arg.Equals (" continue"))  		return AckNackResult.ACK_CONTINUE;  	else if (arg.Equals (" common"))  		return AckNackResult.ACK_COMMON;  	else if (arg.Equals (" ready"))  		return AckNackResult.ACK_READY;  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith ("ACK ")) {  	returnedId.FromString (line.Slice (4' 44));  	if (line.Length == 44)  		return AckNackResult.ACK;  	string arg = line.Substring (44);  	if (arg.Equals (" continue"))  		return AckNackResult.ACK_CONTINUE;  	else if (arg.Equals (" common"))  		return AckNackResult.ACK_COMMON;  	else if (arg.Equals (" ready"))  		return AckNackResult.ACK_READY;  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: returnedId.FromString (line.Slice (4' 44));  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: returnedId.FromString (line.Slice (4' 44));  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.Length == 44)  	return AckNackResult.ACK;  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadString,The following statement contains a magic number: len -= 4;  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadStringRaw,The following statement contains a magic number: len -= 4;  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: IO.ReadFully (ins' lenbuffer' 0' 4);  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try {  	int len = RawParseUtils.parseHexInt16 (lenbuffer' 0);  	if (len != 0 && len < 4)  		throw new IndexOutOfRangeException ();  	return len;  } catch (IndexOutOfRangeException e) {  	throw new IOException ("Invalid packet line header: " + (char)lenbuffer [0] + (char)lenbuffer [1] + (char)lenbuffer [2] + (char)lenbuffer [3]' e);  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try {  	int len = RawParseUtils.parseHexInt16 (lenbuffer' 0);  	if (len != 0 && len < 4)  		throw new IndexOutOfRangeException ();  	return len;  } catch (IndexOutOfRangeException e) {  	throw new IOException ("Invalid packet line header: " + (char)lenbuffer [0] + (char)lenbuffer [1] + (char)lenbuffer [2] + (char)lenbuffer [3]' e);  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try {  	int len = RawParseUtils.parseHexInt16 (lenbuffer' 0);  	if (len != 0 && len < 4)  		throw new IndexOutOfRangeException ();  	return len;  } catch (IndexOutOfRangeException e) {  	throw new IOException ("Invalid packet line header: " + (char)lenbuffer [0] + (char)lenbuffer [1] + (char)lenbuffer [2] + (char)lenbuffer [3]' e);  }  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: if (len != 0 && len < 4)  	throw new IndexOutOfRangeException ();  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: throw new IOException ("Invalid packet line header: " + (char)lenbuffer [0] + (char)lenbuffer [1] + (char)lenbuffer [2] + (char)lenbuffer [3]' e);  
Magic Number,GitSharp.Core.Transport,PacketLineIn,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: throw new IOException ("Invalid packet line header: " + (char)lenbuffer [0] + (char)lenbuffer [1] + (char)lenbuffer [2] + (char)lenbuffer [3]' e);  
Magic Number,GitSharp.Core.Transport,PacketLineOut,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,PacketLineOut,The following statement contains a magic number: _lenbuffer = new byte[5];  
Magic Number,GitSharp.Core.Transport,PacketLineOut,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,WritePacket,The following statement contains a magic number: FormatLength (packet.Length + 4);  
Magic Number,GitSharp.Core.Transport,PacketLineOut,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,WritePacket,The following statement contains a magic number: _out.Write (_lenbuffer' 0' 4);  
Magic Number,GitSharp.Core.Transport,PacketLineOut,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,End,The following statement contains a magic number: _out.Write (_lenbuffer' 0' 4);  
Magic Number,GitSharp.Core.Transport,PacketLineOut,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,FormatLength,The following statement contains a magic number: while (o >= 0 && w != 0) {  	lenbuffer [o--] = (byte)hexchar [w & 0xf];  	w = (int)(((uint)w) >> 4);  }  
Magic Number,GitSharp.Core.Transport,PacketLineOut,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,FormatLength,The following statement contains a magic number: w = (int)(((uint)w) >> 4);  
Magic Number,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadStringRaw ();  	} catch (EndOfStreamException) {  		if (commands.isEmpty ()) {  			return;  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (commands.isEmpty ()) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			foreach (string c in line.Substring (nul + 1).Split (' ')) {  				enabledCapabilities.Add (c);  			}  			line = line.Slice (0' nul);  		}  	}  	if (line.Length < 83) {  		string m = "error: invalid protocol: wanted 'old new ref'";  		sendError (m);  		throw new PackProtocolException (m);  	}  	ObjectId oldId = ObjectId.FromString (line.Slice (0' 40));  	ObjectId newId = ObjectId.FromString (line.Slice (41' 81));  	string name = line.Substring (82);  	var cmd = new ReceiveCommand (oldId' newId' name);  	if (name.Equals (Constants.HEAD)) {  		cmd.setResult (ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  	} else {  		cmd.setRef (refs.get (cmd.getRefName ()));  	}  	commands.Add (cmd);  }  
Magic Number,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadStringRaw ();  	} catch (EndOfStreamException) {  		if (commands.isEmpty ()) {  			return;  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (commands.isEmpty ()) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			foreach (string c in line.Substring (nul + 1).Split (' ')) {  				enabledCapabilities.Add (c);  			}  			line = line.Slice (0' nul);  		}  	}  	if (line.Length < 83) {  		string m = "error: invalid protocol: wanted 'old new ref'";  		sendError (m);  		throw new PackProtocolException (m);  	}  	ObjectId oldId = ObjectId.FromString (line.Slice (0' 40));  	ObjectId newId = ObjectId.FromString (line.Slice (41' 81));  	string name = line.Substring (82);  	var cmd = new ReceiveCommand (oldId' newId' name);  	if (name.Equals (Constants.HEAD)) {  		cmd.setResult (ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  	} else {  		cmd.setRef (refs.get (cmd.getRefName ()));  	}  	commands.Add (cmd);  }  
Magic Number,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadStringRaw ();  	} catch (EndOfStreamException) {  		if (commands.isEmpty ()) {  			return;  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (commands.isEmpty ()) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			foreach (string c in line.Substring (nul + 1).Split (' ')) {  				enabledCapabilities.Add (c);  			}  			line = line.Slice (0' nul);  		}  	}  	if (line.Length < 83) {  		string m = "error: invalid protocol: wanted 'old new ref'";  		sendError (m);  		throw new PackProtocolException (m);  	}  	ObjectId oldId = ObjectId.FromString (line.Slice (0' 40));  	ObjectId newId = ObjectId.FromString (line.Slice (41' 81));  	string name = line.Substring (82);  	var cmd = new ReceiveCommand (oldId' newId' name);  	if (name.Equals (Constants.HEAD)) {  		cmd.setResult (ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  	} else {  		cmd.setRef (refs.get (cmd.getRefName ()));  	}  	commands.Add (cmd);  }  
Magic Number,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadStringRaw ();  	} catch (EndOfStreamException) {  		if (commands.isEmpty ()) {  			return;  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (commands.isEmpty ()) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			foreach (string c in line.Substring (nul + 1).Split (' ')) {  				enabledCapabilities.Add (c);  			}  			line = line.Slice (0' nul);  		}  	}  	if (line.Length < 83) {  		string m = "error: invalid protocol: wanted 'old new ref'";  		sendError (m);  		throw new PackProtocolException (m);  	}  	ObjectId oldId = ObjectId.FromString (line.Slice (0' 40));  	ObjectId newId = ObjectId.FromString (line.Slice (41' 81));  	string name = line.Substring (82);  	var cmd = new ReceiveCommand (oldId' newId' name);  	if (name.Equals (Constants.HEAD)) {  		cmd.setResult (ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  	} else {  		cmd.setRef (refs.get (cmd.getRefName ()));  	}  	commands.Add (cmd);  }  
Magic Number,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true) {  	string line;  	try {  		line = pckIn.ReadStringRaw ();  	} catch (EndOfStreamException) {  		if (commands.isEmpty ()) {  			return;  		}  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (commands.isEmpty ()) {  		int nul = line.IndexOf ('\0');  		if (nul >= 0) {  			foreach (string c in line.Substring (nul + 1).Split (' ')) {  				enabledCapabilities.Add (c);  			}  			line = line.Slice (0' nul);  		}  	}  	if (line.Length < 83) {  		string m = "error: invalid protocol: wanted 'old new ref'";  		sendError (m);  		throw new PackProtocolException (m);  	}  	ObjectId oldId = ObjectId.FromString (line.Slice (0' 40));  	ObjectId newId = ObjectId.FromString (line.Slice (41' 81));  	string name = line.Substring (82);  	var cmd = new ReceiveCommand (oldId' newId' name);  	if (name.Equals (Constants.HEAD)) {  		cmd.setResult (ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  	} else {  		cmd.setRef (refs.get (cmd.getRefName ()));  	}  	commands.Add (cmd);  }  
Magic Number,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: if (line.Length < 83) {  	string m = "error: invalid protocol: wanted 'old new ref'";  	sendError (m);  	throw new PackProtocolException (m);  }  
Magic Number,GitSharp.Core.Transport,RefSpec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: if (Source != null)  	hc = hc * 31 + Source.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,RefSpec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Source.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,RefSpec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: if (Destination != null)  	hc = hc * 31 + Destination.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,RefSpec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Destination.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,SideBandInputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (matcher.Success) {  	string taskname = matcher.Groups [1].Value;  	if (!currentTask.Equals (taskname)) {  		currentTask = taskname;  		lastCnt = 0;  		beginTask (int.Parse (matcher.Groups [3].Value));  	}  	int cnt = int.Parse (matcher.Groups [2].Value);  	monitor.Update (cnt - lastCnt);  	lastCnt = cnt;  	return true;  }  
Magic Number,GitSharp.Core.Transport,SideBandInputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (matcher.Success) {  	string taskname = matcher.Groups [1].Value;  	if (!currentTask.Equals (taskname)) {  		currentTask = taskname;  		lastCnt = 0;  		beginTask (int.Parse (matcher.Groups [3].Value));  	}  	int cnt = int.Parse (matcher.Groups [2].Value);  	monitor.Update (cnt - lastCnt);  	lastCnt = cnt;  	return true;  }  
Magic Number,GitSharp.Core.Transport,SideBandInputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (!currentTask.Equals (taskname)) {  	currentTask = taskname;  	lastCnt = 0;  	beginTask (int.Parse (matcher.Groups [3].Value));  }  
Magic Number,GitSharp.Core.Transport,SideBandInputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: beginTask (int.Parse (matcher.Groups [3].Value));  
Magic Number,GitSharp.Core.Transport,SideBandInputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (matcher.Success) {  	string taskname = matcher.Groups [1].Value;  	if (!currentTask.Equals (taskname)) {  		currentTask = taskname;  		lastCnt = 0;  		beginTask (ProgressMonitor.UNKNOWN);  	}  	int cnt = int.Parse (matcher.Groups [2].Value);  	monitor.Update (cnt - lastCnt);  	lastCnt = cnt;  	return true;  }  
Magic Number,GitSharp.Core.Transport,SideBandOutputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandOutputStream.cs,SideBandOutputStream,The following statement contains a magic number: if (chan <= 0 || chan > 255)  	throw new ArgumentException ("channel " + chan + " must be in range [0' 255]");  
Magic Number,GitSharp.Core.Transport,SideBandOutputStream,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\SideBandOutputStream.cs,SideBandOutputStream,The following statement contains a magic number: _buffer [4] = (byte)chan;  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Upload,The following statement contains a magic number: if (_timeout > 0) {  	var i = new TimeoutStream (_rawIn);  	i.setTimeout (_timeout * 1000);  	var o = new TimeoutStream (_rawOut);  	o.setTimeout (_timeout * 1000);  	_rawIn = i;  	_rawOut = o;  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Upload,The following statement contains a magic number: if (_timeout > 0) {  	var i = new TimeoutStream (_rawIn);  	i.setTimeout (_timeout * 1000);  	var o = new TimeoutStream (_rawOut);  	o.setTimeout (_timeout * 1000);  	_rawIn = i;  	_rawOut = o;  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Upload,The following statement contains a magic number: i.setTimeout (_timeout * 1000);  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Upload,The following statement contains a magic number: o.setTimeout (_timeout * 1000);  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false) {  	string line;  	try {  		line = _pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (isFirst)  			break;  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (!line.StartsWith ("want ") || line.Length < 45) {  		throw new PackProtocolException ("expected want; got " + line);  	}  	if (isFirst && line.Length > 45) {  		string opt = line.Substring (45);  		if (opt.StartsWith (" "))  			opt = opt.Substring (1);  		foreach (string c in opt.Split (' '))  			_options.Add (c);  		line = line.Slice (0' 45);  	}  	ObjectId id = ObjectId.FromString (line.Substring (5));  	RevObject o;  	try {  		o = _walk.parseAny (id);  	} catch (IOException e) {  		throw new PackProtocolException (id.Name + " not valid"' e);  	}  	if (!o.has (ADVERTISED)) {  		throw new PackProtocolException (id.Name + " not valid");  	}  	Want (o);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false) {  	string line;  	try {  		line = _pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (isFirst)  			break;  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (!line.StartsWith ("want ") || line.Length < 45) {  		throw new PackProtocolException ("expected want; got " + line);  	}  	if (isFirst && line.Length > 45) {  		string opt = line.Substring (45);  		if (opt.StartsWith (" "))  			opt = opt.Substring (1);  		foreach (string c in opt.Split (' '))  			_options.Add (c);  		line = line.Slice (0' 45);  	}  	ObjectId id = ObjectId.FromString (line.Substring (5));  	RevObject o;  	try {  		o = _walk.parseAny (id);  	} catch (IOException e) {  		throw new PackProtocolException (id.Name + " not valid"' e);  	}  	if (!o.has (ADVERTISED)) {  		throw new PackProtocolException (id.Name + " not valid");  	}  	Want (o);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false) {  	string line;  	try {  		line = _pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (isFirst)  			break;  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (!line.StartsWith ("want ") || line.Length < 45) {  		throw new PackProtocolException ("expected want; got " + line);  	}  	if (isFirst && line.Length > 45) {  		string opt = line.Substring (45);  		if (opt.StartsWith (" "))  			opt = opt.Substring (1);  		foreach (string c in opt.Split (' '))  			_options.Add (c);  		line = line.Slice (0' 45);  	}  	ObjectId id = ObjectId.FromString (line.Substring (5));  	RevObject o;  	try {  		o = _walk.parseAny (id);  	} catch (IOException e) {  		throw new PackProtocolException (id.Name + " not valid"' e);  	}  	if (!o.has (ADVERTISED)) {  		throw new PackProtocolException (id.Name + " not valid");  	}  	Want (o);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false) {  	string line;  	try {  		line = _pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (isFirst)  			break;  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (!line.StartsWith ("want ") || line.Length < 45) {  		throw new PackProtocolException ("expected want; got " + line);  	}  	if (isFirst && line.Length > 45) {  		string opt = line.Substring (45);  		if (opt.StartsWith (" "))  			opt = opt.Substring (1);  		foreach (string c in opt.Split (' '))  			_options.Add (c);  		line = line.Slice (0' 45);  	}  	ObjectId id = ObjectId.FromString (line.Substring (5));  	RevObject o;  	try {  		o = _walk.parseAny (id);  	} catch (IOException e) {  		throw new PackProtocolException (id.Name + " not valid"' e);  	}  	if (!o.has (ADVERTISED)) {  		throw new PackProtocolException (id.Name + " not valid");  	}  	Want (o);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false) {  	string line;  	try {  		line = _pckIn.ReadString ();  	} catch (EndOfStreamException) {  		if (isFirst)  			break;  		throw;  	}  	if (line == PacketLineIn.END)  		break;  	if (!line.StartsWith ("want ") || line.Length < 45) {  		throw new PackProtocolException ("expected want; got " + line);  	}  	if (isFirst && line.Length > 45) {  		string opt = line.Substring (45);  		if (opt.StartsWith (" "))  			opt = opt.Substring (1);  		foreach (string c in opt.Split (' '))  			_options.Add (c);  		line = line.Slice (0' 45);  	}  	ObjectId id = ObjectId.FromString (line.Substring (5));  	RevObject o;  	try {  		o = _walk.parseAny (id);  	} catch (IOException e) {  		throw new PackProtocolException (id.Name + " not valid"' e);  	}  	if (!o.has (ADVERTISED)) {  		throw new PackProtocolException (id.Name + " not valid");  	}  	Want (o);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: if (!line.StartsWith ("want ") || line.Length < 45) {  	throw new PackProtocolException ("expected want; got " + line);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: if (isFirst && line.Length > 45) {  	string opt = line.Substring (45);  	if (opt.StartsWith (" "))  		opt = opt.Substring (1);  	foreach (string c in opt.Split (' '))  		_options.Add (c);  	line = line.Slice (0' 45);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: if (isFirst && line.Length > 45) {  	string opt = line.Substring (45);  	if (opt.StartsWith (" "))  		opt = opt.Substring (1);  	foreach (string c in opt.Split (' '))  		_options.Add (c);  	line = line.Slice (0' 45);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: if (isFirst && line.Length > 45) {  	string opt = line.Substring (45);  	if (opt.StartsWith (" "))  		opt = opt.Substring (1);  	foreach (string c in opt.Split (' '))  		_options.Add (c);  	line = line.Slice (0' 45);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: line = line.Slice (0' 45);  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: while (true) {  	string line = _pckIn.ReadString ();  	if (line == PacketLineIn.END) {  		if (_commonBase.Count == 0 || _multiAck != BasePackFetchConnection.MultiAck.OFF) {  			_pckOut.WriteString ("NAK\n");  		}  		_pckOut.Flush ();  		if (!biDirectionalPipe)  			return false;  	} else if (line.StartsWith ("have ") && line.Length == 45) {  		ObjectId id = ObjectId.FromString (line.Substring (5));  		if (MatchHave (id)) {  			// Both sides have the same object; let the client know.  			//  			last = id;  			switch (_multiAck) {  			case BasePackFetchConnection.MultiAck.OFF:  				if (_commonBase.Count == 1)  					_pckOut.WriteString ("ACK " + id.Name + "\n");  				break;  			case BasePackFetchConnection.MultiAck.CONTINUE:  				_pckOut.WriteString ("ACK " + id.Name + " continue\n");  				break;  			case BasePackFetchConnection.MultiAck.DETAILED:  				_pckOut.WriteString ("ACK " + id.Name + " common\n");  				break;  			}  		} else if (OkToGiveUp ()) {  			// They have this object; we don't.  			//  			switch (_multiAck) {  			case BasePackFetchConnection.MultiAck.OFF:  				break;  			case BasePackFetchConnection.MultiAck.CONTINUE:  				_pckOut.WriteString ("ACK " + id.Name + " continue\n");  				break;  			case BasePackFetchConnection.MultiAck.DETAILED:  				_pckOut.WriteString ("ACK " + id.Name + " ready\n");  				break;  			}  		}  	} else if (line.Equals ("done")) {  		if (_commonBase.Count == 0) {  			_pckOut.WriteString ("NAK\n");  		} else if (_multiAck != BasePackFetchConnection.MultiAck.OFF) {  			_pckOut.WriteString ("ACK " + last.Name + "\n");  		}  		return true;  	} else {  		throw new PackProtocolException ("expected have; got " + line);  	}  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: while (true) {  	string line = _pckIn.ReadString ();  	if (line == PacketLineIn.END) {  		if (_commonBase.Count == 0 || _multiAck != BasePackFetchConnection.MultiAck.OFF) {  			_pckOut.WriteString ("NAK\n");  		}  		_pckOut.Flush ();  		if (!biDirectionalPipe)  			return false;  	} else if (line.StartsWith ("have ") && line.Length == 45) {  		ObjectId id = ObjectId.FromString (line.Substring (5));  		if (MatchHave (id)) {  			// Both sides have the same object; let the client know.  			//  			last = id;  			switch (_multiAck) {  			case BasePackFetchConnection.MultiAck.OFF:  				if (_commonBase.Count == 1)  					_pckOut.WriteString ("ACK " + id.Name + "\n");  				break;  			case BasePackFetchConnection.MultiAck.CONTINUE:  				_pckOut.WriteString ("ACK " + id.Name + " continue\n");  				break;  			case BasePackFetchConnection.MultiAck.DETAILED:  				_pckOut.WriteString ("ACK " + id.Name + " common\n");  				break;  			}  		} else if (OkToGiveUp ()) {  			// They have this object; we don't.  			//  			switch (_multiAck) {  			case BasePackFetchConnection.MultiAck.OFF:  				break;  			case BasePackFetchConnection.MultiAck.CONTINUE:  				_pckOut.WriteString ("ACK " + id.Name + " continue\n");  				break;  			case BasePackFetchConnection.MultiAck.DETAILED:  				_pckOut.WriteString ("ACK " + id.Name + " ready\n");  				break;  			}  		}  	} else if (line.Equals ("done")) {  		if (_commonBase.Count == 0) {  			_pckOut.WriteString ("NAK\n");  		} else if (_multiAck != BasePackFetchConnection.MultiAck.OFF) {  			_pckOut.WriteString ("ACK " + last.Name + "\n");  		}  		return true;  	} else {  		throw new PackProtocolException ("expected have; got " + line);  	}  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: if (line == PacketLineIn.END) {  	if (_commonBase.Count == 0 || _multiAck != BasePackFetchConnection.MultiAck.OFF) {  		_pckOut.WriteString ("NAK\n");  	}  	_pckOut.Flush ();  	if (!biDirectionalPipe)  		return false;  } else if (line.StartsWith ("have ") && line.Length == 45) {  	ObjectId id = ObjectId.FromString (line.Substring (5));  	if (MatchHave (id)) {  		// Both sides have the same object; let the client know.  		//  		last = id;  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			if (_commonBase.Count == 1)  				_pckOut.WriteString ("ACK " + id.Name + "\n");  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " common\n");  			break;  		}  	} else if (OkToGiveUp ()) {  		// They have this object; we don't.  		//  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " ready\n");  			break;  		}  	}  } else if (line.Equals ("done")) {  	if (_commonBase.Count == 0) {  		_pckOut.WriteString ("NAK\n");  	} else if (_multiAck != BasePackFetchConnection.MultiAck.OFF) {  		_pckOut.WriteString ("ACK " + last.Name + "\n");  	}  	return true;  } else {  	throw new PackProtocolException ("expected have; got " + line);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: if (line == PacketLineIn.END) {  	if (_commonBase.Count == 0 || _multiAck != BasePackFetchConnection.MultiAck.OFF) {  		_pckOut.WriteString ("NAK\n");  	}  	_pckOut.Flush ();  	if (!biDirectionalPipe)  		return false;  } else if (line.StartsWith ("have ") && line.Length == 45) {  	ObjectId id = ObjectId.FromString (line.Substring (5));  	if (MatchHave (id)) {  		// Both sides have the same object; let the client know.  		//  		last = id;  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			if (_commonBase.Count == 1)  				_pckOut.WriteString ("ACK " + id.Name + "\n");  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " common\n");  			break;  		}  	} else if (OkToGiveUp ()) {  		// They have this object; we don't.  		//  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " ready\n");  			break;  		}  	}  } else if (line.Equals ("done")) {  	if (_commonBase.Count == 0) {  		_pckOut.WriteString ("NAK\n");  	} else if (_multiAck != BasePackFetchConnection.MultiAck.OFF) {  		_pckOut.WriteString ("ACK " + last.Name + "\n");  	}  	return true;  } else {  	throw new PackProtocolException ("expected have; got " + line);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: if (line.StartsWith ("have ") && line.Length == 45) {  	ObjectId id = ObjectId.FromString (line.Substring (5));  	if (MatchHave (id)) {  		// Both sides have the same object; let the client know.  		//  		last = id;  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			if (_commonBase.Count == 1)  				_pckOut.WriteString ("ACK " + id.Name + "\n");  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " common\n");  			break;  		}  	} else if (OkToGiveUp ()) {  		// They have this object; we don't.  		//  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " ready\n");  			break;  		}  	}  } else if (line.Equals ("done")) {  	if (_commonBase.Count == 0) {  		_pckOut.WriteString ("NAK\n");  	} else if (_multiAck != BasePackFetchConnection.MultiAck.OFF) {  		_pckOut.WriteString ("ACK " + last.Name + "\n");  	}  	return true;  } else {  	throw new PackProtocolException ("expected have; got " + line);  }  
Magic Number,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: if (line.StartsWith ("have ") && line.Length == 45) {  	ObjectId id = ObjectId.FromString (line.Substring (5));  	if (MatchHave (id)) {  		// Both sides have the same object; let the client know.  		//  		last = id;  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			if (_commonBase.Count == 1)  				_pckOut.WriteString ("ACK " + id.Name + "\n");  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " common\n");  			break;  		}  	} else if (OkToGiveUp ()) {  		// They have this object; we don't.  		//  		switch (_multiAck) {  		case BasePackFetchConnection.MultiAck.OFF:  			break;  		case BasePackFetchConnection.MultiAck.CONTINUE:  			_pckOut.WriteString ("ACK " + id.Name + " continue\n");  			break;  		case BasePackFetchConnection.MultiAck.DETAILED:  			_pckOut.WriteString ("ACK " + id.Name + " ready\n");  			break;  		}  	}  } else if (line.Equals ("done")) {  	if (_commonBase.Count == 0) {  		_pckOut.WriteString ("NAK\n");  	} else if (_multiAck != BasePackFetchConnection.MultiAck.OFF) {  		_pckOut.WriteString ("ACK " + last.Name + "\n");  	}  	return true;  } else {  	throw new PackProtocolException ("expected have; got " + line);  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	Scheme = matcher.Groups [1].Value;  	Scheme = Scheme.Length == 0 ? null : Scheme;  	User = matcher.Groups [2].Value;  	User = User.Length == 0 ? null : User;  	Pass = matcher.Groups [3].Value;  	Pass = Pass.Length == 0 ? null : Pass;  	Host = matcher.Groups [4].Value;  	Host = Host.Length == 0 ? null : Host;  	if (matcher.Groups [5].Success) {  		Port = int.Parse (matcher.Groups [5].Value);  	}  	Path = matcher.Groups [6].Value;  	if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  		Path = Path.Substring (1);  	}  } else {  	matcher = ScpUri.Match (s);  	if (matcher.Success) {  		User = matcher.Groups [1].Value;  		User = User.Length == 0 ? null : User;  		Host = matcher.Groups [2].Value;  		Host = Host.Length == 0 ? null : Host;  		Path = matcher.Groups [3].Value;  		Path = Path.Length == 0 ? null : Path;  	} else {  		throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  	}  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: User = matcher.Groups [2].Value;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: Pass = matcher.Groups [3].Value;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: Host = matcher.Groups [4].Value;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Groups [5].Success) {  	Port = int.Parse (matcher.Groups [5].Value);  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Groups [5].Success) {  	Port = int.Parse (matcher.Groups [5].Value);  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: Port = int.Parse (matcher.Groups [5].Value);  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: Path = matcher.Groups [6].Value;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  	Path = Path.Substring (1);  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (Path.Length >= 3 && Path [0] == '/' && Path [2] == ':' && (Path [1] >= 'A' && Path [1] <= 'Z' || Path [1] >= 'a' && Path [1] <= 'z')) {  	Path = Path.Substring (1);  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	User = matcher.Groups [1].Value;  	User = User.Length == 0 ? null : User;  	Host = matcher.Groups [2].Value;  	Host = Host.Length == 0 ? null : Host;  	Path = matcher.Groups [3].Value;  	Path = Path.Length == 0 ? null : Path;  } else {  	throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success) {  	User = matcher.Groups [1].Value;  	User = User.Length == 0 ? null : User;  	Host = matcher.Groups [2].Value;  	Host = Host.Length == 0 ? null : Host;  	Path = matcher.Groups [3].Value;  	Path = Path.Length == 0 ? null : Path;  } else {  	throw new UriFormatException ("Cannot parse Git URI-ish (" + s + ")");  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: Host = matcher.Groups [2].Value;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: Path = matcher.Groups [3].Value;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Scheme != null) {  	hc = hc * 31 + Scheme.GetHashCode ();  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Scheme.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (User != null) {  	hc = hc * 31 + User.GetHashCode ();  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + User.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Pass != null) {  	hc = hc * 31 + Pass.GetHashCode ();  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Pass.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Host != null) {  	hc = hc * 31 + Host.GetHashCode ();  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Host.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Port > 0) {  	hc = hc * 31 + Port;  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Port;  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Path != null) {  	hc = hc * 31 + Path.GetHashCode ();  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: hc = hc * 31 + Path.GetHashCode ();  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,getHumanishName,The following statement contains a magic number: if (Constants.DOT_GIT.Equals (result)) {  	result = elements2 [elements2.Length - 2];  } else if (result.EndsWith (Constants.DOT_GIT_EXT)) {  	result = result.Slice (0' result.Length - Constants.DOT_GIT_EXT.Length);  }  
Magic Number,GitSharp.Core.Transport,URIish,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,getHumanishName,The following statement contains a magic number: result = elements2 [elements2.Length - 2];  
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (list.Length == 2)  	return create (list [0]' list [1]);  
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (list.Length < 2)  	throw new ArgumentException ("At least two filters needed.");  
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (list.Count () < 2)  	throw new ArgumentException ("At least two filters needed.");  
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2)  	return create (subfilters [0]' subfilters [1]);  
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (list.Length == 2)  	return create (list [0]' list [1]);  
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (list.Length < 2)  	throw new ArgumentException ("At least two filters needed.");  
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (list.Count () < 2)  	throw new ArgumentException ("At least two filters needed.");  
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2)  	return create (subfilters [0]' subfilters [1]);  
Magic Number,GitSharp.Core.Util,FileStreamExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Stream.cs,toArray,The following statement contains a magic number: try {  	// Note: if we can seek' it's likely we have a length  	if (stream.CanSeek) {  		if (stream.Length >= 0) {  			byte[] r = new byte[stream.Length];  			IO.ReadFully (stream' r' 0' r.Length);  			return r;  		}  	}  	var m = new MemoryStream ();  	var buf = new byte[2048];  	int n;  	while ((n = stream.Read (buf' 0' buf.Length)) > 0)  		m.Write (buf' 0' n);  	return m.ToArray ();  } finally {  	stream.Dispose ();  	// [nulltoken] Why the heck is the stream disposed here instead of in the caller method ? Weird.  }  
Magic Number,GitSharp.Core.Util,FS,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\FS.cs,userHomeImpl,The following statement contains a magic number: if (platform == (int)PlatformID.Unix || platform == 6 /* (int)PlatformID.MacOSX */|| platform == (int)PlatformType.UnixMono) {  	userHomeFolderPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal);  } else {  	userHomeFolderPath = Environment.GetEnvironmentVariable ("USERPROFILE");  }  
Magic Number,GitSharp.Core.Util,Crc32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\CRC32.cs,Update,The following statement contains a magic number: _value = CrcTable [(_value ^ value) & 0xFF] ^ (_value >> 8);  
Magic Number,GitSharp.Core.Util,Crc32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\CRC32.cs,Update,The following statement contains a magic number: _value = (_value >> 8) ^ CrcTable [(_value & 0xff) ^ value];  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,Hex,The following statement contains a magic number: for (char i = 'a'; i <= 'f'; i++)  	_hexCharToValue [i] = (byte)((i - 'a') + 10);  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,Hex,The following statement contains a magic number: _hexCharToValue [i] = (byte)((i - 'a') + 10);  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: if (8 <= end - p) {  	return HexStringToUInt32 (bs' p);  }  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: while (n < 8 && p < end) {  	int v = HexCharToValue (bs [p++]);  	if (v < 0) {  		throw new IndexOutOfRangeException ();  	}  	r <<= 4;  	r |= v;  	n++;  }  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: while (n < 8 && p < end) {  	int v = HexCharToValue (bs [p++]);  	if (v < 0) {  		throw new IndexOutOfRangeException ();  	}  	r <<= 4;  	r |= v;  	n++;  }  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: r <<= 4;  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: return r << (8 - n) * 4;  
Magic Number,GitSharp.Core.Util,Hex,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: return r << (8 - n) * 4;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: low |= (intbuf [offset + 2] & (uint)0xff);  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: low <<= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: low |= (intbuf [offset + 3] & (uint)0xff);  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: return ((long)(intbuf [offset] & 0xff)) << 24 | low;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,DecodeUInt64,The following statement contains a magic number: return (DecodeUInt32 (intbuf' offset) << 32) | DecodeUInt32 (intbuf' offset + 4);  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,DecodeUInt64,The following statement contains a magic number: return (DecodeUInt32 (intbuf' offset) << 32) | DecodeUInt32 (intbuf' offset + 4);  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt16,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: intbuf [offset + 3] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: intbuf [offset + 2] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf [offset + 7] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf [offset + 6] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf [offset + 5] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf [offset + 4] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf [offset + 3] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf [offset + 2] = (byte)v;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,ConvertUnsignedByteToSigned,The following statement contains a magic number: return Convert.ToSByte (Convert.ToString (b' 2)' 2);  
Magic Number,GitSharp.Core.Util,NB,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\NB.cs,ConvertUnsignedByteToSigned,The following statement contains a magic number: return Convert.ToSByte (Convert.ToString (b' 2)' 2);  
Magic Number,GitSharp.Core.Util,PathUtil,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\PathUtil.cs,Combine,The following statement contains a magic number: if (paths.Length < 2)  	throw new ArgumentException ("Must have at least two paths"' "paths");  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,formatBase10,The following statement contains a magic number: while (value != 0) {  	b [--o] = Base10Byte [value % 10];  	value /= 10;  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,formatBase10,The following statement contains a magic number: while (value != 0) {  	b [--o] = Base10Byte [value % 10];  	value /= 10;  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,formatBase10,The following statement contains a magic number: b [--o] = Base10Byte [value % 10];  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,formatBase10,The following statement contains a magic number: value /= 10;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The following statement contains a magic number: try {  	int sz = b.Length;  	while (ptr < sz && b [ptr] == ' ')  		ptr++;  	if (ptr >= sz)  		return 0;  	switch (b [ptr]) {  	case ((byte)'-'):  		sign = -1;  		ptr++;  		break;  	case ((byte)'+'):  		ptr++;  		break;  	}  	while (ptr < sz) {  		byte d = b [ptr];  		if ((d < (byte)'0') || (d > (byte)'9'))  			break;  		r = r * 10 + (d - (byte)'0');  		ptr++;  	}  } catch (IndexOutOfRangeException) {  	// Not a valid digit.  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The following statement contains a magic number: while (ptr < sz) {  	byte d = b [ptr];  	if ((d < (byte)'0') || (d > (byte)'9'))  		break;  	r = r * 10 + (d - (byte)'0');  	ptr++;  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The following statement contains a magic number: r = r * 10 + (d - (byte)'0');  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The following statement contains a magic number: try {  	int sz = b.Length;  	while (ptr < sz && b [ptr] == ' ')  		ptr++;  	if (ptr >= sz)  		return 0;  	switch (b [ptr]) {  	case (byte)'-':  		sign = -1;  		ptr++;  		break;  	case (byte)'+':  		ptr++;  		break;  	}  	while (ptr < sz) {  		int v = b [ptr] - (byte)'0';  		if (v < 0)  			break;  		r = (r * 10) + v;  		ptr++;  	}  } catch (IndexOutOfRangeException) {  	// Not a valid digit.  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The following statement contains a magic number: while (ptr < sz) {  	int v = b [ptr] - (byte)'0';  	if (v < 0)  		break;  	r = (r * 10) + v;  	ptr++;  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The following statement contains a magic number: r = (r * 10) + v;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt16,The following statement contains a magic number: try {  	string hex = Charset.forName ("US-ASCII").GetString (bs' p' 4);  	hex = hex.Substring (p);  	return UInt16.Parse (hex' System.Globalization.NumberStyles.AllowHexSpecifier);  } catch (Exception e) {  	throw new IndexOutOfRangeException ("Exception Parsing Hex"' e);  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt32,The following statement contains a magic number: try {  	string hex = Charset.forName ("US-ASCII").GetString (bs' p' 8);  	//string hex = Encoding.ASCII.GetString(bs).Substring(p' 8);  	return (int)UInt32.Parse (hex' System.Globalization.NumberStyles.AllowHexSpecifier);  } catch (Exception e) {  	throw new IndexOutOfRangeException ("Exception Parsing Hex"' e);  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt4,The following statement contains a magic number: try {  	char c = (char)digit;  	UInt16 result = UInt16.Parse (c.ToString ()' System.Globalization.NumberStyles.AllowHexSpecifier);  	if (result > 15)  		throw new OverflowException ();  	return (int)result;  } catch (Exception e) {  	throw new IndexOutOfRangeException ("Exception Parsing Hex"' e);  }  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt4,The following statement contains a magic number: if (result > 15)  	throw new OverflowException ();  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseTimeZoneOffset,The following statement contains a magic number: return tzHours * 60 + tzMins;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,author,The following statement contains a magic number: if (ptr == 0)  	ptr += 46;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,author,The following statement contains a magic number: ptr += 46;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,author,The following statement contains a magic number: while (ptr < sz && b [ptr] == (byte)'p')  	ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,author,The following statement contains a magic number: ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,committer,The following statement contains a magic number: if (ptr == 0)  	ptr += 46;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,committer,The following statement contains a magic number: ptr += 46;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,committer,The following statement contains a magic number: while (ptr < sz && b [ptr] == (byte)'p')  	ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,committer,The following statement contains a magic number: ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,tagger,The following statement contains a magic number: if (ptr == 0)  	ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,tagger,The following statement contains a magic number: ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdent,The following statement contains a magic number: return new PersonIdent (name' email' when * 1000' tz);  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdentOnly,The following statement contains a magic number: if (emailB < stop)  	name = decode (raw' nameB' emailB - 2);  else  	name = decode (raw' nameB' stop);  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdentOnly,The following statement contains a magic number: name = decode (raw' nameB' emailB - 2);  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdentOnly,The following statement contains a magic number: return new PersonIdent (name' email' when * 1000' tz);  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,commitMessage,The following statement contains a magic number: if (ptr == 0)  	ptr += 46;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,commitMessage,The following statement contains a magic number: ptr += 46;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,commitMessage,The following statement contains a magic number: while (ptr < sz && b [ptr] == (byte)'p')  	ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,commitMessage,The following statement contains a magic number: ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,tagMessage,The following statement contains a magic number: if (ptr == 0)  	ptr += 48;  
Magic Number,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,tagMessage,The following statement contains a magic number: ptr += 48;  
Magic Number,GitSharp.Core.Util,TemporaryBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: foreach (Block b in _blocks) {  	os.Write (b.buffer' 0' b.count);  	pm.Update (b.count / 1024);  }  
Magic Number,GitSharp.Core.Util,TemporaryBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: pm.Update (b.count / 1024);  
Magic Number,GitSharp.Core.Util,LocalFileBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: using (FileStream @in = new FileStream (onDiskFile.FullName' System.IO.FileMode.Open' FileAccess.Read)) {  	int cnt;  	byte[] buf = new byte[Block.SZ];  	while ((cnt = @in.Read (buf' 0' buf.Length)) > 0) {  		os.Write (buf' 0' cnt);  		pm.Update (cnt / 1024);  	}  }  
Magic Number,GitSharp.Core.Util,LocalFileBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: while ((cnt = @in.Read (buf' 0' buf.Length)) > 0) {  	os.Write (buf' 0' cnt);  	pm.Update (cnt / 1024);  }  
Magic Number,GitSharp.Core.Util,LocalFileBuffer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: pm.Update (cnt / 1024);  
Magic Number,GitSharp.Core.Util,AlarmState,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,run,The following statement contains a magic number: lock (this) {  	while (!terminated && callingThread.isAlive ()) {  		//try  		//{  		if (0 < deadline) {  			long delay = deadline - now ();  			if (delay <= 0) {  				deadline = 0;  				callingThread.interrupt ();  			} else {  				Thread.sleep ((int)delay);  			}  		} else {  			wait (1000);  		}  		//}  		//catch (InterruptedException e) // Note: [henon] Thread does not throw an equivalent exception in C# ??  		//{  		//   // Treat an interrupt as notice to examine state.  		//}  	}  }  
Magic Number,GitSharp.Core.Util,AlarmState,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,run,The following statement contains a magic number: while (!terminated && callingThread.isAlive ()) {  	//try  	//{  	if (0 < deadline) {  		long delay = deadline - now ();  		if (delay <= 0) {  			deadline = 0;  			callingThread.interrupt ();  		} else {  			Thread.sleep ((int)delay);  		}  	} else {  		wait (1000);  	}  	//}  	//catch (InterruptedException e) // Note: [henon] Thread does not throw an equivalent exception in C# ??  	//{  	//   // Treat an interrupt as notice to examine state.  	//}  }  
Magic Number,GitSharp.Core.Util,AlarmState,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,run,The following statement contains a magic number: if (0 < deadline) {  	long delay = deadline - now ();  	if (delay <= 0) {  		deadline = 0;  		callingThread.interrupt ();  	} else {  		Thread.sleep ((int)delay);  	}  } else {  	wait (1000);  }  
Magic Number,GitSharp.Core.Util,AlarmState,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,run,The following statement contains a magic number: wait (1000);  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i = 0; i < bytes; i++) {  	buffer [endOffset - i] = unchecked((byte)(value & 0xff));  	value = value >> 8;  }  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: value = value >> 8;  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < bytesToConvert; i++) {  	ret = unchecked((ret << 8) | buffer [startIndex + i]);  }  
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: ret = unchecked((ret << 8) | buffer [startIndex + i]);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToChar,The following statement contains a magic number: return unchecked((char)(CheckedFromBytes (value' startIndex' 2)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToInt16,The following statement contains a magic number: return unchecked((short)(CheckedFromBytes (value' startIndex' 2)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToInt32,The following statement contains a magic number: return unchecked((int)(CheckedFromBytes (value' startIndex' 4)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return CheckedFromBytes (value' startIndex' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return unchecked((ushort)(CheckedFromBytes (value' startIndex' 2)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return unchecked((uint)(CheckedFromBytes (value' startIndex' 4)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return unchecked((ulong)(CheckedFromBytes (value' startIndex' 8)));  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	parts [i] = ToInt32 (value' startIndex + i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	parts [i] = ToInt32 (value' startIndex + i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: parts [i] = ToInt32 (value' startIndex + i * 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' bytes' i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' bytes' i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' bytes' i * 4);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' bytes' i * 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' bytes' i * 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  }  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytesImpl (parts [i]' 4' buffer' i * 4 + index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (DoubleToInt64Bits (value)' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (SingleToInt32Bits (value)' 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 2);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (value' 4);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes (unchecked((long)value)' 8);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 2' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (DoubleToInt64Bits (value)' 8' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 2' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 4' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 8' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (SingleToInt32Bits (value)' 4' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 2' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (value' 4' buffer' index);  
Magic Number,MiscUtil.Conversion,EndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes (unchecked((long)value)' 8' buffer' index);  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i = 0; i < bytes; i++) {  	buffer [i + index] = unchecked((byte)(value & 0xff));  	value = value >> 8;  }  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: value = value >> 8;  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i = 0; i < bytesToConvert; i++) {  	ret = unchecked((ret << 8) | buffer [startIndex + bytesToConvert - 1 - i]);  }  
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: ret = unchecked((ret << 8) | buffer [startIndex + bytesToConvert - 1 - i]);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,EndianBinaryReader,The following statement contains a magic number: if (encoding is UnicodeEncoding) {  	minBytesPerChar = 2;  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,EndianBinaryReader,The following statement contains a magic number: minBytesPerChar = 2;  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInt16,The following statement contains a magic number: ReadInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInt32,The following statement contains a magic number: ReadInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInt64,The following statement contains a magic number: ReadInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadUInt16,The following statement contains a magic number: ReadInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadUInt32,The following statement contains a magic number: ReadInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadUInt64,The following statement contains a magic number: ReadInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadSingle,The following statement contains a magic number: ReadInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadDouble,The following statement contains a magic number: ReadInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadDecimal,The following statement contains a magic number: ReadInternal (buffer' 16);  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read,The following statement contains a magic number: if (byteBuffer.Length < count * minBytesPerChar) {  	byteBuffer = new byte[4096];  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read,The following statement contains a magic number: byteBuffer = new byte[4096];  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: for (int shift = 0; shift < 35; shift += 7) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = ret | ((b & 0x7f) << shift);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: for (int shift = 0; shift < 35; shift += 7) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = ret | ((b & 0x7f) << shift);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: shift += 7
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = (ret << 7) | (b & 0x7f);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	int b = stream.ReadByte ();  	if (b == -1) {  		throw new EndOfStreamException ();  	}  	ret = (ret << 7) | (b & 0x7f);  	if ((b & 0x80) == 0) {  		return ret;  	}  }  
Magic Number,MiscUtil.IO,EndianBinaryReader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: ret = (ret << 7) | (b & 0x7f);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 2);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 4);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 8);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal (buffer' 16);  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (value >= 128) {  	buffer [index++] = (byte)((value & 0x7f) | 0x80);  	value = value >> 7;  	index++;  }  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (value >= 128) {  	buffer [index++] = (byte)((value & 0x7f) | 0x80);  	value = value >> 7;  	index++;  }  
Magic Number,MiscUtil.IO,EndianBinaryWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: value = value >> 7;  
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (list.Length == 2) {  	return create (list [0]' list [1]);  }  
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (list.Length < 2) {  	throw new ArgumentException ("At least two filters needed.");  }  
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (list.Count () < 2) {  	throw new ArgumentException ("At least two filters needed.");  }  
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2) {  	return create (subfilters [0]' subfilters [1]);  }  
Magic Number,GitSharp.Core.RevWalk.Filter,CommitTimeRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,CommitTimeRevFilter,The following statement contains a magic number: _when = (int)(ts / 1000);  
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (list.Length == 2) {  	return create (list [0]' list [1]);  }  
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (list.Length < 2) {  	throw new ArgumentException ("At least two filters needed.");  }  
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (list.Count () < 2) {  	throw new ArgumentException ("At least two filters needed.");  }  
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2) {  	return create (subfilters [0]' subfilters [1]);  }  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitFileName,The following statement contains a magic number: while (ptr < eol) {  	int sp = RawParseUtils.nextLF (Buffer' ptr' (byte)' ');  	if (sp >= eol) {  		// We can't split the header' it isn't valid.  		// This may be OK if this is a rename patch.  		//  		return eol;  	}  	int bStart = RawParseUtils.nextLF (Buffer' sp' (byte)'/');  	if (bStart >= eol)  		return eol;  	// If buffer[aStart..sp - 1] = buffer[bStart..eol - 1]  	// we have a valid split.  	//  	if (Eq (aStart' sp - 1' bStart' eol - 1)) {  		if (Buffer [bol] == '"') {  			// We're a double quoted name. The region better end  			// in a double quote too' and we need to decode the  			// characters before reading the name.  			//  			if (Buffer [sp - 2] != '"') {  				return eol;  			}  			oldName = QuotedString.GitPathStyle.GIT_PATH.dequote (Buffer' bol' sp - 1);  			oldName = P1 (oldName);  		} else {  			oldName = RawParseUtils.decode (Constants.CHARSET' Buffer' aStart' sp - 1);  		}  		newName = oldName;  		return eol;  	}  	// This split wasn't correct. Move past the space and try  	// another split as the space must be part of the file name.  	//  	ptr = sp;  }  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitFileName,The following statement contains a magic number: if (Eq (aStart' sp - 1' bStart' eol - 1)) {  	if (Buffer [bol] == '"') {  		// We're a double quoted name. The region better end  		// in a double quote too' and we need to decode the  		// characters before reading the name.  		//  		if (Buffer [sp - 2] != '"') {  			return eol;  		}  		oldName = QuotedString.GitPathStyle.GIT_PATH.dequote (Buffer' bol' sp - 1);  		oldName = P1 (oldName);  	} else {  		oldName = RawParseUtils.decode (Constants.CHARSET' Buffer' aStart' sp - 1);  	}  	newName = oldName;  	return eol;  }  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitFileName,The following statement contains a magic number: if (Buffer [bol] == '"') {  	// We're a double quoted name. The region better end  	// in a double quote too' and we need to decode the  	// characters before reading the name.  	//  	if (Buffer [sp - 2] != '"') {  		return eol;  	}  	oldName = QuotedString.GitPathStyle.GIT_PATH.dequote (Buffer' bol' sp - 1);  	oldName = P1 (oldName);  } else {  	oldName = RawParseUtils.decode (Constants.CHARSET' Buffer' aStart' sp - 1);  }  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitFileName,The following statement contains a magic number: if (Buffer [sp - 2] != '"') {  	return eol;  }  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,ParseFileMode,The following statement contains a magic number: while (ptr < end - 1) {  	tmp <<= 3;  	tmp += Buffer [ptr++] - '0';  }  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,ParseFileMode,The following statement contains a magic number: tmp <<= 3;  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,isHunkHdr,The following statement contains a magic number: if ((ptr - start) < 2)  	return 0;  
Magic Number,GitSharp.Core.Patch,FileHeader,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,isHunkHdr,The following statement contains a magic number: return (ptr - 3) - start;  
Magic Number,GitSharp.Core.Patch,Patch,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseFile,The following statement contains a magic number: while (c < end) {  	if (FileHeader.isHunkHdr (buf' c' end) >= 1) {  		// If we find a disconnected hunk header we might  		// have missed a file header previously. The hunk  		// isn't valid without knowing where it comes from.  		//  		error (buf' c' "Hunk disconnected from file");  		c = RawParseUtils.nextLF (buf' c);  		continue;  	}  	// Valid git style patch?  	//  	if (RawParseUtils.match (buf' c' DiffGit) >= 0) {  		return ParseDiffGit (buf' c' end);  	}  	if (RawParseUtils.match (buf' c' DiffCc) >= 0) {  		return ParseDiffCombined (DiffCc' buf' c' end);  	}  	if (RawParseUtils.match (buf' c' DiffCombined) >= 0) {  		return ParseDiffCombined (DiffCombined' buf' c' end);  	}  	// Junk between files? Leading junk? Traditional  	// (non-git generated) patch?  	//  	int n = RawParseUtils.nextLF (buf' c);  	if (n >= end) {  		// Patches cannot be only one line long. This must be  		// trailing junk that we should ignore.  		//  		return end;  	}  	if (n - c < 6) {  		// A valid header must be at least 6 bytes on the  		// first line' e.g. "--- a/b\n".  		//  		c = n;  		continue;  	}  	if (RawParseUtils.match (buf' c' FileHeader.OLD_NAME) >= 0 && RawParseUtils.match (buf' n' FileHeader.NEW_NAME) >= 0) {  		// Probably a traditional patch. Ensure we have at least  		// a "@@ -0'0" smelling line next. We only check the "@@ -".  		//  		int f = RawParseUtils.nextLF (buf' n);  		if (f >= end)  			return end;  		if (FileHeader.isHunkHdr (buf' f' end) == 1)  			return ParseTraditionalPatch (buf' c' end);  	}  	c = n;  }  
Magic Number,GitSharp.Core.Patch,Patch,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseFile,The following statement contains a magic number: if (n - c < 6) {  	// A valid header must be at least 6 bytes on the  	// first line' e.g. "--- a/b\n".  	//  	c = n;  	continue;  }  
Magic Number,GitSharp.Core.TreeWalk,CanonicalTreeParser,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\CanonicalTreeParser.cs,ParseEntry,The following statement contains a magic number: for (; ;) {  	c = _raw [ptr++];  	if (' ' == c)  		break;  	tmp <<= 3;  	tmp += c - (byte)'0';  }  
Magic Number,GitSharp.Core.TreeWalk,CanonicalTreeParser,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\CanonicalTreeParser.cs,ParseEntry,The following statement contains a magic number: tmp <<= 3;  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: try {  	FileStream @is = entry.OpenInputStream ();  	if (@is == null) {  		return ZeroId;  	}  	try {  		InitializeDigest ();  		_contentDigest.Reset ();  		_contentDigest.Update (HBlob);  		_contentDigest.Update ((byte)' ');  		long blobLength = entry.Length;  		long size = blobLength;  		if (size == 0) {  			_contentDigest.Update ((byte)'0');  		} else {  			int bufn = _contentReadBuffer.Length;  			int p = bufn;  			do {  				_contentReadBuffer [--p] = Digits [(int)(size % 10)];  				size /= 10;  			} while (size > 0);  			_contentDigest.Update (_contentReadBuffer' p' bufn - p);  		}  		_contentDigest.Update (0);  		while (true) {  			int r = @is.Read (_contentReadBuffer' 0' _contentReadBuffer.Length);  			// was: Read(_contentReadBuffer) in java  			if (r <= 0)  				break;  			_contentDigest.Update (_contentReadBuffer' 0' r);  			size += r;  		}  		if (size != blobLength) {  			return ZeroId;  		}  		return _contentDigest.Digest ();  	} finally {  		try {  			@is.Close ();  		} catch (IOException) {  			// Suppress any error related to closing an input  			// stream. We don't care' we should not have any  			// outstanding data to flush or anything like that.  		}  	}  } catch (IOException) {  	// Can't Read the file? Don't report the failure either.  	//  }  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: try {  	FileStream @is = entry.OpenInputStream ();  	if (@is == null) {  		return ZeroId;  	}  	try {  		InitializeDigest ();  		_contentDigest.Reset ();  		_contentDigest.Update (HBlob);  		_contentDigest.Update ((byte)' ');  		long blobLength = entry.Length;  		long size = blobLength;  		if (size == 0) {  			_contentDigest.Update ((byte)'0');  		} else {  			int bufn = _contentReadBuffer.Length;  			int p = bufn;  			do {  				_contentReadBuffer [--p] = Digits [(int)(size % 10)];  				size /= 10;  			} while (size > 0);  			_contentDigest.Update (_contentReadBuffer' p' bufn - p);  		}  		_contentDigest.Update (0);  		while (true) {  			int r = @is.Read (_contentReadBuffer' 0' _contentReadBuffer.Length);  			// was: Read(_contentReadBuffer) in java  			if (r <= 0)  				break;  			_contentDigest.Update (_contentReadBuffer' 0' r);  			size += r;  		}  		if (size != blobLength) {  			return ZeroId;  		}  		return _contentDigest.Digest ();  	} finally {  		try {  			@is.Close ();  		} catch (IOException) {  			// Suppress any error related to closing an input  			// stream. We don't care' we should not have any  			// outstanding data to flush or anything like that.  		}  	}  } catch (IOException) {  	// Can't Read the file? Don't report the failure either.  	//  }  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: try {  	InitializeDigest ();  	_contentDigest.Reset ();  	_contentDigest.Update (HBlob);  	_contentDigest.Update ((byte)' ');  	long blobLength = entry.Length;  	long size = blobLength;  	if (size == 0) {  		_contentDigest.Update ((byte)'0');  	} else {  		int bufn = _contentReadBuffer.Length;  		int p = bufn;  		do {  			_contentReadBuffer [--p] = Digits [(int)(size % 10)];  			size /= 10;  		} while (size > 0);  		_contentDigest.Update (_contentReadBuffer' p' bufn - p);  	}  	_contentDigest.Update (0);  	while (true) {  		int r = @is.Read (_contentReadBuffer' 0' _contentReadBuffer.Length);  		// was: Read(_contentReadBuffer) in java  		if (r <= 0)  			break;  		_contentDigest.Update (_contentReadBuffer' 0' r);  		size += r;  	}  	if (size != blobLength) {  		return ZeroId;  	}  	return _contentDigest.Digest ();  } finally {  	try {  		@is.Close ();  	} catch (IOException) {  		// Suppress any error related to closing an input  		// stream. We don't care' we should not have any  		// outstanding data to flush or anything like that.  	}  }  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: try {  	InitializeDigest ();  	_contentDigest.Reset ();  	_contentDigest.Update (HBlob);  	_contentDigest.Update ((byte)' ');  	long blobLength = entry.Length;  	long size = blobLength;  	if (size == 0) {  		_contentDigest.Update ((byte)'0');  	} else {  		int bufn = _contentReadBuffer.Length;  		int p = bufn;  		do {  			_contentReadBuffer [--p] = Digits [(int)(size % 10)];  			size /= 10;  		} while (size > 0);  		_contentDigest.Update (_contentReadBuffer' p' bufn - p);  	}  	_contentDigest.Update (0);  	while (true) {  		int r = @is.Read (_contentReadBuffer' 0' _contentReadBuffer.Length);  		// was: Read(_contentReadBuffer) in java  		if (r <= 0)  			break;  		_contentDigest.Update (_contentReadBuffer' 0' r);  		size += r;  	}  	if (size != blobLength) {  		return ZeroId;  	}  	return _contentDigest.Digest ();  } finally {  	try {  		@is.Close ();  	} catch (IOException) {  		// Suppress any error related to closing an input  		// stream. We don't care' we should not have any  		// outstanding data to flush or anything like that.  	}  }  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: if (size == 0) {  	_contentDigest.Update ((byte)'0');  } else {  	int bufn = _contentReadBuffer.Length;  	int p = bufn;  	do {  		_contentReadBuffer [--p] = Digits [(int)(size % 10)];  		size /= 10;  	} while (size > 0);  	_contentDigest.Update (_contentReadBuffer' p' bufn - p);  }  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: if (size == 0) {  	_contentDigest.Update ((byte)'0');  } else {  	int bufn = _contentReadBuffer.Length;  	int p = bufn;  	do {  		_contentReadBuffer [--p] = Digits [(int)(size % 10)];  		size /= 10;  	} while (size > 0);  	_contentDigest.Update (_contentReadBuffer' p' bufn - p);  }  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: do {  	_contentReadBuffer [--p] = Digits [(int)(size % 10)];  	size /= 10;  } while (size > 0);  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: do {  	_contentReadBuffer [--p] = Digits [(int)(size % 10)];  	size /= 10;  } while (size > 0);  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: _contentReadBuffer [--p] = Digits [(int)(size % 10)];  
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: size /= 10;  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  	PlotCommit p;  	PlotLane pLane;  	TColor pColor;  	int cx;  	p = (PlotCommit)commit.GetParent (i);  	pLane = p.getLane ();  	if (pLane == null)  		continue;  	pColor = laneColor (pLane);  	cx = laneC (pLane);  	if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  		if (myLaneX < cx) {  			int ix = cx - LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		} else {  			int ix = cx + LANE_WIDTH / 2;  			drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  			drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  		}  	} else {  		drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  	}  	maxCenter = Math.Max (maxCenter' cx);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (Math.Abs (myLaneX - cx) > LANE_WIDTH) {  	if (myLaneX < cx) {  		int ix = cx - LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	} else {  		int ix = cx + LANE_WIDTH / 2;  		drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  		drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  	}  } else {  	drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: if (myLaneX < cx) {  	int ix = cx - LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  } else {  	int ix = cx + LANE_WIDTH / 2;  	drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  	drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' ix' h / 2' cx' h' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawLine (pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < n; ++i) {  	textx += drawLabel (textx + dotSize' h / 2' commit.refs [i]);  }  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: textx += drawLabel (textx + dotSize' h / 2' commit.refs [i]);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawText (msg' textx + dotSize + n * 2' h / 2);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawText (msg' textx + dotSize + n * 2' h / 2);  
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,laneC,The following statement contains a magic number: return laneX (myLane) + LANE_WIDTH / 2;  
Magic Number,GitSharp.Core.RevPlot,PlotCommitList,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevPlot\PlotCommitList.cs,enter,The following statement contains a magic number: if (nChildren == 1 && currCommit.children [0].ParentCount < 2) {  	// Only one child' child has only us as their parent.  	// Stay in the same lane as the child.  	//  	PlotCommit c = currCommit.children [0];  	if (c.lane == null) {  		// Hmmph. This child must be the first along this lane.  		//  		c.lane = nextFreeLane ();  		activeLanes.Add (c.lane);  	}  	for (int r = index - 1; r >= 0; r--) {  		PlotCommit rObj = get (r);  		if (rObj == c)  			break;  		rObj.addPassingLane (c.lane);  	}  	currCommit.lane = c.lane;  	currCommit.lane.parent = currCommit;  } else {  	// More than one child' or our child is a merge.  	// Use a different lane.  	//  	for (int i = 0; i < nChildren; i++) {  		PlotCommit c = currCommit.children [i];  		if (activeLanes.Remove (c.lane)) {  			recycleLane (c.lane);  			freeLanes.Add (c.lane.getPosition ()' c.lane.getPosition ());  		}  	}  	currCommit.lane = nextFreeLane ();  	currCommit.lane.parent = currCommit;  	activeLanes.Add (currCommit.lane);  	int remaining = nChildren;  	for (int r = index - 1; r >= 0; r--) {  		PlotCommit rObj = get (r);  		if (currCommit.isChild (rObj)) {  			if (--remaining == 0)  				break;  		}  		rObj.addPassingLane (currCommit.lane);  	}  }  
Missing Default,GitSharp.Core,ByteArrayExtensions,F:\newReposMay17\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following switch statement is missing a default case: switch (num) {  case 13:  	if ((currentIndex != (source.Length - 1)) && (source [currentIndex + 1] == 10)) {  		indexModifier = 2;  	}  	break;  case 10:  	indexModifier = 1;  	break;  }  
Missing Default,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following switch statement is missing a default case: switch (typeString [offset]) {  case (byte)'b':  	if (typeString [offset + 1] != (byte)'l' || typeString [offset + 2] != (byte)'o' || typeString [offset + 3] != (byte)'b' || typeString [offset + 4] != endMark)  		break;  	offset += 5;  	return ObjectType.Blob;  case (byte)'c':  	if (typeString [offset + 1] != (byte)'o' || typeString [offset + 2] != (byte)'m' || typeString [offset + 3] != (byte)'m' || typeString [offset + 4] != (byte)'i' || typeString [offset + 5] != (byte)'t' || typeString [offset + 6] != endMark)  		break;  	offset += 7;  	return ObjectType.Commit;  case (byte)'t':  	switch (typeString [offset + 1]) {  	case (byte)'a':  		if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 4;  		return ObjectType.Tag;  	case (byte)'r':  		if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  			throw new CorruptObjectException (id' "invalid type");  		}  		offset += 5;  		return ObjectType.Tree;  	}  	break;  }  
Missing Default,GitSharp.Core,Codec,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following switch statement is missing a default case: switch (typeString [offset + 1]) {  case (byte)'a':  	if (typeString [offset + 2] != (byte)'g' || typeString [offset + 2] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 4;  	return ObjectType.Tag;  case (byte)'r':  	if (typeString [offset + 2] != (byte)'e' || typeString [offset + 3] != (byte)'e' || typeString [offset + 4] != endMark) {  		throw new CorruptObjectException (id' "invalid type");  	}  	offset += 5;  	return ObjectType.Tree;  }  
Missing Default,GitSharp.Core,FileMode,F:\newReposMay17\henon_GitSharp\GitSharp.Core\FileMode.cs,FromBits,The following switch statement is missing a default case: switch (bits & TYPE_MASK) // octal 0170000  {  case 0:  	if (bits == 0) {  		return Missing;  	}  	break;  case TYPE_TREE:  	// octal 0040000  	return Tree;  case TYPE_FILE:  	// octal 0100000  	return (bits & OCTAL_0111) != 0 ? ExecutableFile : RegularFile;  case TYPE_SYMLINK:  	// octal 0120000  	return Symlink;  case TYPE_GITLINK:  	// octal 0160000  	return GitLink;  }  
Missing Default,GitSharp.Core,PackIndexWriter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following switch statement is missing a default case: switch (version) {  case 1:  	if (PackIndexWriterV1.CanStore (oe))  		continue;  	version = 2;  	break;  case 2:  	breakLoop = true;  	break;  }  
Missing Default,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,MapTree,The following switch statement is missing a default case: switch (((ObjectType)or.Type)) {  case ObjectType.Tree:  	return new Tree (this' id' raw);  case ObjectType.Commit:  	return MapTree (ObjectId.FromString (raw' 5));  }  
Missing Default,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,IsValidRefName,The following switch statement is missing a default case: switch (c) {  case '.':  	switch (p) {  	case '\0':  	case '/':  	case '.':  		return false;  	}  	if (i == len - 1)  		return false;  	break;  case '/':  	if (i == 0 || i == len - 1)  		return false;  	components++;  	break;  case '{':  	if (p == '@')  		return false;  	break;  case '~':  case '^':  case ':':  case '?':  case '[':  case '*':  case '\\':  	return false;  }  
Missing Default,GitSharp.Core,Repository,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Repository.cs,IsValidRefName,The following switch statement is missing a default case: switch (p) {  case '\0':  case '/':  case '.':  	return false;  }  
Missing Default,GitSharp.Core,Config,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Config.cs,getLong,The following switch statement is missing a default case: switch (StringUtils.toLowerCase (n [n.Length - 1])) {  case 'g':  	mul = GiB;  	break;  case 'm':  	mul = MiB;  	break;  case 'k':  	mul = KiB;  	break;  }  
Missing Default,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (os.Version.Major) {  case 4:  	switch (os.Version.Minor) {  	case 0:  		if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "OSR2";  		} else {  			ClassName = "Windows.v95";  			PlatformSubType = "95";  			Edition = "";  		}  		break;  	case 10:  		if (osvi.szCSDVersion == "A") {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "SE";  		} else {  			ClassName = "Windows.v98";  			PlatformSubType = "98";  			Edition = "";  		}  		break;  	case 90:  		ClassName = "Windows.ME";  		PlatformSubType = "ME";  		Edition = "";  		break;  	}  	break;  }  
Missing Default,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (os.Version.Minor) {  case 0:  	if (osvi.szCSDVersion == "B" || osvi.szCSDVersion == "C") {  		ClassName = "Windows.v95";  		PlatformSubType = "95";  		Edition = "OSR2";  	} else {  		ClassName = "Windows.v95";  		PlatformSubType = "95";  		Edition = "";  	}  	break;  case 10:  	if (osvi.szCSDVersion == "A") {  		ClassName = "Windows.v98";  		PlatformSubType = "98";  		Edition = "SE";  	} else {  		ClassName = "Windows.v98";  		PlatformSubType = "98";  		Edition = "";  	}  	break;  case 90:  	ClassName = "Windows.ME";  	PlatformSubType = "ME";  	Edition = "";  	break;  }  
Missing Default,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (osvi.wProductType) {  case 1:  	ClassName = "Windows.NT";  	PlatformSubType = "NT";  	Edition = "4.0 Workstation";  	break;  case 3:  	if (osvi.wSuiteMask == SuiteVersion.Enterprise) {  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Server Enterprise";  	} else {  		ClassName = "Windows.NT";  		PlatformSubType = "NT";  		Edition = "4.0 Server Standard";  	}  	break;  }  
Missing Default,GitSharp.Core,Win32,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (ospi.dwOSEdition) {  case ProductType.Undefined:  	ClassName = "Windows.Undefined";  	PlatformSubType = "7";  	Edition = "is undefined";  	break;  case ProductType.Ultimate:  	//    1  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Ultimate Edition";  	break;  case ProductType.HomeBasic:  	// 2  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Home Basic Edition";  	break;  case ProductType.HomePremium:  	// 3  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Home Premium Edition";  	break;  case ProductType.Enterprise:  	// 4  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Enterprise Edition";  	break;  case ProductType.HomeBasicN:  	// 5  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Home Basic N Edition (EU only)";  	break;  case ProductType.Business:  	// 6  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Business Edition";  	break;  case ProductType.BusinessN:  	// 10  	ClassName = "Windows.v7";  	PlatformSubType = "7";  	Edition = "Business N Edition (EU only)";  	break;  }  
Missing Default,GitSharp.Core.DirectoryCache,DirCacheEntry,F:\newReposMay17\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,setFileMode,The following switch statement is missing a default case: switch (mode.Bits & FileMode.TYPE_MASK) {  case FileMode.TYPE_MISSING:  case FileMode.TYPE_TREE:  	throw new ArgumentException ("Invalid mode " + mode.Bits + " for path " + getPathString ());  }  
Missing Default,GitSharp.Core.Transport,WalkFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,MarkLocalObjComplete,The following switch statement is missing a default case: switch (obj.Type) {  case Constants.OBJ_BLOB:  	obj.add (COMPLETE);  	break;  case Constants.OBJ_COMMIT:  	PushLocalCommit ((RevCommit)obj);  	break;  case Constants.OBJ_TREE:  	MarkTreeComplete ((RevTree)obj);  	break;  }  
Missing Default,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following switch statement is missing a default case: switch (anr) {  case PacketLineIn.AckNackResult.NAK:  	// More have lines are necessary to compute the  	// pack on the remote side. Keep doing that.  	resultsPending--;  	goto END_READ_RESULT;  case PacketLineIn.AckNackResult.ACK:  	// The remote side is happy and knows exactly what  	// to send us. There is no further negotiation and  	// we can break out immediately.  	_multiAck = MultiAck.OFF;  	resultsPending = 0;  	receivedAck = true;  	goto END_SEND_HAVES;  case PacketLineIn.AckNackResult.ACK_CONTINUE:  case PacketLineIn.AckNackResult.ACK_COMMON:  case PacketLineIn.AckNackResult.ACK_READY:  	// The server knows this commit (ackId). We don't  	// need to send any further along its ancestry' but  	// we need to continue to talk about other parts of  	// our local history.  	MarkCommon (_walk.parseAny (ackId));  	receivedAck = true;  	receivedContinue = true;  	havesSinceLastContinue = 0;  	break;  }  
Missing Default,GitSharp.Core.Transport,BasePackFetchConnection,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following switch statement is missing a default case: switch (anr) {  case PacketLineIn.AckNackResult.NAK:  	// A NAK is a response to an end we queued earlier  	// we eat it and look for another ACK/NAK message.  	//  	break;  case PacketLineIn.AckNackResult.ACK:  	// A solitary ACK at this point means the remote won't  	// speak anymore' but is going to send us a pack now.  	//  	goto END_READ_RESULT_2;  case PacketLineIn.AckNackResult.ACK_CONTINUE:  case PacketLineIn.AckNackResult.ACK_COMMON:  case PacketLineIn.AckNackResult.ACK_READY:  	// We will expect a normal ACK to break out of the loop.  	//  	_multiAck = MultiAck.CONTINUE;  	break;  }  
Missing Default,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,Execute,The following switch statement is missing a default case: switch (cmd.getType ()) {  case ReceiveCommand.Type.DELETE:  	if (!ObjectId.ZeroId.Equals (cmd.getOldId ())) {  		// We can only do a CAS style delete if the client  		// didn't bork its delete request by sending the  		// wrong zero id rather than the advertised one.  		//  		ru.setExpectedOldObjectId (cmd.getOldId ());  	}  	ru.setForceUpdate (true);  	Status (cmd' ru.delete (walk));  	break;  case ReceiveCommand.Type.CREATE:  case ReceiveCommand.Type.UPDATE:  case ReceiveCommand.Type.UPDATE_NONFASTFORWARD:  	ru.setForceUpdate (isAllowNonFastForwards ());  	ru.setExpectedOldObjectId (cmd.getOldId ());  	ru.setNewObjectId (cmd.getNewId ());  	ru.setRefLogMessage ("push"' true);  	Status (cmd' ru.update (walk));  	break;  }  
Missing Default,GitSharp.Core.Transport,ReceivePack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,SendStatusReport,The following switch statement is missing a default case: switch (cmd.getResult ()) {  case ReceiveCommand.Result.NOT_ATTEMPTED:  	r.Append ("server bug; ref not processed");  	break;  case ReceiveCommand.Result.REJECTED_NOCREATE:  	r.Append ("creation prohibited");  	break;  case ReceiveCommand.Result.REJECTED_NODELETE:  	r.Append ("deletion prohibited");  	break;  case ReceiveCommand.Result.REJECTED_NONFASTFORWARD:  	r.Append ("non-fast forward");  	break;  case ReceiveCommand.Result.REJECTED_CURRENT_BRANCH:  	r.Append ("branch is currently checked out");  	break;  case ReceiveCommand.Result.REJECTED_MISSING_OBJECT:  	if (cmd.getMessage () == null)  		r.Append ("missing object(s)");  	else if (cmd.getMessage ().Length == Constants.OBJECT_ID_STRING_LENGTH)  		r.Append ("object " + cmd.getMessage () + " missing");  	else  		r.Append (cmd.getMessage ());  	break;  case ReceiveCommand.Result.REJECTED_OTHER_REASON:  	if (cmd.getMessage () == null)  		r.Append ("unspecified reason");  	else  		r.Append (cmd.getMessage ());  	break;  case ReceiveCommand.Result.LOCK_FAILURE:  	r.Append ("failed to lock");  	break;  case ReceiveCommand.Result.OK:  	// We shouldn't have reached this case (see 'ok' case above).  	continue;  }  
Missing Default,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following switch statement is missing a default case: switch (_multiAck) {  case BasePackFetchConnection.MultiAck.OFF:  	if (_commonBase.Count == 1)  		_pckOut.WriteString ("ACK " + id.Name + "\n");  	break;  case BasePackFetchConnection.MultiAck.CONTINUE:  	_pckOut.WriteString ("ACK " + id.Name + " continue\n");  	break;  case BasePackFetchConnection.MultiAck.DETAILED:  	_pckOut.WriteString ("ACK " + id.Name + " common\n");  	break;  }  
Missing Default,GitSharp.Core.Transport,UploadPack,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following switch statement is missing a default case: switch (_multiAck) {  case BasePackFetchConnection.MultiAck.OFF:  	break;  case BasePackFetchConnection.MultiAck.CONTINUE:  	_pckOut.WriteString ("ACK " + id.Name + " continue\n");  	break;  case BasePackFetchConnection.MultiAck.DETAILED:  	_pckOut.WriteString ("ACK " + id.Name + " ready\n");  	break;  }  
Missing Default,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The following switch statement is missing a default case: switch (b [ptr]) {  case ((byte)'-'):  	sign = -1;  	ptr++;  	break;  case ((byte)'+'):  	ptr++;  	break;  }  
Missing Default,GitSharp.Core.Util,RawParseUtils,F:\newReposMay17\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The following switch statement is missing a default case: switch (b [ptr]) {  case (byte)'-':  	sign = -1;  	ptr++;  	break;  case (byte)'+':  	ptr++;  	break;  }  
Missing Default,GitSharp.Core.RevWalk.Filter,SubStringRevFilter,F:\newReposMay17\henon_GitSharp\GitSharp.Core\RevWalk\Filter\SubStringRevFilter.cs,safe,The following switch statement is missing a default case: switch (c) {  case '.':  case '?':  case '*':  case '+':  case '{':  case '}':  case '(':  case ')':  case '[':  case ']':  case '\\':  	return false;  }  
Missing Default,GitSharp.Core.TreeWalk,WorkingTreeIterator,F:\newReposMay17\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,idBuffer,The following switch statement is missing a default case: switch (Mode & FileMode.TYPE_MASK) {  case FileMode.TYPE_FILE:  	_contentIdFromPtr = ptr;  	return _contentId = IdBufferBlob (_entries [ptr]);  case FileMode.TYPE_SYMLINK:  	// Windows does not support symbolic links' so we should not  	// have reached this particular part of the walk code.  	//  	return ZeroId;  case FileMode.TYPE_GITLINK:  	// TODO: Support obtaining current HEAD SHA-1 from nested repository  	//  	return ZeroId;  }  
