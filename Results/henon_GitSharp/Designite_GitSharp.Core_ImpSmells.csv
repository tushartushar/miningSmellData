Implementation smell,Namespace,Class,File,Method,Description
Long Method,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,IsModified,The method has 107 lines of code.
Long Method,GitSharp.Core,ObjectWriter,C:\repos\henon_GitSharp\GitSharp.Core\ObjectWriter.cs,WriteObject,The method has 129 lines of code.
Long Method,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The method has 262 lines of code.
Long Method,GitSharp.Core,WorkDirCheckout,C:\repos\henon_GitSharp\GitSharp.Core\WorkDirCheckout.cs,ProcessEntry,The method has 101 lines of code.
Long Method,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetMandrivaPlatform,The method has 101 lines of code.
Long Method,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The method has 523 lines of code.
Long Method,GitSharp.Core.Merge,MergeAlgorithm,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The method has 148 lines of code.
Long Method,GitSharp.Core.RevWalk,RewriteTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RewriteTreeFilter.cs,include,The method has 127 lines of code.
Long Method,GitSharp.Core.Transport,FetchProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,executeImp,The method has 105 lines of code.
Long Method,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The method has 131 lines of code.
Long Method,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,The method has 115 lines of code.
Complex Method,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,IsModified,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,GitIndex,C:\repos\henon_GitSharp\GitSharp.Core\GitIndex.cs,writeTree,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkCommit,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,duplicateName,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,Cyclomatic complexity of the method is 20
Complex Method,GitSharp.Core,ObjectWriter,C:\repos\henon_GitSharp\GitSharp.Core\ObjectWriter.cs,WriteObject,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core,OffsetCache<V;R>,C:\repos\henon_GitSharp\GitSharp.Core\OffsetCache.cs,Evict,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core,RefUpdate,C:\repos\henon_GitSharp\GitSharp.Core\RefUpdate.cs,link,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,RefUpdate,C:\repos\henon_GitSharp\GitSharp.Core\RefUpdate.cs,updateImpl,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,Config,C:\repos\henon_GitSharp\GitSharp.Core\Config.cs,replaceStringList,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Config,C:\repos\henon_GitSharp\GitSharp.Core\Config.cs,ReadValue,Cyclomatic complexity of the method is 15
Complex Method,GitSharp.Core,Config,C:\repos\henon_GitSharp\GitSharp.Core\Config.cs,readSectionName,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,Config,C:\repos\henon_GitSharp\GitSharp.Core\Config.cs,readKeyName,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core,Tree,C:\repos\henon_GitSharp\GitSharp.Core\Tree.cs,CompareNames,Cyclomatic complexity of the method is 15
Complex Method,GitSharp.Core,Tree,C:\repos\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core,TreeIterator,C:\repos\henon_GitSharp\GitSharp.Core\TreeIterator.cs,Step,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,RefWriter,C:\repos\henon_GitSharp\GitSharp.Core\RefWriter.cs,writePackedRefs,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,parsePackedRefs,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,readRef,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core,RefDirectoryRename,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectoryRename.cs,doRename,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Diff,EditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,calculate,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.DirectoryCache,DirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEditor.cs,ApplyEdits,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.DirectoryCache,DirCacheTree,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,validate,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.RevWalk,InitialGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\BoundaryGenerator.cs,next,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,MergeBaseGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\MergeBaseGenerator.cs,next,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.RevWalk,ObjectWalk,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\ObjectWalk.cs,nextObject,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.RevWalk,PendingGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\PendingGenerator.cs,next,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,GetFooterLines,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RevCommitList<T>,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommitList.cs,fillTo,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.RevWalk,RevWalk,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,reset,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RewriteGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RewriteGenerator.cs,Cleanup,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevWalk,RewriteTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RewriteTreeFilter.cs,include,Cyclomatic complexity of the method is 18
Complex Method,GitSharp.Core.RevWalk,StartGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\StartGenerator.cs,next,Cyclomatic complexity of the method is 12
Complex Method,GitSharp.Core.Transport,FetchProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,executeImp,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Transport,OpenSshConfig,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,lookup,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,OpenSshConfig,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Transport,Host,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,copyFrom,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,PushProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PushProcess.cs,PrepareRemoteUpdates,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,WalkFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,Cyclomatic complexity of the method is 16
Complex Method,GitSharp.Core.Transport,WalkPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,Push,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Transport,WalkRemoteObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkRemoteObjectDatabase.cs,readPackedRefsImpl,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,BasePackConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Transport,BasePackPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,OpenRepository,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,index,Cyclomatic complexity of the method is 14
Complex Method,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,renameAndOpenPack,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,Cyclomatic complexity of the method is 15
Complex Method,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,SendStatusReport,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,Transport,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Transport.cs,open,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,SendPack,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,Format,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Util,PathUtil,C:\repos\henon_GitSharp\GitSharp.Core\Util\PathUtil.cs,RelativePath,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.Util,RawSubStringPattern,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawSubstringPattern.cs,match,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Util,TemporaryBuffer,C:\repos\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,copy,Cyclomatic complexity of the method is 8
Complex Method,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,GitSharp.Core.Patch,CombinedHunkHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,parseBody,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.Patch,CombinedHunkHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,extractFileLines,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Patch,CombinedHunkHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\CombinedHunkHeader.cs,extractFileLines,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Patch,FileHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitFileName,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.Patch,Patch,C:\repos\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseFile,Cyclomatic complexity of the method is 11
Complex Method,GitSharp.Core.Patch,Patch,C:\repos\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseHunks,Cyclomatic complexity of the method is 13
Complex Method,GitSharp.Core.TreeWalk,NameConflictTreeWalk,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,CombineDF,Cyclomatic complexity of the method is 9
Complex Method,GitSharp.Core.TreeWalk,TreeWalk,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\TreeWalk.cs,next,Cyclomatic complexity of the method is 8
Complex Method,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,Cyclomatic complexity of the method is 10
Long Parameter List,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,AbbreviatedObjectId,The method has 6 parameters. Parameters: nibbles' w1' w2' w3' w4' w5
Long Parameter List,GitSharp.Core,DeltaOfsPackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\DeltaOfsPackedObjectLoader.cs,DeltaOfsPackedObjectLoader,The method has 5 parameters. Parameters: pr' dataOffset' objectOffset' deltaSz' base
Long Parameter List,GitSharp.Core,DeltaRefPackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\DeltaRefPackedObjectLoader.cs,DeltaRefPackedObjectLoader,The method has 5 parameters. Parameters: pr' dataOffset' objectOffset' deltaSz' base
Long Parameter List,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The method has 5 parameters. Parameters: repository' key' f' stage' newContent
Long Parameter List,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,AnyObjectId,The method has 5 parameters. Parameters: w1' w2' w3' w4' w5
Long Parameter List,GitSharp.Core,IndexTreeWalker,C:\repos\henon_GitSharp\GitSharp.Core\IndexTreeWalker.cs,IndexTreeWalker,The method has 5 parameters. Parameters: index' mainTree' newTree' root' visitor
Long Parameter List,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,pathCompare,The method has 7 parameters. Parameters: raw' aPos' aEnd' aMode' bPos' bEnd' bMode
Long Parameter List,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,ObjectId,The method has 5 parameters. Parameters: w1' w2' w3' w4' w5
Long Parameter List,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,ReadFully,The method has 5 parameters. Parameters: position' dstbuf' dstoff' cnt' curs
Long Parameter List,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,CopyToStream,The method has 5 parameters. Parameters: position' buffer' count' stream' windowCursor
Long Parameter List,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The method has 5 parameters. Parameters: d' workTree' objectDir' alternateObjectDir' indexFile
Long Parameter List,GitSharp.Core,Config,C:\repos\henon_GitSharp\GitSharp.Core\Config.cs,replaceStringList,The method has 5 parameters. Parameters: srcState' section' subsection' name' values
Long Parameter List,GitSharp.Core,Tree,C:\repos\henon_GitSharp\GitSharp.Core\Tree.cs,CompareNames,The method has 6 parameters. Parameters: a' nameUTF8' nameStart' nameEnd' lastA' lastB
Long Parameter List,GitSharp.Core,Tree,C:\repos\henon_GitSharp\GitSharp.Core\Tree.cs,BinarySearch,The method has 5 parameters. Parameters: entries' nameUTF8' nameUTF8Last' nameStart' nameEnd
Long Parameter List,GitSharp.Core,WholePackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\WholePackedObjectLoader.cs,WholePackedObjectLoader,The method has 5 parameters. Parameters: pr' dataOffset' objectOffset' type' size
Long Parameter List,GitSharp.Core,WindowCursor,C:\repos\henon_GitSharp\GitSharp.Core\WindowCursor.cs,Copy,The method has 5 parameters. Parameters: pack' position' dstbuf' dstoff' cnt
Long Parameter List,GitSharp.Core,WorkDirCheckout,C:\repos\henon_GitSharp\GitSharp.Core\WorkDirCheckout.cs,WorkDirCheckout,The method has 5 parameters. Parameters: repo' root' head' index' merge
Long Parameter List,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,GetProductInfo,The method has 5 parameters. Parameters: dwOSMajorVersion' dwOSMinorVersion' dwSpMajorVersion' dwSpMinorVersion' dwOSEdition
Long Parameter List,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,resolve,The method has 5 parameters. Parameters: ref' depth' prefix' loose' packed
Long Parameter List,GitSharp.Core.Diff,DiffFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,WriteHunkHeader,The method has 5 parameters. Parameters: out' aCur' aEnd' bCur' bEnd
Long Parameter List,GitSharp.Core.Exceptions,NoClosingBracketException,C:\repos\henon_GitSharp\GitSharp.Core\Exceptions\NoClosingBracketException.cs,NoClosingBracketException,The method has 5 parameters. Parameters: indexOfOpeningBracket' openingBracket' closingBracket' pattern' inner
Long Parameter List,GitSharp.Core.Merge,MergeFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeFormatter.cs,formatMerge,The method has 6 parameters. Parameters: out' res' baseName' oursName' theirsName' charsetName
Long Parameter List,GitSharp.Core.RevWalk,FooterLine,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\FooterLine.cs,FooterLine,The method has 6 parameters. Parameters: b' e' ks' ke' vs' ve
Long Parameter List,GitSharp.Core.Transport,FetchProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,deleteTrackingRef,The method has 5 parameters. Parameters: result' db' walk' spec' localRef
Long Parameter List,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RemotePack,The method has 6 parameters. Parameters: lockMessage' packLocks' oC' r' c' pn
Long Parameter List,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The method has 5 parameters. Parameters: pos' oldCrc' type' data' oe
Long Parameter List,GitSharp.Core.Transport,RemoteRefUpdate,C:\repos\henon_GitSharp\GitSharp.Core\Transport\RemoteRefUpdate.cs,RemoteRefUpdate,The method has 6 parameters. Parameters: localDb' srcRef' remoteName' forceUpdate' localName' expectedOldObjectId
Long Parameter List,GitSharp.Core.Transport,TrackingRefUpdate,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TrackingRefUpdate.cs,TrackingRefUpdate,The method has 6 parameters. Parameters: db' localName' remoteName' forceUpdate' nv' msg
Long Parameter List,GitSharp.Core.Util,IO,C:\repos\henon_GitSharp\GitSharp.Core\Util\IO.cs,ReadFully,The method has 5 parameters. Parameters: fd' pos' dst' off' len
Long Parameter List,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,drawLine,The method has 6 parameters. Parameters: color' x1' y1' x2' y2' width
Long Identifier,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,,The length of the parameter GIT_ALTERNATE_OBJECT_DIRECTORIES_KEY is 36.
Long Identifier,GitSharp.Core,ProductType,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,,The length of the parameter MediumBusinessServerManagement is 30.
Long Statement,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Decode,The length of the statement  "                throw new CorruptObjectException(CommitId' "malformed header:" + new ASCIIEncoding().GetString(res.Buffer ?? new byte[0])); " is 123.
Long Statement,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The length of the statement  "			_buf[size++] = (byte)((nextLength > 0 ? (byte)0x80 : (byte)0x00) | (byte)(objectType << 4) | (byte)(dataLength & 0x0F)); " is 120.
Long Statement,GitSharp.Core.Exceptions,NoClosingBracketException,C:\repos\henon_GitSharp\GitSharp.Core\Exceptions\NoClosingBracketException.cs,CreateMessage,The length of the statement  "            return string.Format("No closing {0} found for {1} at index {2}."' closingBracket' openingBracket' Convert.ToInt32(indexOfOpeningBracket)); " is 139.
Long Statement,GitSharp.Core.Transport,FetchProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\FetchProcess.cs,deleteTrackingRef,The length of the statement  "                        throw new TransportException(_transport.Uri' "Cannot delete stale tracking ref " + name + ": " + Enum.GetName(typeof(RefUpdate.RefUpdateResult)' u.Result)); " is 156.
Long Statement,GitSharp.Core.Transport,PushProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PushProcess.cs,UpdateTrackingRefs,The length of the statement  "                if (rru.HasTrackingRefUpdate && (status == RemoteRefUpdate.UpdateStatus.UP_TO_DATE || status == RemoteRefUpdate.UpdateStatus.OK)) " is 129.
Long Statement,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteIdx,The length of the statement  "				PackIndexWriter iw = _outputVersion <= 0 ? PackIndexWriter.CreateOldestPossible(os' list) : PackIndexWriter.CreateVersion(os' _outputVersion); " is 142.
Long Statement,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,The length of the statement  "				if (cmd.getType() == ReceiveCommand.Type.DELETE && @ref != null && !ObjectId.ZeroId.Equals(cmd.getOldId()) && !@ref.ObjectId.Equals(cmd.getOldId())) " is 148.
Long Statement,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,getHumanishName,The length of the statement  "            // In order to match Java Split behavior (http://java.sun.com/j2se/1.4.2/docs/api/java/lang/String.html#split(java.lang.String) " is 127.
Long Statement,GitSharp.Core.Util,FS,C:\repos\henon_GitSharp\GitSharp.Core\Util\FS.cs,globalHomeImpl,The length of the statement  "                    throw new ArgumentException("GlobalHomeImpl support for '" + Environment.OSVersion.VersionString + " ' is not implemented."); " is 125.
Long Statement,GitSharp.Core.Util,FS,C:\repos\henon_GitSharp\GitSharp.Core\Util\FS.cs,systemHomeImpl,The length of the statement  "                    throw new ArgumentException("SystemHomeImpl support for '" + Environment.OSVersion.VersionString + " ' is not implemented."); " is 125.
Long Statement,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The length of the statement  "                 throw new DecoderFallbackException(string.Format("Unable to decode provided buffer using encoder '{0}'."' cs.WebName) ); " is 120.
Long Statement,GitSharp.Core.Util,AlarmState,C:\repos\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,end,The length of the statement  "				//   Thread.interrupted(); // <-- Note: [henon] this code does nothing but reset an irrelevant java thread internal flag AFAIK (which is not supported by our thread implementation) " is 180.
Long Statement,GitSharp.Core.Util,RefMap,C:\repos\henon_GitSharp\GitSharp.Core\Util\RefMap.cs,GetEnumerator,The length of the statement  "            return new LambdaConverterIterator<Ent' KeyValuePair<string' Ref>>(entrySet().iterator()' (ent) => new KeyValuePair<string' Ref>(ent.getKey()' ent.getValue())); " is 160.
Long Statement,GitSharp.Core.Util.JavaHelper,AtomicReference<T>,C:\repos\henon_GitSharp\GitSharp.Core\Util\JavaHelper\AtomicReference.cs,compareAndSet,The length of the statement  "                if ((Equals(_reference' default(T)) && Equals(expected' default(T))) || (!Equals(_reference' default(T)) && _reference.Equals(expected))) " is 137.
Long Statement,GitSharp.Core.Util.JavaHelper,Charset,C:\repos\henon_GitSharp\GitSharp.Core\Util\JavaHelper\Charset.cs,forName,The length of the statement  "                encodingAlias = "EUC-JP";   // Hacked as euc_JP is not valid from the IANA perspective (http://www.iana.org/assignments/character-sets) " is 135.
Long Statement,GitSharp.Core.RevWalk.Filter,BetweenCommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,ToString,The length of the statement  "                return base.ToString() + "(" + ((long)_when * 1000).MillisToUtcDateTime() + " - " + ((long)_until * 1000).MillisToUtcDateTime() + ")"; " is 134.
Complex Conditional,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,IsModified,The conditional expression  "!File.Exists(file.FullName) || ConfigFileMode && FileCanExecute(file) && FileHasExecute()"  is complex.
Complex Conditional,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The conditional expression  "typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark"  is complex.
Complex Conditional,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The conditional expression  "typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark"  is complex.
Complex Conditional,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The conditional expression  "typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark"  is complex.
Complex Conditional,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The conditional expression  "typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark"  is complex.
Complex Conditional,GitSharp.Core,GitIndex,C:\repos\henon_GitSharp\GitSharp.Core\GitIndex.cs,MakeKey,The conditional expression  "!string.IsNullOrEmpty(f.DirectoryName()) &&  				 wd.IsDirectory() && wd.Exists &&  				 !f.DirectoryName().StartsWith(wd.DirectoryName())"  is complex.
Complex Conditional,GitSharp.Core,IndexTreeWalker,C:\repos\henon_GitSharp\GitSharp.Core\IndexTreeWalker.cs,Compare,The conditional expression  "(((t1 != null) && (t1.Parent == null)) && (t2 != null)) && (t2.Parent == null)"  is complex.
Complex Conditional,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,SelectDeltaReuseForObject,The conditional expression  "(otpBase != null || (Thin && _edgeObjects.Get(idBase) != null)) && IsBetterDeltaReuseLoader(bestLoader' loader)"  is complex.
Complex Conditional,GitSharp.Core.Transport,TransportLocal,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportLocal.cs,canHandle,The conditional expression  "uri.Host != null || uri.Port > 0 || uri.User != null || uri.Pass != null || uri.Path == null"  is complex.
Complex Conditional,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,ValidateCommands,The conditional expression  "cmd.getType() == ReceiveCommand.Type.DELETE && @ref != null && !ObjectId.ZeroId.Equals(cmd.getOldId()) && !@ref.ObjectId.Equals(cmd.getOldId())"  is complex.
Complex Conditional,GitSharp.Core.Transport,TransportBundleFile,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportBundleFile.cs,canHandle,The conditional expression  "uri.Host != null || uri.Port > 0 || uri.User != null || uri.Pass != null || uri.Path == null"  is complex.
Complex Conditional,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The conditional expression  "Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z')"  is complex.
Complex Conditional,GitSharp.Core.Util,AtomicReferenceArray<T>,C:\repos\henon_GitSharp\GitSharp.Core\Util\AtomicReferenceArray.cs,compareAndSet,The conditional expression  "(array[slot] == null && expect==null) || (array[slot] != null && array[slot].Equals(expect))"  is complex.
Complex Conditional,GitSharp.Core.Util,StringUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\StringUtils.cs,toBoolean,The conditional expression  "equalsIgnoreCase("yes"' stringValue)                      || equalsIgnoreCase("true"' stringValue)                      || equalsIgnoreCase("1"' stringValue)                      || equalsIgnoreCase("on"' stringValue)"  is complex.
Complex Conditional,GitSharp.Core.Util,StringUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\StringUtils.cs,toBoolean,The conditional expression  "equalsIgnoreCase("no"' stringValue)                      || equalsIgnoreCase("false"' stringValue)                      || equalsIgnoreCase("0"' stringValue)                      || equalsIgnoreCase("off"' stringValue)"  is complex.
Complex Conditional,GitSharp.Core.Util.JavaHelper,AtomicReference<T>,C:\repos\henon_GitSharp\GitSharp.Core\Util\JavaHelper\AtomicReference.cs,compareAndSet,The conditional expression  "(Equals(_reference' default(T)) && Equals(expected' default(T))) || (!Equals(_reference' default(T)) && _reference.Equals(expected))"  is complex.
Complex Conditional,GitSharp.Core.Patch,HunkHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,parseBody,The conditional expression  "last < end && LinesContext + _oldImage.LinesDeleted - 1 == _oldImage.LineCount  				&& LinesContext + _oldImage.LinesAdded == NewLineCount  				&& RawParseUtils.match(buf' last' Patch.SigFooter) >= 0"  is complex.
Complex Conditional,GitSharp.Core.Patch,Patch,C:\repos\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseHunks,The conditional expression  "fh.Hunks.isEmpty() && BinTrailer.Length < eol - c  						&& RawParseUtils.match(buf' eol - BinTrailer.Length' BinTrailer) >= 0  						&& MatchAny(buf' c' BinHeaders)"  is complex.
Complex Conditional,GitSharp.Core.TreeWalk,NameConflictTreeWalk,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,FastMin,The conditional expression  "_fastMinHasMatch && IsTree(minRef) && !IsTree(t)                              && NameEqual(minRef' t)"  is complex.
Complex Conditional,GitSharp.Core.TreeWalk,NameConflictTreeWalk,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\NameConflictTreeWalk.cs,FastMin,The conditional expression  "_fastMinHasMatch && IsTree(t) && !IsTree(minRef)                        && NameEqual(t' minRef)"  is complex.
Virtual Method Call from Constructor,GitSharp.Core,RefRename,C:\repos\henon_GitSharp\GitSharp.Core\RefRename.cs,RefRename,The constructor "RefRename" calls a virtual method "getRepository".
Virtual Method Call from Constructor,GitSharp.Core,RepositoryConfig,C:\repos\henon_GitSharp\GitSharp.Core\RepositoryConfig.cs,RepositoryConfig,The constructor "RepositoryConfig" calls a virtual method "openUserConfig".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getCurrentTime".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getTimezone".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getCurrentTime".
Virtual Method Call from Constructor,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The constructor "PersonIdent" calls a virtual method "getTimezone".
Virtual Method Call from Constructor,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The constructor "Repository" calls a virtual method "openUserConfig".
Virtual Method Call from Constructor,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The constructor "Repository" calls a virtual method "load".
Virtual Method Call from Constructor,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Repository,The constructor "Repository" calls a virtual method "load".
Virtual Method Call from Constructor,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The constructor "DirCacheEntry" calls a virtual method "Update".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,BlockRevQueue,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "shareFreeList".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,BlockRevQueue,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,BlockRevQueue,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\BlockRevQueue.cs,BlockRevQueue,The constructor "BlockRevQueue" calls a virtual method "add".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,InitialGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\BoundaryGenerator.cs,InitialGenerator,The constructor "InitialGenerator" calls a virtual method "shareFreeList".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,DateRevQueue,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\DateRevQueue.cs,DateRevQueue,The constructor "DateRevQueue" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,Iterator<T>,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,Iterator,The constructor "Iterator" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,RewriteTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RewriteTreeFilter.cs,RewriteTreeFilter,The constructor "RewriteTreeFilter" calls a virtual method "shouldBeRecursive".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,TopoSortGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "shareFreeList".
Virtual Method Call from Constructor,GitSharp.Core.RevWalk,TopoSortGenerator,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\TopoSortGenerator.cs,TopoSortGenerator,The constructor "TopoSortGenerator" calls a virtual method "next".
Virtual Method Call from Constructor,GitSharp.Core.Transport,ReceiveCommand,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceiveCommand.cs,ReceiveCommand,The constructor "ReceiveCommand" calls a virtual method "Equals".
Virtual Method Call from Constructor,GitSharp.Core.Transport,ReceiveCommand,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceiveCommand.cs,ReceiveCommand,The constructor "ReceiveCommand" calls a virtual method "Equals".
Virtual Method Call from Constructor,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The constructor "URIish" calls a virtual method "getOperatingSystem".
Virtual Method Call from Constructor,GitSharp.Core.Patch,OldImage,C:\repos\henon_GitSharp\GitSharp.Core\Patch\HunkHeader.cs,OldImage,The constructor "OldImage" calls a virtual method "getOldId".
Virtual Method Call from Constructor,GitSharp.Core.RevPlot,PlotWalk,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\PlotWalk.cs,PlotWalk,The constructor "PlotWalk" calls a virtual method "sort".
Empty Catch Block,GitSharp.Core,IgnoreHandler,C:\repos\henon_GitSharp\GitSharp.Core\IgnoreHandler.cs,IgnoreHandler,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,IgnoreHandler,C:\repos\henon_GitSharp\GitSharp.Core\IgnoreHandler.cs,IgnoreHandler,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,RenameTo,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,C:\repos\henon_GitSharp\GitSharp.Core\LockFile.cs,Lock,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,C:\repos\henon_GitSharp\GitSharp.Core\LockFile.cs,CopyCurrentContent,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,C:\repos\henon_GitSharp\GitSharp.Core\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,LockFile,C:\repos\henon_GitSharp\GitSharp.Core\LockFile.cs,Unlock,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,DoClose,The method has an empty catch block.
Empty Catch Block,GitSharp.Core,CachedObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,read,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.RevWalk,RevCommitList<T>,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommitList.cs,clearFlag,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,OpenSshConfig,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,PushProcess,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PushProcess.cs,UpdateTrackingRefs,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SshConfigSessionFactory,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SshConfigSessionFactory.cs,knownHosts,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SshConfigSessionFactory,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SshConfigSessionFactory.cs,knownHosts,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SshConfigSessionFactory,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SshConfigSessionFactory.cs,loadIdentity,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,TransportBundleStream,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportBundleStream.cs,close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,TransportGitAnon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportGitAnon.cs,OpenConnection,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,TcpFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportGitAnon.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,TcpPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportGitAnon.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,HttpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportHttp.cs,getAlternates,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,HttpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportHttp.cs,getAlternates,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,SftpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportSftp.cs,writeFile,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,OpenIndex,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,WalkPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,SafeDelete,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,WalkRemoteObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkRemoteObjectDatabase.cs,readPackedRefs,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MaxTimeWanted,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkReachable,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkReachable,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,SendWants,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,MarkAdvertised,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,noRepository,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BasePackPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,noRepository,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,verifyPrerequisites,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,Close,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,Start,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,Start,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,startClient,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,Daemon,C:\repos\henon_GitSharp\GitSharp.Core\Transport\Daemon.cs,OpenRepository,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,sendError,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,sendMessage,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Service,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,decodeNoFallback,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Util,TemporaryBuffer,C:\repos\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,destroy,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.Patch,FileHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,getScriptText,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.TreeWalk,WorkingTreeIterator,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The method has an empty catch block.
Empty Catch Block,GitSharp.Core.TreeWalk,WorkingTreeIterator,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The method has an empty catch block.
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: int b = (word - 1) * 8;
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: if (b + 8 <= nibbles)  			{  				// We have all of the bits required for this word.  				//  				return v;  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: int s = 32 - (nibbles - b) * 4;
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,Mask,The following statement contains a magic number: int s = 32 - (nibbles - b) * 4;
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(_w2' mask(2' other.W2));
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(_w3' mask(3' other.W3));
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: cmp = NB.CompareUInt32(_w4' mask(4' other.W4));
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,prefixCompare,The following statement contains a magic number: return NB.CompareUInt32(_w5' mask(5' other.W5));
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 8)  			{  				return new string(b' 0' _nibbles);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray(b' 8' _w2);
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 16)  			{  				return new string(b' 0' _nibbles);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray(b' 16' _w3);
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 24)  			{  				return new string(b' 0' _nibbles);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray(b' 24' _w4);
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: if (_nibbles <= 32)  			{  				return new string(b' 0' _nibbles);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,name,The following statement contains a magic number: Hex.FillHexCharArray(b' 32' _w5);
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = Hex.HexUInt32(bs' ptr' end);  				int b = Hex.HexUInt32(bs' ptr + 8' end);  				int c = Hex.HexUInt32(bs' ptr + 16' end);  				int d = Hex.HexUInt32(bs' ptr + 24' end);  				int e = Hex.HexUInt32(bs' ptr + 32' end);  				return new AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' ptr' end - ptr' e);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = Hex.HexUInt32(bs' ptr' end);  				int b = Hex.HexUInt32(bs' ptr + 8' end);  				int c = Hex.HexUInt32(bs' ptr + 16' end);  				int d = Hex.HexUInt32(bs' ptr + 24' end);  				int e = Hex.HexUInt32(bs' ptr + 32' end);  				return new AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' ptr' end - ptr' e);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = Hex.HexUInt32(bs' ptr' end);  				int b = Hex.HexUInt32(bs' ptr + 8' end);  				int c = Hex.HexUInt32(bs' ptr + 16' end);  				int d = Hex.HexUInt32(bs' ptr + 24' end);  				int e = Hex.HexUInt32(bs' ptr + 32' end);  				return new AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' ptr' end - ptr' e);  			}
Magic Number,GitSharp.Core,AbbreviatedObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AbbreviatedObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = Hex.HexUInt32(bs' ptr' end);  				int b = Hex.HexUInt32(bs' ptr + 8' end);  				int c = Hex.HexUInt32(bs' ptr + 16' end);  				int d = Hex.HexUInt32(bs' ptr + 24' end);  				int e = Hex.HexUInt32(bs' ptr + 32' end);  				return new AbbreviatedObjectId(end - ptr' a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' ptr' end - ptr' e);  			}
Magic Number,GitSharp.Core,ByteArrayExtensions,C:\repos\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length)              {                  int num = source[currentIndex];                  switch (num)                  {                      case 13:                          if ((currentIndex != (source.Length - 1)) && (source[currentIndex + 1] == 10))                          {                              indexModifier = 2;                          }                          break;                        case 10:                          indexModifier = 1;                          break;                  }              }
Magic Number,GitSharp.Core,ByteArrayExtensions,C:\repos\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length)              {                  int num = source[currentIndex];                  switch (num)                  {                      case 13:                          if ((currentIndex != (source.Length - 1)) && (source[currentIndex + 1] == 10))                          {                              indexModifier = 2;                          }                          break;                        case 10:                          indexModifier = 1;                          break;                  }              }
Magic Number,GitSharp.Core,ByteArrayExtensions,C:\repos\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length)              {                  int num = source[currentIndex];                  switch (num)                  {                      case 13:                          if ((currentIndex != (source.Length - 1)) && (source[currentIndex + 1] == 10))                          {                              indexModifier = 2;                          }                          break;                        case 10:                          indexModifier = 1;                          break;                  }              }
Magic Number,GitSharp.Core,ByteArrayExtensions,C:\repos\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following statement contains a magic number: while (indexModifier == 0 && ++currentIndex < source.Length)              {                  int num = source[currentIndex];                  switch (num)                  {                      case 13:                          if ((currentIndex != (source.Length - 1)) && (source[currentIndex + 1] == 10))                          {                              indexModifier = 2;                          }                          break;                        case 10:                          indexModifier = 1;                          break;                  }              }
Magic Number,GitSharp.Core,ByteBufferWindow,C:\repos\henon_GitSharp\GitSharp.Core\ByteBufferWindow.cs,Inflate,The following statement contains a magic number: var tmp = new byte[512];
Magic Number,GitSharp.Core,ByteBufferWindow,C:\repos\henon_GitSharp\GitSharp.Core\ByteBufferWindow.cs,inflateVerify,The following statement contains a magic number: var tmp = new byte[512];
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,fileFor,The following statement contains a magic number: string d = objectName.Slice(0' 2);
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,fileFor,The following statement contains a magic number: string f = objectName.Substring(2);
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (p.Length != 50 || !p.StartsWith("pack-") || !p.EndsWith(IndexPack.PackSuffix))              {                  throw new IOException("Not a valid pack " + pack);              }
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (i.Length != 49 || !i.StartsWith("pack-") || !i.EndsWith(IndexPack.IndexSuffix))              {                  throw new IOException("Not a valid pack " + idx);              }
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (!p.Slice(0' 45).Equals(i.Slice(0' 45)))              {                  throw new IOException("Pack " + pack + "does not match index");              }
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,openPack,The following statement contains a magic number: if (!p.Slice(0' 45).Equals(i.Slice(0' 45)))              {                  throw new IOException("Pack " + pack + "does not match index");              }
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: var list = new List<PackFile>(names.Count >> 2);
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: foreach (string indexName in names)              {                  // Must match "pack-[0-9a-f]{40}.idx" to be an index.                  //                  if (indexName.Length != 49 || !indexName.EndsWith(".idx"))                      continue;                  string @base = indexName.Slice(0' indexName.Length - 4);                  string packName = IndexPack.GetPackFileName(@base);                    if (!names.Contains(packName))                  {                      // Sometimes C Git's HTTP fetch transport leaves a                      // .idx file behind and does not download the .pack.                      // We have to skip over such useless indexes.                      //                      continue;                  }                  PackFile oldPack;                  forReuse.TryGetValue(packName' out oldPack);                  forReuse.Remove(packName);                  if (oldPack != null)                  {                      list.Add(oldPack);                      continue;                  }                    var packFile = new FileInfo(_packDirectory.FullName + "/" + packName);                    var idxFile = new FileInfo(_packDirectory + "/" + indexName);                  list.Add(new PackFile(idxFile' packFile));                  foundNew = true;              }
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,ScanPacksImpl,The following statement contains a magic number: foreach (string indexName in names)              {                  // Must match "pack-[0-9a-f]{40}.idx" to be an index.                  //                  if (indexName.Length != 49 || !indexName.EndsWith(".idx"))                      continue;                  string @base = indexName.Slice(0' indexName.Length - 4);                  string packName = IndexPack.GetPackFileName(@base);                    if (!names.Contains(packName))                  {                      // Sometimes C Git's HTTP fetch transport leaves a                      // .idx file behind and does not download the .pack.                      // We have to skip over such useless indexes.                      //                      continue;                  }                  PackFile oldPack;                  forReuse.TryGetValue(packName' out oldPack);                  forReuse.Remove(packName);                  if (oldPack != null)                  {                      list.Add(oldPack);                      continue;                  }                    var packFile = new FileInfo(_packDirectory.FullName + "/" + packName);                    var idxFile = new FileInfo(_packDirectory + "/" + indexName);                  list.Add(new PackFile(idxFile' packFile));                  foundNew = true;              }
Magic Number,GitSharp.Core,ObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,loadAlternates,The following statement contains a magic number: var l = new List<ObjectDatabase>(4);
Magic Number,GitSharp.Core,PackList,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,notRacyClean,The following statement contains a magic number: return read - lastModified > 2 * 60 * 1000L;
Magic Number,GitSharp.Core,PackList,C:\repos\henon_GitSharp\GitSharp.Core\ObjectDirectory.cs,notRacyClean,The following statement contains a magic number: return read - lastModified > 2 * 60 * 1000L;
Magic Number,GitSharp.Core,ReflogReader,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,getReverseEntries,The following statement contains a magic number: while (rs >= 0 && max-- > 0)              {                  rs = RawParseUtils.prevLF(log' rs);                  Entry entry = new Entry(log' rs < 0 ? 0 : rs + 2);                  ret.Add(entry);              }
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: _flags = (short)((stage << 12) | _name.Length);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: _flags = (short)((stage << 12) | _name.Length);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Entry,The following statement contains a magic number: b.BaseStream.Position = startposition +  												((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,Write,The following statement contains a magic number: long end = startposition  						  + ((8 + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 20 + 2 + _name.Length + 8) & ~7);
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,IsModified,The following statement contains a magic number: if (javamtime % 1000 == 0)  				{  					lastm = lastm - lastm % 1000;  				}
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,IsModified,The following statement contains a magic number: if (javamtime % 1000 == 0)  				{  					lastm = lastm - lastm % 1000;  				}
Magic Number,GitSharp.Core,Entry,C:\repos\henon_GitSharp\GitSharp.Core\ReflogReader.cs,ToString,The following statement contains a magic number: return Name + "/SHA-1(" +  						 ObjectId.Name + ")/M:" +                           (Ctime / 1000000L).MillisToUtcDateTime() + "/C:" +                           (Mtime / 1000000L).MillisToUtcDateTime() + "/d" +  						 _dev +  						 "/i" + _ino +  						 "/m" + Convert.ToString(Mode' 8) +  						 "/u" + _uid +  						 "/g" + _gid +  						 "/s" + _size +  						 "/f" + _flags +  						 "/@" + Stage;
Magic Number,GitSharp.Core,RepositoryCache,C:\repos\henon_GitSharp\GitSharp.Core\RepositoryCache.cs,RepositoryCache,The following statement contains a magic number: openLocks = new Lock[4];
Magic Number,GitSharp.Core,RepositoryCache,C:\repos\henon_GitSharp\GitSharp.Core\RepositoryCache.cs,clearAll,The following statement contains a magic number: for (int stage = 0; stage < 2; stage++)              {                  var keysToRemove = new List<Key>();                    foreach (KeyValuePair<Key' WeakReference<Repository>> e in cacheMap)                  {                      Repository db = e.Value.get();                      if (db != null)                          db.Dispose();                        keysToRemove.Add(e.Key);                  }                    foreach (Key key in keysToRemove)                  {                      cacheMap.Remove(key);                  }              }
Magic Number,GitSharp.Core,FileKey,C:\repos\henon_GitSharp\GitSharp.Core\RepositoryCache.cs,readFirstLine,The following statement contains a magic number: try                  {                      byte[] buf = IO.ReadFully(head' 4096);                      int n = buf.Length;                      if (n == 0)                          return null;                      if (buf[n - 1] == '\n')                          n--;                      return RawParseUtils.decode(buf' 0' n);                  }                  catch (IOException)                  {                      return null;                  }
Magic Number,GitSharp.Core,UnpackedObjectCache,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectCache.cs,Hash,The following statement contains a magic number: return (int)((uint)(((int)position) << 22) >> 22);
Magic Number,GitSharp.Core,UnpackedObjectCache,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectCache.cs,Hash,The following statement contains a magic number: return (int)((uint)(((int)position) << 22) >> 22);
Magic Number,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,UnsignedRightShift,The following statement contains a magic number: return (n >> s) + (((long) 2) << ~s);
Magic Number,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,UnsignedRightShift,The following statement contains a magic number: return (n >> s) + (2 << ~s);
Magic Number,GitSharp.Core,Extensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Extensions.cs,CreateTempFile,The following statement contains a magic number: int i = 8;
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: var buf = new byte[20];
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 4' W2);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 8' W3);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 12' W4);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 16' W5);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: s.Write(buf' 0' 20);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 4 + off' W2);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 8 + off' W3);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 12 + off' W4);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: NB.encodeInt32(buf' 16 + off' W5);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: b[offset + 2] = W3;
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: b[offset + 3] = W4;
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,copyRawTo,The following statement contains a magic number: b[offset + 4] = W5;
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray(dst' 8' W2);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray(dst' 16' W3);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray(dst' 24' W4);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexByteArray,The following statement contains a magic number: Hex.FillHexByteArray(dst' 32' W5);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: return Abbreviate(repo' 8);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int b = AbbreviatedObjectId.Mask(len' 2' W2);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int c = AbbreviatedObjectId.Mask(len' 3' W3);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int d = AbbreviatedObjectId.Mask(len' 4' W4);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,Abbreviate,The following statement contains a magic number: int e = AbbreviatedObjectId.Mask(len' 5' W5);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,GetFirstByte,The following statement contains a magic number: return (byte)(((uint)W1) >> 24);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(W2' NB.DecodeInt32(bs' p + 4));
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(W3' NB.DecodeInt32(bs' p + 8));
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(W4' NB.DecodeInt32(bs' p + 12));
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: return NB.CompareUInt32(W5' NB.DecodeInt32(bs' p + 16));
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(W3' bs[p + 2]);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: cmp = NB.CompareUInt32(W4' bs[p + 3]);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,CompareTo,The following statement contains a magic number: return NB.CompareUInt32(W5' bs[p + 4]);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray(dest' 8' W2);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray(dest' 16' W3);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray(dest' 24' W4);
Magic Number,GitSharp.Core,AnyObjectId,C:\repos\henon_GitSharp\GitSharp.Core\AnyObjectId.cs,ToHexCharArray,The following statement contains a magic number: Hex.FillHexCharArray(dest' 32' W5);
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: do  			{  				c = delta[deltaPtr++] & 0xff;  				baseLen |= (c & 0x7f) << shift;  				shift += 7;  			} while ((c & 0x80) != 0);
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: do  			{  				c = delta[deltaPtr++] & 0xff;  				resLen |= (c & 0x7f) << shift;  				shift += 7;  			} while ((c & 0x80) != 0);
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & 0xff;  				if ((cmd & 0x80) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a Length.  					//  					int copyOffset = 0;  					if ((cmd & 0x01) != 0)  						copyOffset = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x02) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x04) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 16;  					if ((cmd & 0x08) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 24;    					int copySize = 0;  					if ((cmd & 0x10) != 0)  						copySize = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x20) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x40) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 16;  					if (copySize == 0)  						copySize = 0x10000;    					Array.Copy(baseData' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself.  					//  					Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  					deltaPtr += cmd;  					resultPtr += cmd;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new ArgumentException("unsupported command 0");  				}  			}
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & 0xff;  				if ((cmd & 0x80) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a Length.  					//  					int copyOffset = 0;  					if ((cmd & 0x01) != 0)  						copyOffset = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x02) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x04) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 16;  					if ((cmd & 0x08) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 24;    					int copySize = 0;  					if ((cmd & 0x10) != 0)  						copySize = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x20) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x40) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 16;  					if (copySize == 0)  						copySize = 0x10000;    					Array.Copy(baseData' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself.  					//  					Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  					deltaPtr += cmd;  					resultPtr += cmd;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new ArgumentException("unsupported command 0");  				}  			}
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & 0xff;  				if ((cmd & 0x80) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a Length.  					//  					int copyOffset = 0;  					if ((cmd & 0x01) != 0)  						copyOffset = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x02) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x04) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 16;  					if ((cmd & 0x08) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 24;    					int copySize = 0;  					if ((cmd & 0x10) != 0)  						copySize = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x20) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x40) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 16;  					if (copySize == 0)  						copySize = 0x10000;    					Array.Copy(baseData' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself.  					//  					Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  					deltaPtr += cmd;  					resultPtr += cmd;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new ArgumentException("unsupported command 0");  				}  			}
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & 0xff;  				if ((cmd & 0x80) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a Length.  					//  					int copyOffset = 0;  					if ((cmd & 0x01) != 0)  						copyOffset = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x02) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x04) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 16;  					if ((cmd & 0x08) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 24;    					int copySize = 0;  					if ((cmd & 0x10) != 0)  						copySize = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x20) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x40) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 16;  					if (copySize == 0)  						copySize = 0x10000;    					Array.Copy(baseData' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself.  					//  					Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  					deltaPtr += cmd;  					resultPtr += cmd;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new ArgumentException("unsupported command 0");  				}  			}
Magic Number,GitSharp.Core,BinaryDelta,C:\repos\henon_GitSharp\GitSharp.Core\BinaryDelta.cs,Apply,The following statement contains a magic number: while (deltaPtr < delta.Length)  			{  				int cmd = delta[deltaPtr++] & 0xff;  				if ((cmd & 0x80) != 0)  				{  					// Determine the segment of the base which should  					// be copied into the output. The segment is given  					// as an offset and a Length.  					//  					int copyOffset = 0;  					if ((cmd & 0x01) != 0)  						copyOffset = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x02) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x04) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 16;  					if ((cmd & 0x08) != 0)  						copyOffset |= (delta[deltaPtr++] & 0xff) << 24;    					int copySize = 0;  					if ((cmd & 0x10) != 0)  						copySize = delta[deltaPtr++] & 0xff;  					if ((cmd & 0x20) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 8;  					if ((cmd & 0x40) != 0)  						copySize |= (delta[deltaPtr++] & 0xff) << 16;  					if (copySize == 0)  						copySize = 0x10000;    					Array.Copy(baseData' copyOffset' result' resultPtr' copySize);  					resultPtr += copySize;  				}  				else if (cmd != 0)  				{  					// Anything else the data is literal within the delta  					// itself.  					//  					Array.Copy(delta' deltaPtr' result' resultPtr' cmd);  					deltaPtr += cmd;  					resultPtr += cmd;  				}  				else  				{  					// cmd == 0 has been reserved for future encoding but  					// for now its not acceptable.  					//  					throw new ArgumentException("unsupported command 0");  				}  			}
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following statement contains a magic number: try              {                  switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }              }              catch (IndexOutOfRangeException)              {              }
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: _treeId = ObjectId.FromString(raw' 5);
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: int rawPtr = 46;
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true)  			{  				if (raw[rawPtr] != 'p') break;    				if (np == 0)  				{  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				else if (np == 1)  				{  					ParentIds = new[] { ParentIds[0]' ObjectId.FromString(raw' rawPtr + 7) };  					np++;  				}  				else  				{  					if (ParentIds.Length <= np)  					{  						ObjectId[] old = ParentIds;  						ParentIds = new ObjectId[ParentIds.Length+32];  						for (int i=0; i<np; ++i)  						{  							ParentIds[i] = old[i];  						}  					}  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				rawPtr += 48;  			}
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true)  			{  				if (raw[rawPtr] != 'p') break;    				if (np == 0)  				{  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				else if (np == 1)  				{  					ParentIds = new[] { ParentIds[0]' ObjectId.FromString(raw' rawPtr + 7) };  					np++;  				}  				else  				{  					if (ParentIds.Length <= np)  					{  						ObjectId[] old = ParentIds;  						ParentIds = new ObjectId[ParentIds.Length+32];  						for (int i=0; i<np; ++i)  						{  							ParentIds[i] = old[i];  						}  					}  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				rawPtr += 48;  			}
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true)  			{  				if (raw[rawPtr] != 'p') break;    				if (np == 0)  				{  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				else if (np == 1)  				{  					ParentIds = new[] { ParentIds[0]' ObjectId.FromString(raw' rawPtr + 7) };  					np++;  				}  				else  				{  					if (ParentIds.Length <= np)  					{  						ObjectId[] old = ParentIds;  						ParentIds = new ObjectId[ParentIds.Length+32];  						for (int i=0; i<np; ++i)  						{  							ParentIds[i] = old[i];  						}  					}  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				rawPtr += 48;  			}
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true)  			{  				if (raw[rawPtr] != 'p') break;    				if (np == 0)  				{  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				else if (np == 1)  				{  					ParentIds = new[] { ParentIds[0]' ObjectId.FromString(raw' rawPtr + 7) };  					np++;  				}  				else  				{  					if (ParentIds.Length <= np)  					{  						ObjectId[] old = ParentIds;  						ParentIds = new ObjectId[ParentIds.Length+32];  						for (int i=0; i<np; ++i)  						{  							ParentIds[i] = old[i];  						}  					}  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				rawPtr += 48;  			}
Magic Number,GitSharp.Core,Commit,C:\repos\henon_GitSharp\GitSharp.Core\Commit.cs,Commit,The following statement contains a magic number: while (true)  			{  				if (raw[rawPtr] != 'p') break;    				if (np == 0)  				{  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				else if (np == 1)  				{  					ParentIds = new[] { ParentIds[0]' ObjectId.FromString(raw' rawPtr + 7) };  					np++;  				}  				else  				{  					if (ParentIds.Length <= np)  					{  						ObjectId[] old = ParentIds;  						ParentIds = new ObjectId[ParentIds.Length+32];  						for (int i=0; i<np; ++i)  						{  							ParentIds[i] = old[i];  						}  					}  					ParentIds[np++] = ObjectId.FromString(raw' rawPtr + 7);  				}  				rawPtr += 48;  			}
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,decodeTypeString,The following statement contains a magic number: try              {                  int position = offset.value;                  switch (typeString[position])                  {                      case (byte)'b':                          if (typeString[position + 1] != (byte)'l'                              || typeString[position + 2] != (byte)'o'                              || typeString[position + 3] != (byte)'b'                              || typeString[position + 4] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 5;                          return OBJ_BLOB;                        case (byte)'c':                          if (typeString[position + 1] != (byte)'o'                                  || typeString[position + 2] != (byte)'m'                                  || typeString[position + 3] != (byte)'m'                                  || typeString[position + 4] != (byte)'i'                                  || typeString[position + 5] != (byte)'t'                                  || typeString[position + 6] != endMark)                          {                              throw new CorruptObjectException(id' "invalid type");                          }                          offset.value = position + 7;                          return OBJ_COMMIT;                        case (byte)'t':                          switch (typeString[position + 1])                          {                              case (byte)'a':                                  if (typeString[position + 2] != (byte)'g'                                      || typeString[position + 3] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 4;                                  return OBJ_TAG;                                case (byte)'r':                                  if (typeString[position + 2] != (byte)'e'                                          || typeString[position + 3] != (byte)'e'                                          || typeString[position + 4] != endMark)                                      throw new CorruptObjectException(id' "invalid type");                                  offset.value = position + 5;                                  return OBJ_TREE;                                default:                                  throw new CorruptObjectException(id' "invalid type");                          }                        default:                          throw new CorruptObjectException(id' "invalid type");                  }              }              catch (IndexOutOfRangeException)              {                  throw new CorruptObjectException(id' "invalid type");              }
Magic Number,GitSharp.Core,Constants,C:\repos\henon_GitSharp\GitSharp.Core\Constants.cs,encodeASCII,The following statement contains a magic number: for (int k = r.Length - 1; k >= 0; k--)              {                  char c = s[k];                  if (c > 127)                  {                      throw new ArgumentException("Not ASCII string: " + s);                  }                  r[k] = (byte)c;              }
Magic Number,GitSharp.Core,CoreConfig,C:\repos\henon_GitSharp\GitSharp.Core\CoreConfig.cs,CoreConfig,The following statement contains a magic number: packIndexVersion = rc.getInt("pack"' "indexversion"' 2);
Magic Number,GitSharp.Core,FileMode,C:\repos\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0)  			{  				var tmp = new byte[10];  				int p = tmp.Length;    				while (mode != 0)  				{  					tmp[--p] = (byte)((byte)'0' + (mode & 07));  					mode >>= 3;  				}    				_octalBytes = new byte[tmp.Length - p];  				for (int k = 0; k < _octalBytes.Length; k++)  				{  					_octalBytes[k] = tmp[p + k];  				}  			}  			else  			{  				_octalBytes = new[] { (byte)'0' };  			}
Magic Number,GitSharp.Core,FileMode,C:\repos\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0)  			{  				var tmp = new byte[10];  				int p = tmp.Length;    				while (mode != 0)  				{  					tmp[--p] = (byte)((byte)'0' + (mode & 07));  					mode >>= 3;  				}    				_octalBytes = new byte[tmp.Length - p];  				for (int k = 0; k < _octalBytes.Length; k++)  				{  					_octalBytes[k] = tmp[p + k];  				}  			}  			else  			{  				_octalBytes = new[] { (byte)'0' };  			}
Magic Number,GitSharp.Core,FileMode,C:\repos\henon_GitSharp\GitSharp.Core\FileMode.cs,FileMode,The following statement contains a magic number: if (mode != 0)  			{  				var tmp = new byte[10];  				int p = tmp.Length;    				while (mode != 0)  				{  					tmp[--p] = (byte)((byte)'0' + (mode & 07));  					mode >>= 3;  				}    				_octalBytes = new byte[tmp.Length - p];  				for (int k = 0; k < _octalBytes.Length; k++)  				{  					_octalBytes[k] = tmp[p + k];  				}  			}  			else  			{  				_octalBytes = new[] { (byte)'0' };  			}
Magic Number,GitSharp.Core,FileMode,C:\repos\henon_GitSharp\GitSharp.Core\FileMode.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return (EqualityFunction.GetHashCode() * 397) ^ ObjectType.GetHashCode();  			}
Magic Number,GitSharp.Core,GitIndex,C:\repos\henon_GitSharp\GitSharp.Core\GitIndex.cs,SplitDirPath,The following statement contains a magic number: var tmp = new string[name.Length / 2 + 1];
Magic Number,GitSharp.Core,Header,C:\repos\henon_GitSharp\GitSharp.Core\GitIndex.cs,Header,The following statement contains a magic number: _version = 2;
Magic Number,GitSharp.Core,Header,C:\repos\henon_GitSharp\GitSharp.Core\GitIndex.cs,Read,The following statement contains a magic number: if (_version != 2)  				{  					throw new CorruptObjectException("Unknown index version (or corrupt index):" + _version);  				}
Magic Number,GitSharp.Core,LockFile,C:\repos\henon_GitSharp\GitSharp.Core\LockFile.cs,CopyCurrentContent,The following statement contains a magic number: try              {                  using (FileStream fis = _refFile.OpenRead())                  {                      var buf = new byte[2048];                      int r;                      while ((r = fis.Read(buf' 0' buf.Length)) >= 0)                          _os.Write(buf' 0' r);                  }              }              catch (FileNotFoundException)              {                  // Don't worry about a file that doesn't exist yet' it                  // conceptually has no current content to copy.                  //              }              catch (Exception)              {                  Unlock();                  throw;              }
Magic Number,GitSharp.Core,LockFile,C:\repos\henon_GitSharp\GitSharp.Core\LockFile.cs,waitForStatChange,The following statement contains a magic number: if (_refFile.Length == _lockFile.Length)              {                  long otime = _refFile.lastModified();                  long ntime = _lockFile.lastModified();                  while (otime == ntime)                  {                      Thread.Sleep(25 /* milliseconds */);                      _lockFile.LastWriteTime = DateTime.Now;                      ntime = _lockFile.lastModified();                  }              }
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W2 = NB.DecodeInt32(bs' p + 4);
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W3 = NB.DecodeInt32(bs' p + 8);
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W4 = NB.DecodeInt32(bs' p + 12);
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W5 = NB.DecodeInt32(bs' p + 16);
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W3 = ints[p + 2];
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W4 = ints[p + 3];
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromRaw,The following statement contains a magic number: W5 = ints[p + 4];
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{                  W1 = RawParseUtils.parseHexInt32(bs' p);                  W2 = RawParseUtils.parseHexInt32(bs' p + 8);                  W3 = RawParseUtils.parseHexInt32(bs' p + 16);                  W4 = RawParseUtils.parseHexInt32(bs' p + 24);                  W5 = RawParseUtils.parseHexInt32(bs' p + 32);  			}              catch (IndexOutOfRangeException e)              {                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);              }
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{                  W1 = RawParseUtils.parseHexInt32(bs' p);                  W2 = RawParseUtils.parseHexInt32(bs' p + 8);                  W3 = RawParseUtils.parseHexInt32(bs' p + 16);                  W4 = RawParseUtils.parseHexInt32(bs' p + 24);                  W5 = RawParseUtils.parseHexInt32(bs' p + 32);  			}              catch (IndexOutOfRangeException e)              {                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);              }
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{                  W1 = RawParseUtils.parseHexInt32(bs' p);                  W2 = RawParseUtils.parseHexInt32(bs' p + 8);                  W3 = RawParseUtils.parseHexInt32(bs' p + 16);                  W4 = RawParseUtils.parseHexInt32(bs' p + 24);                  W5 = RawParseUtils.parseHexInt32(bs' p + 32);  			}              catch (IndexOutOfRangeException e)              {                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);              }
Magic Number,GitSharp.Core,MutableObjectId,C:\repos\henon_GitSharp\GitSharp.Core\MutableObjectId.cs,FromHexString,The following statement contains a magic number: try  			{                  W1 = RawParseUtils.parseHexInt32(bs' p);                  W2 = RawParseUtils.parseHexInt32(bs' p + 8);                  W3 = RawParseUtils.parseHexInt32(bs' p + 16);                  W4 = RawParseUtils.parseHexInt32(bs' p + 24);                  W5 = RawParseUtils.parseHexInt32(bs' p + 32);  			}              catch (IndexOutOfRangeException e)              {                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);              }
Magic Number,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,duplicateName,The following statement contains a magic number: for (; ; )              {                  int nextMode = 0;                  for (; ; )                  {                      if (nextPtr >= sz)                          return false;                      byte c = raw[nextPtr++];                      if (' ' == c)                          break;                      nextMode <<= 3;                      nextMode += (c - (byte)'0');                  }                    int nextNamePos = nextPtr;                  for (; ; )                  {                      if (nextPtr == sz)                          return false;                      byte c = raw[nextPtr++];                      if (c == '\0')                          break;                  }                  if (nextNamePos + 1 == nextPtr)                      return false;                    int cmp = pathCompare(raw' thisNamePos' thisNameEnd' FileMode.Tree.Bits' nextNamePos' nextPtr - 1' nextMode);                  if (cmp < 0)                      return false;                  else if (cmp == 0)                      return true;                    nextPtr += Constants.OBJECT_ID_LENGTH;              }
Magic Number,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: while (ptr < sz)              {                  int thisMode = 0;                  for (; ; )                  {                      if (ptr == sz)                          throw new CorruptObjectException("truncated in mode");                      byte c = raw[ptr++];                      if (' ' == c)                          break;                      if (c < '0' || c > '7')                          throw new CorruptObjectException("invalid mode character");                      if (thisMode == 0 && c == '0')                          throw new CorruptObjectException("mode starts with '0'");                      thisMode <<= 3;                      thisMode += (c - (byte)'0');                  }                    if (FileMode.FromBits(thisMode).ObjectType == ObjectType.Bad)                      throw new CorruptObjectException("invalid mode " + NB.DecimalToBase(thisMode' 8));                    int thisNameB = ptr;                  for (; ; )                  {                      if (ptr == sz)                          throw new CorruptObjectException("truncated in name");                      byte c = raw[ptr++];                      if (c == '\0')                          break;                      if (c == '/')                          throw new CorruptObjectException("name contains '/'");                  }                  if (thisNameB + 1 == ptr)                      throw new CorruptObjectException("zero length name");                  if (raw[thisNameB] == '.')                  {                      int nameLen = (ptr - 1) - thisNameB;                      if (nameLen == 1)                          throw new CorruptObjectException("invalid name '.'");                      if (nameLen == 2 && raw[thisNameB + 1] == '.')                          throw new CorruptObjectException("invalid name '..'");                  }                  if (duplicateName(raw' thisNameB' ptr - 1))                      throw new CorruptObjectException("duplicate entry names");                    if (lastNameB != 0)                  {                      int cmp = pathCompare(raw' lastNameB' lastNameE'                             lastMode' thisNameB' ptr - 1' thisMode);                      if (cmp > 0)                          throw new CorruptObjectException("incorrectly sorted");                  }                    lastNameB = thisNameB;                  lastNameE = ptr - 1;                  lastMode = thisMode;                    ptr += Constants.OBJECT_ID_LENGTH;                  if (ptr > sz)                      throw new CorruptObjectException("truncated in object id");              }
Magic Number,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: while (ptr < sz)              {                  int thisMode = 0;                  for (; ; )                  {                      if (ptr == sz)                          throw new CorruptObjectException("truncated in mode");                      byte c = raw[ptr++];                      if (' ' == c)                          break;                      if (c < '0' || c > '7')                          throw new CorruptObjectException("invalid mode character");                      if (thisMode == 0 && c == '0')                          throw new CorruptObjectException("mode starts with '0'");                      thisMode <<= 3;                      thisMode += (c - (byte)'0');                  }                    if (FileMode.FromBits(thisMode).ObjectType == ObjectType.Bad)                      throw new CorruptObjectException("invalid mode " + NB.DecimalToBase(thisMode' 8));                    int thisNameB = ptr;                  for (; ; )                  {                      if (ptr == sz)                          throw new CorruptObjectException("truncated in name");                      byte c = raw[ptr++];                      if (c == '\0')                          break;                      if (c == '/')                          throw new CorruptObjectException("name contains '/'");                  }                  if (thisNameB + 1 == ptr)                      throw new CorruptObjectException("zero length name");                  if (raw[thisNameB] == '.')                  {                      int nameLen = (ptr - 1) - thisNameB;                      if (nameLen == 1)                          throw new CorruptObjectException("invalid name '.'");                      if (nameLen == 2 && raw[thisNameB + 1] == '.')                          throw new CorruptObjectException("invalid name '..'");                  }                  if (duplicateName(raw' thisNameB' ptr - 1))                      throw new CorruptObjectException("duplicate entry names");                    if (lastNameB != 0)                  {                      int cmp = pathCompare(raw' lastNameB' lastNameE'                             lastMode' thisNameB' ptr - 1' thisMode);                      if (cmp > 0)                          throw new CorruptObjectException("incorrectly sorted");                  }                    lastNameB = thisNameB;                  lastNameE = ptr - 1;                  lastMode = thisMode;                    ptr += Constants.OBJECT_ID_LENGTH;                  if (ptr > sz)                      throw new CorruptObjectException("truncated in object id");              }
Magic Number,GitSharp.Core,ObjectChecker,C:\repos\henon_GitSharp\GitSharp.Core\ObjectChecker.cs,checkTree,The following statement contains a magic number: while (ptr < sz)              {                  int thisMode = 0;                  for (; ; )                  {                      if (ptr == sz)                          throw new CorruptObjectException("truncated in mode");                      byte c = raw[ptr++];                      if (' ' == c)                          break;                      if (c < '0' || c > '7')                          throw new CorruptObjectException("invalid mode character");                      if (thisMode == 0 && c == '0')                          throw new CorruptObjectException("mode starts with '0'");                      thisMode <<= 3;                      thisMode += (c - (byte)'0');                  }                    if (FileMode.FromBits(thisMode).ObjectType == ObjectType.Bad)                      throw new CorruptObjectException("invalid mode " + NB.DecimalToBase(thisMode' 8));                    int thisNameB = ptr;                  for (; ; )                  {                      if (ptr == sz)                          throw new CorruptObjectException("truncated in name");                      byte c = raw[ptr++];                      if (c == '\0')                          break;                      if (c == '/')                          throw new CorruptObjectException("name contains '/'");                  }                  if (thisNameB + 1 == ptr)                      throw new CorruptObjectException("zero length name");                  if (raw[thisNameB] == '.')                  {                      int nameLen = (ptr - 1) - thisNameB;                      if (nameLen == 1)                          throw new CorruptObjectException("invalid name '.'");                      if (nameLen == 2 && raw[thisNameB + 1] == '.')                          throw new CorruptObjectException("invalid name '..'");                  }                  if (duplicateName(raw' thisNameB' ptr - 1))                      throw new CorruptObjectException("duplicate entry names");                    if (lastNameB != 0)                  {                      int cmp = pathCompare(raw' lastNameB' lastNameE'                             lastMode' thisNameB' ptr - 1' thisMode);                      if (cmp > 0)                          throw new CorruptObjectException("incorrectly sorted");                  }                    lastNameB = thisNameB;                  lastNameE = ptr - 1;                  lastMode = thisMode;                    ptr += Constants.OBJECT_ID_LENGTH;                  if (ptr > sz)                      throw new CorruptObjectException("truncated in object id");              }
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,Equals,The following statement contains a magic number: return firstBuffer[fi] == secondBuffer[si]  				   && firstBuffer[fi + 1] == secondBuffer[si + 1]  				   && firstBuffer[fi + 2] == secondBuffer[si + 2]  				   && firstBuffer[fi + 3] == secondBuffer[si + 3]  				   && firstBuffer[fi + 4] == secondBuffer[si + 4]  				   && firstBuffer[fi + 5] == secondBuffer[si + 5]  				   && firstBuffer[fi + 6] == secondBuffer[si + 6]  				   && firstBuffer[fi + 7] == secondBuffer[si + 7]  				   && firstBuffer[fi + 8] == secondBuffer[si + 8]  				   && firstBuffer[fi + 9] == secondBuffer[si + 9]  				   && firstBuffer[fi + 10] == secondBuffer[si + 10]  				   && firstBuffer[fi + 11] == secondBuffer[si + 11]  				   && firstBuffer[fi + 12] == secondBuffer[si + 12]  				   && firstBuffer[fi + 13] == secondBuffer[si + 13]  				   && firstBuffer[fi + 14] == secondBuffer[si + 14]  				   && firstBuffer[fi + 15] == secondBuffer[si + 15]  				   && firstBuffer[fi + 16] == secondBuffer[si + 16]  				   && firstBuffer[fi + 17] == secondBuffer[si + 17]  				   && firstBuffer[fi + 18] == secondBuffer[si + 18]  				   && firstBuffer[fi + 19] == secondBuffer[si + 19];
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.parseHexInt32(bs' p);                  int b = RawParseUtils.parseHexInt32(bs' p + 8);                  int c = RawParseUtils.parseHexInt32(bs' p + 16);                  int d = RawParseUtils.parseHexInt32(bs' p + 24);                  int e = RawParseUtils.parseHexInt32(bs' p + 32);  				return new ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  			}
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.parseHexInt32(bs' p);                  int b = RawParseUtils.parseHexInt32(bs' p + 8);                  int c = RawParseUtils.parseHexInt32(bs' p + 16);                  int d = RawParseUtils.parseHexInt32(bs' p + 24);                  int e = RawParseUtils.parseHexInt32(bs' p + 32);  				return new ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  			}
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.parseHexInt32(bs' p);                  int b = RawParseUtils.parseHexInt32(bs' p + 8);                  int c = RawParseUtils.parseHexInt32(bs' p + 16);                  int d = RawParseUtils.parseHexInt32(bs' p + 24);                  int e = RawParseUtils.parseHexInt32(bs' p + 32);  				return new ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  			}
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromHexString,The following statement contains a magic number: try  			{  				int a = RawParseUtils.parseHexInt32(bs' p);                  int b = RawParseUtils.parseHexInt32(bs' p + 8);                  int c = RawParseUtils.parseHexInt32(bs' p + 16);                  int d = RawParseUtils.parseHexInt32(bs' p + 24);                  int e = RawParseUtils.parseHexInt32(bs' p + 32);  				return new ObjectId(a' b' c' d' e);  			}  			catch (IndexOutOfRangeException e)  			{                  throw new InvalidObjectIdException(bs' p' Constants.OBJECT_ID_STRING_LENGTH' e);  			}
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: int b = NB.DecodeInt32(buffer' offset + 4);
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: int c = NB.DecodeInt32(buffer' offset + 8);
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: int d = NB.DecodeInt32(buffer' offset + 12);
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: int e = NB.DecodeInt32(buffer' offset + 16);
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: return new ObjectId(intbuffer[offset]' intbuffer[offset + 1]' intbuffer[offset + 2]' intbuffer[offset + 3]'  								intbuffer[offset + 4]);
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: return new ObjectId(intbuffer[offset]' intbuffer[offset + 1]' intbuffer[offset + 2]' intbuffer[offset + 3]'  								intbuffer[offset + 4]);
Magic Number,GitSharp.Core,ObjectId,C:\repos\henon_GitSharp\GitSharp.Core\ObjectId.cs,FromRaw,The following statement contains a magic number: return new ObjectId(intbuffer[offset]' intbuffer[offset + 1]' intbuffer[offset + 2]' intbuffer[offset + 3]'  								intbuffer[offset + 4]);
Magic Number,GitSharp.Core,OffsetCache<V;R>,C:\repos\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: var eb = (int)(_tableSize * .1);
Magic Number,GitSharp.Core,OffsetCache<V;R>,C:\repos\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else if (eb < 4)  			{  				eb = 4;  			}
Magic Number,GitSharp.Core,OffsetCache<V;R>,C:\repos\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else if (eb < 4)  			{  				eb = 4;  			}
Magic Number,GitSharp.Core,OffsetCache<V;R>,C:\repos\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else if (eb < 4)  			{  				eb = 4;  			}
Magic Number,GitSharp.Core,OffsetCache<V;R>,C:\repos\henon_GitSharp\GitSharp.Core\OffsetCache.cs,OffsetCache,The following statement contains a magic number: if (64 < eb)  			{  				eb = 64;  			}  			else if (eb < 4)  			{  				eb = 4;  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,PackFile,The following statement contains a magic number: _packLastModified = (int)(packFile.lastModified() >> 10);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,PackFile,The following statement contains a magic number: _hash = GetHashCode() * 31;
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: var buf = new byte[20];
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: IO.ReadFully(_fd' 0' buf' 0' 12);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (RawParseUtils.match(buf' 0' Constants.PACK_SIGNATURE) != 4)  			{  				throw new IOException("Not a PACK file.");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: long vers = NB.decodeUInt32(buf' 4);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: long packCnt = NB.decodeUInt32(buf' 8);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException("Unsupported pack version " + vers + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException("Unsupported pack version " + vers + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: IO.ReadFully(_fd' Length - 20' buf' 0' 20);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,OnOpenPack,The following statement contains a magic number: IO.ReadFully(_fd' Length - 20' buf' 0' 20);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: ReadFully(pos' ib' 0' 20' curs);
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: long dataSize = c & 15;
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: int shift = 4;
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: while ((c & 0x80) != 0)  			{  				c = ib[p++] & 0xff;  				dataSize += (c & 0x7f) << shift;  				shift += 7;  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					return new WholePackedObjectLoader(this' pos' objOffset' typeCode' (int)dataSize);    				case Constants.OBJ_OFS_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					p = 0;  					c = ib[p++] & 0xff;  					long ofs = c & 127;    					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & 0xff;  						ofs <<= 7;  						ofs += (c & 127);  					}    					return new DeltaOfsPackedObjectLoader(this' pos + p' objOffset' (int)dataSize' objOffset - ofs);    				case Constants.OBJ_REF_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					return new DeltaRefPackedObjectLoader(this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw(ib));    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					return new WholePackedObjectLoader(this' pos' objOffset' typeCode' (int)dataSize);    				case Constants.OBJ_OFS_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					p = 0;  					c = ib[p++] & 0xff;  					long ofs = c & 127;    					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & 0xff;  						ofs <<= 7;  						ofs += (c & 127);  					}    					return new DeltaOfsPackedObjectLoader(this' pos + p' objOffset' (int)dataSize' objOffset - ofs);    				case Constants.OBJ_REF_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					return new DeltaRefPackedObjectLoader(this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw(ib));    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					return new WholePackedObjectLoader(this' pos' objOffset' typeCode' (int)dataSize);    				case Constants.OBJ_OFS_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					p = 0;  					c = ib[p++] & 0xff;  					long ofs = c & 127;    					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & 0xff;  						ofs <<= 7;  						ofs += (c & 127);  					}    					return new DeltaOfsPackedObjectLoader(this' pos + p' objOffset' (int)dataSize' objOffset - ofs);    				case Constants.OBJ_REF_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					return new DeltaRefPackedObjectLoader(this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw(ib));    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					return new WholePackedObjectLoader(this' pos' objOffset' typeCode' (int)dataSize);    				case Constants.OBJ_OFS_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					p = 0;  					c = ib[p++] & 0xff;  					long ofs = c & 127;    					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & 0xff;  						ofs <<= 7;  						ofs += (c & 127);  					}    					return new DeltaOfsPackedObjectLoader(this' pos + p' objOffset' (int)dataSize' objOffset - ofs);    				case Constants.OBJ_REF_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					return new DeltaRefPackedObjectLoader(this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw(ib));    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					return new WholePackedObjectLoader(this' pos' objOffset' typeCode' (int)dataSize);    				case Constants.OBJ_OFS_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					p = 0;  					c = ib[p++] & 0xff;  					long ofs = c & 127;    					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & 0xff;  						ofs <<= 7;  						ofs += (c & 127);  					}    					return new DeltaOfsPackedObjectLoader(this' pos + p' objOffset' (int)dataSize' objOffset - ofs);    				case Constants.OBJ_REF_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					return new DeltaRefPackedObjectLoader(this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw(ib));    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,Reader,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					return new WholePackedObjectLoader(this' pos' objOffset' typeCode' (int)dataSize);    				case Constants.OBJ_OFS_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					p = 0;  					c = ib[p++] & 0xff;  					long ofs = c & 127;    					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ib[p++] & 0xff;  						ofs <<= 7;  						ofs += (c & 127);  					}    					return new DeltaOfsPackedObjectLoader(this' pos + p' objOffset' (int)dataSize' objOffset - ofs);    				case Constants.OBJ_REF_DELTA:  					ReadFully(pos' ib' 0' 20' curs);  					return new DeltaRefPackedObjectLoader(this' pos + ib.Length' objOffset' (int)dataSize' ObjectId.FromRaw(ib));    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core,PackFile,C:\repos\henon_GitSharp\GitSharp.Core\PackFile.cs,FindEndOffset,The following statement contains a magic number: long maxOffset = Length - 20;
Magic Number,GitSharp.Core,PackIndex,C:\repos\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: try              {                  using (FileStream fs = idxFile.OpenRead())                  {                      byte[] hdr = new byte[8];                      IO.ReadFully(fs' hdr' 0' hdr.Length);                        if (IsTOC(hdr))                      {                          int v = NB.DecodeInt32(hdr' 4);                          switch (v)                          {                              case 2:                                  return new PackIndexV2(fs);                              default:                                  throw new IOException("Unsupported pack index version " + v);                          }                      }                      return new PackIndexV1(fs' hdr);                  }              }              catch (IOException)              {                  throw new IOException("Unable to read pack index: " + idxFile.FullName);              }
Magic Number,GitSharp.Core,PackIndex,C:\repos\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: try              {                  using (FileStream fs = idxFile.OpenRead())                  {                      byte[] hdr = new byte[8];                      IO.ReadFully(fs' hdr' 0' hdr.Length);                        if (IsTOC(hdr))                      {                          int v = NB.DecodeInt32(hdr' 4);                          switch (v)                          {                              case 2:                                  return new PackIndexV2(fs);                              default:                                  throw new IOException("Unsupported pack index version " + v);                          }                      }                      return new PackIndexV1(fs' hdr);                  }              }              catch (IOException)              {                  throw new IOException("Unable to read pack index: " + idxFile.FullName);              }
Magic Number,GitSharp.Core,PackIndex,C:\repos\henon_GitSharp\GitSharp.Core\PackIndex.cs,Open,The following statement contains a magic number: try              {                  using (FileStream fs = idxFile.OpenRead())                  {                      byte[] hdr = new byte[8];                      IO.ReadFully(fs' hdr' 0' hdr.Length);                        if (IsTOC(hdr))                      {                          int v = NB.DecodeInt32(hdr' 4);                          switch (v)                          {                              case 2:                                  return new PackIndexV2(fs);                              default:                                  throw new IOException("Unsupported pack index version " + v);                          }                      }                      return new PackIndexV1(fs' hdr);                  }              }              catch (IOException)              {                  throw new IOException("Unable to read pack index: " + idxFile.FullName);              }
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: _idxHeader = new long[256];
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: for (int k = 0; k < _idxHeader.Length; k++)  				_idxHeader[k] = NB.decodeUInt32(fanoutTable' k * 4);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: for (int k = 0; k < _idxHeader.Length; k++)  			{  				uint n;  				if (k == 0)  					n = (uint)(_idxHeader[k]);  				else  					n = (uint)(_idxHeader[k] - _idxHeader[k - 1]);  				if (n > 0)  				{  					_idxdata[k] = new byte[n * (Constants.OBJECT_ID_LENGTH + 4)];  					IO.ReadFully(fd' _idxdata[k]' 0' _idxdata[k].Length);  				}  			}
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: ObjectCount = _idxHeader[255];
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,PackIndexV1,The following statement contains a magic number: PackChecksum = new byte[20];
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,GetObjectId,The following statement contains a magic number: int dataIdx = ((4 + Constants.OBJECT_ID_LENGTH) * p) + 4;
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,GetObjectId,The following statement contains a magic number: int dataIdx = ((4 + Constants.OBJECT_ID_LENGTH) * p) + 4;
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: int high = data.Length / (4 + Constants.OBJECT_ID_LENGTH);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,PackIndexV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,FindOffset,The following statement contains a magic number: do  			{  				int mid = (low + high) / 2;                  int pos = ((4 + Constants.OBJECT_ID_LENGTH) * mid) + 4;  				int cmp = objId.CompareTo(data' pos);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					uint b0 = data[pos - 4] & (uint)0xff;  					uint b1 = data[pos - 3] & (uint)0xff;  					uint b2 = data[pos - 2] & (uint)0xff;  					uint b3 = data[pos - 1] & (uint)0xff;  					return (((long)b0) << 24) | (b1 << 16) | (b2 << 8) | (b3);  				}  				else  					low = mid + 1;  			} while (low < high);
Magic Number,GitSharp.Core,IndexV1Enumerator,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV1.cs,InnerNext,The following statement contains a magic number: for (; _levelOne < _index._idxdata.Length; _levelOne++)                  {                      if (_index._idxdata[_levelOne] == null)                      {                          continue;                      }                        if (_levelTwo < _index._idxdata[_levelOne].Length)                      {                          entry.Offset = NB.DecodeUInt32(_index._idxdata[_levelOne]' _levelTwo);                          _levelTwo += Constants.OBJECT_ID_LENGTH + 4;                          ReturnedNumber++;                          return entry;                      }                        _levelTwo = 0;                  }
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: var fanoutRaw = new byte[4 * FANOUT];
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				_fanoutTable[k] = NB.DecodeUInt32(fanoutRaw' k * 4);  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				long bucketCnt;  				if (k == 0)  				{  					bucketCnt = _fanoutTable[k];  				}  				else  				{  					bucketCnt = _fanoutTable[k] - _fanoutTable[k - 1];  				}    				if (bucketCnt == 0)  				{  					_names[k] = NoInts;  					_offset32[k] = NoBytes;  					_crc32[k] = NoBytes;  					continue;  				}                    long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException("Index file is too large");  				}    				var intNameLen = (int)nameLen;  				var raw = new byte[intNameLen];  				var bin = new int[intNameLen >> 2];  				IO.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}    				_names[k] = bin;  				_offset32[k] = new byte[(int)(bucketCnt * 4)];  				_crc32[k] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				long bucketCnt;  				if (k == 0)  				{  					bucketCnt = _fanoutTable[k];  				}  				else  				{  					bucketCnt = _fanoutTable[k] - _fanoutTable[k - 1];  				}    				if (bucketCnt == 0)  				{  					_names[k] = NoInts;  					_offset32[k] = NoBytes;  					_crc32[k] = NoBytes;  					continue;  				}                    long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException("Index file is too large");  				}    				var intNameLen = (int)nameLen;  				var raw = new byte[intNameLen];  				var bin = new int[intNameLen >> 2];  				IO.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}    				_names[k] = bin;  				_offset32[k] = new byte[(int)(bucketCnt * 4)];  				_crc32[k] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				long bucketCnt;  				if (k == 0)  				{  					bucketCnt = _fanoutTable[k];  				}  				else  				{  					bucketCnt = _fanoutTable[k] - _fanoutTable[k - 1];  				}    				if (bucketCnt == 0)  				{  					_names[k] = NoInts;  					_offset32[k] = NoBytes;  					_crc32[k] = NoBytes;  					continue;  				}                    long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException("Index file is too large");  				}    				var intNameLen = (int)nameLen;  				var raw = new byte[intNameLen];  				var bin = new int[intNameLen >> 2];  				IO.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}    				_names[k] = bin;  				_offset32[k] = new byte[(int)(bucketCnt * 4)];  				_crc32[k] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				long bucketCnt;  				if (k == 0)  				{  					bucketCnt = _fanoutTable[k];  				}  				else  				{  					bucketCnt = _fanoutTable[k] - _fanoutTable[k - 1];  				}    				if (bucketCnt == 0)  				{  					_names[k] = NoInts;  					_offset32[k] = NoBytes;  					_crc32[k] = NoBytes;  					continue;  				}                    long nameLen = bucketCnt * Constants.OBJECT_ID_LENGTH;  				if (nameLen > int.MaxValue)  				{  					throw new IOException("Index file is too large");  				}    				var intNameLen = (int)nameLen;  				var raw = new byte[intNameLen];  				var bin = new int[intNameLen >> 2];  				IO.ReadFully(fd' raw' 0' raw.Length);  				for (int i = 0; i < bin.Length; i++)  				{  					bin[i] = NB.DecodeInt32(raw' i << 2);  				}    				_names[k] = bin;  				_offset32[k] = new byte[(int)(bucketCnt * 4)];  				_crc32[k] = new byte[(int)(bucketCnt * 4)];  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: for (int k = 0; k < FANOUT; k++)  			{  				byte[] ofs = _offset32[k];  				IO.ReadFully(fd' ofs' 0' ofs.Length);  				for (int p = 0; p < ofs.Length; p += 4)  				{                      if (NB.ConvertUnsignedByteToSigned(ofs[p]) < 0)  					{  						o64cnt++;  					}  				}  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: if (o64cnt > 0)  			{  				_offset64 = new byte[o64cnt * 8];  				IO.ReadFully(fd' _offset64' 0' _offset64.Length);  			}  			else  			{  				_offset64 = NoBytes;  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,PackIndexV2,The following statement contains a magic number: PackChecksum = new byte[20];
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,GetObjectId,The following statement contains a magic number: int p4 = p << 2;
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,FindOffset,The following statement contains a magic number: long p = NB.DecodeUInt32(_offset32[levelOne]' levelTwo << 2);
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,FindOffset,The following statement contains a magic number: if ((p & IS_O64) != 0)  			{  				return NB.DecodeUInt64(_offset64' (8 * (int)(p & ~IS_O64)));  			}
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,FindCRC32,The following statement contains a magic number: return NB.DecodeUInt32(_crc32[levelOne]' levelTwo << 2);
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,BinarySearchLevelTwo,The following statement contains a magic number: var high = (int)((uint)(_offset32[levelOne].Length) >> 2);
Magic Number,GitSharp.Core,PackIndexV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,BinarySearchLevelTwo,The following statement contains a magic number: do  			{  				var mid = (int)((uint)(low + high) >> 1);  				int mid4 = mid << 2;    				int cmp = objId.CompareTo(data' mid4 + mid);  				if (cmp < 0)  				{  					high = mid;  				}  				else if (cmp == 0)  				{  					return mid;  				}  				else  				{  					low = mid + 1;  				}    			} while (low < high);
Magic Number,GitSharp.Core,EntriesEnumeratorV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,IdBufferBuilder,The following statement contains a magic number: idBuffer.FromRaw(_index._names[_levelOne]' _levelTwo - Constants.OBJECT_ID_LENGTH / 4);
Magic Number,GitSharp.Core,EntriesEnumeratorV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,InnerNext,The following statement contains a magic number: for (; _levelOne < _index._names.Length; _levelOne++)                  {                      if (_levelTwo < _index._names[_levelOne].Length)                      {                          int idx = _levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;                          long offset = NB.DecodeUInt32(_index._offset32[_levelOne]' idx);                          if ((offset & IS_O64) != 0)                          {                              idx = (8 * (int)(offset & ~IS_O64));                              offset = NB.DecodeUInt64(_index._offset64' idx);                          }                          entry.Offset = offset;                            _levelTwo += Constants.OBJECT_ID_LENGTH / 4;                          ReturnedNumber++;                          return entry;                      }                      _levelTwo = 0;                  }
Magic Number,GitSharp.Core,EntriesEnumeratorV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,InnerNext,The following statement contains a magic number: for (; _levelOne < _index._names.Length; _levelOne++)                  {                      if (_levelTwo < _index._names[_levelOne].Length)                      {                          int idx = _levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;                          long offset = NB.DecodeUInt32(_index._offset32[_levelOne]' idx);                          if ((offset & IS_O64) != 0)                          {                              idx = (8 * (int)(offset & ~IS_O64));                              offset = NB.DecodeUInt64(_index._offset64' idx);                          }                          entry.Offset = offset;                            _levelTwo += Constants.OBJECT_ID_LENGTH / 4;                          ReturnedNumber++;                          return entry;                      }                      _levelTwo = 0;                  }
Magic Number,GitSharp.Core,EntriesEnumeratorV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,InnerNext,The following statement contains a magic number: for (; _levelOne < _index._names.Length; _levelOne++)                  {                      if (_levelTwo < _index._names[_levelOne].Length)                      {                          int idx = _levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;                          long offset = NB.DecodeUInt32(_index._offset32[_levelOne]' idx);                          if ((offset & IS_O64) != 0)                          {                              idx = (8 * (int)(offset & ~IS_O64));                              offset = NB.DecodeUInt64(_index._offset64' idx);                          }                          entry.Offset = offset;                            _levelTwo += Constants.OBJECT_ID_LENGTH / 4;                          ReturnedNumber++;                          return entry;                      }                      _levelTwo = 0;                  }
Magic Number,GitSharp.Core,EntriesEnumeratorV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexV2.cs,InnerNext,The following statement contains a magic number: for (; _levelOne < _index._names.Length; _levelOne++)                  {                      if (_levelTwo < _index._names[_levelOne].Length)                      {                          int idx = _levelTwo / (Constants.OBJECT_ID_LENGTH / 4) * 4;                          long offset = NB.DecodeUInt32(_index._offset32[_levelOne]' idx);                          if ((offset & IS_O64) != 0)                          {                              idx = (8 * (int)(offset & ~IS_O64));                              offset = NB.DecodeUInt64(_index._offset64' idx);                          }                          entry.Offset = offset;                            _levelTwo += Constants.OBJECT_ID_LENGTH / 4;                          ReturnedNumber++;                          return entry;                      }                      _levelTwo = 0;                  }
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (T oe in objs)              {                  switch (version)                  {                      case 1:                          if (PackIndexWriterV1.CanStore(oe)) continue;                          version = 2;                  		break;                        case 2:                  		breakLoop = true;                  		break;  				}    				if (breakLoop)  				{  					break;  				}              }
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following statement contains a magic number: foreach (T oe in objs)              {                  switch (version)                  {                      case 1:                          if (PackIndexWriterV1.CanStore(oe)) continue;                          version = 2;                  		break;                        case 2:                  		breakLoop = true;                  		break;  				}    				if (breakLoop)  				{  					break;  				}              }
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateVersion,The following statement contains a magic number: switch (version)              {                  case 1:                      return new PackIndexWriterV1(dst);                  case 2:                      return new PackIndexWriterV2(dst);                  default:                      throw new ArgumentException("Unsupported pack index version " + version);              }
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteTOC,The following statement contains a magic number: _stream.Write(tmp' 0 ' 4);
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: int[] fanout = new int[256];
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: for (int i = 1; i < 256; i++)  			    fanout[i] += fanout[i - 1];
Magic Number,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,WriteFanOutTable,The following statement contains a magic number: foreach (int n in fanout)              {                  NB.encodeInt32(tmp' 0' n);                  _stream.Write(tmp' 0' 4);              }
Magic Number,GitSharp.Core,PackIndexWriterV1,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriterV1.cs,WriteInternal,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)              {                  if (!CanStore(oe))                  {                  	throw new IOException("Pack too large for index version 1");                  }                    NB.encodeInt32(tmp' 0' (int)oe.Offset);                  oe.copyRawTo(tmp' 4);                  _stream.Write(tmp' 0' tmp.Length);              }
Magic Number,GitSharp.Core,PackIndexWriterV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteInternal,The following statement contains a magic number: WriteTOC(2);
Magic Number,GitSharp.Core,PackIndexWriterV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteCRCs,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)              {                  NB.encodeInt32(tmp' 0' oe.CRC);              	_stream.BaseStream.Write(tmp' 0' 4);              }
Magic Number,GitSharp.Core,PackIndexWriterV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)              {                  long o = oe.Offset;                  if (o < int.MaxValue)                  {                      NB.encodeInt32(tmp' 0' (int)o);                  }                  else                  {                      NB.encodeInt32(tmp' 0' (1 << 31) | o64++);                  }                  _stream.BaseStream.Write(tmp' 0' 4);              }
Magic Number,GitSharp.Core,PackIndexWriterV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset32,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)              {                  long o = oe.Offset;                  if (o < int.MaxValue)                  {                      NB.encodeInt32(tmp' 0' (int)o);                  }                  else                  {                      NB.encodeInt32(tmp' 0' (1 << 31) | o64++);                  }                  _stream.BaseStream.Write(tmp' 0' 4);              }
Magic Number,GitSharp.Core,PackIndexWriterV2,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriterV2.cs,WriteOffset64,The following statement contains a magic number: foreach (PackedObjectInfo oe in entries)              {                  long o = oe.Offset;                  if (o > int.MaxValue)                  {                      NB.encodeInt64(tmp' 0' o);                  	_stream.BaseStream.Write(tmp' 0' 8);                  }              }
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: int sp = str.IndexOf(' '' gt + 2);
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1)              {                  When = 0;                  tzOffset = -1;              }              else              {                  string tzHoursStr = str.Slice(sp + 1' sp + 4).Trim();                  int tzHours = tzHoursStr[0] == '+' ? int.Parse(tzHoursStr.Substring(1)) : int.Parse(tzHoursStr);                    int tzMins = int.Parse(str.Substring(sp + 4).Trim());                  When = long.Parse(str.Slice(gt + 1' sp).Trim()) * 1000;                  tzOffset = tzHours * 60 + tzMins;              }
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1)              {                  When = 0;                  tzOffset = -1;              }              else              {                  string tzHoursStr = str.Slice(sp + 1' sp + 4).Trim();                  int tzHours = tzHoursStr[0] == '+' ? int.Parse(tzHoursStr.Substring(1)) : int.Parse(tzHoursStr);                    int tzMins = int.Parse(str.Substring(sp + 4).Trim());                  When = long.Parse(str.Slice(gt + 1' sp).Trim()) * 1000;                  tzOffset = tzHours * 60 + tzMins;              }
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1)              {                  When = 0;                  tzOffset = -1;              }              else              {                  string tzHoursStr = str.Slice(sp + 1' sp + 4).Trim();                  int tzHours = tzHoursStr[0] == '+' ? int.Parse(tzHoursStr.Substring(1)) : int.Parse(tzHoursStr);                    int tzMins = int.Parse(str.Substring(sp + 4).Trim());                  When = long.Parse(str.Slice(gt + 1' sp).Trim()) * 1000;                  tzOffset = tzHours * 60 + tzMins;              }
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,PersonIdent,The following statement contains a magic number: if (sp == -1)              {                  When = 0;                  tzOffset = -1;              }              else              {                  string tzHoursStr = str.Slice(sp + 1' sp + 4).Trim();                  int tzHours = tzHoursStr[0] == '+' ? int.Parse(tzHoursStr.Substring(1)) : int.Parse(tzHoursStr);                    int tzMins = int.Parse(str.Substring(sp + 4).Trim());                  When = long.Parse(str.Slice(gt + 1' sp).Trim()) * 1000;                  tzOffset = tzHours * 60 + tzMins;              }
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,ToExternalString,The following statement contains a magic number: r.Append(When / 1000);
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,appendTimezone,The following statement contains a magic number: int offsetHours = offset / 60;
Magic Number,GitSharp.Core,PersonIdent,C:\repos\henon_GitSharp\GitSharp.Core\PersonIdent.cs,appendTimezone,The following statement contains a magic number: int offsetMins = offset % 60;
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,MapTree,The following statement contains a magic number: switch (((ObjectType)or.Type))              {                  case ObjectType.Tree:                      return new Tree(this' id' raw);                    case ObjectType.Commit:                      return MapTree(ObjectId.FromString(raw' 5));              }
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i)              {                  switch (revision[i])                  {                      case '^':                          if (refId == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                          }                            if (i + 1 < revision.Length)                          {                              switch (revision[i + 1])                              {                                  case '0':                                  case '1':                                  case '2':                                  case '3':                                  case '4':                                  case '5':                                  case '6':                                  case '7':                                  case '8':                                  case '9':                                        int j;                                      oref = MapObject(refId' null);                                        while (oref is Tag)                                      {                                          var tag = (Tag)oref;                                          refId = tag.Id;                                          oref = MapObject(refId' null);                                      }                                        Commit oCom = (oref as Commit);                                      if (oCom == null)                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                        for (j = i + 1; j < revision.Length; ++j)                                      {                                          if (!Char.IsDigit(revision[j])) break;                                      }                                        var parentnum = new string(revision.ToCharArray(i + 1' j - i - 1));                                        int pnum;                                        try                                      {                                          pnum = Convert.ToInt32(parentnum);                                      }                                      catch (FormatException)                                      {                                          throw new RevisionSyntaxException(revision' "Invalid commit parent number");                                      }                                      if (pnum != 0)                                      {                                          ObjectId[] parents = oCom.ParentIds;                                          if (pnum > parents.Length)                                              refId = null;                                          else                                              refId = parents[pnum - 1];                                      }                                        i = j - 1;                                      break;                                    case '{':                                      int k;                                      string item = null;                                      for (k = i + 2; k < revision.Length; ++k)                                      {                                          if (revision[k] != '}') continue;                                          item = new string(revision.ToCharArray(i + 2' k - i - 2));                                          break;                                      }                                        i = k;                                      if (item != null)                                      {                                          if (item.Equals("tree"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              Treeish oTree = (oref as Treeish);                                              if (oTree != null)                                              {                                                  refId = oTree.TreeId;                                              }                                              else                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Tree);                                              }                                          }                                          else if (item.Equals("commit"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is Commit))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (item.Equals("blob"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is byte[]))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (string.Empty.Equals(item))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                          }                                          else                                          {                                              throw new RevisionSyntaxException(revision);                                          }                                      }                                      else                                      {                                          throw new RevisionSyntaxException(revision);                                      }                                      break;                                    default:                                      oref = MapObject(refId' null);                                      Commit oComm = (oref as Commit);                                      if (oComm != null)                                      {                                          ObjectId[] parents = oComm.ParentIds;                                          refId = parents.Length == 0 ? null : parents[0];                                      }                                      else                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                      break;                              }                          }                          else                          {                              oref = MapObject(refId' null);                              while (oref is Tag)                              {                                  var tag = (Tag)oref;                                  refId = tag.Id;                                  oref = MapObject(refId' null);                              }                                Commit oCom = (oref as Commit);                              if (oCom != null)                              {                                  ObjectId[] parents = oCom.ParentIds;                                  refId = parents.Length == 0 ? null : parents[0];                              }                              else                              {                                  throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                              }                          }                          break;                        case '~':                          if (oref == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                              oref = MapObject(refId' null);                          }                            while (oref is Tag)                          {                              var tag = (Tag)oref;                              refId = tag.Id;                              oref = MapObject(refId' null);                          }                            if (!(oref is Commit))                          {                              throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                          }                            int l;                          for (l = i + 1; l < revision.Length; ++l)                          {                              if (!Char.IsDigit(revision[l]))                                  break;                          }                            var distnum = new string(revision.ToCharArray(i + 1' l - i - 1));                          int dist;                            try                          {                              dist = Convert.ToInt32(distnum);                          }                          catch (FormatException)                          {                              throw new RevisionSyntaxException("Invalid ancestry length"' revision);                          }                          while (dist > 0)                          {                                ObjectId[] parents = ((Commit)oref).ParentIds;                              if (parents.Length == 0)                              {                                  refId = null;                                  break;                              }                              refId = parents[0];                              oref = MapCommit(refId);                              --dist;                          }                          i = l - 1;                          break;                        case '@':                          int m;                          string time = null;                          for (m = i + 2; m < revision.Length; ++m)                          {                              if (revision[m] != '}') continue;                              time = new string(revision.ToCharArray(i + 2' m - i - 2));                              break;                          }                            if (time != null)                          {                              throw new RevisionSyntaxException("reflogs not yet supported by revision parser yet"' revision);                          }                          i = m - 1;                          break;                        default:                          if (refId != null)                          {                              throw new RevisionSyntaxException(revision);                          }                          break;                  }              }
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i)              {                  switch (revision[i])                  {                      case '^':                          if (refId == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                          }                            if (i + 1 < revision.Length)                          {                              switch (revision[i + 1])                              {                                  case '0':                                  case '1':                                  case '2':                                  case '3':                                  case '4':                                  case '5':                                  case '6':                                  case '7':                                  case '8':                                  case '9':                                        int j;                                      oref = MapObject(refId' null);                                        while (oref is Tag)                                      {                                          var tag = (Tag)oref;                                          refId = tag.Id;                                          oref = MapObject(refId' null);                                      }                                        Commit oCom = (oref as Commit);                                      if (oCom == null)                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                        for (j = i + 1; j < revision.Length; ++j)                                      {                                          if (!Char.IsDigit(revision[j])) break;                                      }                                        var parentnum = new string(revision.ToCharArray(i + 1' j - i - 1));                                        int pnum;                                        try                                      {                                          pnum = Convert.ToInt32(parentnum);                                      }                                      catch (FormatException)                                      {                                          throw new RevisionSyntaxException(revision' "Invalid commit parent number");                                      }                                      if (pnum != 0)                                      {                                          ObjectId[] parents = oCom.ParentIds;                                          if (pnum > parents.Length)                                              refId = null;                                          else                                              refId = parents[pnum - 1];                                      }                                        i = j - 1;                                      break;                                    case '{':                                      int k;                                      string item = null;                                      for (k = i + 2; k < revision.Length; ++k)                                      {                                          if (revision[k] != '}') continue;                                          item = new string(revision.ToCharArray(i + 2' k - i - 2));                                          break;                                      }                                        i = k;                                      if (item != null)                                      {                                          if (item.Equals("tree"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              Treeish oTree = (oref as Treeish);                                              if (oTree != null)                                              {                                                  refId = oTree.TreeId;                                              }                                              else                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Tree);                                              }                                          }                                          else if (item.Equals("commit"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is Commit))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (item.Equals("blob"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is byte[]))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (string.Empty.Equals(item))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                          }                                          else                                          {                                              throw new RevisionSyntaxException(revision);                                          }                                      }                                      else                                      {                                          throw new RevisionSyntaxException(revision);                                      }                                      break;                                    default:                                      oref = MapObject(refId' null);                                      Commit oComm = (oref as Commit);                                      if (oComm != null)                                      {                                          ObjectId[] parents = oComm.ParentIds;                                          refId = parents.Length == 0 ? null : parents[0];                                      }                                      else                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                      break;                              }                          }                          else                          {                              oref = MapObject(refId' null);                              while (oref is Tag)                              {                                  var tag = (Tag)oref;                                  refId = tag.Id;                                  oref = MapObject(refId' null);                              }                                Commit oCom = (oref as Commit);                              if (oCom != null)                              {                                  ObjectId[] parents = oCom.ParentIds;                                  refId = parents.Length == 0 ? null : parents[0];                              }                              else                              {                                  throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                              }                          }                          break;                        case '~':                          if (oref == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                              oref = MapObject(refId' null);                          }                            while (oref is Tag)                          {                              var tag = (Tag)oref;                              refId = tag.Id;                              oref = MapObject(refId' null);                          }                            if (!(oref is Commit))                          {                              throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                          }                            int l;                          for (l = i + 1; l < revision.Length; ++l)                          {                              if (!Char.IsDigit(revision[l]))                                  break;                          }                            var distnum = new string(revision.ToCharArray(i + 1' l - i - 1));                          int dist;                            try                          {                              dist = Convert.ToInt32(distnum);                          }                          catch (FormatException)                          {                              throw new RevisionSyntaxException("Invalid ancestry length"' revision);                          }                          while (dist > 0)                          {                                ObjectId[] parents = ((Commit)oref).ParentIds;                              if (parents.Length == 0)                              {                                  refId = null;                                  break;                              }                              refId = parents[0];                              oref = MapCommit(refId);                              --dist;                          }                          i = l - 1;                          break;                        case '@':                          int m;                          string time = null;                          for (m = i + 2; m < revision.Length; ++m)                          {                              if (revision[m] != '}') continue;                              time = new string(revision.ToCharArray(i + 2' m - i - 2));                              break;                          }                            if (time != null)                          {                              throw new RevisionSyntaxException("reflogs not yet supported by revision parser yet"' revision);                          }                          i = m - 1;                          break;                        default:                          if (refId != null)                          {                              throw new RevisionSyntaxException(revision);                          }                          break;                  }              }
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i)              {                  switch (revision[i])                  {                      case '^':                          if (refId == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                          }                            if (i + 1 < revision.Length)                          {                              switch (revision[i + 1])                              {                                  case '0':                                  case '1':                                  case '2':                                  case '3':                                  case '4':                                  case '5':                                  case '6':                                  case '7':                                  case '8':                                  case '9':                                        int j;                                      oref = MapObject(refId' null);                                        while (oref is Tag)                                      {                                          var tag = (Tag)oref;                                          refId = tag.Id;                                          oref = MapObject(refId' null);                                      }                                        Commit oCom = (oref as Commit);                                      if (oCom == null)                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                        for (j = i + 1; j < revision.Length; ++j)                                      {                                          if (!Char.IsDigit(revision[j])) break;                                      }                                        var parentnum = new string(revision.ToCharArray(i + 1' j - i - 1));                                        int pnum;                                        try                                      {                                          pnum = Convert.ToInt32(parentnum);                                      }                                      catch (FormatException)                                      {                                          throw new RevisionSyntaxException(revision' "Invalid commit parent number");                                      }                                      if (pnum != 0)                                      {                                          ObjectId[] parents = oCom.ParentIds;                                          if (pnum > parents.Length)                                              refId = null;                                          else                                              refId = parents[pnum - 1];                                      }                                        i = j - 1;                                      break;                                    case '{':                                      int k;                                      string item = null;                                      for (k = i + 2; k < revision.Length; ++k)                                      {                                          if (revision[k] != '}') continue;                                          item = new string(revision.ToCharArray(i + 2' k - i - 2));                                          break;                                      }                                        i = k;                                      if (item != null)                                      {                                          if (item.Equals("tree"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              Treeish oTree = (oref as Treeish);                                              if (oTree != null)                                              {                                                  refId = oTree.TreeId;                                              }                                              else                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Tree);                                              }                                          }                                          else if (item.Equals("commit"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is Commit))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (item.Equals("blob"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is byte[]))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (string.Empty.Equals(item))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                          }                                          else                                          {                                              throw new RevisionSyntaxException(revision);                                          }                                      }                                      else                                      {                                          throw new RevisionSyntaxException(revision);                                      }                                      break;                                    default:                                      oref = MapObject(refId' null);                                      Commit oComm = (oref as Commit);                                      if (oComm != null)                                      {                                          ObjectId[] parents = oComm.ParentIds;                                          refId = parents.Length == 0 ? null : parents[0];                                      }                                      else                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                      break;                              }                          }                          else                          {                              oref = MapObject(refId' null);                              while (oref is Tag)                              {                                  var tag = (Tag)oref;                                  refId = tag.Id;                                  oref = MapObject(refId' null);                              }                                Commit oCom = (oref as Commit);                              if (oCom != null)                              {                                  ObjectId[] parents = oCom.ParentIds;                                  refId = parents.Length == 0 ? null : parents[0];                              }                              else                              {                                  throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                              }                          }                          break;                        case '~':                          if (oref == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                              oref = MapObject(refId' null);                          }                            while (oref is Tag)                          {                              var tag = (Tag)oref;                              refId = tag.Id;                              oref = MapObject(refId' null);                          }                            if (!(oref is Commit))                          {                              throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                          }                            int l;                          for (l = i + 1; l < revision.Length; ++l)                          {                              if (!Char.IsDigit(revision[l]))                                  break;                          }                            var distnum = new string(revision.ToCharArray(i + 1' l - i - 1));                          int dist;                            try                          {                              dist = Convert.ToInt32(distnum);                          }                          catch (FormatException)                          {                              throw new RevisionSyntaxException("Invalid ancestry length"' revision);                          }                          while (dist > 0)                          {                                ObjectId[] parents = ((Commit)oref).ParentIds;                              if (parents.Length == 0)                              {                                  refId = null;                                  break;                              }                              refId = parents[0];                              oref = MapCommit(refId);                              --dist;                          }                          i = l - 1;                          break;                        case '@':                          int m;                          string time = null;                          for (m = i + 2; m < revision.Length; ++m)                          {                              if (revision[m] != '}') continue;                              time = new string(revision.ToCharArray(i + 2' m - i - 2));                              break;                          }                            if (time != null)                          {                              throw new RevisionSyntaxException("reflogs not yet supported by revision parser yet"' revision);                          }                          i = m - 1;                          break;                        default:                          if (refId != null)                          {                              throw new RevisionSyntaxException(revision);                          }                          break;                  }              }
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i)              {                  switch (revision[i])                  {                      case '^':                          if (refId == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                          }                            if (i + 1 < revision.Length)                          {                              switch (revision[i + 1])                              {                                  case '0':                                  case '1':                                  case '2':                                  case '3':                                  case '4':                                  case '5':                                  case '6':                                  case '7':                                  case '8':                                  case '9':                                        int j;                                      oref = MapObject(refId' null);                                        while (oref is Tag)                                      {                                          var tag = (Tag)oref;                                          refId = tag.Id;                                          oref = MapObject(refId' null);                                      }                                        Commit oCom = (oref as Commit);                                      if (oCom == null)                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                        for (j = i + 1; j < revision.Length; ++j)                                      {                                          if (!Char.IsDigit(revision[j])) break;                                      }                                        var parentnum = new string(revision.ToCharArray(i + 1' j - i - 1));                                        int pnum;                                        try                                      {                                          pnum = Convert.ToInt32(parentnum);                                      }                                      catch (FormatException)                                      {                                          throw new RevisionSyntaxException(revision' "Invalid commit parent number");                                      }                                      if (pnum != 0)                                      {                                          ObjectId[] parents = oCom.ParentIds;                                          if (pnum > parents.Length)                                              refId = null;                                          else                                              refId = parents[pnum - 1];                                      }                                        i = j - 1;                                      break;                                    case '{':                                      int k;                                      string item = null;                                      for (k = i + 2; k < revision.Length; ++k)                                      {                                          if (revision[k] != '}') continue;                                          item = new string(revision.ToCharArray(i + 2' k - i - 2));                                          break;                                      }                                        i = k;                                      if (item != null)                                      {                                          if (item.Equals("tree"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              Treeish oTree = (oref as Treeish);                                              if (oTree != null)                                              {                                                  refId = oTree.TreeId;                                              }                                              else                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Tree);                                              }                                          }                                          else if (item.Equals("commit"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is Commit))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (item.Equals("blob"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is byte[]))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (string.Empty.Equals(item))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                          }                                          else                                          {                                              throw new RevisionSyntaxException(revision);                                          }                                      }                                      else                                      {                                          throw new RevisionSyntaxException(revision);                                      }                                      break;                                    default:                                      oref = MapObject(refId' null);                                      Commit oComm = (oref as Commit);                                      if (oComm != null)                                      {                                          ObjectId[] parents = oComm.ParentIds;                                          refId = parents.Length == 0 ? null : parents[0];                                      }                                      else                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                      break;                              }                          }                          else                          {                              oref = MapObject(refId' null);                              while (oref is Tag)                              {                                  var tag = (Tag)oref;                                  refId = tag.Id;                                  oref = MapObject(refId' null);                              }                                Commit oCom = (oref as Commit);                              if (oCom != null)                              {                                  ObjectId[] parents = oCom.ParentIds;                                  refId = parents.Length == 0 ? null : parents[0];                              }                              else                              {                                  throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                              }                          }                          break;                        case '~':                          if (oref == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                              oref = MapObject(refId' null);                          }                            while (oref is Tag)                          {                              var tag = (Tag)oref;                              refId = tag.Id;                              oref = MapObject(refId' null);                          }                            if (!(oref is Commit))                          {                              throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                          }                            int l;                          for (l = i + 1; l < revision.Length; ++l)                          {                              if (!Char.IsDigit(revision[l]))                                  break;                          }                            var distnum = new string(revision.ToCharArray(i + 1' l - i - 1));                          int dist;                            try                          {                              dist = Convert.ToInt32(distnum);                          }                          catch (FormatException)                          {                              throw new RevisionSyntaxException("Invalid ancestry length"' revision);                          }                          while (dist > 0)                          {                                ObjectId[] parents = ((Commit)oref).ParentIds;                              if (parents.Length == 0)                              {                                  refId = null;                                  break;                              }                              refId = parents[0];                              oref = MapCommit(refId);                              --dist;                          }                          i = l - 1;                          break;                        case '@':                          int m;                          string time = null;                          for (m = i + 2; m < revision.Length; ++m)                          {                              if (revision[m] != '}') continue;                              time = new string(revision.ToCharArray(i + 2' m - i - 2));                              break;                          }                            if (time != null)                          {                              throw new RevisionSyntaxException("reflogs not yet supported by revision parser yet"' revision);                          }                          i = m - 1;                          break;                        default:                          if (refId != null)                          {                              throw new RevisionSyntaxException(revision);                          }                          break;                  }              }
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i)              {                  switch (revision[i])                  {                      case '^':                          if (refId == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                          }                            if (i + 1 < revision.Length)                          {                              switch (revision[i + 1])                              {                                  case '0':                                  case '1':                                  case '2':                                  case '3':                                  case '4':                                  case '5':                                  case '6':                                  case '7':                                  case '8':                                  case '9':                                        int j;                                      oref = MapObject(refId' null);                                        while (oref is Tag)                                      {                                          var tag = (Tag)oref;                                          refId = tag.Id;                                          oref = MapObject(refId' null);                                      }                                        Commit oCom = (oref as Commit);                                      if (oCom == null)                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                        for (j = i + 1; j < revision.Length; ++j)                                      {                                          if (!Char.IsDigit(revision[j])) break;                                      }                                        var parentnum = new string(revision.ToCharArray(i + 1' j - i - 1));                                        int pnum;                                        try                                      {                                          pnum = Convert.ToInt32(parentnum);                                      }                                      catch (FormatException)                                      {                                          throw new RevisionSyntaxException(revision' "Invalid commit parent number");                                      }                                      if (pnum != 0)                                      {                                          ObjectId[] parents = oCom.ParentIds;                                          if (pnum > parents.Length)                                              refId = null;                                          else                                              refId = parents[pnum - 1];                                      }                                        i = j - 1;                                      break;                                    case '{':                                      int k;                                      string item = null;                                      for (k = i + 2; k < revision.Length; ++k)                                      {                                          if (revision[k] != '}') continue;                                          item = new string(revision.ToCharArray(i + 2' k - i - 2));                                          break;                                      }                                        i = k;                                      if (item != null)                                      {                                          if (item.Equals("tree"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              Treeish oTree = (oref as Treeish);                                              if (oTree != null)                                              {                                                  refId = oTree.TreeId;                                              }                                              else                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Tree);                                              }                                          }                                          else if (item.Equals("commit"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is Commit))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (item.Equals("blob"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is byte[]))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (string.Empty.Equals(item))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                          }                                          else                                          {                                              throw new RevisionSyntaxException(revision);                                          }                                      }                                      else                                      {                                          throw new RevisionSyntaxException(revision);                                      }                                      break;                                    default:                                      oref = MapObject(refId' null);                                      Commit oComm = (oref as Commit);                                      if (oComm != null)                                      {                                          ObjectId[] parents = oComm.ParentIds;                                          refId = parents.Length == 0 ? null : parents[0];                                      }                                      else                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                      break;                              }                          }                          else                          {                              oref = MapObject(refId' null);                              while (oref is Tag)                              {                                  var tag = (Tag)oref;                                  refId = tag.Id;                                  oref = MapObject(refId' null);                              }                                Commit oCom = (oref as Commit);                              if (oCom != null)                              {                                  ObjectId[] parents = oCom.ParentIds;                                  refId = parents.Length == 0 ? null : parents[0];                              }                              else                              {                                  throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                              }                          }                          break;                        case '~':                          if (oref == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                              oref = MapObject(refId' null);                          }                            while (oref is Tag)                          {                              var tag = (Tag)oref;                              refId = tag.Id;                              oref = MapObject(refId' null);                          }                            if (!(oref is Commit))                          {                              throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                          }                            int l;                          for (l = i + 1; l < revision.Length; ++l)                          {                              if (!Char.IsDigit(revision[l]))                                  break;                          }                            var distnum = new string(revision.ToCharArray(i + 1' l - i - 1));                          int dist;                            try                          {                              dist = Convert.ToInt32(distnum);                          }                          catch (FormatException)                          {                              throw new RevisionSyntaxException("Invalid ancestry length"' revision);                          }                          while (dist > 0)                          {                                ObjectId[] parents = ((Commit)oref).ParentIds;                              if (parents.Length == 0)                              {                                  refId = null;                                  break;                              }                              refId = parents[0];                              oref = MapCommit(refId);                              --dist;                          }                          i = l - 1;                          break;                        case '@':                          int m;                          string time = null;                          for (m = i + 2; m < revision.Length; ++m)                          {                              if (revision[m] != '}') continue;                              time = new string(revision.ToCharArray(i + 2' m - i - 2));                              break;                          }                            if (time != null)                          {                              throw new RevisionSyntaxException("reflogs not yet supported by revision parser yet"' revision);                          }                          i = m - 1;                          break;                        default:                          if (refId != null)                          {                              throw new RevisionSyntaxException(revision);                          }                          break;                  }              }
Magic Number,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,Resolve,The following statement contains a magic number: for (int i = 0; i < revision.Length; ++i)              {                  switch (revision[i])                  {                      case '^':                          if (refId == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                          }                            if (i + 1 < revision.Length)                          {                              switch (revision[i + 1])                              {                                  case '0':                                  case '1':                                  case '2':                                  case '3':                                  case '4':                                  case '5':                                  case '6':                                  case '7':                                  case '8':                                  case '9':                                        int j;                                      oref = MapObject(refId' null);                                        while (oref is Tag)                                      {                                          var tag = (Tag)oref;                                          refId = tag.Id;                                          oref = MapObject(refId' null);                                      }                                        Commit oCom = (oref as Commit);                                      if (oCom == null)                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                        for (j = i + 1; j < revision.Length; ++j)                                      {                                          if (!Char.IsDigit(revision[j])) break;                                      }                                        var parentnum = new string(revision.ToCharArray(i + 1' j - i - 1));                                        int pnum;                                        try                                      {                                          pnum = Convert.ToInt32(parentnum);                                      }                                      catch (FormatException)                                      {                                          throw new RevisionSyntaxException(revision' "Invalid commit parent number");                                      }                                      if (pnum != 0)                                      {                                          ObjectId[] parents = oCom.ParentIds;                                          if (pnum > parents.Length)                                              refId = null;                                          else                                              refId = parents[pnum - 1];                                      }                                        i = j - 1;                                      break;                                    case '{':                                      int k;                                      string item = null;                                      for (k = i + 2; k < revision.Length; ++k)                                      {                                          if (revision[k] != '}') continue;                                          item = new string(revision.ToCharArray(i + 2' k - i - 2));                                          break;                                      }                                        i = k;                                      if (item != null)                                      {                                          if (item.Equals("tree"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              Treeish oTree = (oref as Treeish);                                              if (oTree != null)                                              {                                                  refId = oTree.TreeId;                                              }                                              else                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Tree);                                              }                                          }                                          else if (item.Equals("commit"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is Commit))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (item.Equals("blob"))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                              if (!(oref is byte[]))                                              {                                                  throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                              }                                          }                                          else if (string.Empty.Equals(item))                                          {                                              oref = MapObject(refId' null);                                              while (oref is Tag)                                              {                                                  var t = (Tag)oref;                                                  refId = t.Id;                                                  oref = MapObject(refId' null);                                              }                                          }                                          else                                          {                                              throw new RevisionSyntaxException(revision);                                          }                                      }                                      else                                      {                                          throw new RevisionSyntaxException(revision);                                      }                                      break;                                    default:                                      oref = MapObject(refId' null);                                      Commit oComm = (oref as Commit);                                      if (oComm != null)                                      {                                          ObjectId[] parents = oComm.ParentIds;                                          refId = parents.Length == 0 ? null : parents[0];                                      }                                      else                                      {                                          throw new IncorrectObjectTypeException(refId' ObjectType.Commit);                                      }                                      break;                              }                          }                          else                          {                              oref = MapObject(refId' null);                              while (oref is Tag)                              {                                  var tag = (Tag)oref;                                  refId = tag.Id;                                  oref = MapObject(refId' null);                              }                                Commit oCom = (oref as Commit);                              if (oCom != null)                              {                                  ObjectId[] parents = oCom.ParentIds;                                  refId = parents.Length == 0 ? null : parents[0];                              }                              else                              {                                  throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                              }                          }                          break;                        case '~':                          if (oref == null)                          {                              var refstr = new string(revision.ToCharArray(0' i));                              refId = ResolveSimple(refstr);                              if (refId == null) return null;                              oref = MapObject(refId' null);                          }                            while (oref is Tag)                          {                              var tag = (Tag)oref;                              refId = tag.Id;                              oref = MapObject(refId' null);                          }                            if (!(oref is Commit))                          {                              throw new IncorrectObjectTypeException(refId' Constants.TYPE_COMMIT);                          }                            int l;                          for (l = i + 1; l < revision.Length; ++l)                          {                              if (!Char.IsDigit(revision[l]))                                  break;                          }                            var distnum = new string(revision.ToCharArray(i + 1' l - i - 1));                          int dist;                            try                          {                              dist = Convert.ToInt32(distnum);                          }                          catch (FormatException)                          {                              throw new RevisionSyntaxException("Invalid ancestry length"' revision);                          }                          while (dist > 0)                          {                                ObjectId[] parents = ((Commit)oref).ParentIds;                              if (parents.Length == 0)                              {                                  refId = null;                                  break;                              }                              refId = parents[0];                              oref = MapCommit(refId);                              --dist;                          }                          i = l - 1;                          break;                        case '@':                          int m;                          string time = null;                          for (m = i + 2; m < revision.Length; ++m)                          {                              if (revision[m] != '}') continue;                              time = new string(revision.ToCharArray(i + 2' m - i - 2));                              break;                          }                            if (time != null)                          {                              throw new RevisionSyntaxException("reflogs not yet supported by revision parser yet"' revision);                          }                          i = m - 1;                          break;                        default:                          if (refId != null)                          {                              throw new RevisionSyntaxException(revision);                          }                          break;                  }              }
Magic Number,GitSharp.Core,Tag,C:\repos\henon_GitSharp\GitSharp.Core\Tag.cs,Tag,The following statement contains a magic number: if (raw != null)              {                  TagId = id;                  Id = ObjectId.FromString(raw' 7);              }              else                  Id = id;
Magic Number,GitSharp.Core,Tag,C:\repos\henon_GitSharp\GitSharp.Core\Tag.cs,Tag,The following statement contains a magic number: if (refName != null && refName.StartsWith("refs/tags/"))                  refName = refName.Substring(10);
Magic Number,GitSharp.Core,Tag,C:\repos\henon_GitSharp\GitSharp.Core\Tag.cs,decode,The following statement contains a magic number: using (var br = new StreamReader(new MemoryStream(raw)))              {                  string n = br.ReadLine();                  if (n == null || !n.StartsWith("object "))                  {                      throw new CorruptObjectException(TagId' "no object");                  }                  Id = ObjectId.FromString(n.Substring(7));                  n = br.ReadLine();                  if (n == null || !n.StartsWith("type "))                  {                      throw new CorruptObjectException(TagId' "no type");                  }                  TagType = n.Substring("type ".Length);                  n = br.ReadLine();                    if (n == null || !n.StartsWith("tag "))                  {                      throw new CorruptObjectException(TagId' "no tag name");                  }                  TagName = n.Substring("tag ".Length);                  n = br.ReadLine();                    // We should see a "tagger" header here' but some repos have tags                  // without it.                  if (n == null)                      throw new CorruptObjectException(TagId' "no tagger header");                    if (n.Length > 0)                      if (n.StartsWith("tagger "))                          Tagger = new PersonIdent(n.Substring("tagger ".Length));                      else                          throw new CorruptObjectException(TagId' "no tagger/bad header");                    // Message should start with an empty line' but                  StringBuilder tempMessage = new StringBuilder();                  char[] readBuf = new char[2048];                  int readLen;                  int readIndex = 0;                  while ((readLen = br.Read(readBuf' readIndex' readBuf.Length)) > 0)                  {                      //readIndex += readLen;                      tempMessage.Append(readBuf' 0' readLen);                  }                  message = tempMessage.ToString();                  if (message.StartsWith("\n"))                      message = message.Substring(1);              }
Magic Number,GitSharp.Core,Tag,C:\repos\henon_GitSharp\GitSharp.Core\Tag.cs,decode,The following statement contains a magic number: using (var br = new StreamReader(new MemoryStream(raw)))              {                  string n = br.ReadLine();                  if (n == null || !n.StartsWith("object "))                  {                      throw new CorruptObjectException(TagId' "no object");                  }                  Id = ObjectId.FromString(n.Substring(7));                  n = br.ReadLine();                  if (n == null || !n.StartsWith("type "))                  {                      throw new CorruptObjectException(TagId' "no type");                  }                  TagType = n.Substring("type ".Length);                  n = br.ReadLine();                    if (n == null || !n.StartsWith("tag "))                  {                      throw new CorruptObjectException(TagId' "no tag name");                  }                  TagName = n.Substring("tag ".Length);                  n = br.ReadLine();                    // We should see a "tagger" header here' but some repos have tags                  // without it.                  if (n == null)                      throw new CorruptObjectException(TagId' "no tagger header");                    if (n.Length > 0)                      if (n.StartsWith("tagger "))                          Tagger = new PersonIdent(n.Substring("tagger ".Length));                      else                          throw new CorruptObjectException(TagId' "no tagger/bad header");                    // Message should start with an empty line' but                  StringBuilder tempMessage = new StringBuilder();                  char[] readBuf = new char[2048];                  int readLen;                  int readIndex = 0;                  while ((readLen = br.Read(readBuf' readIndex' readBuf.Length)) > 0)                  {                      //readIndex += readLen;                      tempMessage.Append(readBuf' 0' readLen);                  }                  message = tempMessage.ToString();                  if (message.StartsWith("\n"))                      message = message.Substring(1);              }
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if (!_output && ((DateTime.Now - _taskBeganAt).TotalMilliseconds < 500)) return;
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN)  			{  				Display(cmp);  				_writer.Flush();  			}  			else if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork)  			{  				Display(cmp);  				_writer.Flush();  			}
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN)  			{  				Display(cmp);  				_writer.Flush();  			}  			else if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork)  			{  				Display(cmp);  				_writer.Flush();  			}
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: while (m.Length < 25)  			{  				m.Append(' ');  			}
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (_totalWork == UNKNOWN)  			{  				m.Append(cmp);  			}  			else  			{  				string twstr = _totalWork.ToString();  				string cmpstr = cmp.ToString();    				while (cmpstr.Length < twstr.Length)  				{  					cmpstr = " " + cmpstr;  				}    				int pcnt = (cmp * 100 / _totalWork);  				if (pcnt < 100)  				{  					m.Append(' ');  				}    				if (pcnt < 10)  				{  					m.Append(' ');  				}    				m.Append(pcnt);  				m.Append("% (");  				m.Append(cmpstr);  				m.Append("/");  				m.Append(twstr);  				m.Append(")");  			}
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (_totalWork == UNKNOWN)  			{  				m.Append(cmp);  			}  			else  			{  				string twstr = _totalWork.ToString();  				string cmpstr = cmp.ToString();    				while (cmpstr.Length < twstr.Length)  				{  					cmpstr = " " + cmpstr;  				}    				int pcnt = (cmp * 100 / _totalWork);  				if (pcnt < 100)  				{  					m.Append(' ');  				}    				if (pcnt < 10)  				{  					m.Append(' ');  				}    				m.Append(pcnt);  				m.Append("% (");  				m.Append(cmpstr);  				m.Append("/");  				m.Append(twstr);  				m.Append(")");  			}
Magic Number,GitSharp.Core,TextProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\TextProgressMonitor.cs,Display,The following statement contains a magic number: if (_totalWork == UNKNOWN)  			{  				m.Append(cmp);  			}  			else  			{  				string twstr = _totalWork.ToString();  				string cmpstr = cmp.ToString();    				while (cmpstr.Length < twstr.Length)  				{  					cmpstr = " " + cmpstr;  				}    				int pcnt = (cmp * 100 / _totalWork);  				if (pcnt < 100)  				{  					m.Append(' ');  				}    				if (pcnt < 10)  				{  					m.Append(' ');  				}    				m.Append(pcnt);  				m.Append("% (");  				m.Append(cmpstr);  				m.Append("/");  				m.Append(twstr);  				m.Append(")");  			}
Magic Number,GitSharp.Core,Tree,C:\repos\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: while (rawPtr < rawSize)  			{  				int c = raw[rawPtr++];  				if (c < '0' || c > '7')  				{  					throw new CorruptObjectException(Id' "invalid entry mode");  				}    				int mode = c - '0';    				while (true)  				{  					c = raw[rawPtr++];  					if (' ' == c) break;    					if (c < '0' || c > '7')  					{  						throw new CorruptObjectException(Id' "invalid mode");  					}    					mode <<= 3;  					mode += c - '0';  				}    				int nameLen = 0;  				while (raw[rawPtr + nameLen] != 0)  				{  					nameLen++;  				}    				var name = new byte[nameLen];  				Array.Copy(raw' rawPtr' name' 0' nameLen);  				rawPtr += nameLen + 1;    				ObjectId id = ObjectId.FromRaw(raw' rawPtr);  				rawPtr += Constants.OBJECT_ID_LENGTH;    				TreeEntry ent;  				if (FileMode.RegularFile.Equals(mode))  				{  					ent = new FileTreeEntry(this' id' name' false);  				}  				else if (FileMode.ExecutableFile.Equals(mode))  				{  					ent = new FileTreeEntry(this' id' name' true);  				}  				else if (FileMode.Tree.Equals(mode))  				{  					ent = new Tree(this' id' name);  				}                  else if (FileMode.Symlink.Equals(mode))                  {                      ent = new SymlinkTreeEntry(this' id' name);                  }                  else if (FileMode.GitLink.Equals(mode))                  {                      ent = new GitLinkTreeEntry(this' id' name);                  }  				else  				{  					throw new CorruptObjectException(Id' "Invalid mode: " + Convert.ToString(mode' 8));  				}    				temp[nextIndex++] = ent;  			}
Magic Number,GitSharp.Core,Tree,C:\repos\henon_GitSharp\GitSharp.Core\Tree.cs,ReadTree,The following statement contains a magic number: while (rawPtr < rawSize)  			{  				int c = raw[rawPtr++];  				if (c < '0' || c > '7')  				{  					throw new CorruptObjectException(Id' "invalid entry mode");  				}    				int mode = c - '0';    				while (true)  				{  					c = raw[rawPtr++];  					if (' ' == c) break;    					if (c < '0' || c > '7')  					{  						throw new CorruptObjectException(Id' "invalid mode");  					}    					mode <<= 3;  					mode += c - '0';  				}    				int nameLen = 0;  				while (raw[rawPtr + nameLen] != 0)  				{  					nameLen++;  				}    				var name = new byte[nameLen];  				Array.Copy(raw' rawPtr' name' 0' nameLen);  				rawPtr += nameLen + 1;    				ObjectId id = ObjectId.FromRaw(raw' rawPtr);  				rawPtr += Constants.OBJECT_ID_LENGTH;    				TreeEntry ent;  				if (FileMode.RegularFile.Equals(mode))  				{  					ent = new FileTreeEntry(this' id' name' false);  				}  				else if (FileMode.ExecutableFile.Equals(mode))  				{  					ent = new FileTreeEntry(this' id' name' true);  				}  				else if (FileMode.Tree.Equals(mode))  				{  					ent = new Tree(this' id' name);  				}                  else if (FileMode.Symlink.Equals(mode))                  {                      ent = new SymlinkTreeEntry(this' id' name);                  }                  else if (FileMode.GitLink.Equals(mode))                  {                      ent = new GitLinkTreeEntry(this' id' name);                  }  				else  				{  					throw new CorruptObjectException(Id' "Invalid mode: " + Convert.ToString(mode' 8));  				}    				temp[nextIndex++] = ent;  			}
Magic Number,GitSharp.Core,TreeVisitorWithCurrentDirectory,C:\repos\henon_GitSharp\GitSharp.Core\TreeVisitorWithCurrentDirectory.cs,TreeVisitorWithCurrentDirectory,The following statement contains a magic number: stack = new Stack<DirectoryInfo>(16);
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,UnpackedObjectLoader,C:\repos\henon_GitSharp\GitSharp.Core\UnpackedObjectLoader.cs,UnpackedObjectLoader,The following statement contains a magic number: try  			{  				int fb = compressed[0] & 0xff;  				if (fb == 0x78 && (((fb << 8) | compressed[1] & 0xff) % 31) == 0)  				{  					inflater.SetInput(compressed);  					var hdr = new byte[64];  					int avail = 0;  					while (!inflater.IsFinished && avail < hdr.Length)  					{  						try  						{  							avail += inflater.Inflate(hdr' avail' hdr.Length - avail);  						}  						catch (IOException dfe)  						{  							var coe = new CorruptObjectException(id' "bad stream"' dfe);  							//inflater.end();  							throw coe;  						}  					}    					if (avail < 5)  					{  						throw new CorruptObjectException(id' "no header");  					}    					var p = new MutableInteger();  					_objectType = Constants.decodeTypeString(id' hdr' (byte)' '' p);  					_objectSize = RawParseUtils.parseBase10(hdr' p.value' p);    					if (_objectSize < 0)  					{  						throw new CorruptObjectException(id' "negative size");  					}    					if (hdr[p.value++] != 0)  					{  						throw new CorruptObjectException(id' "garbage after size");  					}    					_bytes = new byte[_objectSize];    					if (p.value < avail)  					{  						Array.Copy(hdr' p.value' _bytes' 0' avail - p.value);  					}    					Decompress(id' inflater' avail - p.value);  				}  				else  				{  					int p = 0;  					int c = compressed[p++] & 0xff;  					int typeCode = (c >> 4) & 7;  					int size = c & 15;  					int shift = 4;  					while ((c & 0x80) != 0)  					{  						c = compressed[p++] & 0xff;  						size += (c & 0x7f) << shift;  						shift += 7;  					}    					switch (typeCode)  					{  						case Constants.OBJ_COMMIT:  						case Constants.OBJ_TREE:  						case Constants.OBJ_BLOB:  						case Constants.OBJ_TAG:  							_objectType = typeCode;  							break;    						default:  							throw new CorruptObjectException(id' "invalid type");  					}    					_objectSize = size;  					_bytes = new byte[_objectSize];  					inflater.SetInput(compressed' p' compressed.Length - p);  					Decompress(id' inflater' 0);  				}  			}  			finally  			{  				InflaterCache.Instance.release(inflater);  			}
Magic Number,GitSharp.Core,WindowCache,C:\repos\henon_GitSharp\GitSharp.Core\WindowCache.cs,Bits,The following statement contains a magic number: if (newSize < 4096)              {                  throw new ArgumentException("Invalid window size");              }
Magic Number,GitSharp.Core,WindowCache,C:\repos\henon_GitSharp\GitSharp.Core\WindowCache.cs,TableSize,The following statement contains a magic number: return (int) Math.Min(5*(limit/wsz)/2' 2000000000);
Magic Number,GitSharp.Core,WindowCache,C:\repos\henon_GitSharp\GitSharp.Core\WindowCache.cs,TableSize,The following statement contains a magic number: return (int) Math.Min(5*(limit/wsz)/2' 2000000000);
Magic Number,GitSharp.Core,WindowCache,C:\repos\henon_GitSharp\GitSharp.Core\WindowCache.cs,TableSize,The following statement contains a magic number: return (int) Math.Min(5*(limit/wsz)/2' 2000000000);
Magic Number,GitSharp.Core,WindowCache,C:\repos\henon_GitSharp\GitSharp.Core\WindowCache.cs,LockCount,The following statement contains a magic number: return Math.Max(cfg.PackedGitOpenFiles' 32);
Magic Number,GitSharp.Core,WindowCacheConfig,C:\repos\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: PackedGitOpenFiles = 128;
Magic Number,GitSharp.Core,WindowCacheConfig,C:\repos\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: PackedGitLimit = 10 * Mb;
Magic Number,GitSharp.Core,WindowCacheConfig,C:\repos\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: PackedGitWindowSize = 8 * Kb;
Magic Number,GitSharp.Core,WindowCacheConfig,C:\repos\henon_GitSharp\GitSharp.Core\WindowCacheConfig.cs,WindowCacheConfig,The following statement contains a magic number: DeltaBaseCacheLimit = 10 * Mb;
Magic Number,GitSharp.Core,PackLock,C:\repos\henon_GitSharp\GitSharp.Core\PackLock.cs,PackLock,The following statement contains a magic number: string p = packFile.DirectoryName + Path.DirectorySeparatorChar + n.Slice(0' n.Length - 5) + ".keep";
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,PackWriter,The following statement contains a magic number: _buf = new byte[16384];
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: Array.Copy(Constants.PACK_SIGNATURE' 0' _buf' 0' 4);
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: NB.encodeInt32(_buf' 4' PackVersionGenerated);
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: NB.encodeInt32(_buf' 8' getObjectsNumber());
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteHeader,The following statement contains a magic number: _pos.Write(_buf' 0' 12);
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteDeltaObjectReuse,The following statement contains a magic number: if (DeltaBaseAsOffset && otp.DeltaBase != null)  			{  				WriteObjectHeader(Constants.OBJ_OFS_DELTA' reuse.RawSize);    				ObjectToPack deltaBase = otp.DeltaBase;  				long offsetDiff = otp.Offset - deltaBase.Offset;  				int localPos = _buf.Length - 1;  				_buf[localPos] = (byte)(offsetDiff & 0x7F);  				while ((offsetDiff >>= 7) > 0)  				{  					_buf[--localPos] = (byte)(0x80 | (--offsetDiff & 0x7F));  				}    				_pos.Write(_buf' localPos' _buf.Length - localPos);  			}  			else  			{  				WriteObjectHeader(Constants.OBJ_REF_DELTA' reuse.RawSize);  				otp.DeltaBaseId.copyRawTo(_buf' 0);  				_pos.Write(_buf' 0' Constants.OBJECT_ID_LENGTH);  			}
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The following statement contains a magic number: var nextLength = (long)(((ulong)dataLength) >> 4);
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The following statement contains a magic number: _buf[size++] = (byte)((nextLength > 0 ? (byte)0x80 : (byte)0x00) | (byte)(objectType << 4) | (byte)(dataLength & 0x0F));
Magic Number,GitSharp.Core,PackWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackWriter.cs,WriteObjectHeader,The following statement contains a magic number: while (dataLength > 0)  			{  				nextLength = (long)(((ulong)nextLength) >> 7);  				_buf[size++] = (byte)((nextLength > 0 ? (byte)0x80 : (byte)0x00) | (byte)(dataLength & 0x7F));  				dataLength = nextLength;  			}
Magic Number,GitSharp.Core,CachedObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string d in fanout) {                  if (d.Length != 2)                      continue;                  string[] entries = PathUtil.CombineDirectoryPath(objects' d).GetFiles().Select(x => x.FullName).ToArray();                  if (entries == null)                      continue;                  foreach (string e in entries) {                      if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)                          continue;                      try {                          _unpackedObjects.Add(ObjectId.FromString(d + e));                      } catch (ArgumentException) {                          // ignoring the file that does not represent loose object                      }                  }              }
Magic Number,GitSharp.Core,CachedObjectDirectory,C:\repos\henon_GitSharp\GitSharp.Core\CachedObjectDirectory.cs,CachedObjectDirectory,The following statement contains a magic number: foreach (string d in fanout) {                  if (d.Length != 2)                      continue;                  string[] entries = PathUtil.CombineDirectoryPath(objects' d).GetFiles().Select(x => x.FullName).ToArray();                  if (entries == null)                      continue;                  foreach (string e in entries) {                      if (e.Length != Constants.OBJECT_ID_STRING_LENGTH - 2)                          continue;                      try {                          _unpackedObjects.Add(ObjectId.FromString(d + e));                      } catch (ArgumentException) {                          // ignoring the file that does not represent loose object                      }                  }              }
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,Linux,The following statement contains a magic number: if (release.Length > 0)  			{  				string str = release[0].ToString();  				string platformType = str.Substring(5'str.Length-13);  				VersionFile = str;  				  				switch (platformType)  				{  					case "arch":  						GetArchPlatform( this' null);  						break;  					case "fedora":  						GetFedoraPlatform( this' null);  						break;  					case "gentoo":  						GetGentooPlatform( this' null);  						break;  					case "mandriva":  						GetMandrivaPlatform( this' null);  						break;  					case "redhat": 	//RedHat variants  						GetRedHatPlatform( this' null);  						break;  					case "suse":  						GetSusePlatform( this' null);  						break;  					case "lsb": 	//Ubuntu variants  						GetUbuntuPlatform( this' null);  						break;  					default:  						GetDefaultLinuxPlatform( this' null);  						break;  				}  			}  			else if (slackware.Length > 0)  			{  				VersionFile = "/etc/" + slackware[0].ToString();  				GetSlackwarePlatform( this' null);  			}  			else if (debian.Length > 0)  			{  				VersionFile = "/etc/" + debian[0].ToString();  				GetDebianPlatform( this' null);  			}  			else  			{  				GetDefaultLinuxPlatform( this' null);  			}
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,Linux,The following statement contains a magic number: if (release.Length > 0)  			{  				string str = release[0].ToString();  				string platformType = str.Substring(5'str.Length-13);  				VersionFile = str;  				  				switch (platformType)  				{  					case "arch":  						GetArchPlatform( this' null);  						break;  					case "fedora":  						GetFedoraPlatform( this' null);  						break;  					case "gentoo":  						GetGentooPlatform( this' null);  						break;  					case "mandriva":  						GetMandrivaPlatform( this' null);  						break;  					case "redhat": 	//RedHat variants  						GetRedHatPlatform( this' null);  						break;  					case "suse":  						GetSusePlatform( this' null);  						break;  					case "lsb": 	//Ubuntu variants  						GetUbuntuPlatform( this' null);  						break;  					default:  						GetDefaultLinuxPlatform( this' null);  						break;  				}  			}  			else if (slackware.Length > 0)  			{  				VersionFile = "/etc/" + slackware[0].ToString();  				GetSlackwarePlatform( this' null);  			}  			else if (debian.Length > 0)  			{  				VersionFile = "/etc/" + debian[0].ToString();  				GetDebianPlatform( this' null);  			}  			else  			{  				GetDefaultLinuxPlatform( this' null);  			}
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetFedoraPlatform,The following statement contains a magic number: obj.Version = lines[0].Substring(pt+8' pt2-1).Trim();
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetMandrivaPlatform,The following statement contains a magic number: obj.Version = lines[0].Substring(pt+8' pt2-1).Trim();
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetRedHatPlatform,The following statement contains a magic number: obj.Version = lines[0].Substring(pt+8' pt2 - 1 - pt + 8).Trim();
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetRedHatPlatform,The following statement contains a magic number: obj.Version = lines[0].Substring(pt+8' pt2 - 1 - pt + 8).Trim();
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetSusePlatform,The following statement contains a magic number: obj.Version = lines[1].Substring(11' lines[1].Length - 11);
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetSusePlatform,The following statement contains a magic number: obj.Version = lines[1].Substring(11' lines[1].Length - 11);
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetUbuntuPlatform,The following statement contains a magic number: int pt1 = lines[2].IndexOf("=");
Magic Number,GitSharp.Core,Linux,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Linux.cs,GetUbuntuPlatform,The following statement contains a magic number: obj.Edition = lines[2].Substring(pt1+1).Trim();
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following statement contains a magic number: switch (os.Platform)  			{  				case PlatformID.Win32Windows:  					switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}  					  					break;  				case PlatformID.Win32NT:  					switch (os.Version.Major)  					{  						case 3:  							ClassName = "Windows.NT";  							PlatformSubType = "NT";  							Edition = "3.51";  							break;  						case 4:  							switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}  							break;  						case 5:  							switch (os.Version.Minor)  							{  								case 0:  									switch (osvi.wSuiteMask)  									{  										case SuiteVersion.DataCenter:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Data Center";  											break;  										case SuiteVersion.Enterprise:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Advanced";  											break;  										default:  											ClassName = "Windows.v2000";  											PlatformSubType = "2000";  											Edition = "Standard";  											break;  									}  									break;  								case 1:  									if (osvi.wSuiteMask == SuiteVersion.Personal)  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional";  									}  									else  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Home";  									}  									break;  								case 2:  									if ((osvi.wProductType == NTVersion.Workstation) &&  									    (sysInfo.processorArchitecture == ProcessorArchitecture.AMD64))  									{  										ClassName = "Windows.XP";  										PlatformSubType = "XP";  										Edition = "Professional x64";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         (GetSystemMetrics(SystemMetrics.ServerR2) == 0) &&  									         (osvi.wSuiteMask == SuiteVersion.Enterprise))  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 Enterprise";  									}  									else if ((osvi.wProductType == NTVersion.Server) &&  									         GetSystemMetrics(SystemMetrics.ServerR2) != 0)  									{  										ClassName = "Windows.v2003";  										PlatformSubType = "Server";  										Edition = "2003 R2";  									}  									else  									{  										switch (osvi.wSuiteMask)  										{  											case SuiteVersion.DataCenter:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Data Center";  												break;  											case SuiteVersion.Blade:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Web Edition";  												break;  											case SuiteVersion.WHServer:  												ClassName = "Windows.v2003";  												PlatformSubType = "2003";  												Edition = "Home Server";  												break;  											default:  												ClassName = "Windows.v2003";  												PlatformSubType = "Server";  												Edition = "2003 Standard";  												break;  										}  									}  									break;  							}  							break;  						case 6:  							Win32ProductInfo ospi = new Win32ProductInfo();  							ospi.dwOSProductInfoSize = Marshal.SizeOf(ospi);  							ospi.dwOSMajorVersion = os.Version.Major;  							ospi.dwOSMinorVersion = os.Version.Minor;  							ospi.dwSpMajorVersion = 0;  							ospi.dwSpMinorVersion = 0;  							  							GetProductInfo(ospi);  							Version = Version+"."+ospi.dwOSEdition;  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.wProductType == NTVersion.Workstation)  									{  										// Vista Detection  										switch (ospi.dwOSEdition)  										{  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  											case ProductType.Ultimate: //    1  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate Edition";  												break;  											case ProductType.HomeBasic: // 2  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic Edition";  												break;  											case ProductType.HomePremium: // 3  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium Edition";  												break;  											case ProductType.Enterprise: // 4  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise Edition";  												break;  											case ProductType.HomeBasicN: // 5  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Basic N Edition (EU Only)";  												break;  											case ProductType.Business: // 6  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business Edition";  												break;  											case ProductType.Starter:// B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Starter Edition";  												break;  											case ProductType.BusinessN: // 10  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Business N Edition (EU Only)";  												break;  											case ProductType.HomePremiumN: // 1A  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Home Premium N Edition (EU Only)";  												break;  											case ProductType.EnterpriseN: // 1B  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Enterprise N Edition (EU Only)";  												break;  											case ProductType.UltimateN: // 1C  												ClassName = "Windows.Vista";  												PlatformSubType = "Vista";  												Edition = "Ultimate N Edition (EU Only)";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "Vista";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "Vista";  												Edition = "is not defined!";  												break;  										}  									}  									else  									{  										switch (ospi.dwOSEdition)  										{  												//Windows 2008 Detection  												  											case ProductType.Undefined:  												ClassName = "Windows.Undefined";  												PlatformSubType = "2008";  												Edition = "is not defined!";  												break;  											case ProductType.StandardServer: // 7  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server";  												break;  											case ProductType.DataCenterServer://8  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server";  												break;  											case ProductType.SmallBusinessServer://9  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server";  												break;  											case ProductType.EnterpriseServer:// A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server";  												break;  											case ProductType.DataCenterServerCore: // C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core";  												break;  											case ProductType.StandardServerCore: // D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core";  												break;  											case ProductType.EnterpriseServerCore: // E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core";  												break;  											case ProductType.EnterpriseServerIA64: // F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server IA64";  												break;  											case ProductType.WebServer: // 11  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server";  												break;  											case ProductType.ClusterServer: // 12  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Cluster Server";  												break;  											case ProductType.HomeServer: // 13  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Server";  												break;  											case ProductType.StorageExpressServer: // 14  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server";  												break;  											case ProductType.StorageStandardServer: // 15  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server";  												break;  											case ProductType.StorageWorkgroupServer: // 16  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server";  												break;  											case ProductType.StorageEnterpriseServer: // 17  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server";  												break;  											case ProductType.ServerForSmallBusiness: // 18  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Businesses";  												break;  											case ProductType.SmallBusinessServerPremium: // 19  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Premium";  												break;  											case ProductType.WebServerCore: // 1D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Web Server Core";  												break;  											case ProductType.MediumBusinessServerManagement: // 1E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Management";  												break;  											case ProductType.MediumBusinessServerSecurity: // 1F  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Security";  												break;  											case ProductType.MediumBusinessServerMessaging: // 20  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Medium Business Server Messaging";  												break;  											case ProductType.SmallBusinessServerPrime: // 21  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Small Business Server Prime";  												break;  											case ProductType.HomePremiumServer: // 22  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Home Premium Server";  												break;  											case ProductType.ServerForSmallBusinessV: // 23  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Server for Small Business (Hyper-V)";  												break;  											case ProductType.StandardServerV: // 24  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerV: // 25  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server (Hyper-V)";  												break;  											case ProductType.EnterpriseServerV: // 26  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server (Hyper-V)";  												break;  											case ProductType.DataCenterServerCoreV: // 27  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Data Center Server Core (Hyper-V)";  												break;  											case ProductType.StandardServerCoreV: // 28  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Standard Server Core (Hyper-V)";  												break;  											case ProductType.EnterpriseServerCoreV: // 29  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Enterprise Server Core (Hyper-V)";  												break;  											case ProductType.HyperV: // 2A  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "(Hyper-V)";  												break;  											case ProductType.StorageExpressServerCore: // 2B  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Express Server Core";  												break;  											case ProductType.StorageStandardServerCore: // 2C  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Standard Server Core";  												break;  											case ProductType.StorageWorkgroupServerCore: // 2D  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Workgroup Server Core";  												break;  											case ProductType.StorageEnterpriseServerCore: // 2E  												ClassName = "Windows.v2008";  												PlatformSubType = "2008";  												Edition = "Storage Enterprise Server Core";  												break;  											case ProductType.Unlicensed: // 0xABCDABCD  												ClassName = "Windows.Unlicensed";  												PlatformSubType = "2008";  												Edition = "Unlicensed";  												break;  											default:  												ClassName = "Windows.Unknown";  												PlatformSubType = "2008";  												Edition = "is unknown!";  												break;  										}  									}  									break;  								case 1:  									switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}  									break;  							} //End os.Version.Minor  							break;  					} // End os.Version.Major  					break;  			}
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,delete,The following statement contains a magic number: int levels = levelsIn(name) - 2;
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: try              {                  buf = IO.ReadFully(path' 4096);              }              catch (FileNotFoundException)              {                  return null; // doesn't exist; not a reference.              }              catch (DirectoryNotFoundException)              {                  return null; // doesn't exist; not a reference.              }
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: if (isSymRef(buf' n))              {                  // trim trailing whitespace                  while (0 < n && Char.IsWhiteSpace((char)buf[n - 1]))                      n--;                  if (n < 6)                  {                      string content = RawParseUtils.decode(buf' 0' n);                      throw new IOException("Not a ref: " + name + ": " + content);                  }                  string target = RawParseUtils.decode(buf' 5' n);                  return newSymbolicRef(modified' name' target);              }
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,scanRef,The following statement contains a magic number: if (isSymRef(buf' n))              {                  // trim trailing whitespace                  while (0 < n && Char.IsWhiteSpace((char)buf[n - 1]))                      n--;                  if (n < 6)                  {                      string content = RawParseUtils.decode(buf' 0' n);                      throw new IOException("Not a ref: " + name + ": " + content);                  }                  string target = RawParseUtils.decode(buf' 5' n);                  return newSymbolicRef(modified' name' target);              }
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: if (n < 6)                  return false;
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: return buf[0] == 'r' //                     && buf[1] == 'e' //                     && buf[2] == 'f' //                     && buf[3] == ':' //                     && buf[4] == ' ';
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: return buf[0] == 'r' //                     && buf[1] == 'e' //                     && buf[2] == 'f' //                     && buf[3] == ':' //                     && buf[4] == ' ';
Magic Number,GitSharp.Core,RefDirectory,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectory.cs,isSymRef,The following statement contains a magic number: return buf[0] == 'r' //                     && buf[1] == 'e' //                     && buf[2] == 'f' //                     && buf[3] == ':' //                     && buf[4] == ' ';
Magic Number,GitSharp.Core,RefDirectoryRename,C:\repos\henon_GitSharp\GitSharp.Core\RefDirectoryRename.cs,renameLog,The following statement contains a magic number: try              {                  int levels = RefDirectory.levelsIn(src.getName()) - 2;                  RefDirectory.delete(srcLog' levels);                  return true;              }              catch (IOException)              {                  rename(dstLog.FullName' srcLog.FullName);                  return false;              }
Magic Number,GitSharp.Core.Diff,DiffFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,DiffFormatter,The following statement contains a magic number: setContext(3);
Magic Number,GitSharp.Core.Diff,DiffFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,CombineA,The following statement contains a magic number: return e[i].BeginA - e[i - 1].EndA <= 2 * _context;
Magic Number,GitSharp.Core.Diff,DiffFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Diff\DiffFormatter.cs,CombineB,The following statement contains a magic number: return e[i].BeginB - e[i - 1].EndB <= 2 * _context;
Magic Number,GitSharp.Core.Diff,RawText,C:\repos\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,size,The following statement contains a magic number: return lines.size() - 2;
Magic Number,GitSharp.Core.Diff,RawText,C:\repos\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,writeLine,The following statement contains a magic number: int end = lines.get(i + 2);
Magic Number,GitSharp.Core.Diff,RawText,C:\repos\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,HashLine,The following statement contains a magic number: int hash = 5381;
Magic Number,GitSharp.Core.Diff,RawText,C:\repos\henon_GitSharp\GitSharp.Core\Diff\RawText.cs,HashLine,The following statement contains a magic number: for (; ptr < end; ptr++)  			{  				hash = (hash << 5) ^ (raw[ptr] & 0xff);  			}
Magic Number,GitSharp.Core.Diff,EditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,getIndex,The following statement contains a magic number: if (((d + k - middleK) % 2) == 1)                          throw new InvalidOperationException("odd: " + d + " + " + k + " - " + middleK);
Magic Number,GitSharp.Core.Diff,EditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,getIndex,The following statement contains a magic number: return (d + k - middleK) / 2;
Magic Number,GitSharp.Core.Diff,EditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,newSnake,The following statement contains a magic number: long ret = ((long)x) << 32;
Magic Number,GitSharp.Core.Diff,EditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,snake2x,The following statement contains a magic number: return (int)((ulong)snake >> 32);
Magic Number,GitSharp.Core.Diff,EditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,calculate,The following statement contains a magic number: for (int k = endK; k >= beginK; k -= 2)                      {                          int left = -1' right = -1;                          long leftSnake = -1L' rightSnake = -1L;                          // TODO: refactor into its own function                          int i;                          if (k > prevBeginK)                          {                              i = getIndex(d - 1' k - 1);                              left = x.get(i);                              int end = snake(k - 1' left);                              leftSnake = left != end ?                                                          newSnake(k - 1' end) :                                                                                   _snake.get(i);                                if (meets(d' k - 1' end' leftSnake))                                  return true;                              left = getLeft(end);                          }                          if (k < prevEndK)                          {                              i = getIndex(d - 1' k + 1);                              right = x.get(i);                              int end = snake(k + 1' right);                              rightSnake = right != end ?                                                            newSnake(k + 1' end) :                                                                                     _snake.get(i);                                if (meets(d' k + 1' end' rightSnake))                                  return true;                              right = getRight(end);                          }                          int newX;                          long newSnakeTmp;                          if (k >= prevEndK ||                              (k > prevBeginK &&                                  isBetter(left' right)))                          {                              newX = left;                              newSnakeTmp = leftSnake;                          }                          else                          {                              newX = right;                              newSnakeTmp = rightSnake;                          }                            if (meets(d' k' newX' newSnakeTmp))                              return true;                          adjustMinMaxK(k' newX);                          i = getIndex(d' k);                          x.set(i' newX);                          _snake.set(i' newSnakeTmp);                      }
Magic Number,GitSharp.Core.Diff,ForwardEditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,meets,The following statement contains a magic number: if (((d - 1 + k - _middleEdit.backward.middleK) % 2) == 1)                          return false;
Magic Number,GitSharp.Core.Diff,BackwardEditPaths,C:\repos\henon_GitSharp\GitSharp.Core\Diff\MyersDiff.cs,meets,The following statement contains a magic number: if (((d + k - _middleEdit.forward.middleK) % 2) == 1)                          return false;
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (_entries.Length == _entryCnt)  			{  				var n = new DirCacheEntry[(_entryCnt + 16) * 3 / 2];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (_entries.Length == _entryCnt)  			{  				var n = new DirCacheEntry[(_entryCnt + 16) * 3 / 2];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastAdd,The following statement contains a magic number: if (_entries.Length == _entryCnt)  			{  				var n = new DirCacheEntry[(_entryCnt + 16) * 3 / 2];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (_entryCnt + cnt > _entries.Length)  			{  				int m1 = (_entryCnt + 16) * 3 / 2;  				int m2 = _entryCnt + cnt;  				var n = new DirCacheEntry[Math.Max(m1' m2)];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (_entryCnt + cnt > _entries.Length)  			{  				int m1 = (_entryCnt + 16) * 3 / 2;  				int m2 = _entryCnt + cnt;  				var n = new DirCacheEntry[Math.Max(m1' m2)];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,FastKeep,The following statement contains a magic number: if (_entryCnt + cnt > _entries.Length)  			{  				int m1 = (_entryCnt + 16) * 3 / 2;  				int m2 = _entryCnt + cnt;  				var n = new DirCacheEntry[Math.Max(m1' m2)];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,BaseDirCacheEditor,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\BaseDirCacheEditor.cs,Replace,The following statement contains a magic number: if (_entryCnt < _entries.Length / 2)  			{  				var n = new DirCacheEntry[_entryCnt];  				Array.Copy(_entries' 0' n' 0' _entryCnt);  				_entries = n;  			}
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,builder,The following statement contains a magic number: return new DirCacheBuilder(this' _entryCnt + 16);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,editor,The following statement contains a magic number: return new DirCacheEditor(this' _entryCnt + 16);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: var hdr = new byte[20];
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: IO.ReadFully(inStream' hdr' 0' 12);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: md.Update(hdr' 0' 12);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: int ver = NB.DecodeInt32(hdr' 4);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: if (ver != 2)              {                  throw new CorruptObjectException("Unknown DIRC version " + ver);              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: _entryCnt = NB.DecodeInt32(hdr' 8);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true)              {                  var pos = inStream.Position;                  IO.ReadFully(inStream' hdr' 0' 20);                    if (inStream.ReadByte() < 0)                  {                      // No extensions present; the file ended where we expected.                      //                      break;                  }                  inStream.Seek(pos' SeekOrigin.Begin);                  md.Update(hdr' 0' 8);                  IO.skipFully(inStream' 8);                    long sz = NB.decodeUInt32(hdr' 4);                    switch (NB.DecodeInt32(hdr' 0))                  {                      case ExtTree:                          if (int.MaxValue < sz)                          {                              throw new CorruptObjectException("DIRC extension "                                          + formatExtensionName(hdr) + " is too large at "                                          + sz + " bytes.");                          }                          byte[] raw = new byte[(int)sz];                          IO.ReadFully(inStream' raw' 0' raw.Length);                          md.Update(raw' 0' raw.Length);                          _cacheTree = new DirCacheTree(raw' new MutableInteger()' null);                          break;                        default:                          if (hdr[0] >= (byte)'A' && hdr[0] <= (byte)'Z')                          {                              // The extension is optional and is here only as                              // a performance optimization. Since we do not                              // understand it' we can safely skip past it' after                              // we include its data in our checksum.                              //                              skipOptionalExtension(inStream' md' hdr' sz);                          }                          else                          {                              // The extension is not an optimization and is                              // _required_ to understand this index format.                              // Since we did not trap it above we must abort.                              //                              throw new CorruptObjectException("DIRC extension "                                      + formatExtensionName(hdr)                                      + " not supported by this version.");                          }                            break;                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true)              {                  var pos = inStream.Position;                  IO.ReadFully(inStream' hdr' 0' 20);                    if (inStream.ReadByte() < 0)                  {                      // No extensions present; the file ended where we expected.                      //                      break;                  }                  inStream.Seek(pos' SeekOrigin.Begin);                  md.Update(hdr' 0' 8);                  IO.skipFully(inStream' 8);                    long sz = NB.decodeUInt32(hdr' 4);                    switch (NB.DecodeInt32(hdr' 0))                  {                      case ExtTree:                          if (int.MaxValue < sz)                          {                              throw new CorruptObjectException("DIRC extension "                                          + formatExtensionName(hdr) + " is too large at "                                          + sz + " bytes.");                          }                          byte[] raw = new byte[(int)sz];                          IO.ReadFully(inStream' raw' 0' raw.Length);                          md.Update(raw' 0' raw.Length);                          _cacheTree = new DirCacheTree(raw' new MutableInteger()' null);                          break;                        default:                          if (hdr[0] >= (byte)'A' && hdr[0] <= (byte)'Z')                          {                              // The extension is optional and is here only as                              // a performance optimization. Since we do not                              // understand it' we can safely skip past it' after                              // we include its data in our checksum.                              //                              skipOptionalExtension(inStream' md' hdr' sz);                          }                          else                          {                              // The extension is not an optimization and is                              // _required_ to understand this index format.                              // Since we did not trap it above we must abort.                              //                              throw new CorruptObjectException("DIRC extension "                                      + formatExtensionName(hdr)                                      + " not supported by this version.");                          }                            break;                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true)              {                  var pos = inStream.Position;                  IO.ReadFully(inStream' hdr' 0' 20);                    if (inStream.ReadByte() < 0)                  {                      // No extensions present; the file ended where we expected.                      //                      break;                  }                  inStream.Seek(pos' SeekOrigin.Begin);                  md.Update(hdr' 0' 8);                  IO.skipFully(inStream' 8);                    long sz = NB.decodeUInt32(hdr' 4);                    switch (NB.DecodeInt32(hdr' 0))                  {                      case ExtTree:                          if (int.MaxValue < sz)                          {                              throw new CorruptObjectException("DIRC extension "                                          + formatExtensionName(hdr) + " is too large at "                                          + sz + " bytes.");                          }                          byte[] raw = new byte[(int)sz];                          IO.ReadFully(inStream' raw' 0' raw.Length);                          md.Update(raw' 0' raw.Length);                          _cacheTree = new DirCacheTree(raw' new MutableInteger()' null);                          break;                        default:                          if (hdr[0] >= (byte)'A' && hdr[0] <= (byte)'Z')                          {                              // The extension is optional and is here only as                              // a performance optimization. Since we do not                              // understand it' we can safely skip past it' after                              // we include its data in our checksum.                              //                              skipOptionalExtension(inStream' md' hdr' sz);                          }                          else                          {                              // The extension is not an optimization and is                              // _required_ to understand this index format.                              // Since we did not trap it above we must abort.                              //                              throw new CorruptObjectException("DIRC extension "                                      + formatExtensionName(hdr)                                      + " not supported by this version.");                          }                            break;                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,ReadFrom,The following statement contains a magic number: while (true)              {                  var pos = inStream.Position;                  IO.ReadFully(inStream' hdr' 0' 20);                    if (inStream.ReadByte() < 0)                  {                      // No extensions present; the file ended where we expected.                      //                      break;                  }                  inStream.Seek(pos' SeekOrigin.Begin);                  md.Update(hdr' 0' 8);                  IO.skipFully(inStream' 8);                    long sz = NB.decodeUInt32(hdr' 4);                    switch (NB.DecodeInt32(hdr' 0))                  {                      case ExtTree:                          if (int.MaxValue < sz)                          {                              throw new CorruptObjectException("DIRC extension "                                          + formatExtensionName(hdr) + " is too large at "                                          + sz + " bytes.");                          }                          byte[] raw = new byte[(int)sz];                          IO.ReadFully(inStream' raw' 0' raw.Length);                          md.Update(raw' 0' raw.Length);                          _cacheTree = new DirCacheTree(raw' new MutableInteger()' null);                          break;                        default:                          if (hdr[0] >= (byte)'A' && hdr[0] <= (byte)'Z')                          {                              // The extension is optional and is here only as                              // a performance optimization. Since we do not                              // understand it' we can safely skip past it' after                              // we include its data in our checksum.                              //                              skipOptionalExtension(inStream' md' hdr' sz);                          }                          else                          {                              // The extension is not an optimization and is                              // _required_ to understand this index format.                              // Since we did not trap it above we must abort.                              //                              throw new CorruptObjectException("DIRC extension "                                      + formatExtensionName(hdr)                                      + " not supported by this version.");                          }                            break;                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,skipOptionalExtension,The following statement contains a magic number: byte[] b = new byte[4096];
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,formatExtensionName,The following statement contains a magic number: return "'" + Charset.forName("ISO-8859-1").GetString(hdr' 0' 4) + "'";
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: var tmp = new byte[128];
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32(tmp' 4' /* version */2);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32(tmp' 4' /* version */2);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: NB.encodeInt32(tmp' 8' _entryCnt);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: dos.Write(tmp' 0' 12);
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_lastModified <= 0)               {                  // Write a new index' as no entries require smudging.                  //                  for (int i = 0; i < _entryCnt; i++)                  {                      _sortedEntries[i].write(dos);                  }              }              else              {                  int smudge_s = (int)(_lastModified / 1000);                  int smudge_ns = ((int)(_lastModified % 1000)) * 1000000;                  for (int i = 0; i < _entryCnt; i++)                  {                      DirCacheEntry e = _sortedEntries[i];                      if (e.mightBeRacilyClean(smudge_s' smudge_ns))                          e.smudgeRacilyClean();                      e.write(dos);                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_lastModified <= 0)               {                  // Write a new index' as no entries require smudging.                  //                  for (int i = 0; i < _entryCnt; i++)                  {                      _sortedEntries[i].write(dos);                  }              }              else              {                  int smudge_s = (int)(_lastModified / 1000);                  int smudge_ns = ((int)(_lastModified % 1000)) * 1000000;                  for (int i = 0; i < _entryCnt; i++)                  {                      DirCacheEntry e = _sortedEntries[i];                      if (e.mightBeRacilyClean(smudge_s' smudge_ns))                          e.smudgeRacilyClean();                      e.write(dos);                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_lastModified <= 0)               {                  // Write a new index' as no entries require smudging.                  //                  for (int i = 0; i < _entryCnt; i++)                  {                      _sortedEntries[i].write(dos);                  }              }              else              {                  int smudge_s = (int)(_lastModified / 1000);                  int smudge_ns = ((int)(_lastModified % 1000)) * 1000000;                  for (int i = 0; i < _entryCnt; i++)                  {                      DirCacheEntry e = _sortedEntries[i];                      if (e.mightBeRacilyClean(smudge_s' smudge_ns))                          e.smudgeRacilyClean();                      e.write(dos);                  }              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_cacheTree != null)              {                  var bb = new LocalFileBuffer();                  _cacheTree.write(tmp' bb);                  bb.close();                    NB.encodeInt32(tmp' 0' ExtTree);                  NB.encodeInt32(tmp' 4' (int)bb.Length);                  dos.Write(tmp' 0' 8);                  bb.writeTo(dos' null);              }
Magic Number,GitSharp.Core.DirectoryCache,DirCache,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCache.cs,WriteTo,The following statement contains a magic number: if (_cacheTree != null)              {                  var bb = new LocalFileBuffer();                  _cacheTree.write(tmp' bb);                  bb.close();                    NB.encodeInt32(tmp' 0' ExtTree);                  NB.encodeInt32(tmp' 4' (int)bb.Length);                  dos.Write(tmp' 0' 8);                  bb.writeTo(dos' null);              }
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: if (stage < 0 || 3 < stage)                  throw new ArgumentException("Invalid stage " + stage                      + " for path " + toString(newPath));
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DirCacheEntry,The following statement contains a magic number: int flags = ((stage & 0x3) << 12);
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,write,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,write,The following statement contains a magic number: int expLen = (actLen + 8) & ~7;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,mightBeRacilyClean,The following statement contains a magic number: if (smudge_s == mtime)                  return smudge_ns <= NB.DecodeInt32(_info' @base + 4) / 1000000;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,mightBeRacilyClean,The following statement contains a magic number: if (smudge_s == mtime)                  return smudge_ns <= NB.DecodeInt32(_info' @base + 4) / 1000000;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,smudgeRacilyClean,The following statement contains a magic number: _info.Fill(@base' @base + 8' (byte)127);
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,smudgeRacilyClean,The following statement contains a magic number: _info.Fill(@base' @base + 8' (byte)127);
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,getStage,The following statement contains a magic number: return (int)((uint)(_info[_infoOffset + PFlags]) >> 4) & 0x3;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DecodeTimestamp,The following statement contains a magic number: int ms = NB.DecodeInt32(_info' @base + 4) / 1000000;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,DecodeTimestamp,The following statement contains a magic number: int ms = NB.DecodeInt32(_info' @base + 4) / 1000000;
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32(_info' @base' (int)(when / 1000));
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32(_info' @base + 4' ((int)(when % 1000)) * 1000000);
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32(_info' @base + 4' ((int)(when % 1000)) * 1000000);
Magic Number,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,EncodeTimestamp,The following statement contains a magic number: NB.encodeInt32(_info' @base + 4' ((int)(when % 1000)) * 1000000);
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: while (entryIdx < endIdx)              {                  DirCacheEntry e = cache[entryIdx];                  if (e.getStage() != 0)                  {                      throw new UnmergedPathException(e);                  }                    byte[] ep = e.Path;                  if (childIdx < _childCount)                  {                      DirCacheTree st = _children[childIdx];                      if (st.contains(ep' pathOffset' ep.Length))                      {                          int stOffset = pathOffset + st.nameLength() + 1;                          st.writeTree(cache' entryIdx' stOffset' ow);                            size += FileMode.Tree.copyToLength();                          size += st.nameLength();                          size += Constants.OBJECT_ID_LENGTH + 2;                            entryIdx += st._entrySpan;                          childIdx++;                          continue;                      }                  }                    FileMode mode = e.getFileMode();                    size += mode.copyToLength();                  size += ep.Length - pathOffset;                  size += Constants.OBJECT_ID_LENGTH + 2;                  entryIdx++;              }
Magic Number,GitSharp.Core.DirectoryCache,DirCacheTree,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheTree.cs,ComputeSize,The following statement contains a magic number: while (entryIdx < endIdx)              {                  DirCacheEntry e = cache[entryIdx];                  if (e.getStage() != 0)                  {                      throw new UnmergedPathException(e);                  }                    byte[] ep = e.Path;                  if (childIdx < _childCount)                  {                      DirCacheTree st = _children[childIdx];                      if (st.contains(ep' pathOffset' ep.Length))                      {                          int stOffset = pathOffset + st.nameLength() + 1;                          st.writeTree(cache' entryIdx' stOffset' ow);                            size += FileMode.Tree.copyToLength();                          size += st.nameLength();                          size += Constants.OBJECT_ID_LENGTH + 2;                            entryIdx += st._entrySpan;                          childIdx++;                          continue;                      }                  }                    FileMode mode = e.getFileMode();                    size += mode.copyToLength();                  size += ep.Length - pathOffset;                  size += Constants.OBJECT_ID_LENGTH + 2;                  entryIdx++;              }
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,C:\repos\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: var stars = new string('*'' 80);
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,C:\repos\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: sb.AppendLine(indent + new string('-'' 80));
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,C:\repos\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: foreach (string line in exception.StackTrace.Split(new[] { " at " }' StringSplitOptions.RemoveEmptyEntries))              {                  if (string.IsNullOrEmpty(line.Trim())) continue;                	string[] parts = line.Trim().Split(new[] { " in " }' StringSplitOptions.RemoveEmptyEntries);                  string classInfo = parts[0];                    if (parts.Length == 2)                  {                      parts = parts[1].Trim().Split(new[] { "line" }' StringSplitOptions.RemoveEmptyEntries);                      if (parts.Length == 2)                      {                          string srcFile = parts[0];                          int lineNr = int.Parse(parts[1]);  						sb.AppendFormat(indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd(':')' lineNr' classInfo);                      }                      else                      {  						sb.AppendLine(indent + "  " + classInfo);                      }                  }                  else                  {                  	sb.AppendLine(indent + "  " + classInfo);                  }              }
Magic Number,GitSharp.Core.Exceptions,ExceptionExtensions,C:\repos\henon_GitSharp\GitSharp.Core\Exceptions\ExceptionExtensions.cs,PrintRecursive,The following statement contains a magic number: foreach (string line in exception.StackTrace.Split(new[] { " at " }' StringSplitOptions.RemoveEmptyEntries))              {                  if (string.IsNullOrEmpty(line.Trim())) continue;                	string[] parts = line.Trim().Split(new[] { " in " }' StringSplitOptions.RemoveEmptyEntries);                  string classInfo = parts[0];                    if (parts.Length == 2)                  {                      parts = parts[1].Trim().Split(new[] { "line" }' StringSplitOptions.RemoveEmptyEntries);                      if (parts.Length == 2)                      {                          string srcFile = parts[0];                          int lineNr = int.Parse(parts[1]);  						sb.AppendFormat(indent + "  {0}({1}'1):   {2}\n"' srcFile.TrimEnd(':')' lineNr' classInfo);                      }                      else                      {  						sb.AppendLine(indent + "  " + classInfo);                      }                  }                  else                  {                  	sb.AppendLine(indent + "  " + classInfo);                  }              }
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: IList<IHead> nextHeadsSuggestion = new List<IHead>(2) { LastHead.Instance };
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,CreateHeadsStartValues,The following statement contains a magic number: for (int i = allHeads.Count - 1; i >= 0; i--)  			{  				AbstractHead head = allHeads[i];    				// explanation:  				// a and * of the pattern "a*b"  				// need *b as newHeads  				// that's why * extends the list for it self and it's left neighbor.  				if (head.IsStar)  				{  					nextHeadsSuggestion.Add(head);  					head.setNewHeads(nextHeadsSuggestion);  				}  				else  				{  					head.setNewHeads(nextHeadsSuggestion);  					nextHeadsSuggestion = new List<IHead>(2) { head };  				}  			}
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: int firstValidEndBracketIndex = indexOfStartBracket + 2;
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: do  			{  				int possibleGroupEnd = pattern.IndexOf(']'' firstValidEndBracketIndex);  				if (possibleGroupEnd == -1)  				{  					throw new NoClosingBracketException(indexOfStartBracket' "["' "]"' pattern);  				}    				Match charClassStartMatch = Regex.Match(pattern.Substring(firstValidCharClassIndex)' CharacterClassStartPattern);    				bool foundCharClass = charClassStartMatch.Success;  				int charClassStartMatchIndex = charClassStartMatch.Index + firstValidCharClassIndex;    				if (foundCharClass && charClassStartMatchIndex < possibleGroupEnd)  				{  					string classStart = charClassStartMatch.Groups[0].Value;  					string classEnd = classStart[1] + "]";    					int classStartIndex = charClassStartMatchIndex;  					int classEndIndex = pattern.IndexOf(classEnd' classStartIndex + 2);    					if (classEndIndex == -1)  					{  						throw new NoClosingBracketException(classStartIndex' classStart' classEnd' pattern);  					}    					firstValidCharClassIndex = classEndIndex + 2;  					firstValidEndBracketIndex = firstValidCharClassIndex;  				}  				else  				{  					groupEnd = possibleGroupEnd;  				}  			} while (groupEnd == -1);
Magic Number,GitSharp.Core.FnMatch,FileNameMatcher,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\FileNameMatcher.cs,FindGroupEnd,The following statement contains a magic number: do  			{  				int possibleGroupEnd = pattern.IndexOf(']'' firstValidEndBracketIndex);  				if (possibleGroupEnd == -1)  				{  					throw new NoClosingBracketException(indexOfStartBracket' "["' "]"' pattern);  				}    				Match charClassStartMatch = Regex.Match(pattern.Substring(firstValidCharClassIndex)' CharacterClassStartPattern);    				bool foundCharClass = charClassStartMatch.Success;  				int charClassStartMatchIndex = charClassStartMatch.Index + firstValidCharClassIndex;    				if (foundCharClass && charClassStartMatchIndex < possibleGroupEnd)  				{  					string classStart = charClassStartMatch.Groups[0].Value;  					string classEnd = classStart[1] + "]";    					int classStartIndex = charClassStartMatchIndex;  					int classEndIndex = pattern.IndexOf(classEnd' classStartIndex + 2);    					if (classEndIndex == -1)  					{  						throw new NoClosingBracketException(classStartIndex' classStart' classEnd' pattern);  					}    					firstValidCharClassIndex = classEndIndex + 2;  					firstValidEndBracketIndex = firstValidCharClassIndex;  				}  				else  				{  					groupEnd = possibleGroupEnd;  				}  			} while (groupEnd == -1);
Magic Number,GitSharp.Core.FnMatch,GroupHead,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,The following statement contains a magic number: while (match.Success)              {                  string characterClass = match.Groups[0].Value;                    if (characterClass.Length == 3 && characterClass[1] == '-')                  {                      char start = characterClass[0];                      char end = characterClass[2];                      _characterClasses.Add(new CharacterRange(start' end));                  }                  else if (characterClass.Equals("[:alnum:]"))                  {                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:alpha:]"))                  {                      _characterClasses.Add(LetterPattern.Instance);                  }                  else if (characterClass.Equals("[:blank:]"))                  {                      _characterClasses.Add(new OneCharacterPattern(' '));                      _characterClasses.Add(new OneCharacterPattern('\t'));                  }                  else if (characterClass.Equals("[:cntrl:]"))                  {                      _characterClasses.Add(new CharacterRange('\u0000'' '\u001F'));                      _characterClasses.Add(new OneCharacterPattern('\u007F'));                  }                  else if (characterClass.Equals("[:digit:]"))                  {                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:graph:]"))                  {                      _characterClasses.Add(new CharacterRange('\u0021'' '\u007E'));                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:lower:]"))                  {                      _characterClasses.Add(LowerPattern.Instance);                  }                  else if (characterClass.Equals("[:print:]"))                  {                      _characterClasses.Add(new CharacterRange('\u0020'' '\u007E'));                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:punct:]"))                  {                      _characterClasses.Add(PunctPattern.Instance);                  }                  else if (characterClass.Equals("[:space:]"))                  {                      _characterClasses.Add(WhitespacePattern.Instance);                  }                  else if (characterClass.Equals("[:upper:]"))                  {                      _characterClasses.Add(UpperPattern.Instance);                  }                  else if (characterClass.Equals("[:xdigit:]"))                  {                      _characterClasses.Add(new CharacterRange('0'' '9'));                      _characterClasses.Add(new CharacterRange('a'' 'f'));                      _characterClasses.Add(new CharacterRange('A'' 'F'));                  }                  else if (characterClass.Equals("[:word:]"))                  {                      _characterClasses.Add(new OneCharacterPattern('_'));                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else                  {                      string message = string.Format("The character class \"{0}\" is not supported."' characterClass);                      throw new InvalidPatternException(message' wholePattern);                  }                    pattern = pattern.Replace(characterClass' string.Empty);                  match = RegexPattern.Match(pattern);              }
Magic Number,GitSharp.Core.FnMatch,GroupHead,C:\repos\henon_GitSharp\GitSharp.Core\FnMatch\GroupHead.cs,GroupHead,The following statement contains a magic number: while (match.Success)              {                  string characterClass = match.Groups[0].Value;                    if (characterClass.Length == 3 && characterClass[1] == '-')                  {                      char start = characterClass[0];                      char end = characterClass[2];                      _characterClasses.Add(new CharacterRange(start' end));                  }                  else if (characterClass.Equals("[:alnum:]"))                  {                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:alpha:]"))                  {                      _characterClasses.Add(LetterPattern.Instance);                  }                  else if (characterClass.Equals("[:blank:]"))                  {                      _characterClasses.Add(new OneCharacterPattern(' '));                      _characterClasses.Add(new OneCharacterPattern('\t'));                  }                  else if (characterClass.Equals("[:cntrl:]"))                  {                      _characterClasses.Add(new CharacterRange('\u0000'' '\u001F'));                      _characterClasses.Add(new OneCharacterPattern('\u007F'));                  }                  else if (characterClass.Equals("[:digit:]"))                  {                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:graph:]"))                  {                      _characterClasses.Add(new CharacterRange('\u0021'' '\u007E'));                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:lower:]"))                  {                      _characterClasses.Add(LowerPattern.Instance);                  }                  else if (characterClass.Equals("[:print:]"))                  {                      _characterClasses.Add(new CharacterRange('\u0020'' '\u007E'));                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else if (characterClass.Equals("[:punct:]"))                  {                      _characterClasses.Add(PunctPattern.Instance);                  }                  else if (characterClass.Equals("[:space:]"))                  {                      _characterClasses.Add(WhitespacePattern.Instance);                  }                  else if (characterClass.Equals("[:upper:]"))                  {                      _characterClasses.Add(UpperPattern.Instance);                  }                  else if (characterClass.Equals("[:xdigit:]"))                  {                      _characterClasses.Add(new CharacterRange('0'' '9'));                      _characterClasses.Add(new CharacterRange('a'' 'f'));                      _characterClasses.Add(new CharacterRange('A'' 'F'));                  }                  else if (characterClass.Equals("[:word:]"))                  {                      _characterClasses.Add(new OneCharacterPattern('_'));                      _characterClasses.Add(LetterPattern.Instance);                      _characterClasses.Add(DigitPattern.Instance);                  }                  else                  {                      string message = string.Format("The character class \"{0}\" is not supported."' characterClass);                      throw new InvalidPatternException(message' wholePattern);                  }                    pattern = pattern.Replace(characterClass' string.Empty);                  match = RegexPattern.Match(pattern);              }
Magic Number,GitSharp.Core.Merge,ThreeWayMerger,C:\repos\henon_GitSharp\GitSharp.Core\Merge\ThreeWayMerger.cs,Merge,The following statement contains a magic number: return tips.Length != 2 ? false : base.Merge(tips);
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: List<Sequence> sequences = new List<Sequence>(3);
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: while (theirsEdit != END_EDIT || oursEdit != END_EDIT)              {                  if (oursEdit.EndA <= theirsEdit.BeginA)                  {                      // something was changed in ours not overlapping with any change                      // from theirs. First add the common part in front of the edit                      // then the edit.                      if (current != oursEdit.BeginA)                      {                          result.add(0' current' oursEdit.BeginA'                              MergeChunk.ConflictState.NO_CONFLICT);                      }                      result.add(1' oursEdit.BeginB' oursEdit.EndB'                          MergeChunk.ConflictState.NO_CONFLICT);                      current = oursEdit.EndA;                      oursEdit = nextEdit(baseToOurs);                  }                  else if (theirsEdit.EndA <= oursEdit.BeginA)                  {                      // something was changed in theirs not overlapping with any                      // from ours. First add the common part in front of the edit                      // then the edit.                      if (current != theirsEdit.BeginA)                      {                          result.add(0' current' theirsEdit.BeginA'                              MergeChunk.ConflictState.NO_CONFLICT);                      }                      result.add(2' theirsEdit.BeginB' theirsEdit.EndB'                          MergeChunk.ConflictState.NO_CONFLICT);                      current = theirsEdit.EndA;                      theirsEdit = nextEdit(baseToTheirs);                  }                  else                  {                      // here we found a real overlapping modification                        // if there is a common part in front of the conflict add it                      if (oursEdit.BeginA != current                          && theirsEdit.BeginA != current)                      {                          result.add(0' current' Math.Min(oursEdit.BeginA'                              theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);                      }                        // set some initial values for the ranges in A and B which we                      // want to handle                      int oursBeginB = oursEdit.BeginB;                      int theirsBeginB = theirsEdit.BeginB;                      // harmonize the start of the ranges in A and B                      if (oursEdit.BeginA < theirsEdit.BeginA)                      {                          theirsBeginB -= theirsEdit.BeginA                              - oursEdit.BeginA;                      }                      else                      {                          oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;                      }                        // combine edits:                      // Maybe an Edit on one side corresponds to multiple Edits on                      // the other side. Then we have to combine the Edits of the                      // other side - so in the end we can merge together two single                      // edits.                      //                      // It is important to notice that this combining will extend the                      // ranges of our conflict always downwards (towards the end of                      // the content). The starts of the conflicting ranges in ours                      // and theirs are not touched here.                      //                      // This combining is an iterative process: after we have                      // combined some edits we have to do the check again. The                      // combined edits could now correspond to multiple edits on the                      // other side.                      //                      // Example: when this combining algorithm works on the following                      // edits                      // oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and                      // theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))                      // it will merge them into                      // oursEdits=((0-8'0-8)'(10-11'10-11)) and                      // theirsEdits=((0-7'0-7))                      //                      // Since the only interesting thing to us is how in ours and                      // theirs the end of the conflicting range is changing we let                      // oursEdit and theirsEdit point to the last conflicting edit                      Edit nextOursEdit = nextEdit(baseToOurs);                      Edit nextTheirsEdit = nextEdit(baseToTheirs);                      for (; ; )                      {                          if (oursEdit.EndA > nextTheirsEdit.BeginA)                          {                              theirsEdit = nextTheirsEdit;                              nextTheirsEdit = nextEdit(baseToTheirs);                          }                          else if (theirsEdit.EndA > nextOursEdit.BeginA)                          {                              oursEdit = nextOursEdit;                              nextOursEdit = nextEdit(baseToOurs);                          }                          else                          {                              break;                          }                      }                        // harmonize the end of the ranges in A and B                      int oursEndB = oursEdit.EndB;                      int theirsEndB = theirsEdit.EndB;                      if (oursEdit.EndA < theirsEdit.EndA)                      {                          oursEndB += theirsEdit.EndA - oursEdit.EndA;                      }                      else                      {                          theirsEndB += oursEdit.EndA - theirsEdit.EndA;                      }                        // Add the conflict                      result.add(1' oursBeginB' oursEndB'                          MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);                      result.add(2' theirsBeginB' theirsEndB'                          MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);                        current = Math.Max(oursEdit.EndA' theirsEdit.EndA);                      oursEdit = nextOursEdit;                      theirsEdit = nextTheirsEdit;                  }              }
Magic Number,GitSharp.Core.Merge,MergeAlgorithm,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeAlgorithm.cs,merge,The following statement contains a magic number: while (theirsEdit != END_EDIT || oursEdit != END_EDIT)              {                  if (oursEdit.EndA <= theirsEdit.BeginA)                  {                      // something was changed in ours not overlapping with any change                      // from theirs. First add the common part in front of the edit                      // then the edit.                      if (current != oursEdit.BeginA)                      {                          result.add(0' current' oursEdit.BeginA'                              MergeChunk.ConflictState.NO_CONFLICT);                      }                      result.add(1' oursEdit.BeginB' oursEdit.EndB'                          MergeChunk.ConflictState.NO_CONFLICT);                      current = oursEdit.EndA;                      oursEdit = nextEdit(baseToOurs);                  }                  else if (theirsEdit.EndA <= oursEdit.BeginA)                  {                      // something was changed in theirs not overlapping with any                      // from ours. First add the common part in front of the edit                      // then the edit.                      if (current != theirsEdit.BeginA)                      {                          result.add(0' current' theirsEdit.BeginA'                              MergeChunk.ConflictState.NO_CONFLICT);                      }                      result.add(2' theirsEdit.BeginB' theirsEdit.EndB'                          MergeChunk.ConflictState.NO_CONFLICT);                      current = theirsEdit.EndA;                      theirsEdit = nextEdit(baseToTheirs);                  }                  else                  {                      // here we found a real overlapping modification                        // if there is a common part in front of the conflict add it                      if (oursEdit.BeginA != current                          && theirsEdit.BeginA != current)                      {                          result.add(0' current' Math.Min(oursEdit.BeginA'                              theirsEdit.BeginA)' MergeChunk.ConflictState.NO_CONFLICT);                      }                        // set some initial values for the ranges in A and B which we                      // want to handle                      int oursBeginB = oursEdit.BeginB;                      int theirsBeginB = theirsEdit.BeginB;                      // harmonize the start of the ranges in A and B                      if (oursEdit.BeginA < theirsEdit.BeginA)                      {                          theirsBeginB -= theirsEdit.BeginA                              - oursEdit.BeginA;                      }                      else                      {                          oursBeginB -= oursEdit.BeginA - theirsEdit.BeginA;                      }                        // combine edits:                      // Maybe an Edit on one side corresponds to multiple Edits on                      // the other side. Then we have to combine the Edits of the                      // other side - so in the end we can merge together two single                      // edits.                      //                      // It is important to notice that this combining will extend the                      // ranges of our conflict always downwards (towards the end of                      // the content). The starts of the conflicting ranges in ours                      // and theirs are not touched here.                      //                      // This combining is an iterative process: after we have                      // combined some edits we have to do the check again. The                      // combined edits could now correspond to multiple edits on the                      // other side.                      //                      // Example: when this combining algorithm works on the following                      // edits                      // oursEdits=((0-5'0-5)'(6-8'6-8)'(10-11'10-11)) and                      // theirsEdits=((0-1'0-1)'(2-3'2-3)'(5-7'5-7))                      // it will merge them into                      // oursEdits=((0-8'0-8)'(10-11'10-11)) and                      // theirsEdits=((0-7'0-7))                      //                      // Since the only interesting thing to us is how in ours and                      // theirs the end of the conflicting range is changing we let                      // oursEdit and theirsEdit point to the last conflicting edit                      Edit nextOursEdit = nextEdit(baseToOurs);                      Edit nextTheirsEdit = nextEdit(baseToTheirs);                      for (; ; )                      {                          if (oursEdit.EndA > nextTheirsEdit.BeginA)                          {                              theirsEdit = nextTheirsEdit;                              nextTheirsEdit = nextEdit(baseToTheirs);                          }                          else if (theirsEdit.EndA > nextOursEdit.BeginA)                          {                              oursEdit = nextOursEdit;                              nextOursEdit = nextEdit(baseToOurs);                          }                          else                          {                              break;                          }                      }                        // harmonize the end of the ranges in A and B                      int oursEndB = oursEdit.EndB;                      int theirsEndB = theirsEdit.EndB;                      if (oursEdit.EndA < theirsEdit.EndA)                      {                          oursEndB += theirsEdit.EndA - oursEdit.EndA;                      }                      else                      {                          theirsEndB += oursEdit.EndA - theirsEdit.EndA;                      }                        // Add the conflict                      result.add(1' oursBeginB' oursEndB'                          MergeChunk.ConflictState.FIRST_CONFLICTING_RANGE);                      result.add(2' theirsBeginB' theirsEndB'                          MergeChunk.ConflictState.NEXT_CONFLICTING_RANGE);                        current = Math.Max(oursEdit.EndA' theirsEdit.EndA);                      oursEdit = nextOursEdit;                      theirsEdit = nextTheirsEdit;                  }              }
Magic Number,GitSharp.Core.Merge,MergeFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeFormatter.cs,formatMerge,The following statement contains a magic number: bool threeWayMerge = (res.getSequences().Count == 3);
Magic Number,GitSharp.Core.Merge,MergeFormatter,C:\repos\henon_GitSharp\GitSharp.Core\Merge\MergeFormatter.cs,formatMerge,The following statement contains a magic number: var names = new List<String>(3);
Magic Number,GitSharp.Core.RevWalk,Block,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\BlockObjQueue.cs,resetToMiddle,The following statement contains a magic number: HeadIndex = TailIndex = BLOCK_SIZE / 2;
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: idBuffer.FromString(raw' 5);
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: int ptr = 46;
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null)  			{  				var pList = new RevCommit[1];  				int nParents = 0;    				while (true)  				{  					if (raw[ptr] != (byte)'p') break;  					idBuffer.FromString(raw' ptr + 7);  					RevCommit p = walk.lookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else if (nParents == 1)  					{  						pList = new[] { pList[0]' p };  						nParents = 2;  					}  					else  					{  						if (pList.Length <= nParents)  						{  							RevCommit[] old = pList;  							pList = new RevCommit[pList.Length + 32];  							Array.Copy(old' 0' pList' 0' nParents);  						}  						pList[nParents++] = p;  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					RevCommit[] old = pList;  					pList = new RevCommit[nParents];  					Array.Copy(old' 0' pList' 0' nParents);  				}  				Parents = pList;  			}
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null)  			{  				var pList = new RevCommit[1];  				int nParents = 0;    				while (true)  				{  					if (raw[ptr] != (byte)'p') break;  					idBuffer.FromString(raw' ptr + 7);  					RevCommit p = walk.lookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else if (nParents == 1)  					{  						pList = new[] { pList[0]' p };  						nParents = 2;  					}  					else  					{  						if (pList.Length <= nParents)  						{  							RevCommit[] old = pList;  							pList = new RevCommit[pList.Length + 32];  							Array.Copy(old' 0' pList' 0' nParents);  						}  						pList[nParents++] = p;  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					RevCommit[] old = pList;  					pList = new RevCommit[nParents];  					Array.Copy(old' 0' pList' 0' nParents);  				}  				Parents = pList;  			}
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null)  			{  				var pList = new RevCommit[1];  				int nParents = 0;    				while (true)  				{  					if (raw[ptr] != (byte)'p') break;  					idBuffer.FromString(raw' ptr + 7);  					RevCommit p = walk.lookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else if (nParents == 1)  					{  						pList = new[] { pList[0]' p };  						nParents = 2;  					}  					else  					{  						if (pList.Length <= nParents)  						{  							RevCommit[] old = pList;  							pList = new RevCommit[pList.Length + 32];  							Array.Copy(old' 0' pList' 0' nParents);  						}  						pList[nParents++] = p;  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					RevCommit[] old = pList;  					pList = new RevCommit[nParents];  					Array.Copy(old' 0' pList' 0' nParents);  				}  				Parents = pList;  			}
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,parseCanonical,The following statement contains a magic number: if (Parents == null)  			{  				var pList = new RevCommit[1];  				int nParents = 0;    				while (true)  				{  					if (raw[ptr] != (byte)'p') break;  					idBuffer.FromString(raw' ptr + 7);  					RevCommit p = walk.lookupCommit(idBuffer);  					if (nParents == 0)  					{  						pList[nParents++] = p;  					}  					else if (nParents == 1)  					{  						pList = new[] { pList[0]' p };  						nParents = 2;  					}  					else  					{  						if (pList.Length <= nParents)  						{  							RevCommit[] old = pList;  							pList = new RevCommit[pList.Length + 32];  							Array.Copy(old' 0' pList' 0' nParents);  						}  						pList[nParents++] = p;  					}  					ptr += 48;  				}  				if (nParents != pList.Length)  				{  					RevCommit[] old = pList;  					pList = new RevCommit[nParents];  					Array.Copy(old' 0' pList' 0' nParents);  				}  				Parents = pList;  			}
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,GetFooterLines,The following statement contains a magic number: var r = new List<FooterLine>(4);
Magic Number,GitSharp.Core.RevWalk,RevCommit,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevCommit.cs,GetFooterLines,The following statement contains a magic number: while (true)  			{  				ptr = RawParseUtils.prevLF(raw' ptr);  				if (ptr <= msgB)  				{  					break; // Don't parse commit headers as footer lines.  				}    				int keyStart = ptr + 2;  				if (raw[keyStart] == '\n')  				{  					break; // Stop at first paragraph break' no footers above it.  				}    				int keyEnd = RawParseUtils.endOfFooterLineKey(raw' keyStart);  				if (keyEnd < 0)  				{  					continue; // Not a well formed footer line' skip it.  				}    				// Skip over the ': *' at the end of the key before the value.  				//  				int valStart = keyEnd + 1;  				while (valStart < raw.Length && raw[valStart] == ' ')  				{  					valStart++;  				}    				// Value ends at the LF' and does not include it.  				//  				int valEnd = RawParseUtils.nextLF(raw' valStart);  				if (raw[valEnd - 1] == '\n')  				{  					valEnd--;  				}    				r.Add(new FooterLine(raw' enc' keyStart' keyEnd' valStart' valEnd));  			}
Magic Number,GitSharp.Core.RevWalk,RevObjectList<T>,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevObjectList.cs,get,The following statement contains a magic number: if (index >> s.Shift >= 1024)  			{  				return null;  			}
Magic Number,GitSharp.Core.RevWalk,RevTag,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevTag.cs,parseCanonical,The following statement contains a magic number: var pos = new MutableInteger { value = 53 };
Magic Number,GitSharp.Core.RevWalk,RevTag,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevTag.cs,parseCanonical,The following statement contains a magic number: walk.IdBuffer.FromString(rawTag' 7);
Magic Number,GitSharp.Core.RevWalk,RevTag,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevTag.cs,parseCanonical,The following statement contains a magic number: int p = pos.value += 4;
Magic Number,GitSharp.Core.RevWalk,RevWalk,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\RevWalk.cs,allocFlag,The following statement contains a magic number: if (_freeFlags == 0)  			{  				throw new ArgumentException(32 - ReservedFlags + " flags already created.");  			}
Magic Number,GitSharp.Core.Transport,OpenSshConfig,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,The following statement contains a magic number: var current = new List<Host>(4);
Magic Number,GitSharp.Core.Transport,OpenSshConfig,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,parse,The following statement contains a magic number: while ((line = sr.ReadLine()) != null)              {                  line = line.Trim();                  if (line.Length == 0 || line.StartsWith("#"))                      continue;                    var regex = new Regex("[ \t]*[= \t]");                    string[] parts = regex.Split(line' 2);                  string keyword = parts[0].Trim();                  string argValue = parts[1].Trim();                    var regex2 = new Regex("[ \t]");                  if (StringUtils.equalsIgnoreCase("Host"' keyword))                  {                      current.Clear();                      foreach (string pattern in regex2.Split(argValue))                      {                          string name = dequote(pattern);                          Host c = m.get(name);                          if (c == null)                          {                              c = new Host();                              m.put(name' c);                          }                          current.Add(c);                      }                      continue;                  }                    if (current.isEmpty())                  {                      // We received an option outside of a Host block. We                      // don't know who this should match against' so skip.                      //                      continue;                  }                    if (StringUtils.equalsIgnoreCase("HostName"' keyword))                  {                      foreach (Host c in current)                          if (c.hostName == null)                              c.hostName = dequote(argValue);                  }                  else if (StringUtils.equalsIgnoreCase("User"' keyword))                  {                      foreach (Host c in current)                          if (c.user == null)                              c.user = dequote(argValue);                  }                  else if (StringUtils.equalsIgnoreCase("Port"' keyword))                  {                      try                      {                          int port = int.Parse(dequote(argValue));                          foreach (Host c in current)                              if (c.port == 0)                                  c.port = port;                      }                      catch (FormatException)                      {                          // Bad port number. Don't set it.                      }                  }                  else if (StringUtils.equalsIgnoreCase("IdentityFile"' keyword))                  {                      foreach (Host c in current)                          if (c.identityFile == null)                              c.identityFile = toFile(dequote(argValue));                  }                  else if (StringUtils.equalsIgnoreCase("PreferredAuthentications"' keyword))                  {                      foreach (Host c in current)                          if (c.preferredAuthentications == null)                              c.preferredAuthentications = nows(dequote(argValue));                  }                  else if (StringUtils.equalsIgnoreCase("BatchMode"' keyword))                  {                      foreach (Host c in current)                          if (c.batchMode == null)                              c.batchMode = yesno(dequote(argValue));                  }                  else if (StringUtils.equalsIgnoreCase("StrictHostKeyChecking"' keyword))                  {                      string value = dequote(argValue);                      foreach (Host c in current)                          if (c.strictHostKeyChecking == null)                              c.strictHostKeyChecking = value;                  }              }
Magic Number,GitSharp.Core.Transport,OpenSshConfig,C:\repos\henon_GitSharp\GitSharp.Core\Transport\OpenSshConfig.cs,toFile,The following statement contains a magic number: if (path.StartsWith("~/"))              {                  return PathUtil.CombineFilePath(_home' path.Substring(2));              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (!_output && now - _taskBeganAt < 500)                  return;
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  if (now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }              else              {                  if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  if (now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }              else              {                  if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  if (now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }              else              {                  if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,Update,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  if (now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }              else              {                  if ((cmp * 100 / _totalWork) != (_lastWorked * 100) / _totalWork || now - _lastOutput >= 500)                  {                      display(cmp' null);                      _lastOutput = now;                  }              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  m.Append(cmp);              }              else              {                  int pcnt = (cmp * 100 / _totalWork);                  if (pcnt < 100)                      m.Append(' ');                  if (pcnt < 10)                      m.Append(' ');                  m.Append(pcnt);                  m.Append("% (");                  m.Append(cmp);                  m.Append("/");                  m.Append(_totalWork);                  m.Append(")");              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  m.Append(cmp);              }              else              {                  int pcnt = (cmp * 100 / _totalWork);                  if (pcnt < 100)                      m.Append(' ');                  if (pcnt < 10)                      m.Append(' ');                  m.Append(pcnt);                  m.Append("% (");                  m.Append(cmp);                  m.Append("/");                  m.Append(_totalWork);                  m.Append(")");              }
Magic Number,GitSharp.Core.Transport,SideBandProgressMonitor,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandProgressMonitor.cs,display,The following statement contains a magic number: if (_totalWork == UNKNOWN)              {                  m.Append(cmp);              }              else              {                  int pcnt = (cmp * 100 / _totalWork);                  if (pcnt < 100)                      m.Append(' ');                  if (pcnt < 10)                      m.Append(' ');                  m.Append(pcnt);                  m.Append("% (");                  m.Append(cmp);                  m.Append("/");                  m.Append(_totalWork);                  m.Append(")");              }
Magic Number,GitSharp.Core.Transport,SshTransport,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SshTransport.cs,InitSession,The following statement contains a magic number: int tms = Timeout > 0 ? Timeout * 1000 : 0;
Magic Number,GitSharp.Core.Transport,TransportGitSsh,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,commandFor,The following statement contains a magic number: if (gitspace >= 0)              {                  SqMinimal(cmd' exe.Slice(0' gitspace + 3));                  cmd.Append(' ');                  SqMinimal(cmd' exe.Substring(gitspace + 4));              }              else                  SqMinimal(cmd' exe);
Magic Number,GitSharp.Core.Transport,TransportGitSsh,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,commandFor,The following statement contains a magic number: if (gitspace >= 0)              {                  SqMinimal(cmd' exe.Slice(0' gitspace + 3));                  cmd.Append(' ');                  SqMinimal(cmd' exe.Substring(gitspace + 4));              }              else                  SqMinimal(cmd' exe);
Magic Number,GitSharp.Core.Transport,TransportGitSsh,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportGitSsh.cs,checkExecFailure,The following statement contains a magic number: if (status == 127)              {                  String why = _errStream.ToString();                  IOException cause = null;                  if (why != null && why.Length > 0)                      cause = new IOException(why);                  throw new TransportException(Uri' "cannot execute: "                          + commandFor(exe)' cause);              }
Magic Number,GitSharp.Core.Transport,HttpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportHttp.cs,getPackNames,The following statement contains a magic number: try                  {                      using (StreamReader br = openReader(INFO_PACKS))                      {                          while (true)                          {                              string s = br.ReadLine();                              if (string.IsNullOrEmpty(s)) break;                                if (!s.StartsWith("P pack-") || !s.EndsWith(IndexPack.PackSuffix))                              {                                  throw InvalidAdvertisement(s);                              }                              packs.Add(s.Substring(2));                          }                            return packs;                      }                  }                  catch (FileNotFoundException)                  {                      return packs;                  }
Magic Number,GitSharp.Core.Transport,HttpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportHttp.cs,ReadAdvertisedImpl,The following statement contains a magic number: while (true)                  {                      string line = br.ReadLine();                      if (line == null) break;                        int tab = line.IndexOf('\t');                      if (tab < 0)                      {                          throw InvalidAdvertisement(line);                      }                        string name = line.Substring(tab + 1);                      ObjectId id = ObjectId.FromString(line.Slice(0' tab));                      if (name.EndsWith("^{}"))                      {                          name = name.Slice(0' name.Length - 3);                          Ref prior = avail.get(name);                          if (prior == null)                          {                              throw OutOfOrderAdvertisement(name);                          }                            if (prior.PeeledObjectId != null)                          {                              throw DuplicateAdvertisement(name + "^{}");                          }                            avail.put(name' new PeeledTag(Storage.Network' name' prior.ObjectId' id));                      }                      else                      {                          Ref prior = avail.put(name' new PeeledNonTag(Storage.Network' name' id));                            if (prior != null)                          {                              throw DuplicateAdvertisement(name);                          }                      }                  }
Magic Number,GitSharp.Core.Transport,SftpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportSftp.cs,SftpObjectDatabase,The following statement contains a magic number: if (path.StartsWith("~/"))                  {                      path = path.Substring(2);                  }
Magic Number,GitSharp.Core.Transport,SftpObjectDatabase,C:\repos\henon_GitSharp\GitSharp.Core\Transport\TransportSftp.cs,getPackNames,The following statement contains a magic number: try                  {                      var list = new List<ChannelSftp.LsEntry>();                      foreach (object o in _ftp.ls("pack")) list.Add((ChannelSftp.LsEntry)o);                        var files = new Dictionary<string' ChannelSftp.LsEntry>();                      var mtimes = new Dictionary<string' int>();                        foreach (ChannelSftp.LsEntry ent in list)                      {                          files.Add(ent.getFilename()' ent);                      }                        foreach (ChannelSftp.LsEntry ent in list)                      {                          string n = ent.getFilename();                          if (!n.StartsWith("pack-") || n.EndsWith(IndexPack.PackSuffix)) continue;                            string @in = IndexPack.GetIndexFileName(n.Slice(0' n.Length - 5));                          if (!files.ContainsKey(@in)) continue;                            mtimes.Add(n' ent.getAttrs().getMTime());                          packs.Add(n);                      }                        packs.Sort((a' b) => mtimes[a] - mtimes[b]);                  }                  catch (SftpException je)                  {                      throw new TransportException("Can't ls " + _objectsPath + "/pack: " + je.message' je);                  }
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,WalkFetchConnection,The following statement contains a magic number: _packLocks = new List<PackLock>(4);
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,The following statement contains a magic number: while (true)              {                  // Try a pack file we know about' but don't have yet. Odds are                  // that if it has this object' it has others related to it so                  // getting the pack is a good bet.                  //                  if (DownloadPackedObject(pm' id))                      return;                    // Search for a loose object over all alternates' starting                  // from the one we last successfully located an object through.                  //                  string idStr = id.Name;                  string subdir = idStr.Slice(0' 2);                  string file = idStr.Substring(2);                  string looseName = subdir + "/" + file;                    for (int i = _lastRemoteIdx; i < _remotes.Count; i++)                  {                      if (DownloadLooseObject(id' looseName' _remotes[i]))                      {                          _lastRemoteIdx = i;                          return;                      }                  }                    for (int i = 0; i < _lastRemoteIdx; i++)                  {                      if (DownloadLooseObject(id' looseName' _remotes[i]))                      {                          _lastRemoteIdx = i;                          return;                      }                  }                    // Try to obtain more pack information and search those.                  //                  while (_noPacksYet.Count > 0)                  {                      WalkRemoteObjectDatabase wrr = _noPacksYet.First.Value;                      _noPacksYet.RemoveFirst();                      ICollection<string> packNameList;                      try                      {                          pm.BeginTask("Listing packs"' ProgressMonitor.UNKNOWN);                          packNameList = wrr.getPackNames();                      }                      catch (IOException e)                      {                          // Try another repository.                          //                          RecordError(id' e);                          continue;                      }                      finally                      {                          pm.EndTask();                      }                        if (packNameList == null || packNameList.Count == 0)                          continue;                      foreach (string packName in packNameList)                      {                          bool contains = _packsConsidered.Contains(packName);                          _packsConsidered.Add(packName);                          if (!contains)                          {                              _unfetchedPacks.AddLast(new RemotePack(_lockMessage' _packLocks' _objCheck' _local' wrr' packName));                          }                      }                      if (DownloadPackedObject(pm' id))                          return;                  }                    // Try to expand the first alternate we haven't expanded yet.                  //                  ICollection<WalkRemoteObjectDatabase> al = ExpandOneAlternate(id' pm);                  if (al != null && al.Count > 0)                  {                      foreach (WalkRemoteObjectDatabase alt in al)                      {                          _remotes.Add(alt);                          _noPacksYet.AddLast(alt);                          _noAlternatesYet.AddLast(alt);                      }                      continue;                  }                    // We could not obtain the object. There may be reasons why.                  //                  List<Exception> failures = _fetchErrors.get(id.Copy());                    var te = new TransportException("Cannot get " + id.Name + ".");                    if (failures != null && failures.Count > 0)                  {                      te = failures.Count == 1 ?                          new TransportException("Cannot get " + id.Name + "."' failures[0]) :                          new TransportException("Cannot get " + id.Name + "."' new CompoundException(failures));                  }                    throw te;              }
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,DownloadObject,The following statement contains a magic number: while (true)              {                  // Try a pack file we know about' but don't have yet. Odds are                  // that if it has this object' it has others related to it so                  // getting the pack is a good bet.                  //                  if (DownloadPackedObject(pm' id))                      return;                    // Search for a loose object over all alternates' starting                  // from the one we last successfully located an object through.                  //                  string idStr = id.Name;                  string subdir = idStr.Slice(0' 2);                  string file = idStr.Substring(2);                  string looseName = subdir + "/" + file;                    for (int i = _lastRemoteIdx; i < _remotes.Count; i++)                  {                      if (DownloadLooseObject(id' looseName' _remotes[i]))                      {                          _lastRemoteIdx = i;                          return;                      }                  }                    for (int i = 0; i < _lastRemoteIdx; i++)                  {                      if (DownloadLooseObject(id' looseName' _remotes[i]))                      {                          _lastRemoteIdx = i;                          return;                      }                  }                    // Try to obtain more pack information and search those.                  //                  while (_noPacksYet.Count > 0)                  {                      WalkRemoteObjectDatabase wrr = _noPacksYet.First.Value;                      _noPacksYet.RemoveFirst();                      ICollection<string> packNameList;                      try                      {                          pm.BeginTask("Listing packs"' ProgressMonitor.UNKNOWN);                          packNameList = wrr.getPackNames();                      }                      catch (IOException e)                      {                          // Try another repository.                          //                          RecordError(id' e);                          continue;                      }                      finally                      {                          pm.EndTask();                      }                        if (packNameList == null || packNameList.Count == 0)                          continue;                      foreach (string packName in packNameList)                      {                          bool contains = _packsConsidered.Contains(packName);                          _packsConsidered.Add(packName);                          if (!contains)                          {                              _unfetchedPacks.AddLast(new RemotePack(_lockMessage' _packLocks' _objCheck' _local' wrr' packName));                          }                      }                      if (DownloadPackedObject(pm' id))                          return;                  }                    // Try to expand the first alternate we haven't expanded yet.                  //                  ICollection<WalkRemoteObjectDatabase> al = ExpandOneAlternate(id' pm);                  if (al != null && al.Count > 0)                  {                      foreach (WalkRemoteObjectDatabase alt in al)                      {                          _remotes.Add(alt);                          _noPacksYet.AddLast(alt);                          _noAlternatesYet.AddLast(alt);                      }                      continue;                  }                    // We could not obtain the object. There may be reasons why.                  //                  List<Exception> failures = _fetchErrors.get(id.Copy());                    var te = new TransportException("Cannot get " + id.Name + ".");                    if (failures != null && failures.Count > 0)                  {                      te = failures.Count == 1 ?                          new TransportException("Cannot get " + id.Name + "."' failures[0]) :                          new TransportException("Cannot get " + id.Name + "."' new CompoundException(failures));                  }                    throw te;              }
Magic Number,GitSharp.Core.Transport,WalkFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RecordError,The following statement contains a magic number: if (errors == null)              {                  errors = new List<Exception>(2);                  _fetchErrors.put(objId' errors);              }
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RemotePack,The following statement contains a magic number: _idxName = IndexPack.GetIndexFileName(PackName.Slice(0' PackName.Length - 5));
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RemotePack,The following statement contains a magic number: if (tn.StartsWith("pack-"))                  {                      tn = tn.Substring(5);                  }
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,RemotePack,The following statement contains a magic number: if (tn.EndsWith(IndexPack.IndexSuffix))                  {                      tn = tn.Slice(0' tn.Length - 4);                  }
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: using (Stream s = _connection.open("pack/" + _idxName))                  {                      pm.BeginTask("Get " + _idxName.Slice(0' 12) + "..idx"' !s.CanSeek ? ProgressMonitor.UNKNOWN : (int)(s.Length / 1024));                        try                      {                          using (var fos = new FileStream(TmpIdx.FullName' System.IO.FileMode.CreateNew' FileAccess.Write))                          {                              var buf = new byte[2048];                              int cnt;                              while (!pm.IsCancelled && (cnt = s.Read(buf' 0' buf.Length)) > 0)                              {                                  fos.Write(buf' 0' cnt);                                  pm.Update(cnt / 1024);                              }                          }                      }                      catch (IOException)                      {                          TmpIdx.DeleteFile();                          throw;                      }                  }
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: using (Stream s = _connection.open("pack/" + _idxName))                  {                      pm.BeginTask("Get " + _idxName.Slice(0' 12) + "..idx"' !s.CanSeek ? ProgressMonitor.UNKNOWN : (int)(s.Length / 1024));                        try                      {                          using (var fos = new FileStream(TmpIdx.FullName' System.IO.FileMode.CreateNew' FileAccess.Write))                          {                              var buf = new byte[2048];                              int cnt;                              while (!pm.IsCancelled && (cnt = s.Read(buf' 0' buf.Length)) > 0)                              {                                  fos.Write(buf' 0' cnt);                                  pm.Update(cnt / 1024);                              }                          }                      }                      catch (IOException)                      {                          TmpIdx.DeleteFile();                          throw;                      }                  }
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: using (Stream s = _connection.open("pack/" + _idxName))                  {                      pm.BeginTask("Get " + _idxName.Slice(0' 12) + "..idx"' !s.CanSeek ? ProgressMonitor.UNKNOWN : (int)(s.Length / 1024));                        try                      {                          using (var fos = new FileStream(TmpIdx.FullName' System.IO.FileMode.CreateNew' FileAccess.Write))                          {                              var buf = new byte[2048];                              int cnt;                              while (!pm.IsCancelled && (cnt = s.Read(buf' 0' buf.Length)) > 0)                              {                                  fos.Write(buf' 0' cnt);                                  pm.Update(cnt / 1024);                              }                          }                      }                      catch (IOException)                      {                          TmpIdx.DeleteFile();                          throw;                      }                  }
Magic Number,GitSharp.Core.Transport,RemotePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,OpenIndex,The following statement contains a magic number: using (Stream s = _connection.open("pack/" + _idxName))                  {                      pm.BeginTask("Get " + _idxName.Slice(0' 12) + "..idx"' !s.CanSeek ? ProgressMonitor.UNKNOWN : (int)(s.Length / 1024));                        try                      {                          using (var fos = new FileStream(TmpIdx.FullName' System.IO.FileMode.CreateNew' FileAccess.Write))                          {                              var buf = new byte[2048];                              int cnt;                              while (!pm.IsCancelled && (cnt = s.Read(buf' 0' buf.Length)) > 0)                              {                                  fos.Write(buf' 0' cnt);                                  pm.Update(cnt / 1024);                              }                          }                      }                      catch (IOException)                      {                          TmpIdx.DeleteFile();                          throw;                      }                  }
Magic Number,GitSharp.Core.Transport,WalkPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkPushConnection.cs,Sendpack,The following statement contains a magic number: try              {                  var pw = new PackWriter(_local' monitor);                  var need = new List<ObjectId>();                  var have = new List<ObjectId>();                    foreach (RemoteRefUpdate r in updates)                  {                      need.Add(r.NewObjectId);                  }                    foreach (Ref r in Refs)                  {                      have.Add(r.ObjectId);                      if (r.PeeledObjectId != null)                      {                          have.Add(r.PeeledObjectId);                      }                  }                  pw.preparePack(need' have);                    // We don't have to continue further if the pack will                  // be an empty pack' as the remote has all objects it                  // needs to complete this change.                  //                  if (pw.getObjectsNumber() == 0) return;                    _packNames = new Dictionary<string' string>();                  foreach (string n in _dest.getPackNames())                  {                      _packNames.put(n' n);                  }                    string b = "pack-" + pw.computeName().Name;                  string packName = b + IndexPack.PackSuffix;                  pathPack = "pack/" + packName;                  pathIdx = "pack/" + b + IndexPack.IndexSuffix;                    if (_packNames.remove(packName) != null)                  {                      // The remote already contains this pack. We should                      // remove the index before overwriting to prevent bad                      // offsets from appearing to clients.                      //                      _dest.writeInfoPacks(_packNames.Keys);                      _dest.deleteFile(pathIdx);                  }                    // Write the pack file' then the index' as readers look the                  // other direction (index' then pack file).                  //                  string wt = "Put " + b.Slice(0' 12);                  using (Stream os = _dest.writeFile(pathPack' monitor' wt + "." + IndexPack.PackSuffix))                  {                      pw.writePack(os);                  }                    using (Stream os = _dest.writeFile(pathIdx' monitor' wt + "." + IndexPack.IndexSuffix))                  {                      pw.writeIndex(os);                  }                    // Record the pack at the start of the pack info list. This                  // way clients are likely to consult the newest pack first'                  // and discover the most recent objects there.                  //                  var infoPacks = new List<string> { packName };                  infoPacks.AddRange(_packNames.Keys);                  _dest.writeInfoPacks(infoPacks);              }              catch (IOException err)              {                  SafeDelete(pathIdx);                  SafeDelete(pathPack);                    throw new TransportException(_uri' "cannot store objects"' err);              }
Magic Number,GitSharp.Core.Transport,BasePackConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: while (true)              {                  string line;                    try                  {                      line = pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (avail.Count == 0)                      {                          throw noRepository();                      }                        throw;                  }                    if (line == PacketLineIn.END)                      break;                    if (avail.Count == 0)                  {                      int nul = line.IndexOf('\0');                      if (nul >= 0)                      {                          // The first line (if any) may contain "hidden"                          // capability values after a NUL byte.                          foreach (string c in line.Substring(nul + 1).Split(' '))                              remoteCapabilies.Add(c);                          line = line.Slice(0' nul);                      }                  }                    string name = line.Slice(41' line.Length);                  if (avail.Count == 0 && name.Equals("capabilities^{}"))                  {                      // special line from git-receive-pack to show                      // capabilities when there are no refs to advertise                      continue;                  }                    ObjectId id = ObjectId.FromString(line.Slice(0' 40));                  if (name.Equals(".have"))                      additionalHaves.Add(id);                  else if (name.EndsWith("^{}"))                  {                      name = name.Slice(0' name.Length - 3);                      Ref prior = avail.get(name);                      if (prior == null)                          throw new PackProtocolException(uri' "advertisement of " + name + "^{} came before " + name);                        if (prior.PeeledObjectId != null)                          throw duplicateAdvertisement(name + "^{}");                        avail.put(name' new PeeledTag(Storage.Network' name' prior.ObjectId' id));                  }                  else                  {                      Ref prior = avail.put(name' new PeeledNonTag(Storage.Network' name' id));                      if (prior != null)                          throw duplicateAdvertisement(name);                                        }              }
Magic Number,GitSharp.Core.Transport,BasePackConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: while (true)              {                  string line;                    try                  {                      line = pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (avail.Count == 0)                      {                          throw noRepository();                      }                        throw;                  }                    if (line == PacketLineIn.END)                      break;                    if (avail.Count == 0)                  {                      int nul = line.IndexOf('\0');                      if (nul >= 0)                      {                          // The first line (if any) may contain "hidden"                          // capability values after a NUL byte.                          foreach (string c in line.Substring(nul + 1).Split(' '))                              remoteCapabilies.Add(c);                          line = line.Slice(0' nul);                      }                  }                    string name = line.Slice(41' line.Length);                  if (avail.Count == 0 && name.Equals("capabilities^{}"))                  {                      // special line from git-receive-pack to show                      // capabilities when there are no refs to advertise                      continue;                  }                    ObjectId id = ObjectId.FromString(line.Slice(0' 40));                  if (name.Equals(".have"))                      additionalHaves.Add(id);                  else if (name.EndsWith("^{}"))                  {                      name = name.Slice(0' name.Length - 3);                      Ref prior = avail.get(name);                      if (prior == null)                          throw new PackProtocolException(uri' "advertisement of " + name + "^{} came before " + name);                        if (prior.PeeledObjectId != null)                          throw duplicateAdvertisement(name + "^{}");                        avail.put(name' new PeeledTag(Storage.Network' name' prior.ObjectId' id));                  }                  else                  {                      Ref prior = avail.put(name' new PeeledNonTag(Storage.Network' name' id));                      if (prior != null)                          throw duplicateAdvertisement(name);                                        }              }
Magic Number,GitSharp.Core.Transport,BasePackConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackConnection.cs,readAdvertisedRefsImpl,The following statement contains a magic number: while (true)              {                  string line;                    try                  {                      line = pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (avail.Count == 0)                      {                          throw noRepository();                      }                        throw;                  }                    if (line == PacketLineIn.END)                      break;                    if (avail.Count == 0)                  {                      int nul = line.IndexOf('\0');                      if (nul >= 0)                      {                          // The first line (if any) may contain "hidden"                          // capability values after a NUL byte.                          foreach (string c in line.Substring(nul + 1).Split(' '))                              remoteCapabilies.Add(c);                          line = line.Slice(0' nul);                      }                  }                    string name = line.Slice(41' line.Length);                  if (avail.Count == 0 && name.Equals("capabilities^{}"))                  {                      // special line from git-receive-pack to show                      // capabilities when there are no refs to advertise                      continue;                  }                    ObjectId id = ObjectId.FromString(line.Slice(0' 40));                  if (name.Equals(".have"))                      additionalHaves.Add(id);                  else if (name.EndsWith("^{}"))                  {                      name = name.Slice(0' name.Length - 3);                      Ref prior = avail.get(name);                      if (prior == null)                          throw new PackProtocolException(uri' "advertisement of " + name + "^{} came before " + name);                        if (prior.PeeledObjectId != null)                          throw duplicateAdvertisement(name + "^{}");                        avail.put(name' new PeeledTag(Storage.Network' name' prior.ObjectId' id));                  }                  else                  {                      Ref prior = avail.put(name' new PeeledNonTag(Storage.Network' name' id));                      if (prior != null)                          throw duplicateAdvertisement(name);                                        }              }
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,SendWants,The following statement contains a magic number: foreach (Ref r in want)              {                  try                  {                      if (_walk.parseAny(r.ObjectId).has(REACHABLE))                      {                          // We already have this object. Asking for it is                          // not a very good idea.                          //                          continue;                      }                  }                  catch (IOException)                  {                      // Its OK' we don't have it' but we want to fix that                      // by fetching the object from the other side.                  }                    var line = new StringBuilder(46);                  line.Append("want ");                  line.Append(r.ObjectId.Name);                  if (first)                  {                      line.Append(EnableCapabilities());                      first = false;                  }                  line.Append('\n');                  pckOut.WriteString(line.ToString());              }
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: for (; ; )              {                  RevCommit c = _walk.next();                  if (c == null)                  {                      goto END_SEND_HAVES;                  }                    pckOut.WriteString("have " + c.getId().Name + "\n");                  havesSent++;                  havesSinceLastContinue++;                    if ((31 & havesSent) != 0)                  {                      // We group the have lines into blocks of 32' each marked                      // with a flush (aka end). This one is within a block so                      // continue with another have line.                      //                      continue;                  }                    if (monitor.IsCancelled)                      throw new CancelledException();                    pckOut.End();                  resultsPending++; // Each end will cause a result to come back.                    if (havesSent == 32)                  {                      // On the first block we race ahead and try to send                      // more of the second block while waiting for the                      // remote to respond to our first block request.                      // This keeps us one block ahead of the peer.                      //                      continue;                  }                    for (; ; )                  {                      PacketLineIn.AckNackResult anr = pckIn.readACK(ackId);                        switch (anr)                      {                          case PacketLineIn.AckNackResult.NAK:                              // More have lines are necessary to compute the                              // pack on the remote side. Keep doing that.                                resultsPending--;                              goto END_READ_RESULT;                            case PacketLineIn.AckNackResult.ACK:                              // The remote side is happy and knows exactly what                              // to send us. There is no further negotiation and                              // we can break out immediately.                                _multiAck = MultiAck.OFF;                              resultsPending = 0;                              receivedAck = true;                              goto END_SEND_HAVES;                            case PacketLineIn.AckNackResult.ACK_CONTINUE:                          case PacketLineIn.AckNackResult.ACK_COMMON:                          case PacketLineIn.AckNackResult.ACK_READY:                              // The server knows this commit (ackId). We don't                              // need to send any further along its ancestry' but                              // we need to continue to talk about other parts of                              // our local history.                                MarkCommon(_walk.parseAny(ackId));                              receivedAck = true;                              receivedContinue = true;                              havesSinceLastContinue = 0;                              break;                      }                          if (monitor.IsCancelled)                          throw new CancelledException();                  }                END_READ_RESULT:                  if (receivedContinue && havesSinceLastContinue > MAX_HAVES)                  {                      // Our history must be really different from the remote's.                      // We just sent a whole slew of have lines' and it did not                      // recognize any of them. Avoid sending our entire history                      // to them by giving up early.                      //                      break;                  }              }
Magic Number,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following statement contains a magic number: for (; ; )              {                  RevCommit c = _walk.next();                  if (c == null)                  {                      goto END_SEND_HAVES;                  }                    pckOut.WriteString("have " + c.getId().Name + "\n");                  havesSent++;                  havesSinceLastContinue++;                    if ((31 & havesSent) != 0)                  {                      // We group the have lines into blocks of 32' each marked                      // with a flush (aka end). This one is within a block so                      // continue with another have line.                      //                      continue;                  }                    if (monitor.IsCancelled)                      throw new CancelledException();                    pckOut.End();                  resultsPending++; // Each end will cause a result to come back.                    if (havesSent == 32)                  {                      // On the first block we race ahead and try to send                      // more of the second block while waiting for the                      // remote to respond to our first block request.                      // This keeps us one block ahead of the peer.                      //                      continue;                  }                    for (; ; )                  {                      PacketLineIn.AckNackResult anr = pckIn.readACK(ackId);                        switch (anr)                      {                          case PacketLineIn.AckNackResult.NAK:                              // More have lines are necessary to compute the                              // pack on the remote side. Keep doing that.                                resultsPending--;                              goto END_READ_RESULT;                            case PacketLineIn.AckNackResult.ACK:                              // The remote side is happy and knows exactly what                              // to send us. There is no further negotiation and                              // we can break out immediately.                                _multiAck = MultiAck.OFF;                              resultsPending = 0;                              receivedAck = true;                              goto END_SEND_HAVES;                            case PacketLineIn.AckNackResult.ACK_CONTINUE:                          case PacketLineIn.AckNackResult.ACK_COMMON:                          case PacketLineIn.AckNackResult.ACK_READY:                              // The server knows this commit (ackId). We don't                              // need to send any further along its ancestry' but                              // we need to continue to talk about other parts of                              // our local history.                                MarkCommon(_walk.parseAny(ackId));                              receivedAck = true;                              receivedContinue = true;                              havesSinceLastContinue = 0;                              break;                      }                          if (monitor.IsCancelled)                          throw new CancelledException();                  }                END_READ_RESULT:                  if (receivedContinue && havesSinceLastContinue > MAX_HAVES)                  {                      // Our history must be really different from the remote's.                      // We just sent a whole slew of have lines' and it did not                      // recognize any of them. Avoid sending our entire history                      // to them by giving up early.                      //                      break;                  }              }
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: while ((refLine = pckIn.ReadString()) != PacketLineIn.END)              {                  bool ok = false;                  int refNameEnd = -1;                  if (refLine.StartsWith("ok "))                  {                      ok = true;                      refNameEnd = refLine.Length;                  }                  else if (refLine.StartsWith("ng "))                  {                      refNameEnd = refLine.IndexOf(' '' 3);                  }                  if (refNameEnd == -1)                  {                      throw new PackProtocolException(uri + ": unexpected report line: " + refLine);                  }                  string refName = refLine.Slice(3' refNameEnd);                  string message = (ok ? null : refLine.Substring(refNameEnd + 1));                  RemoteRefUpdate rru = refUpdates.get(refName);                  if (rru == null)                      throw new PackProtocolException(uri                              + ": unexpected ref report: " + refName);                  if (ok)                  {                      rru.Status = RemoteRefUpdate.UpdateStatus.OK;                  }                  else                  {                      rru.Status = RemoteRefUpdate.UpdateStatus.REJECTED_OTHER_REASON;                      rru.Message = message;                  }              }
Magic Number,GitSharp.Core.Transport,BasePackPushConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackPushConnection.cs,readStatusReport,The following statement contains a magic number: while ((refLine = pckIn.ReadString()) != PacketLineIn.END)              {                  bool ok = false;                  int refNameEnd = -1;                  if (refLine.StartsWith("ok "))                  {                      ok = true;                      refNameEnd = refLine.Length;                  }                  else if (refLine.StartsWith("ng "))                  {                      refNameEnd = refLine.IndexOf(' '' 3);                  }                  if (refNameEnd == -1)                  {                      throw new PackProtocolException(uri + ": unexpected report line: " + refLine);                  }                  string refName = refLine.Slice(3' refNameEnd);                  string message = (ok ? null : refLine.Substring(refNameEnd + 1));                  RemoteRefUpdate rru = refUpdates.get(refName);                  if (rru == null)                      throw new PackProtocolException(uri                              + ": unexpected ref report: " + refName);                  if (ok)                  {                      rru.Status = RemoteRefUpdate.UpdateStatus.OK;                  }                  else                  {                      rru.Status = RemoteRefUpdate.UpdateStatus.REJECTED_OTHER_REASON;                      rru.Message = message;                  }              }
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,BundleFetchConnection,The following statement contains a magic number: try              {                  switch (readSignature())                  {                      case 2:                          readBundleV2();                          break;                        default:                          throw new TransportException(_transport.Uri' "not a bundle");                  }              }              catch (TransportException)              {                  Close();                  throw;              }              catch (IOException err)              {                  Close();                  throw new TransportException(_transport.Uri' err.Message' err);              }              catch (Exception err)              {                  Close();                  throw new TransportException(_transport.Uri' err.Message' err);              }
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readSignature,The following statement contains a magic number: string rev = readLine(new byte[1024]);
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readSignature,The following statement contains a magic number: if (TransportBundleConstants.V2_BUNDLE_SIGNATURE.Equals(rev))                  return 2;
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: byte[] hdrbuf = new byte[1024];
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ; )              {                  string line = readLine(hdrbuf);                  if (line.Length == 0)                      break;                    if (line[0] == '-')                  {                      ObjectId id = ObjectId.FromString(line.Slice(1' 41));                      String shortDesc = null;                      if (line.Length > 42)                          shortDesc = line.Substring(42);                      _prereqs.put(id' shortDesc);                      continue;                  }                    string name = line.Slice(41' line.Length);                  ObjectId id2 = ObjectId.FromString(line.Slice(0' 40));                  Ref prior = avail.put(name' new Unpeeled(Storage.Network' name' id2));                  if (prior != null)                  {                      throw duplicateAdvertisement(name);                  }              }
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ; )              {                  string line = readLine(hdrbuf);                  if (line.Length == 0)                      break;                    if (line[0] == '-')                  {                      ObjectId id = ObjectId.FromString(line.Slice(1' 41));                      String shortDesc = null;                      if (line.Length > 42)                          shortDesc = line.Substring(42);                      _prereqs.put(id' shortDesc);                      continue;                  }                    string name = line.Slice(41' line.Length);                  ObjectId id2 = ObjectId.FromString(line.Slice(0' 40));                  Ref prior = avail.put(name' new Unpeeled(Storage.Network' name' id2));                  if (prior != null)                  {                      throw duplicateAdvertisement(name);                  }              }
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ; )              {                  string line = readLine(hdrbuf);                  if (line.Length == 0)                      break;                    if (line[0] == '-')                  {                      ObjectId id = ObjectId.FromString(line.Slice(1' 41));                      String shortDesc = null;                      if (line.Length > 42)                          shortDesc = line.Substring(42);                      _prereqs.put(id' shortDesc);                      continue;                  }                    string name = line.Slice(41' line.Length);                  ObjectId id2 = ObjectId.FromString(line.Slice(0' 40));                  Ref prior = avail.put(name' new Unpeeled(Storage.Network' name' id2));                  if (prior != null)                  {                      throw duplicateAdvertisement(name);                  }              }
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ; )              {                  string line = readLine(hdrbuf);                  if (line.Length == 0)                      break;                    if (line[0] == '-')                  {                      ObjectId id = ObjectId.FromString(line.Slice(1' 41));                      String shortDesc = null;                      if (line.Length > 42)                          shortDesc = line.Substring(42);                      _prereqs.put(id' shortDesc);                      continue;                  }                    string name = line.Slice(41' line.Length);                  ObjectId id2 = ObjectId.FromString(line.Slice(0' 40));                  Ref prior = avail.put(name' new Unpeeled(Storage.Network' name' id2));                  if (prior != null)                  {                      throw duplicateAdvertisement(name);                  }              }
Magic Number,GitSharp.Core.Transport,BundleFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BundleFetchConnection.cs,readBundleV2,The following statement contains a magic number: for (; ; )              {                  string line = readLine(hdrbuf);                  if (line.Length == 0)                      break;                    if (line[0] == '-')                  {                      ObjectId id = ObjectId.FromString(line.Slice(1' 41));                      String shortDesc = null;                      if (line.Length > 42)                          shortDesc = line.Substring(42);                      _prereqs.put(id' shortDesc);                      continue;                  }                    string name = line.Slice(41' line.Length);                  ObjectId id2 = ObjectId.FromString(line.Slice(0' 40));                  Ref prior = avail.put(name' new Unpeeled(Storage.Network' name' id2));                  if (prior != null)                  {                      throw duplicateAdvertisement(name);                  }              }
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,index,The following statement contains a magic number: progress.Start(2 /* tasks */);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: int typecode = (c >> 4) & 7;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: int typecode = (c >> 4) & 7;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: long sz = c & 15;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: int shift = 4;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: while ((c & 0x80) != 0)  			{  				c = ReadFromFile();  				sz += (c & 0x7f) << shift;  				shift += 7;  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					type = typecode;  					data = InflateFromFile((int)sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromFile() & 0xff;  					while ((c & 128) != 0)  					{  						c = ReadFromFile() & 0xff;  					}  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				case Constants.OBJ_REF_DELTA:  					_crc.Update(_buffer' FillFromFile(20)' 20);  					Use(20);  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				default:  					throw new IOException("Unknown object type " + typecode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					type = typecode;  					data = InflateFromFile((int)sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromFile() & 0xff;  					while ((c & 128) != 0)  					{  						c = ReadFromFile() & 0xff;  					}  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				case Constants.OBJ_REF_DELTA:  					_crc.Update(_buffer' FillFromFile(20)' 20);  					Use(20);  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				default:  					throw new IOException("Unknown object type " + typecode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					type = typecode;  					data = InflateFromFile((int)sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromFile() & 0xff;  					while ((c & 128) != 0)  					{  						c = ReadFromFile() & 0xff;  					}  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				case Constants.OBJ_REF_DELTA:  					_crc.Update(_buffer' FillFromFile(20)' 20);  					Use(20);  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				default:  					throw new IOException("Unknown object type " + typecode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ResolveDeltas,The following statement contains a magic number: switch (typecode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					type = typecode;  					data = InflateFromFile((int)sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromFile() & 0xff;  					while ((c & 128) != 0)  					{  						c = ReadFromFile() & 0xff;  					}  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				case Constants.OBJ_REF_DELTA:  					_crc.Update(_buffer' FillFromFile(20)' 20);  					Use(20);  					data = BinaryDelta.Apply(data' InflateFromFile((int)sz));  					break;    				default:  					throw new IOException("Unknown object type " + typecode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixThinPack,The following statement contains a magic number: _originalEof = _packOut.Length - 20;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixThinPack,The following statement contains a magic number: var missing = new List<DeltaChain>(64);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: _buffer[hdrlen++] = (byte)((typeCode << 4) | sz & 15);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: _buffer[hdrlen++] = (byte)((typeCode << 4) | sz & 15);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: sz = (int)(((uint)sz) >> 4);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,WriteWhole,The following statement contains a magic number: while (sz > 0)  			{  				_buffer[hdrlen - 1] |= 0x80;  				_buffer[hdrlen++] = (byte)(sz & 0x7f);  				sz = (int)(((uint)sz) >> 7);  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,The following statement contains a magic number: FillFromFile(12);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,The following statement contains a magic number: NB.encodeInt32(_buffer' 8' _entryCount);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,FixHeaderFooter,The following statement contains a magic number: _packOut.Write(_buffer' 0' 12);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: int hdrln = Constants.PACK_SIGNATURE.Length + 4 + 4;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: int hdrln = Constants.PACK_SIGNATURE.Length + 4 + 4;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: long vers = NB.DecodeUInt32(_buffer' p + 4);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException("Unsupported pack version " + vers + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: if (vers != 2 && vers != 3)  			{  				throw new IOException("Unsupported pack version " + vers + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackHeader,The following statement contains a magic number: _objectCount = NB.decodeUInt32(_buffer' p + 8);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: int c = FillFromInput(20);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: _packcsum = new byte[20];
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: Array.Copy(_buffer' c' _packcsum' 0' 20);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,ReadPackFooter,The following statement contains a magic number: Use(20);
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: int typeCode = (c >> 4) & 7;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: long sz = c & 15;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: int shift = 4;
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: while ((c & 0x80) != 0)  			{  				c = ReadFromInput();  				sz += (c & 0x7f) << shift;  				shift += 7;  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,IndexOneObject,The following statement contains a magic number: switch (typeCode)  			{  				case Constants.OBJ_COMMIT:  				case Constants.OBJ_TREE:  				case Constants.OBJ_BLOB:  				case Constants.OBJ_TAG:  					Whole(typeCode' pos' sz);  					break;    				case Constants.OBJ_OFS_DELTA:  					c = ReadFromInput();  					long ofs = c & 127;  					while ((c & 128) != 0)  					{  						ofs += 1;  						c = ReadFromInput();  						ofs <<= 7;  						ofs += (c & 127);  					}  					long pbase = pos - ofs;  					SkipInflateFromInput(sz);  					var n = new UnresolvedDelta(pos' (int)_crc.Value);  					n.Next = _baseByPos.put(pbase' n);  					_deltaCount++;  					break;    				case Constants.OBJ_REF_DELTA:  					c = FillFromInput(20);  					_crc.Update(_buffer' c' 20);  					ObjectId baseId = ObjectId.FromRaw(_buffer' c);  					Use(20);  					DeltaChain r = _baseById.Get(baseId);  					if (r == null)  					{  						r = new DeltaChain(baseId);  						_baseById.Add(r);  					}  					SkipInflateFromInput(sz);  					r.Add(new UnresolvedDelta(pos' (int)_crc.Value));  					_deltaCount++;  					break;    				default:  					throw new IOException("Unknown object type " + typeCode + ".");  			}
Magic Number,GitSharp.Core.Transport,IndexPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\IndexPack.cs,SkipInflateFromInput,The following statement contains a magic number: try  			{  				byte[] dst = _objectData;  				int n = 0;  				int p = -1;  				while (!inf.IsFinished)  				{  					if (inf.IsNeedingInput)  					{  						if (p >= 0)  						{  							_crc.Update(_buffer' p' _bAvail);  							Use(_bAvail);  						}  						p = FillFromInput(1);  						inf.SetInput(_buffer' p' _bAvail);  					}    					int free = dst.Length - n;  					if (free < 8)  					{  						sz -= n;  						n = 0;  						free = dst.Length;  					}  					n += inf.Inflate(dst' n' free);  				}    				if (n != sz)  				{  					throw new IOException("wrong decompressed length");  				}    				n = _bAvail - inf.RemainingInput;  				if (n > 0)  				{  					_crc.Update(_buffer' p' n);  					Use(n);  				}  			}  			catch (IOException e)  			{  				throw Corrupt(e);  			}  			finally  			{  				inf.Reset();  			}
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,PacketLineIn,The following statement contains a magic number: lenbuffer = new byte[4];
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith("ACK "))              {                  returnedId.FromString(line.Slice(4' 44));                    if (line.Length == 44)                      return AckNackResult.ACK;                    string arg = line.Substring(44);                  if (arg.Equals(" continue"))                      return AckNackResult.ACK_CONTINUE;                  else if (arg.Equals(" common"))                      return AckNackResult.ACK_COMMON;                  else if (arg.Equals(" ready"))                      return AckNackResult.ACK_READY;              }
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith("ACK "))              {                  returnedId.FromString(line.Slice(4' 44));                    if (line.Length == 44)                      return AckNackResult.ACK;                    string arg = line.Substring(44);                  if (arg.Equals(" continue"))                      return AckNackResult.ACK_CONTINUE;                  else if (arg.Equals(" common"))                      return AckNackResult.ACK_COMMON;                  else if (arg.Equals(" ready"))                      return AckNackResult.ACK_READY;              }
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith("ACK "))              {                  returnedId.FromString(line.Slice(4' 44));                    if (line.Length == 44)                      return AckNackResult.ACK;                    string arg = line.Substring(44);                  if (arg.Equals(" continue"))                      return AckNackResult.ACK_CONTINUE;                  else if (arg.Equals(" common"))                      return AckNackResult.ACK_COMMON;                  else if (arg.Equals(" ready"))                      return AckNackResult.ACK_READY;              }
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,readACK,The following statement contains a magic number: if (line.StartsWith("ACK "))              {                  returnedId.FromString(line.Slice(4' 44));                    if (line.Length == 44)                      return AckNackResult.ACK;                    string arg = line.Substring(44);                  if (arg.Equals(" continue"))                      return AckNackResult.ACK_CONTINUE;                  else if (arg.Equals(" common"))                      return AckNackResult.ACK_COMMON;                  else if (arg.Equals(" ready"))                      return AckNackResult.ACK_READY;              }
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadString,The following statement contains a magic number: len -= 4;
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadStringRaw,The following statement contains a magic number: len -= 4;
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: IO.ReadFully(ins' lenbuffer' 0' 4);
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try              {                  int len = RawParseUtils.parseHexInt16(lenbuffer' 0);                  if (len != 0 && len < 4)                      throw new IndexOutOfRangeException();                  return len;              }              catch (IndexOutOfRangeException e)              {                  throw new IOException("Invalid packet line header: " + (char)lenbuffer[0] +                                        (char)lenbuffer[1] + (char)lenbuffer[2] + (char)lenbuffer[3]' e);              }
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try              {                  int len = RawParseUtils.parseHexInt16(lenbuffer' 0);                  if (len != 0 && len < 4)                      throw new IndexOutOfRangeException();                  return len;              }              catch (IndexOutOfRangeException e)              {                  throw new IOException("Invalid packet line header: " + (char)lenbuffer[0] +                                        (char)lenbuffer[1] + (char)lenbuffer[2] + (char)lenbuffer[3]' e);              }
Magic Number,GitSharp.Core.Transport,PacketLineIn,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineIn.cs,ReadLength,The following statement contains a magic number: try              {                  int len = RawParseUtils.parseHexInt16(lenbuffer' 0);                  if (len != 0 && len < 4)                      throw new IndexOutOfRangeException();                  return len;              }              catch (IndexOutOfRangeException e)              {                  throw new IOException("Invalid packet line header: " + (char)lenbuffer[0] +                                        (char)lenbuffer[1] + (char)lenbuffer[2] + (char)lenbuffer[3]' e);              }
Magic Number,GitSharp.Core.Transport,PacketLineOut,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,PacketLineOut,The following statement contains a magic number: _lenbuffer = new byte[5];
Magic Number,GitSharp.Core.Transport,PacketLineOut,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,WritePacket,The following statement contains a magic number: FormatLength(packet.Length + 4);
Magic Number,GitSharp.Core.Transport,PacketLineOut,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,WritePacket,The following statement contains a magic number: _out.Write(_lenbuffer' 0' 4);
Magic Number,GitSharp.Core.Transport,PacketLineOut,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,End,The following statement contains a magic number: _out.Write(_lenbuffer' 0' 4);
Magic Number,GitSharp.Core.Transport,PacketLineOut,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,FormatLength,The following statement contains a magic number: int o = 3;
Magic Number,GitSharp.Core.Transport,PacketLineOut,C:\repos\henon_GitSharp\GitSharp.Core\Transport\PacketLineOut.cs,FormatLength,The following statement contains a magic number: while (o >= 0 && w != 0)  			{  				lenbuffer[o--] = (byte)hexchar[w & 0xf];  				w = (int)(((uint)w) >> 4);  			}
Magic Number,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true)  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EndOfStreamException)  				{  					if (commands.isEmpty())  					{  						return;  					}  					throw;  				}    				if (line == PacketLineIn.END)  					break;    				if (commands.isEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						foreach (string c in line.Substring(nul + 1).Split(' '))  						{  							enabledCapabilities.Add(c);  						}  						line = line.Slice(0' nul);  					}  				}    				if (line.Length < 83)  				{  					string m = "error: invalid protocol: wanted 'old new ref'";  					sendError(m);  					throw new PackProtocolException(m);  				}    				ObjectId oldId = ObjectId.FromString(line.Slice(0' 40));  				ObjectId newId = ObjectId.FromString(line.Slice(41' 81));  				string name = line.Substring(82);  				var cmd = new ReceiveCommand(oldId' newId' name);    				if (name.Equals(Constants.HEAD))  				{  					cmd.setResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.setRef(refs.get(cmd.getRefName()));  				}    				commands.Add(cmd);  			}
Magic Number,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true)  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EndOfStreamException)  				{  					if (commands.isEmpty())  					{  						return;  					}  					throw;  				}    				if (line == PacketLineIn.END)  					break;    				if (commands.isEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						foreach (string c in line.Substring(nul + 1).Split(' '))  						{  							enabledCapabilities.Add(c);  						}  						line = line.Slice(0' nul);  					}  				}    				if (line.Length < 83)  				{  					string m = "error: invalid protocol: wanted 'old new ref'";  					sendError(m);  					throw new PackProtocolException(m);  				}    				ObjectId oldId = ObjectId.FromString(line.Slice(0' 40));  				ObjectId newId = ObjectId.FromString(line.Slice(41' 81));  				string name = line.Substring(82);  				var cmd = new ReceiveCommand(oldId' newId' name);    				if (name.Equals(Constants.HEAD))  				{  					cmd.setResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.setRef(refs.get(cmd.getRefName()));  				}    				commands.Add(cmd);  			}
Magic Number,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true)  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EndOfStreamException)  				{  					if (commands.isEmpty())  					{  						return;  					}  					throw;  				}    				if (line == PacketLineIn.END)  					break;    				if (commands.isEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						foreach (string c in line.Substring(nul + 1).Split(' '))  						{  							enabledCapabilities.Add(c);  						}  						line = line.Slice(0' nul);  					}  				}    				if (line.Length < 83)  				{  					string m = "error: invalid protocol: wanted 'old new ref'";  					sendError(m);  					throw new PackProtocolException(m);  				}    				ObjectId oldId = ObjectId.FromString(line.Slice(0' 40));  				ObjectId newId = ObjectId.FromString(line.Slice(41' 81));  				string name = line.Substring(82);  				var cmd = new ReceiveCommand(oldId' newId' name);    				if (name.Equals(Constants.HEAD))  				{  					cmd.setResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.setRef(refs.get(cmd.getRefName()));  				}    				commands.Add(cmd);  			}
Magic Number,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true)  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EndOfStreamException)  				{  					if (commands.isEmpty())  					{  						return;  					}  					throw;  				}    				if (line == PacketLineIn.END)  					break;    				if (commands.isEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						foreach (string c in line.Substring(nul + 1).Split(' '))  						{  							enabledCapabilities.Add(c);  						}  						line = line.Slice(0' nul);  					}  				}    				if (line.Length < 83)  				{  					string m = "error: invalid protocol: wanted 'old new ref'";  					sendError(m);  					throw new PackProtocolException(m);  				}    				ObjectId oldId = ObjectId.FromString(line.Slice(0' 40));  				ObjectId newId = ObjectId.FromString(line.Slice(41' 81));  				string name = line.Substring(82);  				var cmd = new ReceiveCommand(oldId' newId' name);    				if (name.Equals(Constants.HEAD))  				{  					cmd.setResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.setRef(refs.get(cmd.getRefName()));  				}    				commands.Add(cmd);  			}
Magic Number,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,RecvCommands,The following statement contains a magic number: while (true)  			{  				string line;  				try  				{  					line = pckIn.ReadStringRaw();  				}  				catch (EndOfStreamException)  				{  					if (commands.isEmpty())  					{  						return;  					}  					throw;  				}    				if (line == PacketLineIn.END)  					break;    				if (commands.isEmpty())  				{  					int nul = line.IndexOf('\0');  					if (nul >= 0)  					{  						foreach (string c in line.Substring(nul + 1).Split(' '))  						{  							enabledCapabilities.Add(c);  						}  						line = line.Slice(0' nul);  					}  				}    				if (line.Length < 83)  				{  					string m = "error: invalid protocol: wanted 'old new ref'";  					sendError(m);  					throw new PackProtocolException(m);  				}    				ObjectId oldId = ObjectId.FromString(line.Slice(0' 40));  				ObjectId newId = ObjectId.FromString(line.Slice(41' 81));  				string name = line.Substring(82);  				var cmd = new ReceiveCommand(oldId' newId' name);    				if (name.Equals(Constants.HEAD))  				{  					cmd.setResult(ReceiveCommand.Result.REJECTED_CURRENT_BRANCH);  				}  				else  				{  					cmd.setRef(refs.get(cmd.getRefName()));  				}    				commands.Add(cmd);  			}
Magic Number,GitSharp.Core.Transport,RefSpec,C:\repos\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: if (Source != null)                  hc = hc * 31 + Source.GetHashCode();
Magic Number,GitSharp.Core.Transport,RefSpec,C:\repos\henon_GitSharp\GitSharp.Core\Transport\RefSpec.cs,GetHashCode,The following statement contains a magic number: if (Destination != null)                  hc = hc * 31 + Destination.GetHashCode();
Magic Number,GitSharp.Core.Transport,SideBandInputStream,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (matcher.Success)  			{  				string taskname = matcher.Groups[1].Value;  				if (!currentTask.Equals(taskname))  				{  					currentTask = taskname;  					lastCnt = 0;  					beginTask(int.Parse(matcher.Groups[3].Value));  				}  				int cnt = int.Parse(matcher.Groups[2].Value);  				monitor.Update(cnt - lastCnt);  				lastCnt = cnt;  				return true;  			}
Magic Number,GitSharp.Core.Transport,SideBandInputStream,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (matcher.Success)  			{  				string taskname = matcher.Groups[1].Value;  				if (!currentTask.Equals(taskname))  				{  					currentTask = taskname;  					lastCnt = 0;  					beginTask(int.Parse(matcher.Groups[3].Value));  				}  				int cnt = int.Parse(matcher.Groups[2].Value);  				monitor.Update(cnt - lastCnt);  				lastCnt = cnt;  				return true;  			}
Magic Number,GitSharp.Core.Transport,SideBandInputStream,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandInputStream.cs,doProgressLine,The following statement contains a magic number: if (matcher.Success)  			{  				string taskname = matcher.Groups[1].Value;  				if (!currentTask.Equals(taskname))  				{  					currentTask = taskname;  					lastCnt = 0;  					beginTask(ProgressMonitor.UNKNOWN);  				}  				int cnt = int.Parse(matcher.Groups[2].Value);  				monitor.Update(cnt - lastCnt);  				lastCnt = cnt;  				return true;  			}
Magic Number,GitSharp.Core.Transport,SideBandOutputStream,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandOutputStream.cs,SideBandOutputStream,The following statement contains a magic number: if (chan <= 0 || chan > 255)  				throw new ArgumentException("channel " + chan  						+ " must be in range [0' 255]");
Magic Number,GitSharp.Core.Transport,SideBandOutputStream,C:\repos\henon_GitSharp\GitSharp.Core\Transport\SideBandOutputStream.cs,SideBandOutputStream,The following statement contains a magic number: _buffer[4] = (byte)chan;
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Upload,The following statement contains a magic number: if (_timeout > 0)              {                  var i = new TimeoutStream(_rawIn);  					i.setTimeout(_timeout * 1000);                  var o = new TimeoutStream(_rawOut );  					 o.setTimeout(_timeout * 1000);                  _rawIn = i;                  _rawOut = o;              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Upload,The following statement contains a magic number: if (_timeout > 0)              {                  var i = new TimeoutStream(_rawIn);  					i.setTimeout(_timeout * 1000);                  var o = new TimeoutStream(_rawOut );  					 o.setTimeout(_timeout * 1000);                  _rawIn = i;                  _rawOut = o;              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false)              {                  string line;                  try                  {                      line = _pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (isFirst) break;                      throw;                  }                    if (line == PacketLineIn.END) break;                  if (!line.StartsWith("want ") || line.Length < 45)                  {                      throw new PackProtocolException("expected want; got " + line);                  }                    if (isFirst && line.Length > 45)                  {                      string opt = line.Substring(45);                      if (opt.StartsWith(" "))                          opt = opt.Substring(1);                      foreach (string c in opt.Split(' '))                          _options.Add(c);                      line = line.Slice(0' 45);                  }                    ObjectId id = ObjectId.FromString(line.Substring(5));                  RevObject o;                  try                  {                      o = _walk.parseAny(id);                  }                  catch (IOException e)                  {                      throw new PackProtocolException(id.Name + " not valid"' e);                  }                  if (!o.has(ADVERTISED))                  {                      throw new PackProtocolException(id.Name + " not valid");                  }                    Want(o);              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false)              {                  string line;                  try                  {                      line = _pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (isFirst) break;                      throw;                  }                    if (line == PacketLineIn.END) break;                  if (!line.StartsWith("want ") || line.Length < 45)                  {                      throw new PackProtocolException("expected want; got " + line);                  }                    if (isFirst && line.Length > 45)                  {                      string opt = line.Substring(45);                      if (opt.StartsWith(" "))                          opt = opt.Substring(1);                      foreach (string c in opt.Split(' '))                          _options.Add(c);                      line = line.Slice(0' 45);                  }                    ObjectId id = ObjectId.FromString(line.Substring(5));                  RevObject o;                  try                  {                      o = _walk.parseAny(id);                  }                  catch (IOException e)                  {                      throw new PackProtocolException(id.Name + " not valid"' e);                  }                  if (!o.has(ADVERTISED))                  {                      throw new PackProtocolException(id.Name + " not valid");                  }                    Want(o);              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false)              {                  string line;                  try                  {                      line = _pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (isFirst) break;                      throw;                  }                    if (line == PacketLineIn.END) break;                  if (!line.StartsWith("want ") || line.Length < 45)                  {                      throw new PackProtocolException("expected want; got " + line);                  }                    if (isFirst && line.Length > 45)                  {                      string opt = line.Substring(45);                      if (opt.StartsWith(" "))                          opt = opt.Substring(1);                      foreach (string c in opt.Split(' '))                          _options.Add(c);                      line = line.Slice(0' 45);                  }                    ObjectId id = ObjectId.FromString(line.Substring(5));                  RevObject o;                  try                  {                      o = _walk.parseAny(id);                  }                  catch (IOException e)                  {                      throw new PackProtocolException(id.Name + " not valid"' e);                  }                  if (!o.has(ADVERTISED))                  {                      throw new PackProtocolException(id.Name + " not valid");                  }                    Want(o);              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false)              {                  string line;                  try                  {                      line = _pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (isFirst) break;                      throw;                  }                    if (line == PacketLineIn.END) break;                  if (!line.StartsWith("want ") || line.Length < 45)                  {                      throw new PackProtocolException("expected want; got " + line);                  }                    if (isFirst && line.Length > 45)                  {                      string opt = line.Substring(45);                      if (opt.StartsWith(" "))                          opt = opt.Substring(1);                      foreach (string c in opt.Split(' '))                          _options.Add(c);                      line = line.Slice(0' 45);                  }                    ObjectId id = ObjectId.FromString(line.Substring(5));                  RevObject o;                  try                  {                      o = _walk.parseAny(id);                  }                  catch (IOException e)                  {                      throw new PackProtocolException(id.Name + " not valid"' e);                  }                  if (!o.has(ADVERTISED))                  {                      throw new PackProtocolException(id.Name + " not valid");                  }                    Want(o);              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,RecvWants,The following statement contains a magic number: for (; ; isFirst = false)              {                  string line;                  try                  {                      line = _pckIn.ReadString();                  }                  catch (EndOfStreamException)                  {                      if (isFirst) break;                      throw;                  }                    if (line == PacketLineIn.END) break;                  if (!line.StartsWith("want ") || line.Length < 45)                  {                      throw new PackProtocolException("expected want; got " + line);                  }                    if (isFirst && line.Length > 45)                  {                      string opt = line.Substring(45);                      if (opt.StartsWith(" "))                          opt = opt.Substring(1);                      foreach (string c in opt.Split(' '))                          _options.Add(c);                      line = line.Slice(0' 45);                  }                    ObjectId id = ObjectId.FromString(line.Substring(5));                  RevObject o;                  try                  {                      o = _walk.parseAny(id);                  }                  catch (IOException e)                  {                      throw new PackProtocolException(id.Name + " not valid"' e);                  }                  if (!o.has(ADVERTISED))                  {                      throw new PackProtocolException(id.Name + " not valid");                  }                    Want(o);              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: while (true)              {                  string line = _pckIn.ReadString();                    if (line == PacketLineIn.END)                  {                      if (_commonBase.Count == 0 || _multiAck != BasePackFetchConnection.MultiAck.OFF)                      {                          _pckOut.WriteString("NAK\n");                      }                      _pckOut.Flush();                        if (!biDirectionalPipe)                          return false;                  }                  else if (line.StartsWith("have ") && line.Length == 45)                  {                      ObjectId id = ObjectId.FromString(line.Substring(5));                      if (MatchHave(id))                      {                          // Both sides have the same object; let the client know.                          //                          last = id;                          switch (_multiAck)                          {                              case BasePackFetchConnection.MultiAck.OFF:                                  if (_commonBase.Count == 1)                                      _pckOut.WriteString("ACK " + id.Name + "\n");                                  break;                              case BasePackFetchConnection.MultiAck.CONTINUE:                                    _pckOut.WriteString("ACK " + id.Name + " continue\n");                                  break;                              case BasePackFetchConnection.MultiAck.DETAILED:                                  _pckOut.WriteString("ACK " + id.Name + " common\n");                                  break;                          }                      }                      else if (OkToGiveUp())                      {                          // They have this object; we don't.                          //                          switch (_multiAck)                          {                              case BasePackFetchConnection.MultiAck.OFF:                                  break;                              case BasePackFetchConnection.MultiAck.CONTINUE:                                  _pckOut.WriteString("ACK " + id.Name + " continue\n");                                  break;                              case BasePackFetchConnection.MultiAck.DETAILED:                                  _pckOut.WriteString("ACK " + id.Name + " ready\n");                                  break;                          }                      }                  }                  else if (line.Equals("done"))                  {                      if (_commonBase.Count == 0)                      {                          _pckOut.WriteString("NAK\n");                      }                      else if (_multiAck != BasePackFetchConnection.MultiAck.OFF)                      {                          _pckOut.WriteString("ACK " + last.Name + "\n");                      }                        return true;                  }                  else                  {                      throw new PackProtocolException("expected have; got " + line);                  }              }
Magic Number,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following statement contains a magic number: while (true)              {                  string line = _pckIn.ReadString();                    if (line == PacketLineIn.END)                  {                      if (_commonBase.Count == 0 || _multiAck != BasePackFetchConnection.MultiAck.OFF)                      {                          _pckOut.WriteString("NAK\n");                      }                      _pckOut.Flush();                        if (!biDirectionalPipe)                          return false;                  }                  else if (line.StartsWith("have ") && line.Length == 45)                  {                      ObjectId id = ObjectId.FromString(line.Substring(5));                      if (MatchHave(id))                      {                          // Both sides have the same object; let the client know.                          //                          last = id;                          switch (_multiAck)                          {                              case BasePackFetchConnection.MultiAck.OFF:                                  if (_commonBase.Count == 1)                                      _pckOut.WriteString("ACK " + id.Name + "\n");                                  break;                              case BasePackFetchConnection.MultiAck.CONTINUE:                                    _pckOut.WriteString("ACK " + id.Name + " continue\n");                                  break;                              case BasePackFetchConnection.MultiAck.DETAILED:                                  _pckOut.WriteString("ACK " + id.Name + " common\n");                                  break;                          }                      }                      else if (OkToGiveUp())                      {                          // They have this object; we don't.                          //                          switch (_multiAck)                          {                              case BasePackFetchConnection.MultiAck.OFF:                                  break;                              case BasePackFetchConnection.MultiAck.CONTINUE:                                  _pckOut.WriteString("ACK " + id.Name + " continue\n");                                  break;                              case BasePackFetchConnection.MultiAck.DETAILED:                                  _pckOut.WriteString("ACK " + id.Name + " ready\n");                                  break;                          }                      }                  }                  else if (line.Equals("done"))                  {                      if (_commonBase.Count == 0)                      {                          _pckOut.WriteString("NAK\n");                      }                      else if (_multiAck != BasePackFetchConnection.MultiAck.OFF)                      {                          _pckOut.WriteString("ACK " + last.Name + "\n");                      }                        return true;                  }                  else                  {                      throw new PackProtocolException("expected have; got " + line);                  }              }
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,URIish,The following statement contains a magic number: if (matcher.Success)  			{  				Scheme = matcher.Groups[1].Value;  				Scheme = Scheme.Length == 0 ? null : Scheme;  				User = matcher.Groups[2].Value;  				User = User.Length == 0 ? null : User;  				Pass = matcher.Groups[3].Value;  				Pass = Pass.Length == 0 ? null : Pass;  				Host = matcher.Groups[4].Value;  				Host = Host.Length == 0 ? null : Host;  				if (matcher.Groups[5].Success)  				{  					Port = int.Parse(matcher.Groups[5].Value);  				}  				Path = matcher.Groups[6].Value;  				if (Path.Length >= 3 && Path[0] == '/' && Path[2] == ':' && (Path[1] >= 'A' && Path[1] <= 'Z' || Path[1] >= 'a' && Path[1] <= 'z'))  				{  					Path = Path.Substring(1);  				}  			}  			else  			{  				matcher = ScpUri.Match(s);  				if (matcher.Success)  				{  					User = matcher.Groups[1].Value;  					User = User.Length == 0 ? null : User;  					Host = matcher.Groups[2].Value;  					Host = Host.Length == 0 ? null : Host;  					Path = matcher.Groups[3].Value;  					Path = Path.Length == 0 ? null : Path;  				}  				else  				{  					throw new UriFormatException("Cannot parse Git URI-ish (" + s + ")");  				}  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Scheme != null)  			{  				hc = hc * 31 + Scheme.GetHashCode();  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (User != null)  			{  				hc = hc * 31 + User.GetHashCode();  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Pass != null)  			{  				hc = hc * 31 + Pass.GetHashCode();  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Host != null)  			{  				hc = hc * 31 + Host.GetHashCode();  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Port > 0)  			{  				hc = hc * 31 + Port;  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,GetHashCode,The following statement contains a magic number: if (Path != null)  			{  				hc = hc * 31 + Path.GetHashCode();  			}
Magic Number,GitSharp.Core.Transport,URIish,C:\repos\henon_GitSharp\GitSharp.Core\Transport\URIish.cs,getHumanishName,The following statement contains a magic number: if (Constants.DOT_GIT.Equals(result))  	        {  	            result = elements2[elements2.Length - 2];  	        }  	        else if (result.EndsWith(Constants.DOT_GIT_EXT))  	        {                  result = result.Slice(0' result.Length - Constants.DOT_GIT_EXT.Length);  	        }
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (list.Length == 2)                  return create(list[0]' list[1]);
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (list.Length < 2)                  throw new ArgumentException("At least two filters needed.");
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (list.Count() < 2)                  throw new ArgumentException("At least two filters needed.");
Magic Number,GitSharp.Core.TreeWalk.Filter,AndTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\AndTreeFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2)                  return create(subfilters[0]' subfilters[1]);
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (list.Length == 2)                  return create(list[0]' list[1]);
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (list.Length < 2)                  throw new ArgumentException("At least two filters needed.");
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (list.Count() < 2)                  throw new ArgumentException("At least two filters needed.");
Magic Number,GitSharp.Core.TreeWalk.Filter,OrTreeFilter,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\Filter\OrTreeFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2)                  return create(subfilters[0]' subfilters[1]);
Magic Number,GitSharp.Core.Util,FileStreamExtensions,C:\repos\henon_GitSharp\GitSharp.Core\Util\Stream.cs,toArray,The following statement contains a magic number: try              {                  // Note: if we can seek' it's likely we have a length                  if (stream.CanSeek)                  {                      if (stream.Length >= 0)                      {                          byte[] r = new byte[stream.Length];                          IO.ReadFully(stream' r' 0' r.Length);                          return r;                      }                  }                    var m = new MemoryStream();                  var buf = new byte[2048];                  int n;                  while ((n = stream.Read(buf' 0' buf.Length)) > 0)                      m.Write(buf' 0' n);                  return m.ToArray();              }              finally              {                  stream.Dispose(); // [nulltoken] Why the heck is the stream disposed here instead of in the caller method ? Weird.              }
Magic Number,GitSharp.Core.Util,FS,C:\repos\henon_GitSharp\GitSharp.Core\Util\FS.cs,userHomeImpl,The following statement contains a magic number: if (platform == (int)PlatformID.Unix || platform  == 6 /* (int)PlatformID.MacOSX */                  || platform == (int)PlatformType.UnixMono)              {                  userHomeFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal);              }              else              {                  userHomeFolderPath = Environment.GetEnvironmentVariable("USERPROFILE");              }
Magic Number,GitSharp.Core.Util,Crc32,C:\repos\henon_GitSharp\GitSharp.Core\Util\CRC32.cs,Update,The following statement contains a magic number: _value = CrcTable[(_value ^ value) & 0xFF] ^ (_value >> 8);
Magic Number,GitSharp.Core.Util,Crc32,C:\repos\henon_GitSharp\GitSharp.Core\Util\CRC32.cs,Update,The following statement contains a magic number: _value = (_value >> 8) ^ CrcTable[(_value & 0xff) ^ value];
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,Hex,The following statement contains a magic number: for (char i = 'a'; i <= 'f'; i++)                  _hexCharToValue[i] = (byte)((i - 'a') + 10);
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,FillHexByteArray,The following statement contains a magic number: int curOffset = offset + 7;
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,FillHexCharArray,The following statement contains a magic number: int curOffset = offset + 7;
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: if (8 <= end - p)  			{  				return HexStringToUInt32(bs' p);  			}
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: while (n < 8 && p < end)  			{  				int v = HexCharToValue(bs[p++]);  				if (v < 0)  				{  					throw new IndexOutOfRangeException();  				}  				r <<= 4;  				r |= v;  				n++;  			}
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: while (n < 8 && p < end)  			{  				int v = HexCharToValue(bs[p++]);  				if (v < 0)  				{  					throw new IndexOutOfRangeException();  				}  				r <<= 4;  				r |= v;  				n++;  			}
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: return r << (8 - n) * 4;
Magic Number,GitSharp.Core.Util,Hex,C:\repos\henon_GitSharp\GitSharp.Core\Util\Hex.cs,HexUInt32,The following statement contains a magic number: return r << (8 - n) * 4;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt16,The following statement contains a magic number: int r = (intbuf[offset] & 0xff) << 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: uint low = (intbuf[offset + 1] & (uint)0xff) << 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: low |= (intbuf[offset + 2] & (uint)0xff);
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: low <<= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: low |= (intbuf[offset + 3] & (uint)0xff);
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,decodeUInt32,The following statement contains a magic number: return ((long)(intbuf[offset] & 0xff)) << 24 | low;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,DecodeUInt64,The following statement contains a magic number: return (DecodeUInt32(intbuf' offset) << 32) | DecodeUInt32(intbuf' offset + 4);
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,DecodeUInt64,The following statement contains a magic number: return (DecodeUInt32(intbuf' offset) << 32) | DecodeUInt32(intbuf' offset + 4);
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt16,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: intbuf[offset + 3] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: intbuf[offset + 2] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt32,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf[offset + 7] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf[offset + 6] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf[offset + 5] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf[offset + 4] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf[offset + 3] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: intbuf[offset + 2] = (byte)v;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,encodeInt64,The following statement contains a magic number: v >>= 8;
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,ConvertUnsignedByteToSigned,The following statement contains a magic number: return Convert.ToSByte(Convert.ToString(b' 2)' 2);
Magic Number,GitSharp.Core.Util,NB,C:\repos\henon_GitSharp\GitSharp.Core\Util\NB.cs,ConvertUnsignedByteToSigned,The following statement contains a magic number: return Convert.ToSByte(Convert.ToString(b' 2)' 2);
Magic Number,GitSharp.Core.Util,PathUtil,C:\repos\henon_GitSharp\GitSharp.Core\Util\PathUtil.cs,Combine,The following statement contains a magic number: if (paths.Length < 2)                  throw new ArgumentException("Must have at least two paths"' "paths");
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,formatBase10,The following statement contains a magic number: while (value != 0)  			{  				b[--o] = Base10Byte[value % 10];  				value /= 10;  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,formatBase10,The following statement contains a magic number: while (value != 0)  			{  				b[--o] = Base10Byte[value % 10];  				value /= 10;  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The following statement contains a magic number: try  			{  				int sz = b.Length;  				while (ptr < sz && b[ptr] == ' ')  					ptr++;  				if (ptr >= sz)  					return 0;    				switch (b[ptr])  				{  					case ((byte)'-'):  						sign = -1;  						ptr++;  						break;  					case ((byte)'+'):  						ptr++;  						break;  				}    				while (ptr < sz)  				{  					byte d = b[ptr];  					if ((d < (byte)'0') || (d > (byte)'9'))  						break;  					r = r * 10 + (d - (byte)'0');  					ptr++;  				}  			}  			catch (IndexOutOfRangeException)  			{  				// Not a valid digit.  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The following statement contains a magic number: try  			{  				int sz = b.Length;  				while (ptr < sz && b[ptr] == ' ')  					ptr++;  				if (ptr >= sz)  					return 0;    				switch (b[ptr])  				{  					case (byte)'-':  						sign = -1;  						ptr++;  						break;  					case (byte)'+':  						ptr++;  						break;  				}    				while (ptr < sz)  				{  					int v = b[ptr] - (byte)'0';  					if (v < 0)  						break;  					r = (r * 10) + v;  					ptr++;  				}  			}  			catch (IndexOutOfRangeException)  			{  				// Not a valid digit.  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt16,The following statement contains a magic number: try   			{                  string hex = Charset.forName("US-ASCII").GetString(bs' p' 4);  				  				hex = hex.Substring(p);  				return UInt16.Parse(hex'System.Globalization.NumberStyles.AllowHexSpecifier);  			}  			catch (Exception e)  			{  				throw new IndexOutOfRangeException("Exception Parsing Hex"'e);  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt32,The following statement contains a magic number: try   			{                  string hex = Charset.forName("US-ASCII").GetString(bs' p' 8);                  //string hex = Encoding.ASCII.GetString(bs).Substring(p' 8);  				  				return (int)UInt32.Parse(hex'System.Globalization.NumberStyles.AllowHexSpecifier);  			}  			catch (Exception e)  			{  				throw new IndexOutOfRangeException("Exception Parsing Hex"'e);  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseHexInt4,The following statement contains a magic number: try   			{  				char c = (char)digit;  				UInt16 result = UInt16.Parse(c.ToString()'System.Globalization.NumberStyles.AllowHexSpecifier);  				  				if (result > 15)  					throw new OverflowException();  				  				return (int)result;  			}  			catch (Exception e)  			{  				throw new IndexOutOfRangeException("Exception Parsing Hex"'e);  			}
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseTimeZoneOffset,The following statement contains a magic number: int tzMins = v % 100;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseTimeZoneOffset,The following statement contains a magic number: int tzHours = v / 100;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseTimeZoneOffset,The following statement contains a magic number: return tzHours * 60 + tzMins;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,lineMap,The following statement contains a magic number: IntList map = new IntList((end - ptr) / 36);
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,author,The following statement contains a magic number: if (ptr == 0)  				ptr += 46;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,author,The following statement contains a magic number: while (ptr < sz && b[ptr] == (byte)'p')  				ptr += 48;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,committer,The following statement contains a magic number: if (ptr == 0)  				ptr += 46;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,committer,The following statement contains a magic number: while (ptr < sz && b[ptr] == (byte)'p')  				ptr += 48;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,tagger,The following statement contains a magic number: if (ptr == 0)  				ptr += 48;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdent,The following statement contains a magic number: string name = decode(cs' raw' nameB' emailB - 2);
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdent,The following statement contains a magic number: return new PersonIdent(name' email' when * 1000' tz);
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdentOnly,The following statement contains a magic number: if (emailB < stop)  				name = decode(raw' nameB' emailB - 2);  			else  				name = decode(raw' nameB' stop);
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parsePersonIdentOnly,The following statement contains a magic number: return new PersonIdent(name' email' when * 1000' tz);
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,commitMessage,The following statement contains a magic number: if (ptr == 0)  				ptr += 46;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,commitMessage,The following statement contains a magic number: while (ptr < sz && b[ptr] == (byte)'p')  				ptr += 48;
Magic Number,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,tagMessage,The following statement contains a magic number: if (ptr == 0)  				ptr += 48;
Magic Number,GitSharp.Core.Util,IntList,C:\repos\henon_GitSharp\GitSharp.Core\Util\IntList.cs,grow,The following statement contains a magic number: var n = new int[(entries.Length + 16) * 3 / 2];
Magic Number,GitSharp.Core.Util,IntList,C:\repos\henon_GitSharp\GitSharp.Core\Util\IntList.cs,grow,The following statement contains a magic number: var n = new int[(entries.Length + 16) * 3 / 2];
Magic Number,GitSharp.Core.Util,IntList,C:\repos\henon_GitSharp\GitSharp.Core\Util\IntList.cs,grow,The following statement contains a magic number: var n = new int[(entries.Length + 16) * 3 / 2];
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,GitPathStyle,The following statement contains a magic number: quote_m = new int[128];
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following statement contains a magic number: StringBuilder r = new StringBuilder(2 + in_str.Length);
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following statement contains a magic number: for (int i = 0; i < in_str.Length; i++) {  				    int c = in_str[i] & 0xff;                      if (c < quote_m.Length)                      {                          int style = quote_m[c];  					    if (style == 0) {  						    r.Append((char) c);  						    continue;  					    }  					    if (style > 0) {  						    reuse = false;  						    r.Append('\\');  						    r.Append((char) style);  						    continue;  					    }  				    }    				    reuse = false;  				    r.Append('\\');  				    r.Append((char) (((c >> 6) & 03) + '0'));  				    r.Append((char) (((c >> 3) & 07) + '0'));  				    r.Append((char) (((c >> 0) & 07) + '0'));  			    }
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following statement contains a magic number: for (int i = 0; i < in_str.Length; i++) {  				    int c = in_str[i] & 0xff;                      if (c < quote_m.Length)                      {                          int style = quote_m[c];  					    if (style == 0) {  						    r.Append((char) c);  						    continue;  					    }  					    if (style > 0) {  						    reuse = false;  						    r.Append('\\');  						    r.Append((char) style);  						    continue;  					    }  				    }    				    reuse = false;  				    r.Append('\\');  				    r.Append((char) (((c >> 6) & 03) + '0'));  				    r.Append((char) (((c >> 3) & 07) + '0'));  				    r.Append((char) (((c >> 0) & 07) + '0'));  			    }
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following statement contains a magic number: for (int i = 0; i < in_str.Length; i++) {  				    int c = in_str[i] & 0xff;                      if (c < quote_m.Length)                      {                          int style = quote_m[c];  					    if (style == 0) {  						    r.Append((char) c);  						    continue;  					    }  					    if (style > 0) {  						    reuse = false;  						    r.Append('\\');  						    r.Append((char) style);  						    continue;  					    }  				    }    				    reuse = false;  				    r.Append('\\');  				    r.Append((char) (((c >> 6) & 03) + '0'));  				    r.Append((char) (((c >> 3) & 07) + '0'));  				    r.Append((char) (((c >> 0) & 07) + '0'));  			    }
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following statement contains a magic number: for (int i = 0; i < in_str.Length; i++) {  				    int c = in_str[i] & 0xff;                      if (c < quote_m.Length)                      {                          int style = quote_m[c];  					    if (style == 0) {  						    r.Append((char) c);  						    continue;  					    }  					    if (style > 0) {  						    reuse = false;  						    r.Append('\\');  						    r.Append((char) style);  						    continue;  					    }  				    }    				    reuse = false;  				    r.Append('\\');  				    r.Append((char) (((c >> 6) & 03) + '0'));  				    r.Append((char) (((c >> 3) & 07) + '0'));  				    r.Append((char) (((c >> 0) & 07) + '0'));  			    }
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following statement contains a magic number: for (int i = 0; i < in_str.Length; i++) {  				    int c = in_str[i] & 0xff;                      if (c < quote_m.Length)                      {                          int style = quote_m[c];  					    if (style == 0) {  						    r.Append((char) c);  						    continue;  					    }  					    if (style > 0) {  						    reuse = false;  						    r.Append('\\');  						    r.Append((char) style);  						    continue;  					    }  				    }    				    reuse = false;  				    r.Append('\\');  				    r.Append((char) (((c >> 6) & 03) + '0'));  				    r.Append((char) (((c >> 3) & 07) + '0'));  				    r.Append((char) (((c >> 0) & 07) + '0'));  			    }
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,dequote,The following statement contains a magic number: if (2 <= end - offset && instr[offset] == '"' && instr[end - 1] == '"')  				    return dq(instr' offset + 1' end - 1);
Magic Number,GitSharp.Core.Util,GitPathStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,dq,The following statement contains a magic number: while (offset < end)                  {  				    byte b = instr[offset++];  				    if (b != '\\') {  					    r[rPtr++] = b;  					    continue;  				    }    				    if (offset == end) {  					    // Lone trailing backslash. Treat it as a literal.  					    //  					    r[rPtr++] = (byte)'\\';  					    break;  				    }    				    switch (instr[offset++]) {  				    case (byte)'a':  					    r[rPtr++] = 0x07 /* \a = BEL */;  					    continue;  				    case (byte)'b':  					    r[rPtr++] = (byte)'\b';  					    continue;  				    case (byte)'f':  					    r[rPtr++] = (byte)'\f';  					    continue;  				    case (byte)'n':  					    r[rPtr++] = (byte)'\n';  					    continue;  				    case (byte)'r':  					    r[rPtr++] = (byte)'\r';  					    continue;  				    case (byte)'t':  					    r[rPtr++] = (byte)'\t';  					    continue;  				    case (byte)'v':  					    r[rPtr++] = 0x0B/* \v = VT */;  					    continue;    				    case (byte)'\\':  				    case (byte)'"':  					    r[rPtr++] = instr[offset - 1];  					    continue;    				    case (byte)'0':  				    case (byte)'1':  				    case (byte)'2':  				    case (byte)'3': {  					    int cp = instr[offset - 1] - '0';  					    while (offset < end) {  						    byte c = instr[offset];  						    if ('0' <= c && c <= '7') {  							    cp <<= 3;  							    cp |= c - '0';  							    offset++;  						    } else {  							    break;  						    }  					    }  					    r[rPtr++] = (byte) cp;  					    continue;  				    }    				    default:  					    // Any other code is taken literally.  					    //  					    r[rPtr++] = (byte)'\\';  					    r[rPtr++] = instr[offset - 1];  					    continue;  				    }  			    }
Magic Number,GitSharp.Core.Util,TemporaryBuffer,C:\repos\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: foreach (Block b in _blocks)              {                  os.Write(b.buffer' 0' b.count);                  pm.Update(b.count / 1024);              }
Magic Number,GitSharp.Core.Util,LocalFileBuffer,C:\repos\henon_GitSharp\GitSharp.Core\Util\TemporaryBuffer.cs,writeTo,The following statement contains a magic number: using (FileStream @in = new FileStream(onDiskFile.FullName' System.IO.FileMode.Open' FileAccess.Read))              {                  int cnt;                  byte[] buf = new byte[Block.SZ];                  while ((cnt = @in.Read(buf' 0' buf.Length)) > 0)                  {                      os.Write(buf' 0' cnt);                      pm.Update(cnt / 1024);                  }              }
Magic Number,GitSharp.Core.Util,AlarmState,C:\repos\henon_GitSharp\GitSharp.Core\Util\IO\InterruptTimer.cs,run,The following statement contains a magic number: lock (this)  			{  				while (!terminated && callingThread.isAlive())  				{  					//try  					//{  					if (0 < deadline)  					{  						long delay = deadline - now();  						if (delay <= 0)  						{  							deadline = 0;  							callingThread.interrupt();  						}  						else  						{  							Thread.sleep((int)delay);  						}  					}  					else  					{  						wait(1000);  					}  					//}  					//catch (InterruptedException e) // Note: [henon] Thread does not throw an equivalent exception in C# ??  					//{  					//   // Treat an interrupt as notice to examine state.  					//}  				}  			}
Magic Number,GitSharp.Core.Util,RefList<T>,C:\repos\henon_GitSharp\GitSharp.Core\Util\RefList.cs,copy,The following statement contains a magic number: Builder<T> r = new Builder<T>(Math.Max(16' n));
Magic Number,GitSharp.Core.Util,Builder<TRef>,C:\repos\henon_GitSharp\GitSharp.Core\Util\RefList.cs,add,The following statement contains a magic number: if (_list.Length == _size)                  {                      var n = new Ref[_size * 2];                      Array.Copy(_list' 0' n' 0' _size);                      _list = n;                  }
Magic Number,GitSharp.Core.Util,Builder<TRef>,C:\repos\henon_GitSharp\GitSharp.Core\Util\RefList.cs,addAll,The following statement contains a magic number: if (_list.Length < _size + cnt)                  {                      var n = new Ref[Math.Max(_size * 2' _size + cnt)];                      Array.Copy(_list' 0' n' 0' _size);                      _list = n;                  }
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\BigEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i=0; i < bytes; i++)  			{  				buffer[endOffset-i] = unchecked((byte)(value&0xff));  				value = value >> 8;  			}
Magic Number,MiscUtil.Conversion,BigEndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\BigEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i=0; i < bytesToConvert; i++)  			{  				ret = unchecked((ret << 8) | buffer[startIndex+i]);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToChar,The following statement contains a magic number: return unchecked((char) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToInt16,The following statement contains a magic number: return unchecked((short) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToInt32,The following statement contains a magic number: return unchecked((int) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToInt64,The following statement contains a magic number: return CheckedFromBytes(value' startIndex' 8);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return unchecked((ushort) (CheckedFromBytes(value' startIndex' 2)));
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return unchecked((uint) (CheckedFromBytes(value' startIndex' 4)));
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return unchecked((ulong) (CheckedFromBytes(value' startIndex' 8)));
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: int[] parts = new int[4];
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				parts[i] = ToInt32(value' startIndex+i*4);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,ToDecimal,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				parts[i] = ToInt32(value' startIndex+i*4);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: byte[] bytes = new byte[16];
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' bytes' i*4);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' bytes' i*4);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' bytes' i*4);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' buffer' i*4+index);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' buffer' i*4+index);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: for (int i=0; i < 4; i++)  			{  				CopyBytesImpl(parts[i]' 4' buffer' i*4+index);  			}
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(DoubleToInt64Bits(value)' 8);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 8);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(SingleToInt32Bits(value)' 4);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 2);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(value' 4);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,GetBytes,The following statement contains a magic number: return GetBytes(unchecked((long)value)' 8);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(DoubleToInt64Bits(value)' 8' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 8' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(SingleToInt32Bits(value)' 4' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 2' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(value' 4' buffer' index);
Magic Number,MiscUtil.Conversion,EndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBitConverter.cs,CopyBytes,The following statement contains a magic number: CopyBytes(unchecked((long)value)' 8' buffer' index);
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\LittleEndianBitConverter.cs,CopyBytesImpl,The following statement contains a magic number: for (int i=0; i < bytes; i++)  			{  				buffer[i+index] = unchecked((byte)(value&0xff));  				value = value >> 8;  			}
Magic Number,MiscUtil.Conversion,LittleEndianBitConverter,C:\repos\henon_GitSharp\GitSharp.Core\Util\LittleEndianBitConverter.cs,FromBytes,The following statement contains a magic number: for (int i=0; i < bytesToConvert; i++)  			{  				ret = unchecked((ret << 8) | buffer[startIndex+bytesToConvert-1-i]);  			}
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,EndianBinaryReader,The following statement contains a magic number: if (encoding is UnicodeEncoding)  			{  				minBytesPerChar = 2;  			}
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInt16,The following statement contains a magic number: ReadInternal(buffer' 2);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInt32,The following statement contains a magic number: ReadInternal(buffer' 4);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadInt64,The following statement contains a magic number: ReadInternal(buffer' 8);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadUInt16,The following statement contains a magic number: ReadInternal(buffer' 2);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadUInt32,The following statement contains a magic number: ReadInternal(buffer' 4);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadUInt64,The following statement contains a magic number: ReadInternal(buffer' 8);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadSingle,The following statement contains a magic number: ReadInternal(buffer' 4);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadDouble,The following statement contains a magic number: ReadInternal(buffer' 8);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadDecimal,The following statement contains a magic number: ReadInternal(buffer' 16);
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read,The following statement contains a magic number: if (byteBuffer.Length < count*minBytesPerChar)  			{  				byteBuffer = new byte[4096];  			}
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: for (int shift = 0; shift < 35; shift+=7)  			{  				int b = stream.ReadByte();  				if (b==-1)  				{  					throw new EndOfStreamException();  				}  				ret = ret | ((b&0x7f) << shift);  				if ((b & 0x80) == 0)  				{  					return ret;  				}  			}
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,Read7BitEncodedInt,The following statement contains a magic number: for (int shift = 0; shift < 35; shift+=7)  			{  				int b = stream.ReadByte();  				if (b==-1)  				{  					throw new EndOfStreamException();  				}  				ret = ret | ((b&0x7f) << shift);  				if ((b & 0x80) == 0)  				{  					return ret;  				}  			}
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: for (int i=0; i < 5; i++)  			{  				int b = stream.ReadByte();  				if (b==-1)  				{  					throw new EndOfStreamException();  				}  				ret = (ret << 7) | (b&0x7f);  				if ((b & 0x80) == 0)  				{  					return ret;  				}  			}
Magic Number,MiscUtil.IO,EndianBinaryReader,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryReader.cs,ReadBigEndian7BitEncodedInt,The following statement contains a magic number: for (int i=0; i < 5; i++)  			{  				int b = stream.ReadByte();  				if (b==-1)  				{  					throw new EndOfStreamException();  				}  				ret = (ret << 7) | (b&0x7f);  				if ((b & 0x80) == 0)  				{  					return ret;  				}  			}
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 2);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 4);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 8);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 2);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 4);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 8);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 4);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 8);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write,The following statement contains a magic number: WriteInternal(buffer' 16);
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (value >= 128)  			{  				buffer[index++]= (byte)((value&0x7f) | 0x80);  				value = value >> 7;  				index++;  			}
Magic Number,MiscUtil.IO,EndianBinaryWriter,C:\repos\henon_GitSharp\GitSharp.Core\Util\EndianBinaryWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (value >= 128)  			{  				buffer[index++]= (byte)((value&0x7f) | 0x80);  				value = value >> 7;  				index++;  			}
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (list.Length == 2)  			{  				return create(list[0]' list[1]);  			}
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (list.Length < 2)  			{  				throw new ArgumentException("At least two filters needed.");  			}
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (list.Count() < 2)  			{  				throw new ArgumentException("At least two filters needed.");  			}
Magic Number,GitSharp.Core.RevWalk.Filter,AndRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\AndRevFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2)  			{  				return create(subfilters[0]' subfilters[1]);  			}
Magic Number,GitSharp.Core.RevWalk.Filter,CommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,CommitTimeRevFilter,The following statement contains a magic number: _when = (int)(ts / 1000);
Magic Number,GitSharp.Core.RevWalk.Filter,BeforeCommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,ToString,The following statement contains a magic number: return base.ToString() + "(" + ((long)_when * 1000).MillisToUtcDateTime() + ")";
Magic Number,GitSharp.Core.RevWalk.Filter,AfterCommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,ToString,The following statement contains a magic number: return base.ToString() + "(" + ((long)_when * 1000).MillisToUtcDateTime() + ")";
Magic Number,GitSharp.Core.RevWalk.Filter,BetweenCommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,BetweenCommitTimeRevFilter,The following statement contains a magic number: _until = (int)(until / 1000);
Magic Number,GitSharp.Core.RevWalk.Filter,BetweenCommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,ToString,The following statement contains a magic number: return base.ToString() + "(" + ((long)_when * 1000).MillisToUtcDateTime() + " - " + ((long)_until * 1000).MillisToUtcDateTime() + ")";
Magic Number,GitSharp.Core.RevWalk.Filter,BetweenCommitTimeRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\CommitTimeRevFilter.cs,ToString,The following statement contains a magic number: return base.ToString() + "(" + ((long)_when * 1000).MillisToUtcDateTime() + " - " + ((long)_until * 1000).MillisToUtcDateTime() + ")";
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (list.Length == 2)  			{  				return create(list[0]' list[1]);  			}
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (list.Length < 2)  			{  				throw new ArgumentException("At least two filters needed.");  			}
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (list.Count() < 2)  			{  				throw new ArgumentException("At least two filters needed.");  			}
Magic Number,GitSharp.Core.RevWalk.Filter,OrRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\OrRevFilter.cs,create,The following statement contains a magic number: if (subfilters.Length == 2)  			{  				return create(subfilters[0]' subfilters[1]);  			}
Magic Number,GitSharp.Core.RevWalk.Filter,RevFilterNoMerges,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\RevFilter.cs,include,The following statement contains a magic number: return cmit.ParentCount < 2;
Magic Number,GitSharp.Core.Patch,FileHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,parseGitFileName,The following statement contains a magic number: while (ptr < eol)  			{  				int sp = RawParseUtils.nextLF(Buffer' ptr' (byte)' ');  				if (sp >= eol)  				{  					// We can't split the header' it isn't valid.  					// This may be OK if this is a rename patch.  					//  					return eol;  				}  				int bStart = RawParseUtils.nextLF(Buffer' sp' (byte)'/');  				if (bStart >= eol)  					return eol;    				// If buffer[aStart..sp - 1] = buffer[bStart..eol - 1]  				// we have a valid split.  				//  				if (Eq(aStart' sp - 1' bStart' eol - 1))  				{  					if (Buffer[bol] == '"')  					{  						// We're a double quoted name. The region better end  						// in a double quote too' and we need to decode the  						// characters before reading the name.  						//  						if (Buffer[sp - 2] != '"')  						{  							return eol;  						}  						oldName = QuotedString.GitPathStyle.GIT_PATH.dequote(Buffer' bol' sp - 1);  						oldName = P1(oldName);  					}  					else  					{  						oldName = RawParseUtils.decode(Constants.CHARSET' Buffer' aStart' sp - 1);  					}  					newName = oldName;  					return eol;  				}    				// This split wasn't correct. Move past the space and try  				// another split as the space must be part of the file name.  				//  				ptr = sp;  			}
Magic Number,GitSharp.Core.Patch,FileHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,ParseFileMode,The following statement contains a magic number: while (ptr < end - 1)  			{  				tmp <<= 3;  				tmp += Buffer[ptr++] - '0';  			}
Magic Number,GitSharp.Core.Patch,FileHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,isHunkHdr,The following statement contains a magic number: if ((ptr - start) < 2)  				return 0;
Magic Number,GitSharp.Core.Patch,FileHeader,C:\repos\henon_GitSharp\GitSharp.Core\Patch\FileHeader.cs,isHunkHdr,The following statement contains a magic number: return (ptr - 3) - start;
Magic Number,GitSharp.Core.Patch,Patch,C:\repos\henon_GitSharp\GitSharp.Core\Patch\Patch.cs,ParseFile,The following statement contains a magic number: while (c < end)  			{  				if (FileHeader.isHunkHdr(buf' c' end) >= 1)  				{  					// If we find a disconnected hunk header we might  					// have missed a file header previously. The hunk  					// isn't valid without knowing where it comes from.  					//  					error(buf' c' "Hunk disconnected from file");  					c = RawParseUtils.nextLF(buf' c);  					continue;  				}    				// Valid git style patch?  				//  				if (RawParseUtils.match(buf' c' DiffGit) >= 0)  				{  					return ParseDiffGit(buf' c' end);  				}  				if (RawParseUtils.match(buf' c' DiffCc) >= 0)  				{  					return ParseDiffCombined(DiffCc' buf' c' end);  				}  				if (RawParseUtils.match(buf' c' DiffCombined) >= 0)  				{  					return ParseDiffCombined(DiffCombined' buf' c' end);  				}    				// Junk between files? Leading junk? Traditional  				// (non-git generated) patch?  				//  				int n = RawParseUtils.nextLF(buf' c);  				if (n >= end)  				{  					// Patches cannot be only one line long. This must be  					// trailing junk that we should ignore.  					//  					return end;  				}    				if (n - c < 6)  				{  					// A valid header must be at least 6 bytes on the  					// first line' e.g. "--- a/b\n".  					//  					c = n;  					continue;  				}    				if (RawParseUtils.match(buf' c' FileHeader.OLD_NAME) >= 0 &&  					RawParseUtils.match(buf' n' FileHeader.NEW_NAME) >= 0)  				{  					// Probably a traditional patch. Ensure we have at least  					// a "@@ -0'0" smelling line next. We only check the "@@ -".  					//  					int f = RawParseUtils.nextLF(buf' n);  					if (f >= end)  						return end;  					if (FileHeader.isHunkHdr(buf' f' end) == 1)  						return ParseTraditionalPatch(buf' c' end);  				}    				c = n;  			}
Magic Number,GitSharp.Core.TreeWalk,CanonicalTreeParser,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\CanonicalTreeParser.cs,ParseEntry,The following statement contains a magic number: for (; ; )              {                  c = _raw[ptr++];                  if (' ' == c)                      break;                  tmp <<= 3;                  tmp += c - (byte)'0';              }
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: try              {                  FileStream @is = entry.OpenInputStream();                  if (@is == null)                  {                      return ZeroId;                  }                    try                  {                      InitializeDigest();                        _contentDigest.Reset();                      _contentDigest.Update(HBlob);                      _contentDigest.Update((byte)' ');                        long blobLength = entry.Length;                                            long size = blobLength;                      if (size == 0)                      {                          _contentDigest.Update((byte)'0');                      }                      else                      {                          int bufn = _contentReadBuffer.Length;                          int p = bufn;                          do                          {                              _contentReadBuffer[--p] = Digits[(int)(size % 10)];                              size /= 10;                          } while (size > 0);                            _contentDigest.Update(_contentReadBuffer' p' bufn - p);                      }                        _contentDigest.Update(0);                        while (true)                      {                          int r = @is.Read(_contentReadBuffer' 0' _contentReadBuffer.Length); // was: Read(_contentReadBuffer) in java                          if (r <= 0) break;                          _contentDigest.Update(_contentReadBuffer' 0' r);                          size += r;                      }                        if (size != blobLength)                      {                          return ZeroId;                      }                        return _contentDigest.Digest();                  }                  finally                  {                      try                      {                          @is.Close();                      }                      catch (IOException)                      {                          // Suppress any error related to closing an input                          // stream. We don't care' we should not have any                          // outstanding data to flush or anything like that.                      }                  }              }              catch (IOException)              {                  // Can't Read the file? Don't report the failure either.                  //              }
Magic Number,GitSharp.Core.TreeWalk,WorkingTreeIterator,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,IdBufferBlob,The following statement contains a magic number: try              {                  FileStream @is = entry.OpenInputStream();                  if (@is == null)                  {                      return ZeroId;                  }                    try                  {                      InitializeDigest();                        _contentDigest.Reset();                      _contentDigest.Update(HBlob);                      _contentDigest.Update((byte)' ');                        long blobLength = entry.Length;                                            long size = blobLength;                      if (size == 0)                      {                          _contentDigest.Update((byte)'0');                      }                      else                      {                          int bufn = _contentReadBuffer.Length;                          int p = bufn;                          do                          {                              _contentReadBuffer[--p] = Digits[(int)(size % 10)];                              size /= 10;                          } while (size > 0);                            _contentDigest.Update(_contentReadBuffer' p' bufn - p);                      }                        _contentDigest.Update(0);                        while (true)                      {                          int r = @is.Read(_contentReadBuffer' 0' _contentReadBuffer.Length); // was: Read(_contentReadBuffer) in java                          if (r <= 0) break;                          _contentDigest.Update(_contentReadBuffer' 0' r);                          size += r;                      }                        if (size != blobLength)                      {                          return ZeroId;                      }                        return _contentDigest.Digest();                  }                  finally                  {                      try                      {                          @is.Close();                      }                      catch (IOException)                      {                          // Suppress any error related to closing an input                          // stream. We don't care' we should not have any                          // outstanding data to flush or anything like that.                      }                  }              }              catch (IOException)              {                  // Can't Read the file? Don't report the failure either.                  //              }
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < nParent; i++) {  				PlotCommit p;  				PlotLane pLane;  				TColor pColor;  				int cx;  	  				p = (PlotCommit) commit.GetParent(i);  				pLane = p.getLane();  				if (pLane == null)  					continue;  	  				pColor = laneColor(pLane);  				cx = laneC(pLane);  	  				if (Math.Abs(myLaneX - cx) > LANE_WIDTH) {  					if (myLaneX < cx) {  						int ix = cx - LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					} else {  						int ix = cx + LANE_WIDTH / 2;  						drawLine(pColor' myLaneX' h / 2' ix' h / 2' LINE_WIDTH);  						drawLine(pColor' ix' h / 2' cx' h' LINE_WIDTH);  					}  				} else {  					drawLine(pColor' myLaneX' h / 2' cx' h' LINE_WIDTH);  				}  				maxCenter = Math.Max(maxCenter' cx);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: int dotX = myLaneX - dotSize / 2 - 1;
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: int dotY = (h - dotSize) / 2;
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: int textx = Math.Max(maxCenter + LANE_WIDTH / 2' dotX + dotSize) + 8;
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: int textx = Math.Max(maxCenter + LANE_WIDTH / 2' dotX + dotSize) + 8;
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: for (int i = 0; i < n; ++i) {  				textx += drawLabel(textx + dotSize' h/2' commit.refs[i]);  			}
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawText(msg' textx + dotSize + n*2' h / 2);
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,paintCommit,The following statement contains a magic number: drawText(msg' textx + dotSize + n*2' h / 2);
Magic Number,GitSharp.Core.RevPlot,AbstractPlotRenderer<TColor>,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\AbstractPlotRenderer.cs,laneC,The following statement contains a magic number: return laneX(myLane) + LANE_WIDTH / 2;
Magic Number,GitSharp.Core.RevPlot,PlotCommitList,C:\repos\henon_GitSharp\GitSharp.Core\RevPlot\PlotCommitList.cs,enter,The following statement contains a magic number: if (nChildren == 1 && currCommit.children[0].ParentCount < 2) {                  // Only one child' child has only us as their parent.                  // Stay in the same lane as the child.                  //                  PlotCommit c = currCommit.children[0];                  if (c.lane == null) {                      // Hmmph. This child must be the first along this lane.                      //                      c.lane = nextFreeLane();                      activeLanes.Add(c.lane);                  }                    for (int r = index - 1; r >= 0; r--) {                      PlotCommit rObj = get(r);                      if (rObj == c)                          break;                      rObj.addPassingLane(c.lane);                  }                  currCommit.lane = c.lane;                  currCommit.lane.parent = currCommit;              } else {                  // More than one child' or our child is a merge.                  // Use a different lane.                  //                    for (int i = 0; i < nChildren; i++) {                      PlotCommit c = currCommit.children[i];                      if (activeLanes.Remove(c.lane)) {                          recycleLane(c.lane);                          freeLanes.Add(c.lane.getPosition()' c.lane.getPosition());                      }                  }                    currCommit.lane = nextFreeLane();                  currCommit.lane.parent = currCommit;                  activeLanes.Add(currCommit.lane);                    int remaining = nChildren;                  for (int r = index - 1; r >= 0; r--) {                      PlotCommit rObj = get(r);                      if (currCommit.isChild(rObj)) {                          if (--remaining == 0)                              break;                      }                      rObj.addPassingLane(currCommit.lane);                  }              }
Missing Default,GitSharp.Core,ByteArrayExtensions,C:\repos\henon_GitSharp\GitSharp.Core\ByteArrayExtensions.cs,ReadLine,The following switch statement is missing a default case: switch (num)                  {                      case 13:                          if ((currentIndex != (source.Length - 1)) && (source[currentIndex + 1] == 10))                          {                              indexModifier = 2;                          }                          break;                        case 10:                          indexModifier = 1;                          break;                  }
Missing Default,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following switch statement is missing a default case: switch (typeString[offset])                  {                      case (byte)'b':                          if (typeString[offset + 1] != (byte)'l' ||                          typeString[offset + 2] != (byte)'o' ||                          typeString[offset + 3] != (byte)'b' ||                          typeString[offset + 4] != endMark) break;                          offset += 5;                          return ObjectType.Blob;                        case (byte)'c':                          if (typeString[offset + 1] != (byte)'o' || typeString[offset + 2] != (byte)'m' ||                          typeString[offset + 3] != (byte)'m' || typeString[offset + 4] != (byte)'i' ||                          typeString[offset + 5] != (byte)'t' || typeString[offset + 6] != endMark) break;                          offset += 7;                          return ObjectType.Commit;                        case (byte)'t':                          switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }                          break;                  }
Missing Default,GitSharp.Core,Codec,C:\repos\henon_GitSharp\GitSharp.Core\Codec.cs,DecodeTypeString,The following switch statement is missing a default case: switch (typeString[offset + 1])                          {                              case (byte)'a':                                  if (typeString[offset + 2] != (byte)'g' || typeString[offset + 2] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 4;                                  return ObjectType.Tag;                                case (byte)'r':                                  if (typeString[offset + 2] != (byte)'e' || typeString[offset + 3] != (byte)'e' || typeString[offset + 4] != endMark)                                  {                                      throw new CorruptObjectException(id' "invalid type");                                  }                                  offset += 5;                                  return ObjectType.Tree;                            }
Missing Default,GitSharp.Core,FileMode,C:\repos\henon_GitSharp\GitSharp.Core\FileMode.cs,FromBits,The following switch statement is missing a default case: switch (bits & TYPE_MASK) // octal 0170000  			{  				case 0:  					if (bits == 0)  					{  						return Missing;  					}  					break;    				case TYPE_TREE: // octal 0040000  					return Tree;    				case TYPE_FILE: // octal 0100000  					return (bits & OCTAL_0111) != 0 ? ExecutableFile : RegularFile;    				case TYPE_SYMLINK: // octal 0120000  					return Symlink;    				case TYPE_GITLINK: // octal 0160000  					return GitLink;  			}
Missing Default,GitSharp.Core,PackIndexWriter,C:\repos\henon_GitSharp\GitSharp.Core\PackIndexWriter.cs,CreateOldestPossible,The following switch statement is missing a default case: switch (version)                  {                      case 1:                          if (PackIndexWriterV1.CanStore(oe)) continue;                          version = 2;                  		break;                        case 2:                  		breakLoop = true;                  		break;  				}
Missing Default,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,MapTree,The following switch statement is missing a default case: switch (((ObjectType)or.Type))              {                  case ObjectType.Tree:                      return new Tree(this' id' raw);                    case ObjectType.Commit:                      return MapTree(ObjectId.FromString(raw' 5));              }
Missing Default,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,IsValidRefName,The following switch statement is missing a default case: switch (c)                  {                      case '.':                          switch (p)                          {                              case '\0':                              case '/':                              case '.':                                  return false;                          }                            if (i == len - 1) return false;                          break;                        case '/':                          if (i == 0 || i == len - 1) return false;                          components++;                          break;                        case '{':                          if (p == '@') return false;                          break;                        case '~':                      case '^':                      case ':':                      case '?':                      case '[':                      case '*':                      case '\\':                          return false;                  }
Missing Default,GitSharp.Core,Repository,C:\repos\henon_GitSharp\GitSharp.Core\Repository.cs,IsValidRefName,The following switch statement is missing a default case: switch (p)                          {                              case '\0':                              case '/':                              case '.':                                  return false;                          }
Missing Default,GitSharp.Core,Config,C:\repos\henon_GitSharp\GitSharp.Core\Config.cs,getLong,The following switch statement is missing a default case: switch (StringUtils.toLowerCase(n[n.Length - 1]))              {                  case 'g':                      mul = GiB;                      break;                    case 'm':                      mul = MiB;                      break;                    case 'k':                      mul = KiB;                      break;              }
Missing Default,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (os.Version.Major)  					{  						case 4:  							switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}  							break;  					}
Missing Default,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (os.Version.Minor)  							{  								case 0:  									if (osvi.szCSDVersion == "B" ||  									    osvi.szCSDVersion == "C")  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "OSR2";  									}  									else  									{  										ClassName = "Windows.v95";  										PlatformSubType = "95";  										Edition = "";  									}  									break;  								case 10:  									if (osvi.szCSDVersion == "A")  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "SE";  									}  									else  									{  										ClassName = "Windows.v98";  										PlatformSubType = "98";  										Edition = "";  									}  									break;  								case 90:  									ClassName = "Windows.ME";  									PlatformSubType = "ME";  									Edition = "";  									break;  							}
Missing Default,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (osvi.wProductType)  							{  								case 1:  									ClassName = "Windows.NT";  									PlatformSubType = "NT";  									Edition = "4.0 Workstation";  									break;  								case 3:  									if (osvi.wSuiteMask == SuiteVersion.Enterprise)  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Enterprise";  									}  									else  									{  										ClassName = "Windows.NT";  										PlatformSubType = "NT";  										Edition = "4.0 Server Standard";  									}  									break;  							}
Missing Default,GitSharp.Core,Win32,C:\repos\henon_GitSharp\GitSharp.Core\Platform\Windows.cs,Win32,The following switch statement is missing a default case: switch (ospi.dwOSEdition)  									{  										case ProductType.Undefined:  											ClassName = "Windows.Undefined";  											PlatformSubType = "7";  											Edition = "is undefined";  											break;  										case ProductType.Ultimate: //    1  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Ultimate Edition";  											break;  										case ProductType.HomeBasic: // 2  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic Edition";  											break;  										case ProductType.HomePremium: // 3  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Premium Edition";  											break;  										case ProductType.Enterprise: // 4  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Enterprise Edition";  											break;  										case ProductType.HomeBasicN: // 5  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Home Basic N Edition (EU only)";  											break;  										case ProductType.Business: // 6  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business Edition";  											break;  										case ProductType.BusinessN: // 10  											ClassName = "Windows.v7";  											PlatformSubType = "7";  											Edition = "Business N Edition (EU only)";  											break;  									}
Missing Default,GitSharp.Core.DirectoryCache,DirCacheEntry,C:\repos\henon_GitSharp\GitSharp.Core\DirectoryCache\DirCacheEntry.cs,setFileMode,The following switch statement is missing a default case: switch (mode.Bits & FileMode.TYPE_MASK)              {                  case FileMode.TYPE_MISSING:                  case FileMode.TYPE_TREE:                      throw new ArgumentException("Invalid mode " + mode.Bits                          + " for path " + getPathString());              }
Missing Default,GitSharp.Core.Transport,WalkFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\WalkFetchConnection.cs,MarkLocalObjComplete,The following switch statement is missing a default case: switch (obj.Type)              {                  case Constants.OBJ_BLOB:                      obj.add(COMPLETE);                      break;                    case Constants.OBJ_COMMIT:                      PushLocalCommit((RevCommit)obj);                      break;                    case Constants.OBJ_TREE:                      MarkTreeComplete((RevTree)obj);                      break;              }
Missing Default,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following switch statement is missing a default case: switch (anr)                      {                          case PacketLineIn.AckNackResult.NAK:                              // More have lines are necessary to compute the                              // pack on the remote side. Keep doing that.                                resultsPending--;                              goto END_READ_RESULT;                            case PacketLineIn.AckNackResult.ACK:                              // The remote side is happy and knows exactly what                              // to send us. There is no further negotiation and                              // we can break out immediately.                                _multiAck = MultiAck.OFF;                              resultsPending = 0;                              receivedAck = true;                              goto END_SEND_HAVES;                            case PacketLineIn.AckNackResult.ACK_CONTINUE:                          case PacketLineIn.AckNackResult.ACK_COMMON:                          case PacketLineIn.AckNackResult.ACK_READY:                              // The server knows this commit (ackId). We don't                              // need to send any further along its ancestry' but                              // we need to continue to talk about other parts of                              // our local history.                                MarkCommon(_walk.parseAny(ackId));                              receivedAck = true;                              receivedContinue = true;                              havesSinceLastContinue = 0;                              break;                      }
Missing Default,GitSharp.Core.Transport,BasePackFetchConnection,C:\repos\henon_GitSharp\GitSharp.Core\Transport\BasePackFetchConnection.cs,Negotiate,The following switch statement is missing a default case: switch (anr)                  {                      case PacketLineIn.AckNackResult.NAK:                          // A NAK is a response to an end we queued earlier                          // we eat it and look for another ACK/NAK message.                          //                          break;                        case PacketLineIn.AckNackResult.ACK:                          // A solitary ACK at this point means the remote won't                          // speak anymore' but is going to send us a pack now.                          //                          goto END_READ_RESULT_2;                        case PacketLineIn.AckNackResult.ACK_CONTINUE:                      case PacketLineIn.AckNackResult.ACK_COMMON:                      case PacketLineIn.AckNackResult.ACK_READY:                          // We will expect a normal ACK to break out of the loop.                          //                          _multiAck = MultiAck.CONTINUE;                          break;                  }
Missing Default,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,Execute,The following switch statement is missing a default case: switch (cmd.getType())  				{  					case ReceiveCommand.Type.DELETE:  						if (!ObjectId.ZeroId.Equals(cmd.getOldId()))  						{  							// We can only do a CAS style delete if the client  							// didn't bork its delete request by sending the  							// wrong zero id rather than the advertised one.  							//  							ru.setExpectedOldObjectId(cmd.getOldId());  						}  						ru.setForceUpdate(true);  						Status(cmd' ru.delete(walk));  						break;    					case ReceiveCommand.Type.CREATE:  					case ReceiveCommand.Type.UPDATE:  					case ReceiveCommand.Type.UPDATE_NONFASTFORWARD:  						ru.setForceUpdate(isAllowNonFastForwards());  						ru.setExpectedOldObjectId(cmd.getOldId());  						ru.setNewObjectId(cmd.getNewId());  						ru.setRefLogMessage("push"' true);  						Status(cmd' ru.update(walk));  						break;  				}
Missing Default,GitSharp.Core.Transport,ReceivePack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\ReceivePack.cs,SendStatusReport,The following switch statement is missing a default case: switch (cmd.getResult())  				{  					case ReceiveCommand.Result.NOT_ATTEMPTED:  						r.Append("server bug; ref not processed");  						break;    					case ReceiveCommand.Result.REJECTED_NOCREATE:  						r.Append("creation prohibited");  						break;    					case ReceiveCommand.Result.REJECTED_NODELETE:  						r.Append("deletion prohibited");  						break;    					case ReceiveCommand.Result.REJECTED_NONFASTFORWARD:  						r.Append("non-fast forward");  						break;    					case ReceiveCommand.Result.REJECTED_CURRENT_BRANCH:  						r.Append("branch is currently checked out");  						break;    					case ReceiveCommand.Result.REJECTED_MISSING_OBJECT:  						if (cmd.getMessage() == null)  							r.Append("missing object(s)");  						else if (cmd.getMessage().Length == Constants.OBJECT_ID_STRING_LENGTH)  							r.Append("object " + cmd.getMessage() + " missing");  						else  							r.Append(cmd.getMessage());  						break;    					case ReceiveCommand.Result.REJECTED_OTHER_REASON:  						if (cmd.getMessage() == null)  							r.Append("unspecified reason");  						else  							r.Append(cmd.getMessage());  						break;    					case ReceiveCommand.Result.LOCK_FAILURE:  						r.Append("failed to lock");  						break;    					case ReceiveCommand.Result.OK:  						// We shouldn't have reached this case (see 'ok' case above).  						continue;  				}
Missing Default,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following switch statement is missing a default case: switch (_multiAck)                          {                              case BasePackFetchConnection.MultiAck.OFF:                                  if (_commonBase.Count == 1)                                      _pckOut.WriteString("ACK " + id.Name + "\n");                                  break;                              case BasePackFetchConnection.MultiAck.CONTINUE:                                    _pckOut.WriteString("ACK " + id.Name + " continue\n");                                  break;                              case BasePackFetchConnection.MultiAck.DETAILED:                                  _pckOut.WriteString("ACK " + id.Name + " common\n");                                  break;                          }
Missing Default,GitSharp.Core.Transport,UploadPack,C:\repos\henon_GitSharp\GitSharp.Core\Transport\UploadPack.cs,Negotiate,The following switch statement is missing a default case: switch (_multiAck)                          {                              case BasePackFetchConnection.MultiAck.OFF:                                  break;                              case BasePackFetchConnection.MultiAck.CONTINUE:                                  _pckOut.WriteString("ACK " + id.Name + " continue\n");                                  break;                              case BasePackFetchConnection.MultiAck.DETAILED:                                  _pckOut.WriteString("ACK " + id.Name + " ready\n");                                  break;                          }
Missing Default,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseBase10,The following switch statement is missing a default case: switch (b[ptr])  				{  					case ((byte)'-'):  						sign = -1;  						ptr++;  						break;  					case ((byte)'+'):  						ptr++;  						break;  				}
Missing Default,GitSharp.Core.Util,RawParseUtils,C:\repos\henon_GitSharp\GitSharp.Core\Util\RawParseUtils.cs,parseLongBase10,The following switch statement is missing a default case: switch (b[ptr])  				{  					case (byte)'-':  						sign = -1;  						ptr++;  						break;  					case (byte)'+':  						ptr++;  						break;  				}
Missing Default,GitSharp.Core.Util,BourneStyle,C:\repos\henon_GitSharp\GitSharp.Core\Util\QuotedString.cs,quote,The following switch statement is missing a default case: switch (instr[i]) {  				    case '\'':  				    case '!':  					    r.Append(instr' start' i - start);  					    r.Append('\'');  					    r.Append('\\');  					    r.Append(instr[i]);  					    r.Append('\'');  					    start = i + 1;  					    break;  				    }
Missing Default,GitSharp.Core.RevWalk.Filter,SubStringRevFilter,C:\repos\henon_GitSharp\GitSharp.Core\RevWalk\Filter\SubStringRevFilter.cs,safe,The following switch statement is missing a default case: switch (c)  				{  					case '.':  					case '?':  					case '*':  					case '+':  					case '{':  					case '}':  					case '(':  					case ')':  					case '[':  					case ']':  					case '\\':  						return false;  				}
Missing Default,GitSharp.Core.TreeWalk,WorkingTreeIterator,C:\repos\henon_GitSharp\GitSharp.Core\TreeWalk\WorkingTreeIterator.cs,idBuffer,The following switch statement is missing a default case: switch (Mode & FileMode.TYPE_MASK)              {                  case FileMode.TYPE_FILE:                      _contentIdFromPtr = ptr;                      return _contentId = IdBufferBlob(_entries[ptr]);                    case FileMode.TYPE_SYMLINK:                      // Windows does not support symbolic links' so we should not                      // have reached this particular part of the walk code.                      //                      return ZeroId;                    case FileMode.TYPE_GITLINK:                      // TODO: Support obtaining current HEAD SHA-1 from nested repository                      //                      return ZeroId;              }
